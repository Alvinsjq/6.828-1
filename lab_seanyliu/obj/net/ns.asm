
obj/net/ns:     file format elf32-i386

Disassembly of section .text:

00800020 <_start>:
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 3f 0a 00 00       	call   800a70 <libmain>
1:      jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>
	...

00800034 <next_i>:
static envid_t input_envid;
static envid_t output_envid;

static bool buse[QUEUE_SIZE];
static int next_i(int i) { return (i+1) % QUEUE_SIZE; }
  800034:	55                   	push   %ebp
  800035:	89 e5                	mov    %esp,%ebp
  800037:	8b 45 08             	mov    0x8(%ebp),%eax
  80003a:	40                   	inc    %eax
  80003b:	ba 14 00 00 00       	mov    $0x14,%edx
  800040:	89 d1                	mov    %edx,%ecx
  800042:	99                   	cltd   
  800043:	f7 f9                	idiv   %ecx
  800045:	89 d0                	mov    %edx,%eax
  800047:	c9                   	leave  
  800048:	c3                   	ret    

00800049 <prev_i>:
static int prev_i(int i) { return (i ? i-1 : QUEUE_SIZE-1); }
  800049:	55                   	push   %ebp
  80004a:	89 e5                	mov    %esp,%ebp
  80004c:	8b 55 08             	mov    0x8(%ebp),%edx
  80004f:	b8 13 00 00 00       	mov    $0x13,%eax
  800054:	85 d2                	test   %edx,%edx
  800056:	74 03                	je     80005b <prev_i+0x12>
  800058:	8d 42 ff             	lea    0xffffffff(%edx),%eax
  80005b:	c9                   	leave  
  80005c:	c3                   	ret    

0080005d <get_buffer>:

static void *
get_buffer() {
  80005d:	55                   	push   %ebp
  80005e:	89 e5                	mov    %esp,%ebp
  800060:	83 ec 08             	sub    $0x8,%esp
    void *va;

    int i;
    for (i = 0; i < QUEUE_SIZE; i++)
  800063:	ba 00 00 00 00       	mov    $0x0,%edx
  800068:	b8 20 84 81 00       	mov    $0x818420,%eax
	if (!buse[i]) break;
  80006d:	83 3c 90 00          	cmpl   $0x0,(%eax,%edx,4)
  800071:	74 06                	je     800079 <get_buffer+0x1c>
  800073:	42                   	inc    %edx
  800074:	83 fa 13             	cmp    $0x13,%edx
  800077:	7e f4                	jle    80006d <get_buffer+0x10>

    if (i == QUEUE_SIZE) {
  800079:	83 fa 14             	cmp    $0x14,%edx
  80007c:	75 14                	jne    800092 <get_buffer+0x35>
	panic("NS: buffer overflow");
  80007e:	83 ec 04             	sub    $0x4,%esp
  800081:	68 20 19 81 00       	push   $0x811920
  800086:	6a 3f                	push   $0x3f
  800088:	68 34 19 81 00       	push   $0x811934
  80008d:	e8 3a 0a 00 00       	call   800acc <_panic>
	return 0;
    }

    va = (void *)(REQVA + i * PGSIZE);
  800092:	89 d0                	mov    %edx,%eax
  800094:	c1 e0 0c             	shl    $0xc,%eax
  800097:	05 00 b0 fe 0f       	add    $0xffeb000,%eax
    buse[i] = 1;
  80009c:	c7 04 95 20 84 81 00 	movl   $0x1,0x818420(,%edx,4)
  8000a3:	01 00 00 00 
    
    return va;
}
  8000a7:	c9                   	leave  
  8000a8:	c3                   	ret    

008000a9 <put_buffer>:

static void
put_buffer(void *va) {
  8000a9:	55                   	push   %ebp
  8000aa:	89 e5                	mov    %esp,%ebp
    int i = ((uint32_t)va - REQVA) / PGSIZE;
  8000ac:	8b 45 08             	mov    0x8(%ebp),%eax
  8000af:	2d 00 b0 fe 0f       	sub    $0xffeb000,%eax
  8000b4:	c1 e8 0c             	shr    $0xc,%eax
    buse[i] = 0;
  8000b7:	c7 04 85 20 84 81 00 	movl   $0x0,0x818420(,%eax,4)
  8000be:	00 00 00 00 
}
  8000c2:	c9                   	leave  
  8000c3:	c3                   	ret    

008000c4 <lwip_init>:

static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
  8000c4:	55                   	push   %ebp
  8000c5:	89 e5                	mov    %esp,%ebp
  8000c7:	53                   	push   %ebx
  8000c8:	83 ec 18             	sub    $0x18,%esp
  8000cb:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct ip_addr ipaddr, netmask, gateway;
    ipaddr.addr  = init_addr;
  8000ce:	8b 45 10             	mov    0x10(%ebp),%eax
  8000d1:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    netmask.addr = init_mask;
  8000d4:	8b 45 14             	mov    0x14(%ebp),%eax
  8000d7:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    gateway.addr = init_gw;
  8000da:	8b 45 18             	mov    0x18(%ebp),%eax
  8000dd:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)

    if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8000e0:	68 5f 92 80 00       	push   $0x80925f
  8000e5:	68 27 db 80 00       	push   $0x80db27
  8000ea:	ff 75 0c             	pushl  0xc(%ebp)
  8000ed:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  8000f0:	50                   	push   %eax
  8000f1:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  8000f4:	50                   	push   %eax
  8000f5:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  8000f8:	50                   	push   %eax
  8000f9:	53                   	push   %ebx
  8000fa:	e8 31 71 00 00       	call   807230 <netif_add>
  8000ff:	83 c4 20             	add    $0x20,%esp
  800102:	85 c0                	test   %eax,%eax
  800104:	75 14                	jne    80011a <lwip_init+0x56>
		       if_state,
		       jif_init,
		       ip_input))
	panic("lwip_init: error in netif_add\n");
  800106:	83 ec 04             	sub    $0x4,%esp
  800109:	68 2c 1a 81 00       	push   $0x811a2c
  80010e:	6a 5c                	push   $0x5c
  800110:	68 34 19 81 00       	push   $0x811934
  800115:	e8 b2 09 00 00       	call   800acc <_panic>

    netif_set_default(nif);
  80011a:	83 ec 0c             	sub    $0xc,%esp
  80011d:	53                   	push   %ebx
  80011e:	e8 07 73 00 00       	call   80742a <netif_set_default>
    netif_set_up(nif);
  800123:	89 1c 24             	mov    %ebx,(%esp)
  800126:	e8 0c 73 00 00       	call   807437 <netif_set_up>
}
  80012b:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80012e:	c9                   	leave  
  80012f:	c3                   	ret    

00800130 <net_timer>:

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  800130:	55                   	push   %ebp
  800131:	89 e5                	mov    %esp,%ebp
  800133:	56                   	push   %esi
  800134:	53                   	push   %ebx
    struct timer_thread *t = (struct timer_thread *) arg;
  800135:	8b 75 08             	mov    0x8(%ebp),%esi

    for (;;) {
	uint32_t cur = sys_time_msec();
  800138:	e8 ca 16 00 00       	call   801807 <sys_time_msec>
  80013d:	89 c3                	mov    %eax,%ebx

	lwip_core_lock();
  80013f:	e8 1c d3 00 00       	call   80d460 <lwip_core_lock>
	t->func();
  800144:	ff 56 04             	call   *0x4(%esi)
	lwip_core_unlock();
  800147:	e8 19 d3 00 00       	call   80d465 <lwip_core_unlock>

	thread_wait(0, 0, cur + t->msec);
  80014c:	83 ec 04             	sub    $0x4,%esp
  80014f:	89 d8                	mov    %ebx,%eax
  800151:	03 06                	add    (%esi),%eax
  800153:	50                   	push   %eax
  800154:	6a 00                	push   $0x0
  800156:	6a 00                	push   $0x0
  800158:	e8 5f d3 00 00       	call   80d4bc <thread_wait>
  80015d:	83 c4 10             	add    $0x10,%esp
  800160:	eb d6                	jmp    800138 <net_timer+0x8>

00800162 <start_timer>:
    }
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800162:	55                   	push   %ebp
  800163:	89 e5                	mov    %esp,%ebp
  800165:	83 ec 08             	sub    $0x8,%esp
  800168:	8b 55 08             	mov    0x8(%ebp),%edx
  80016b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    t->msec = msec;
  80016e:	8b 45 14             	mov    0x14(%ebp),%eax
  800171:	89 02                	mov    %eax,(%edx)
    t->func = func;
  800173:	8b 45 0c             	mov    0xc(%ebp),%eax
  800176:	89 42 04             	mov    %eax,0x4(%edx)
    t->name = name;
  800179:	89 4a 08             	mov    %ecx,0x8(%edx)
    int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80017c:	52                   	push   %edx
  80017d:	68 30 01 80 00       	push   $0x800130
  800182:	51                   	push   %ecx
  800183:	6a 00                	push   $0x0
  800185:	e8 44 d4 00 00       	call   80d5ce <thread_create>
    if (r < 0)
  80018a:	83 c4 10             	add    $0x10,%esp
  80018d:	85 c0                	test   %eax,%eax
  80018f:	79 1e                	jns    8001af <start_timer+0x4d>
	panic("cannot create timer thread: %s", e2s(r));
  800191:	83 ec 0c             	sub    $0xc,%esp
  800194:	50                   	push   %eax
  800195:	e8 62 d7 00 00       	call   80d8fc <e2s>
  80019a:	83 c4 10             	add    $0x10,%esp
  80019d:	50                   	push   %eax
  80019e:	68 4c 1a 81 00       	push   $0x811a4c
  8001a3:	6a 7a                	push   $0x7a
  8001a5:	68 34 19 81 00       	push   $0x811934
  8001aa:	e8 1d 09 00 00       	call   800acc <_panic>
}
  8001af:	c9                   	leave  
  8001b0:	c3                   	ret    

008001b1 <tcpip_init_done>:

static void
tcpip_init_done(void *arg)
{
  8001b1:	55                   	push   %ebp
  8001b2:	89 e5                	mov    %esp,%ebp
  8001b4:	83 ec 14             	sub    $0x14,%esp
  8001b7:	8b 45 08             	mov    0x8(%ebp),%eax
    uint32_t *done = arg;
    *done = 1;
  8001ba:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    thread_wakeup(done);
  8001c0:	50                   	push   %eax
  8001c1:	e8 d5 d2 00 00       	call   80d49b <thread_wakeup>
}
  8001c6:	c9                   	leave  
  8001c7:	c3                   	ret    

008001c8 <serve_init>:

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  8001c8:	55                   	push   %ebp
  8001c9:	89 e5                	mov    %esp,%ebp
  8001cb:	53                   	push   %ebx
  8001cc:	83 ec 04             	sub    $0x4,%esp
  8001cf:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int r;
    lwip_core_lock();
  8001d2:	e8 89 d2 00 00       	call   80d460 <lwip_core_lock>

    uint32_t done = 0;
  8001d7:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
    tcpip_init(&tcpip_init_done, &done);
  8001de:	83 ec 08             	sub    $0x8,%esp
  8001e1:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  8001e4:	50                   	push   %eax
  8001e5:	68 b1 01 80 00       	push   $0x8001b1
  8001ea:	e8 35 4d 00 00       	call   804f24 <tcpip_init>
    lwip_core_unlock();
  8001ef:	e8 71 d2 00 00       	call   80d465 <lwip_core_unlock>
    thread_wait(&done, 0, (uint32_t)~0);
  8001f4:	83 c4 0c             	add    $0xc,%esp
  8001f7:	6a ff                	push   $0xffffffff
  8001f9:	6a 00                	push   $0x0
  8001fb:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  8001fe:	50                   	push   %eax
  8001ff:	e8 b8 d2 00 00       	call   80d4bc <thread_wait>
    lwip_core_lock();
  800204:	e8 57 d2 00 00       	call   80d460 <lwip_core_lock>

    lwip_init(&nif, &output_envid, ipaddr, netmask, gw);
  800209:	83 c4 04             	add    $0x4,%esp
  80020c:	ff 75 10             	pushl  0x10(%ebp)
  80020f:	ff 75 0c             	pushl  0xc(%ebp)
  800212:	53                   	push   %ebx
  800213:	68 0c 84 81 00       	push   $0x81840c
  800218:	68 20 e6 b3 00       	push   $0xb3e620
  80021d:	e8 a2 fe ff ff       	call   8000c4 <lwip_init>

    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  800222:	83 c4 20             	add    $0x20,%esp
  800225:	68 88 13 00 00       	push   $0x1388
  80022a:	68 3f 19 81 00       	push   $0x81193f
  80022f:	68 f1 bd 80 00       	push   $0x80bdf1
  800234:	68 e0 83 81 00       	push   $0x8183e0
  800239:	e8 24 ff ff ff       	call   800162 <start_timer>
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  80023e:	68 fa 00 00 00       	push   $0xfa
  800243:	68 49 19 81 00       	push   $0x811949
  800248:	68 33 8c 80 00       	push   $0x808c33
  80024d:	68 ec 83 81 00       	push   $0x8183ec
  800252:	e8 0b ff ff ff       	call   800162 <start_timer>
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800257:	83 c4 20             	add    $0x20,%esp
  80025a:	68 f4 01 00 00       	push   $0x1f4
  80025f:	68 55 19 81 00       	push   $0x811955
  800264:	68 f9 87 80 00       	push   $0x8087f9
  800269:	68 f8 83 81 00       	push   $0x8183f8
  80026e:	e8 ef fe ff ff       	call   800162 <start_timer>

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x" 
  800273:	83 ec 0c             	sub    $0xc,%esp
  800276:	53                   	push   %ebx
  800277:	e8 50 a3 00 00       	call   80a5cc <inet_ntoa>
  80027c:	83 c4 10             	add    $0x10,%esp
  80027f:	50                   	push   %eax
  800280:	0f b6 05 4a e6 b3 00 	movzbl 0xb3e64a,%eax
  800287:	50                   	push   %eax
  800288:	0f b6 05 49 e6 b3 00 	movzbl 0xb3e649,%eax
  80028f:	50                   	push   %eax
  800290:	0f b6 05 48 e6 b3 00 	movzbl 0xb3e648,%eax
  800297:	50                   	push   %eax
  800298:	0f b6 05 47 e6 b3 00 	movzbl 0xb3e647,%eax
  80029f:	50                   	push   %eax
  8002a0:	0f b6 05 46 e6 b3 00 	movzbl 0xb3e646,%eax
  8002a7:	50                   	push   %eax
  8002a8:	0f b6 05 45 e6 b3 00 	movzbl 0xb3e645,%eax
  8002af:	50                   	push   %eax
  8002b0:	68 6c 1a 81 00       	push   $0x811a6c
  8002b5:	e8 02 09 00 00       	call   800bbc <cprintf>
	    " bound to static IP %s\n", 
	    nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
	    nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
	    inet_ntoa(ia));
    
    lwip_core_unlock();
  8002ba:	83 c4 30             	add    $0x30,%esp
  8002bd:	e8 a3 d1 00 00       	call   80d465 <lwip_core_unlock>

    cprintf("NS: TCP/IP initialized.\n");
  8002c2:	83 ec 0c             	sub    $0xc,%esp
  8002c5:	68 61 19 81 00       	push   $0x811961
  8002ca:	e8 ed 08 00 00       	call   800bbc <cprintf>
}
  8002cf:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8002d2:	c9                   	leave  
  8002d3:	c3                   	ret    

008002d4 <serve_accept>:

static void
serve_accept(envid_t envid, struct Nsreq_accept* rq) {
  8002d4:	55                   	push   %ebp
  8002d5:	89 e5                	mov    %esp,%ebp
  8002d7:	57                   	push   %edi
  8002d8:	56                   	push   %esi
  8002d9:	53                   	push   %ebx
  8002da:	83 ec 0c             	sub    $0xc,%esp
    int r;
    struct Nsret_accept *ret;

    void *buf = get_buffer();
  8002dd:	e8 7b fd ff ff       	call   80005d <get_buffer>
  8002e2:	89 c3                	mov    %eax,%ebx
    sys_page_alloc(0, buf, PTE_P|PTE_W|PTE_U);
  8002e4:	83 ec 04             	sub    $0x4,%esp
  8002e7:	6a 07                	push   $0x7
  8002e9:	50                   	push   %eax
  8002ea:	6a 00                	push   $0x0
  8002ec:	e8 a1 12 00 00       	call   801592 <sys_page_alloc>

    ret = (struct Nsret_accept*)buf;
  8002f1:	89 df                	mov    %ebx,%edi
    r = lwip_accept(rq->req_s, &ret->ret_addr, &ret->ret_addrlen);
  8002f3:	83 c4 0c             	add    $0xc,%esp
  8002f6:	8d 43 10             	lea    0x10(%ebx),%eax
  8002f9:	50                   	push   %eax
  8002fa:	53                   	push   %ebx
  8002fb:	8b 45 0c             	mov    0xc(%ebp),%eax
  8002fe:	ff 30                	pushl  (%eax)
  800300:	e8 2a 30 00 00       	call   80332f <lwip_accept>
  800305:	89 c6                	mov    %eax,%esi
    if (r < 0) perror("serve_accept");
  800307:	83 c4 10             	add    $0x10,%esp
  80030a:	85 c0                	test   %eax,%eax
  80030c:	79 10                	jns    80031e <serve_accept+0x4a>
  80030e:	83 ec 0c             	sub    $0xc,%esp
  800311:	68 7a 19 81 00       	push   $0x81197a
  800316:	e8 bd d5 00 00       	call   80d8d8 <perror>
  80031b:	83 c4 10             	add    $0x10,%esp

    ipc_send(envid, r, ret, PTE_P|PTE_W|PTE_U);
  80031e:	6a 07                	push   $0x7
  800320:	57                   	push   %edi
  800321:	56                   	push   %esi
  800322:	ff 75 08             	pushl  0x8(%ebp)
  800325:	e8 c5 19 00 00       	call   801cef <ipc_send>
    sys_page_unmap(0, buf);
  80032a:	83 c4 08             	add    $0x8,%esp
  80032d:	53                   	push   %ebx
  80032e:	6a 00                	push   $0x0
  800330:	e8 e2 12 00 00       	call   801617 <sys_page_unmap>
    put_buffer(buf);
  800335:	53                   	push   %ebx
  800336:	e8 6e fd ff ff       	call   8000a9 <put_buffer>
}
  80033b:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80033e:	5b                   	pop    %ebx
  80033f:	5e                   	pop    %esi
  800340:	5f                   	pop    %edi
  800341:	c9                   	leave  
  800342:	c3                   	ret    

00800343 <serve_bind>:

static void
serve_bind(envid_t envid, struct Nsreq_bind* rq) {
  800343:	55                   	push   %ebp
  800344:	89 e5                	mov    %esp,%ebp
  800346:	53                   	push   %ebx
  800347:	83 ec 08             	sub    $0x8,%esp
  80034a:	8b 55 0c             	mov    0xc(%ebp),%edx
    int r = lwip_bind(rq->req_s, &rq->req_name, rq->req_namelen);
  80034d:	ff 72 14             	pushl  0x14(%edx)
  800350:	8d 42 04             	lea    0x4(%edx),%eax
  800353:	50                   	push   %eax
  800354:	ff 32                	pushl  (%edx)
  800356:	e8 c8 31 00 00       	call   803523 <lwip_bind>
  80035b:	89 c3                	mov    %eax,%ebx
    if (r < 0) perror("serve_bind");
  80035d:	83 c4 10             	add    $0x10,%esp
  800360:	85 c0                	test   %eax,%eax
  800362:	79 10                	jns    800374 <serve_bind+0x31>
  800364:	83 ec 0c             	sub    $0xc,%esp
  800367:	68 87 19 81 00       	push   $0x811987
  80036c:	e8 67 d5 00 00       	call   80d8d8 <perror>
  800371:	83 c4 10             	add    $0x10,%esp
    ipc_send(envid, r, 0, 0);
  800374:	6a 00                	push   $0x0
  800376:	6a 00                	push   $0x0
  800378:	53                   	push   %ebx
  800379:	ff 75 08             	pushl  0x8(%ebp)
  80037c:	e8 6e 19 00 00       	call   801cef <ipc_send>
}
  800381:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  800384:	c9                   	leave  
  800385:	c3                   	ret    

00800386 <serve_shutdown>:

static void
serve_shutdown(envid_t envid, struct Nsreq_shutdown* rq) {
  800386:	55                   	push   %ebp
  800387:	89 e5                	mov    %esp,%ebp
  800389:	53                   	push   %ebx
  80038a:	83 ec 0c             	sub    $0xc,%esp
  80038d:	8b 45 0c             	mov    0xc(%ebp),%eax
    int r = lwip_shutdown(rq->req_s, rq->req_how);
  800390:	ff 70 04             	pushl  0x4(%eax)
  800393:	ff 30                	pushl  (%eax)
  800395:	e8 ac 3f 00 00       	call   804346 <lwip_shutdown>
  80039a:	89 c3                	mov    %eax,%ebx
    if (r < 0) perror("serve_shutdown");
  80039c:	83 c4 10             	add    $0x10,%esp
  80039f:	85 c0                	test   %eax,%eax
  8003a1:	79 10                	jns    8003b3 <serve_shutdown+0x2d>
  8003a3:	83 ec 0c             	sub    $0xc,%esp
  8003a6:	68 92 19 81 00       	push   $0x811992
  8003ab:	e8 28 d5 00 00       	call   80d8d8 <perror>
  8003b0:	83 c4 10             	add    $0x10,%esp
    ipc_send(envid, r, 0, 0);
  8003b3:	6a 00                	push   $0x0
  8003b5:	6a 00                	push   $0x0
  8003b7:	53                   	push   %ebx
  8003b8:	ff 75 08             	pushl  0x8(%ebp)
  8003bb:	e8 2f 19 00 00       	call   801cef <ipc_send>
}
  8003c0:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8003c3:	c9                   	leave  
  8003c4:	c3                   	ret    

008003c5 <serve_close>:

static void
serve_close(envid_t envid, struct Nsreq_close* rq) {
  8003c5:	55                   	push   %ebp
  8003c6:	89 e5                	mov    %esp,%ebp
  8003c8:	53                   	push   %ebx
  8003c9:	83 ec 10             	sub    $0x10,%esp
    int r = lwip_close(rq->req_s);
  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8003cf:	ff 30                	pushl  (%eax)
  8003d1:	e8 0e 32 00 00       	call   8035e4 <lwip_close>
  8003d6:	89 c3                	mov    %eax,%ebx
    if (r < 0) perror("serve_close");
  8003d8:	83 c4 10             	add    $0x10,%esp
  8003db:	85 c0                	test   %eax,%eax
  8003dd:	79 10                	jns    8003ef <serve_close+0x2a>
  8003df:	83 ec 0c             	sub    $0xc,%esp
  8003e2:	68 a1 19 81 00       	push   $0x8119a1
  8003e7:	e8 ec d4 00 00       	call   80d8d8 <perror>
  8003ec:	83 c4 10             	add    $0x10,%esp
    ipc_send(envid, r, 0, 0);
  8003ef:	6a 00                	push   $0x0
  8003f1:	6a 00                	push   $0x0
  8003f3:	53                   	push   %ebx
  8003f4:	ff 75 08             	pushl  0x8(%ebp)
  8003f7:	e8 f3 18 00 00       	call   801cef <ipc_send>
}
  8003fc:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8003ff:	c9                   	leave  
  800400:	c3                   	ret    

00800401 <serve_connect>:

static void
serve_connect(envid_t envid, struct Nsreq_connect* rq) {
  800401:	55                   	push   %ebp
  800402:	89 e5                	mov    %esp,%ebp
  800404:	53                   	push   %ebx
  800405:	83 ec 08             	sub    $0x8,%esp
  800408:	8b 55 0c             	mov    0xc(%ebp),%edx
    int r = lwip_connect(rq->req_s, &rq->req_name, rq->req_namelen);
  80040b:	ff 72 14             	pushl  0x14(%edx)
  80040e:	8d 42 04             	lea    0x4(%edx),%eax
  800411:	50                   	push   %eax
  800412:	ff 32                	pushl  (%edx)
  800414:	e8 53 32 00 00       	call   80366c <lwip_connect>
  800419:	89 c3                	mov    %eax,%ebx
    if (r < 0) perror("serve_connect");
  80041b:	83 c4 10             	add    $0x10,%esp
  80041e:	85 c0                	test   %eax,%eax
  800420:	79 10                	jns    800432 <serve_connect+0x31>
  800422:	83 ec 0c             	sub    $0xc,%esp
  800425:	68 ad 19 81 00       	push   $0x8119ad
  80042a:	e8 a9 d4 00 00       	call   80d8d8 <perror>
  80042f:	83 c4 10             	add    $0x10,%esp
    ipc_send(envid, r, 0, 0);
  800432:	6a 00                	push   $0x0
  800434:	6a 00                	push   $0x0
  800436:	53                   	push   %ebx
  800437:	ff 75 08             	pushl  0x8(%ebp)
  80043a:	e8 b0 18 00 00       	call   801cef <ipc_send>
}
  80043f:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  800442:	c9                   	leave  
  800443:	c3                   	ret    

00800444 <serve_listen>:

static void
serve_listen(envid_t envid, struct Nsreq_listen* rq) {
  800444:	55                   	push   %ebp
  800445:	89 e5                	mov    %esp,%ebp
  800447:	53                   	push   %ebx
  800448:	83 ec 0c             	sub    $0xc,%esp
  80044b:	8b 45 0c             	mov    0xc(%ebp),%eax
    int r = lwip_listen(rq->req_s, rq->req_backlog);
  80044e:	ff 70 04             	pushl  0x4(%eax)
  800451:	ff 30                	pushl  (%eax)
  800453:	e8 ea 32 00 00       	call   803742 <lwip_listen>
  800458:	89 c3                	mov    %eax,%ebx
    if (r < 0) perror("serve_listen");
  80045a:	83 c4 10             	add    $0x10,%esp
  80045d:	85 c0                	test   %eax,%eax
  80045f:	79 10                	jns    800471 <serve_listen+0x2d>
  800461:	83 ec 0c             	sub    $0xc,%esp
  800464:	68 bb 19 81 00       	push   $0x8119bb
  800469:	e8 6a d4 00 00       	call   80d8d8 <perror>
  80046e:	83 c4 10             	add    $0x10,%esp
    ipc_send(envid, r, 0, 0);
  800471:	6a 00                	push   $0x0
  800473:	6a 00                	push   $0x0
  800475:	53                   	push   %ebx
  800476:	ff 75 08             	pushl  0x8(%ebp)
  800479:	e8 71 18 00 00       	call   801cef <ipc_send>
}
  80047e:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  800481:	c9                   	leave  
  800482:	c3                   	ret    

00800483 <serve_recv>:

static void
serve_recv(envid_t envid, struct Nsreq_recv* rq) {
  800483:	55                   	push   %ebp
  800484:	89 e5                	mov    %esp,%ebp
  800486:	53                   	push   %ebx
  800487:	83 ec 04             	sub    $0x4,%esp
  80048a:	8b 45 0c             	mov    0xc(%ebp),%eax
    int r;
    void *mem;
    extern uint8_t nsipcbuf[PGSIZE];	// page-aligned, declared in entry.S

    mem = (void *)nsipcbuf;
    r = lwip_recv(rq->req_s, mem, rq->req_len, rq->req_flags);
  80048d:	ff 70 08             	pushl  0x8(%eax)
  800490:	ff 70 04             	pushl  0x4(%eax)
  800493:	68 00 70 81 00       	push   $0x817000
  800498:	ff 30                	pushl  (%eax)
  80049a:	e8 9c 35 00 00       	call   803a3b <lwip_recv>
  80049f:	89 c3                	mov    %eax,%ebx
    if (r < 0) perror("serve_recv");
  8004a1:	83 c4 10             	add    $0x10,%esp
  8004a4:	85 c0                	test   %eax,%eax
  8004a6:	79 10                	jns    8004b8 <serve_recv+0x35>
  8004a8:	83 ec 0c             	sub    $0xc,%esp
  8004ab:	68 c8 19 81 00       	push   $0x8119c8
  8004b0:	e8 23 d4 00 00       	call   80d8d8 <perror>
  8004b5:	83 c4 10             	add    $0x10,%esp

    ipc_send(envid, r, mem, PTE_P|PTE_W|PTE_U);
  8004b8:	6a 07                	push   $0x7
  8004ba:	68 00 70 81 00       	push   $0x817000
  8004bf:	53                   	push   %ebx
  8004c0:	ff 75 08             	pushl  0x8(%ebp)
  8004c3:	e8 27 18 00 00       	call   801cef <ipc_send>
}
  8004c8:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8004cb:	c9                   	leave  
  8004cc:	c3                   	ret    

008004cd <serve_send>:

static void
serve_send(envid_t envid, struct Nsreq_send* rq) {
  8004cd:	55                   	push   %ebp
  8004ce:	89 e5                	mov    %esp,%ebp
  8004d0:	53                   	push   %ebx
  8004d1:	83 ec 04             	sub    $0x4,%esp
  8004d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    int r = lwip_send(rq->req_s, &rq->req_dataptr, rq->req_size, rq->req_flags);
  8004d7:	ff 70 08             	pushl  0x8(%eax)
  8004da:	ff 70 04             	pushl  0x4(%eax)
  8004dd:	8d 50 0c             	lea    0xc(%eax),%edx
  8004e0:	52                   	push   %edx
  8004e1:	ff 30                	pushl  (%eax)
  8004e3:	e8 70 35 00 00       	call   803a58 <lwip_send>
  8004e8:	89 c3                	mov    %eax,%ebx
    if (r < 0) perror("serve_send");
  8004ea:	83 c4 10             	add    $0x10,%esp
  8004ed:	85 c0                	test   %eax,%eax
  8004ef:	79 10                	jns    800501 <serve_send+0x34>
  8004f1:	83 ec 0c             	sub    $0xc,%esp
  8004f4:	68 d3 19 81 00       	push   $0x8119d3
  8004f9:	e8 da d3 00 00       	call   80d8d8 <perror>
  8004fe:	83 c4 10             	add    $0x10,%esp
    ipc_send(envid, r, 0, 0);
  800501:	6a 00                	push   $0x0
  800503:	6a 00                	push   $0x0
  800505:	53                   	push   %ebx
  800506:	ff 75 08             	pushl  0x8(%ebp)
  800509:	e8 e1 17 00 00       	call   801cef <ipc_send>
}
  80050e:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  800511:	c9                   	leave  
  800512:	c3                   	ret    

00800513 <serve_socket>:

static void
serve_socket(envid_t envid, struct Nsreq_socket *rq) {
  800513:	55                   	push   %ebp
  800514:	89 e5                	mov    %esp,%ebp
  800516:	53                   	push   %ebx
  800517:	83 ec 08             	sub    $0x8,%esp
  80051a:	8b 45 0c             	mov    0xc(%ebp),%eax
    int r = lwip_socket(rq->req_domain, rq->req_type, rq->req_protocol);
  80051d:	ff 70 08             	pushl  0x8(%eax)
  800520:	ff 70 04             	pushl  0x4(%eax)
  800523:	ff 30                	pushl  (%eax)
  800525:	e8 26 37 00 00       	call   803c50 <lwip_socket>
  80052a:	89 c3                	mov    %eax,%ebx
    if (r < 0) perror("serve_socket");
  80052c:	83 c4 10             	add    $0x10,%esp
  80052f:	85 c0                	test   %eax,%eax
  800531:	79 10                	jns    800543 <serve_socket+0x30>
  800533:	83 ec 0c             	sub    $0xc,%esp
  800536:	68 de 19 81 00       	push   $0x8119de
  80053b:	e8 98 d3 00 00       	call   80d8d8 <perror>
  800540:	83 c4 10             	add    $0x10,%esp
    ipc_send(envid, r, 0, 0);
  800543:	6a 00                	push   $0x0
  800545:	6a 00                	push   $0x0
  800547:	53                   	push   %ebx
  800548:	ff 75 08             	pushl  0x8(%ebp)
  80054b:	e8 9f 17 00 00       	call   801cef <ipc_send>
}
  800550:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  800553:	c9                   	leave  
  800554:	c3                   	ret    

00800555 <process_timer>:

static void
process_timer(envid_t envid) {
  800555:	55                   	push   %ebp
  800556:	89 e5                	mov    %esp,%ebp
  800558:	56                   	push   %esi
  800559:	53                   	push   %ebx
  80055a:	8b 75 08             	mov    0x8(%ebp),%esi
    uint32_t start, now, to;

    if (envid != timer_envid) {
  80055d:	3b 35 04 84 81 00    	cmp    0x818404,%esi
  800563:	74 10                	je     800575 <process_timer+0x20>
	cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  800565:	83 ec 08             	sub    $0x8,%esp
  800568:	56                   	push   %esi
  800569:	68 a8 1a 81 00       	push   $0x811aa8
  80056e:	e8 49 06 00 00       	call   800bbc <cprintf>
	return;
  800573:	eb 25                	jmp    80059a <process_timer+0x45>
    }

    start = sys_time_msec();
  800575:	e8 8d 12 00 00       	call   801807 <sys_time_msec>
  80057a:	89 c3                	mov    %eax,%ebx
    thread_yield();
  80057c:	e8 f6 d1 00 00       	call   80d777 <thread_yield>
    now = sys_time_msec();
  800581:	e8 81 12 00 00       	call   801807 <sys_time_msec>

    to = TIMER_INTERVAL - (now - start);
  800586:	29 d8                	sub    %ebx,%eax
  800588:	ba fa 00 00 00       	mov    $0xfa,%edx
  80058d:	29 c2                	sub    %eax,%edx
    ipc_send(envid, to, 0, 0);
  80058f:	6a 00                	push   $0x0
  800591:	6a 00                	push   $0x0
  800593:	52                   	push   %edx
  800594:	56                   	push   %esi
  800595:	e8 55 17 00 00       	call   801cef <ipc_send>
}
  80059a:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80059d:	5b                   	pop    %ebx
  80059e:	5e                   	pop    %esi
  80059f:	c9                   	leave  
  8005a0:	c3                   	ret    

008005a1 <net_recv>:

static void
net_recv(envid_t envid, struct jif_pkt* pkt) {
  8005a1:	55                   	push   %ebp
  8005a2:	89 e5                	mov    %esp,%ebp
  8005a4:	53                   	push   %ebx
  8005a5:	83 ec 0c             	sub    $0xc,%esp
  8005a8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    jif_input(&nif, (void *)pkt);
  8005ab:	53                   	push   %ebx
  8005ac:	68 20 e6 b3 00       	push   $0xb3e620
  8005b1:	e8 e4 d4 00 00       	call   80da9a <jif_input>
    sys_page_unmap(0, (void*)pkt);
  8005b6:	83 c4 08             	add    $0x8,%esp
  8005b9:	53                   	push   %ebx
  8005ba:	6a 00                	push   $0x0
  8005bc:	e8 56 10 00 00       	call   801617 <sys_page_unmap>
}
  8005c1:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8005c4:	c9                   	leave  
  8005c5:	c3                   	ret    

008005c6 <serve_thread>:

struct st_args {
	int32_t req;
	uint32_t whom;
	void *va;
};

static void
serve_thread(uint32_t a) {
  8005c6:	55                   	push   %ebp
  8005c7:	89 e5                	mov    %esp,%ebp
  8005c9:	53                   	push   %ebx
  8005ca:	83 ec 04             	sub    $0x4,%esp
	struct st_args *args = (struct st_args *)a;
  8005cd:	8b 5d 08             	mov    0x8(%ebp),%ebx

	switch (args->req) {
  8005d0:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8005d3:	0f 87 d3 00 00 00    	ja     8006ac <serve_thread+0xe6>
  8005d9:	8b 03                	mov    (%ebx),%eax
  8005db:	ff 24 85 64 1b 81 00 	jmp    *0x811b64(,%eax,4)
	  case NSREQ_ACCEPT:
		serve_accept(args->whom, (struct Nsreq_accept*)args->va);
  8005e2:	83 ec 08             	sub    $0x8,%esp
  8005e5:	ff 73 08             	pushl  0x8(%ebx)
  8005e8:	ff 73 04             	pushl  0x4(%ebx)
  8005eb:	e8 e4 fc ff ff       	call   8002d4 <serve_accept>
		break;
  8005f0:	83 c4 10             	add    $0x10,%esp
  8005f3:	e9 c9 00 00 00       	jmp    8006c1 <serve_thread+0xfb>
	  case NSREQ_BIND:
		serve_bind(args->whom, (struct Nsreq_bind*)args->va);
  8005f8:	83 ec 08             	sub    $0x8,%esp
  8005fb:	ff 73 08             	pushl  0x8(%ebx)
  8005fe:	ff 73 04             	pushl  0x4(%ebx)
  800601:	e8 3d fd ff ff       	call   800343 <serve_bind>
		break;
  800606:	83 c4 10             	add    $0x10,%esp
  800609:	e9 b3 00 00 00       	jmp    8006c1 <serve_thread+0xfb>
	  case NSREQ_SHUTDOWN:
		serve_shutdown(args->whom, (struct Nsreq_shutdown*)args->va);
  80060e:	83 ec 08             	sub    $0x8,%esp
  800611:	ff 73 08             	pushl  0x8(%ebx)
  800614:	ff 73 04             	pushl  0x4(%ebx)
  800617:	e8 6a fd ff ff       	call   800386 <serve_shutdown>
		break;
  80061c:	83 c4 10             	add    $0x10,%esp
  80061f:	e9 9d 00 00 00       	jmp    8006c1 <serve_thread+0xfb>
	  case NSREQ_CLOSE:
		serve_close(args->whom, (struct Nsreq_close*)args->va);
  800624:	83 ec 08             	sub    $0x8,%esp
  800627:	ff 73 08             	pushl  0x8(%ebx)
  80062a:	ff 73 04             	pushl  0x4(%ebx)
  80062d:	e8 93 fd ff ff       	call   8003c5 <serve_close>
		break;
  800632:	83 c4 10             	add    $0x10,%esp
  800635:	e9 87 00 00 00       	jmp    8006c1 <serve_thread+0xfb>
	  case NSREQ_CONNECT:
		serve_connect(args->whom, (struct Nsreq_connect*)args->va);
  80063a:	83 ec 08             	sub    $0x8,%esp
  80063d:	ff 73 08             	pushl  0x8(%ebx)
  800640:	ff 73 04             	pushl  0x4(%ebx)
  800643:	e8 b9 fd ff ff       	call   800401 <serve_connect>
		break;
  800648:	83 c4 10             	add    $0x10,%esp
  80064b:	eb 74                	jmp    8006c1 <serve_thread+0xfb>
	  case NSREQ_LISTEN:
		serve_listen(args->whom, (struct Nsreq_listen*)args->va);
  80064d:	83 ec 08             	sub    $0x8,%esp
  800650:	ff 73 08             	pushl  0x8(%ebx)
  800653:	ff 73 04             	pushl  0x4(%ebx)
  800656:	e8 e9 fd ff ff       	call   800444 <serve_listen>
		break;
  80065b:	83 c4 10             	add    $0x10,%esp
  80065e:	eb 61                	jmp    8006c1 <serve_thread+0xfb>
	  case NSREQ_RECV:
		serve_recv(args->whom, (struct Nsreq_recv*)args->va);
  800660:	83 ec 08             	sub    $0x8,%esp
  800663:	ff 73 08             	pushl  0x8(%ebx)
  800666:	ff 73 04             	pushl  0x4(%ebx)
  800669:	e8 15 fe ff ff       	call   800483 <serve_recv>
		break;
  80066e:	83 c4 10             	add    $0x10,%esp
  800671:	eb 4e                	jmp    8006c1 <serve_thread+0xfb>
	  case NSREQ_SEND:
		serve_send(args->whom, (struct Nsreq_send*)args->va);
  800673:	83 ec 08             	sub    $0x8,%esp
  800676:	ff 73 08             	pushl  0x8(%ebx)
  800679:	ff 73 04             	pushl  0x4(%ebx)
  80067c:	e8 4c fe ff ff       	call   8004cd <serve_send>
		break;
  800681:	83 c4 10             	add    $0x10,%esp
  800684:	eb 3b                	jmp    8006c1 <serve_thread+0xfb>
	  case NSREQ_SOCKET:
		serve_socket(args->whom, (struct Nsreq_socket*)args->va);
  800686:	83 ec 08             	sub    $0x8,%esp
  800689:	ff 73 08             	pushl  0x8(%ebx)
  80068c:	ff 73 04             	pushl  0x4(%ebx)
  80068f:	e8 7f fe ff ff       	call   800513 <serve_socket>
		break;
  800694:	83 c4 10             	add    $0x10,%esp
  800697:	eb 28                	jmp    8006c1 <serve_thread+0xfb>
	  case NSREQ_INPUT:
		net_recv(args->whom, (struct jif_pkt*)args->va);
  800699:	83 ec 08             	sub    $0x8,%esp
  80069c:	ff 73 08             	pushl  0x8(%ebx)
  80069f:	ff 73 04             	pushl  0x4(%ebx)
  8006a2:	e8 fa fe ff ff       	call   8005a1 <net_recv>
		break;
  8006a7:	83 c4 10             	add    $0x10,%esp
  8006aa:	eb 15                	jmp    8006c1 <serve_thread+0xfb>
	  default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  8006ac:	83 ec 04             	sub    $0x4,%esp
  8006af:	ff 33                	pushl  (%ebx)
  8006b1:	ff 73 04             	pushl  0x4(%ebx)
  8006b4:	68 e4 1a 81 00       	push   $0x811ae4
  8006b9:	e8 fe 04 00 00       	call   800bbc <cprintf>
		break;
  8006be:	83 c4 10             	add    $0x10,%esp
	}

	put_buffer(args->va);
  8006c1:	ff 73 08             	pushl  0x8(%ebx)
  8006c4:	e8 e0 f9 ff ff       	call   8000a9 <put_buffer>
	sys_page_unmap(0, (void*) args->va);
  8006c9:	83 ec 04             	sub    $0x4,%esp
  8006cc:	ff 73 08             	pushl  0x8(%ebx)
  8006cf:	6a 00                	push   $0x0
  8006d1:	e8 41 0f 00 00       	call   801617 <sys_page_unmap>
	free(args);
  8006d6:	89 1c 24             	mov    %ebx,(%esp)
  8006d9:	e8 87 24 00 00       	call   802b65 <free>
}
  8006de:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8006e1:	c9                   	leave  
  8006e2:	c3                   	ret    

008006e3 <serve>:

void
serve(void) {
  8006e3:	55                   	push   %ebp
  8006e4:	89 e5                	mov    %esp,%ebp
  8006e6:	56                   	push   %esi
  8006e7:	53                   	push   %ebx
  8006e8:	83 ec 10             	sub    $0x10,%esp
	int32_t req;
	uint32_t whom;
	int perm;
	void *va;
	
	while (1) {
		perm = 0;
  8006eb:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
		va = get_buffer();
  8006f2:	e8 66 f9 ff ff       	call   80005d <get_buffer>
  8006f7:	89 c3                	mov    %eax,%ebx
		req = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8006f9:	83 ec 04             	sub    $0x4,%esp
  8006fc:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  8006ff:	50                   	push   %eax
  800700:	53                   	push   %ebx
  800701:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  800704:	50                   	push   %eax
  800705:	e8 82 15 00 00       	call   801c8c <ipc_recv>
  80070a:	89 c6                	mov    %eax,%esi
		if (debug) {
  80070c:	83 c4 10             	add    $0x10,%esp
			cprintf("ns req %d from %08x\n", req, whom);
		}

		// first take care of requests that do not contain an argument page
		switch (req) {
  80070f:	83 f8 0c             	cmp    $0xc,%eax
  800712:	75 16                	jne    80072a <serve+0x47>
		  case NSREQ_TIMER:
			process_timer(whom);
  800714:	83 ec 0c             	sub    $0xc,%esp
  800717:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  80071a:	e8 36 fe ff ff       	call   800555 <process_timer>
			put_buffer(va);
  80071f:	53                   	push   %ebx
  800720:	e8 84 f9 ff ff       	call   8000a9 <put_buffer>
			continue;
  800725:	83 c4 14             	add    $0x14,%esp
  800728:	eb c1                	jmp    8006eb <serve+0x8>
		  default:
			break;
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  80072a:	f6 45 f4 01          	testb  $0x1,0xfffffff4(%ebp)
  80072e:	75 15                	jne    800745 <serve+0x62>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  800730:	83 ec 08             	sub    $0x8,%esp
  800733:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  800736:	68 08 1b 81 00       	push   $0x811b08
  80073b:	e8 7c 04 00 00       	call   800bbc <cprintf>
			continue; // just leave it hanging...
  800740:	83 c4 10             	add    $0x10,%esp
  800743:	eb a6                	jmp    8006eb <serve+0x8>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  800745:	83 ec 0c             	sub    $0xc,%esp
  800748:	6a 0c                	push   $0xc
  80074a:	e8 90 22 00 00       	call   8029df <malloc>
  80074f:	89 c2                	mov    %eax,%edx
		if (!args)
  800751:	83 c4 10             	add    $0x10,%esp
  800754:	85 c0                	test   %eax,%eax
  800756:	75 17                	jne    80076f <serve+0x8c>
			panic("could not allocate thread args structure");
  800758:	83 ec 04             	sub    $0x4,%esp
  80075b:	68 38 1b 81 00       	push   $0x811b38
  800760:	68 5f 01 00 00       	push   $0x15f
  800765:	68 34 19 81 00       	push   $0x811934
  80076a:	e8 5d 03 00 00       	call   800acc <_panic>

		args->req = req;
  80076f:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  800771:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  800774:	89 42 04             	mov    %eax,0x4(%edx)
		args->va = va;
  800777:	89 5a 08             	mov    %ebx,0x8(%edx)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  80077a:	52                   	push   %edx
  80077b:	68 c6 05 80 00       	push   $0x8005c6
  800780:	68 eb 19 81 00       	push   $0x8119eb
  800785:	6a 00                	push   $0x0
  800787:	e8 42 ce 00 00       	call   80d5ce <thread_create>
		thread_yield(); // let the thread created run
  80078c:	e8 e6 cf 00 00       	call   80d777 <thread_yield>
  800791:	83 c4 10             	add    $0x10,%esp
  800794:	e9 52 ff ff ff       	jmp    8006eb <serve+0x8>

00800799 <tmain>:
	}
}

static void
tmain(uint32_t arg) {
  800799:	55                   	push   %ebp
  80079a:	89 e5                	mov    %esp,%ebp
  80079c:	83 ec 14             	sub    $0x14,%esp
	serve_init(inet_addr(IP),
  80079f:	68 f8 19 81 00       	push   $0x8119f8
  8007a4:	e8 47 9c 00 00       	call   80a3f0 <inet_addr>
  8007a9:	83 c4 0c             	add    $0xc,%esp
  8007ac:	50                   	push   %eax
  8007ad:	83 ec 04             	sub    $0x4,%esp
  8007b0:	68 01 1a 81 00       	push   $0x811a01
  8007b5:	e8 36 9c 00 00       	call   80a3f0 <inet_addr>
  8007ba:	83 c4 08             	add    $0x8,%esp
  8007bd:	50                   	push   %eax
  8007be:	68 0f 1a 81 00       	push   $0x811a0f
  8007c3:	e8 28 9c 00 00       	call   80a3f0 <inet_addr>
  8007c8:	89 04 24             	mov    %eax,(%esp)
  8007cb:	e8 f8 f9 ff ff       	call   8001c8 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  8007d0:	e8 0e ff ff ff       	call   8006e3 <serve>
}
  8007d5:	c9                   	leave  
  8007d6:	c3                   	ret    

008007d7 <umain>:

void
umain(void)
{
  8007d7:	55                   	push   %ebp
  8007d8:	89 e5                	mov    %esp,%ebp
  8007da:	53                   	push   %ebx
  8007db:	83 ec 04             	sub    $0x4,%esp
	envid_t ns_envid = sys_getenvid();
  8007de:	e8 71 0d 00 00       	call   801554 <sys_getenvid>
  8007e3:	89 c3                	mov    %eax,%ebx

        binaryname = "ns";
  8007e5:	c7 05 00 80 81 00 10 	movl   $0x812310,0x818000
  8007ec:	23 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  8007ef:	e8 0e 13 00 00       	call   801b02 <fork>
  8007f4:	a3 04 84 81 00       	mov    %eax,0x818404
	if (timer_envid < 0)
  8007f9:	85 c0                	test   %eax,%eax
  8007fb:	79 17                	jns    800814 <umain+0x3d>
		panic("error forking");
  8007fd:	83 ec 04             	sub    $0x4,%esp
  800800:	68 19 1a 81 00       	push   $0x811a19
  800805:	68 7c 01 00 00       	push   $0x17c
  80080a:	68 34 19 81 00       	push   $0x811934
  80080f:	e8 b8 02 00 00       	call   800acc <_panic>
	else if (timer_envid == 0) {
  800814:	83 3d 04 84 81 00 00 	cmpl   $0x0,0x818404
  80081b:	75 13                	jne    800830 <umain+0x59>
		timer(ns_envid, TIMER_INTERVAL);
  80081d:	83 ec 08             	sub    $0x8,%esp
  800820:	68 fa 00 00 00       	push   $0xfa
  800825:	53                   	push   %ebx
  800826:	e8 99 00 00 00       	call   8008c4 <timer>
		return;
  80082b:	e9 8f 00 00 00       	jmp    8008bf <umain+0xe8>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  800830:	e8 cd 12 00 00       	call   801b02 <fork>
  800835:	a3 08 84 81 00       	mov    %eax,0x818408
	if (input_envid < 0)
  80083a:	85 c0                	test   %eax,%eax
  80083c:	79 17                	jns    800855 <umain+0x7e>
		panic("error forking");
  80083e:	83 ec 04             	sub    $0x4,%esp
  800841:	68 19 1a 81 00       	push   $0x811a19
  800846:	68 86 01 00 00       	push   $0x186
  80084b:	68 34 19 81 00       	push   $0x811934
  800850:	e8 77 02 00 00       	call   800acc <_panic>
	else if (input_envid == 0) {
  800855:	83 3d 08 84 81 00 00 	cmpl   $0x0,0x818408
  80085c:	75 0b                	jne    800869 <umain+0x92>
		input(ns_envid);
  80085e:	83 ec 0c             	sub    $0xc,%esp
  800861:	53                   	push   %ebx
  800862:	e8 d5 00 00 00       	call   80093c <input>
		return;
  800867:	eb 56                	jmp    8008bf <umain+0xe8>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  800869:	e8 94 12 00 00       	call   801b02 <fork>
  80086e:	a3 0c 84 81 00       	mov    %eax,0x81840c
	if (output_envid < 0)
  800873:	85 c0                	test   %eax,%eax
  800875:	79 17                	jns    80088e <umain+0xb7>
		panic("error forking");
  800877:	83 ec 04             	sub    $0x4,%esp
  80087a:	68 19 1a 81 00       	push   $0x811a19
  80087f:	68 90 01 00 00       	push   $0x190
  800884:	68 34 19 81 00       	push   $0x811934
  800889:	e8 3e 02 00 00       	call   800acc <_panic>
	else if (output_envid == 0) {
  80088e:	83 3d 0c 84 81 00 00 	cmpl   $0x0,0x81840c
  800895:	75 0b                	jne    8008a2 <umain+0xcb>
		output(ns_envid);
  800897:	83 ec 0c             	sub    $0xc,%esp
  80089a:	53                   	push   %ebx
  80089b:	e8 60 01 00 00       	call   800a00 <output>
		return;
  8008a0:	eb 1d                	jmp    8008bf <umain+0xe8>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization. 
	thread_init();
  8008a2:	e8 c5 cb 00 00       	call   80d46c <thread_init>
	thread_create(0, "main", tmain, 0);
  8008a7:	6a 00                	push   $0x0
  8008a9:	68 99 07 80 00       	push   $0x800799
  8008ae:	68 27 1a 81 00       	push   $0x811a27
  8008b3:	6a 00                	push   $0x0
  8008b5:	e8 14 cd 00 00       	call   80d5ce <thread_create>
	thread_yield();
  8008ba:	e8 b8 ce 00 00       	call   80d777 <thread_yield>
	// never coming here!
}
  8008bf:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8008c2:	c9                   	leave  
  8008c3:	c3                   	ret    

008008c4 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  8008c4:	55                   	push   %ebp
  8008c5:	89 e5                	mov    %esp,%ebp
  8008c7:	56                   	push   %esi
  8008c8:	53                   	push   %ebx
  8008c9:	83 ec 10             	sub    $0x10,%esp
  8008cc:	8b 75 08             	mov    0x8(%ebp),%esi
	uint32_t stop = sys_time_msec() + initial_to;
  8008cf:	e8 33 0f 00 00       	call   801807 <sys_time_msec>
  8008d4:	89 c3                	mov    %eax,%ebx
  8008d6:	03 5d 0c             	add    0xc(%ebp),%ebx

	binaryname = "ns_timer";
  8008d9:	c7 05 00 80 81 00 90 	movl   $0x811b90,0x818000
  8008e0:	1b 81 00 

	while (1) {
		while(sys_time_msec() < stop) {
  8008e3:	eb 05                	jmp    8008ea <timer+0x26>
			sys_yield();
  8008e5:	e8 89 0c 00 00       	call   801573 <sys_yield>
  8008ea:	e8 18 0f 00 00       	call   801807 <sys_time_msec>
  8008ef:	39 d8                	cmp    %ebx,%eax
  8008f1:	72 f2                	jb     8008e5 <timer+0x21>
		}

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8008f3:	6a 00                	push   $0x0
  8008f5:	6a 00                	push   $0x0
  8008f7:	6a 0c                	push   $0xc
  8008f9:	56                   	push   %esi
  8008fa:	e8 f0 13 00 00       	call   801cef <ipc_send>

		while (1) {
  8008ff:	83 c4 10             	add    $0x10,%esp
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800902:	83 ec 04             	sub    $0x4,%esp
  800905:	6a 00                	push   $0x0
  800907:	6a 00                	push   $0x0
  800909:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  80090c:	50                   	push   %eax
  80090d:	e8 7a 13 00 00       	call   801c8c <ipc_recv>
  800912:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  800914:	83 c4 10             	add    $0x10,%esp
  800917:	3b 75 f4             	cmp    0xfffffff4(%ebp),%esi
  80091a:	74 15                	je     800931 <timer+0x6d>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  80091c:	83 ec 08             	sub    $0x8,%esp
  80091f:	ff 75 f4             	pushl  0xfffffff4(%ebp)
  800922:	68 9c 1b 81 00       	push   $0x811b9c
  800927:	e8 90 02 00 00       	call   800bbc <cprintf>
				continue;
  80092c:	83 c4 10             	add    $0x10,%esp
  80092f:	eb d1                	jmp    800902 <timer+0x3e>
			}

			stop = sys_time_msec() + to;
  800931:	e8 d1 0e 00 00       	call   801807 <sys_time_msec>
  800936:	8d 1c 18             	lea    (%eax,%ebx,1),%ebx
			break;
  800939:	eb af                	jmp    8008ea <timer+0x26>
	...

0080093c <input>:
#include "kern/e100.h"

void
input(envid_t ns_envid)
{
  80093c:	55                   	push   %ebp
  80093d:	89 e5                	mov    %esp,%ebp
  80093f:	57                   	push   %edi
  800940:	56                   	push   %esi
  800941:	53                   	push   %ebx
  800942:	83 ec 0c             	sub    $0xc,%esp
  800945:	8b 7d 08             	mov    0x8(%ebp),%edi
	binaryname = "ns_input";
  800948:	c7 05 00 80 81 00 d7 	movl   $0x811bd7,0x818000
  80094f:	1b 81 00 

	// LAB 6: Your code here:
	// 	- read a packet from the device driver
	//	- send it to the network server
	int r;
	//struct jif_pkt* packet = (struct jif_pkt*) UTEMP;

        // Challenge
        // Allocate pages for which the RU can write to
        int curr_buffer = 0;
  800952:	be 00 00 00 00       	mov    $0x0,%esi
	struct jif_pkt* packet;
        int *packetidx = 0;
        struct Page *packetpage;
        int pidx;
        for (pidx = 0; pidx < DMA_RU_SIZE; pidx++) {
  800957:	bb 00 00 00 00       	mov    $0x0,%ebx
	  if ((r = sys_page_alloc(sys_getenvid(), UTEMP + (pidx * PGSIZE), PTE_P | PTE_W | PTE_U)) < 0) {
  80095c:	83 ec 04             	sub    $0x4,%esp
  80095f:	6a 07                	push   $0x7
  800961:	89 d8                	mov    %ebx,%eax
  800963:	c1 e0 0c             	shl    $0xc,%eax
  800966:	05 00 00 40 00       	add    $0x400000,%eax
  80096b:	50                   	push   %eax
  80096c:	83 ec 04             	sub    $0x4,%esp
  80096f:	e8 e0 0b 00 00       	call   801554 <sys_getenvid>
  800974:	89 04 24             	mov    %eax,(%esp)
  800977:	e8 16 0c 00 00       	call   801592 <sys_page_alloc>
  80097c:	83 c4 10             	add    $0x10,%esp
  80097f:	85 c0                	test   %eax,%eax
  800981:	79 12                	jns    800995 <input+0x59>
            // sys_page_alloc memsets to zero
	    panic("input: %e", r);
  800983:	50                   	push   %eax
  800984:	68 e0 1b 81 00       	push   $0x811be0
  800989:	6a 19                	push   $0x19
  80098b:	68 ea 1b 81 00       	push   $0x811bea
  800990:	e8 37 01 00 00       	call   800acc <_panic>
  800995:	43                   	inc    %ebx
  800996:	83 fb 02             	cmp    $0x2,%ebx
  800999:	7e c1                	jle    80095c <input+0x20>
	  }
        }

        // Tell the kernel about the pages that we just made
        if ((r = sys_map_receive_buffers((char *)UTEMP)) < 0) {
  80099b:	83 ec 0c             	sub    $0xc,%esp
  80099e:	68 00 00 40 00       	push   $0x400000
  8009a3:	e8 7e 0e 00 00       	call   801826 <sys_map_receive_buffers>
  8009a8:	83 c4 10             	add    $0x10,%esp
  8009ab:	85 c0                	test   %eax,%eax
  8009ad:	79 12                	jns    8009c1 <input+0x85>
          panic("input.c; failed to tell e100 about receive buffers: %e", r);
  8009af:	50                   	push   %eax
  8009b0:	68 f8 1b 81 00       	push   $0x811bf8
  8009b5:	6a 1f                	push   $0x1f
  8009b7:	68 ea 1b 81 00       	push   $0x811bea
  8009bc:	e8 0b 01 00 00       	call   800acc <_panic>
        }

	while(1) {
          // Keep checking if the current page has any packets
	  struct jif_pkt* packet = (struct jif_pkt*) (UTEMP + (curr_buffer * PGSIZE));
  8009c1:	89 f0                	mov    %esi,%eax
  8009c3:	c1 e0 0c             	shl    $0xc,%eax
  8009c6:	8d 98 00 00 40 00    	lea    0x400000(%eax),%ebx
          if ((r = sys_receive_packet_zerocopy(&packet->jp_len)) < 0) {
  8009cc:	83 ec 0c             	sub    $0xc,%esp
  8009cf:	53                   	push   %ebx
  8009d0:	e8 92 0e 00 00       	call   801867 <sys_receive_packet_zerocopy>
  8009d5:	83 c4 10             	add    $0x10,%esp
  8009d8:	85 c0                	test   %eax,%eax
  8009da:	79 07                	jns    8009e3 <input+0xa7>
            sys_yield();
  8009dc:	e8 92 0b 00 00       	call   801573 <sys_yield>
  8009e1:	eb de                	jmp    8009c1 <input+0x85>
          } else {
	    ipc_send(ns_envid, NSREQ_INPUT, packet, PTE_P | PTE_W | PTE_U);
  8009e3:	6a 07                	push   $0x7
  8009e5:	53                   	push   %ebx
  8009e6:	6a 0a                	push   $0xa
  8009e8:	57                   	push   %edi
  8009e9:	e8 01 13 00 00       	call   801cef <ipc_send>
            curr_buffer = (curr_buffer + 1) % DMA_RU_SIZE;
  8009ee:	8d 46 01             	lea    0x1(%esi),%eax
  8009f1:	b9 03 00 00 00       	mov    $0x3,%ecx
  8009f6:	99                   	cltd   
  8009f7:	f7 f9                	idiv   %ecx
  8009f9:	89 d6                	mov    %edx,%esi
  8009fb:	83 c4 10             	add    $0x10,%esp
  8009fe:	eb c1                	jmp    8009c1 <input+0x85>

00800a00 <output>:


void
output(envid_t ns_envid)
{
  800a00:	55                   	push   %ebp
  800a01:	89 e5                	mov    %esp,%ebp
  800a03:	56                   	push   %esi
  800a04:	53                   	push   %ebx
  800a05:	83 ec 10             	sub    $0x10,%esp
  800a08:	8b 75 08             	mov    0x8(%ebp),%esi
  int r;
  envid_t fromenv;
  void *pg  = (void *)PKTMAP;
  800a0b:	bb 00 00 00 10       	mov    $0x10000000,%ebx
  struct jif_pkt *packet;

	binaryname = "ns_output";
  800a10:	c7 05 00 80 81 00 2f 	movl   $0x811c2f,0x818000
  800a17:	1c 81 00 
	// LAB 6: Your code here:
	// 	- read a packet from the network server
	//	- send the packet to the device driver

  while(1) {
    if ((r = ipc_recv(&fromenv, pg, NULL)) != NSREQ_OUTPUT) {
  800a1a:	83 ec 04             	sub    $0x4,%esp
  800a1d:	6a 00                	push   $0x0
  800a1f:	53                   	push   %ebx
  800a20:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  800a23:	50                   	push   %eax
  800a24:	e8 63 12 00 00       	call   801c8c <ipc_recv>
  800a29:	83 c4 10             	add    $0x10,%esp
  800a2c:	83 f8 0b             	cmp    $0xb,%eax
  800a2f:	74 12                	je     800a43 <output+0x43>
      panic("output.c error: %d", r);
  800a31:	50                   	push   %eax
  800a32:	68 39 1c 81 00       	push   $0x811c39
  800a37:	6a 15                	push   $0x15
  800a39:	68 4c 1c 81 00       	push   $0x811c4c
  800a3e:	e8 89 00 00 00       	call   800acc <_panic>
    }
    if (ns_envid != fromenv) {
  800a43:	3b 75 f4             	cmp    0xfffffff4(%ebp),%esi
  800a46:	74 14                	je     800a5c <output+0x5c>
      panic("output.c didn't receive from right env");
  800a48:	83 ec 04             	sub    $0x4,%esp
  800a4b:	68 5c 1c 81 00       	push   $0x811c5c
  800a50:	6a 18                	push   $0x18
  800a52:	68 4c 1c 81 00       	push   $0x811c4c
  800a57:	e8 70 00 00 00       	call   800acc <_panic>
    }
  
    packet = (struct jif_pkt*) pg;
    sys_transmit_packet(packet->jp_data, packet->jp_len);
  800a5c:	83 ec 08             	sub    $0x8,%esp
  800a5f:	ff 33                	pushl  (%ebx)
  800a61:	8d 43 04             	lea    0x4(%ebx),%eax
  800a64:	50                   	push   %eax
  800a65:	e8 19 0d 00 00       	call   801783 <sys_transmit_packet>
  800a6a:	83 c4 10             	add    $0x10,%esp
  800a6d:	eb ab                	jmp    800a1a <output+0x1a>
	...

00800a70 <libmain>:
char *binaryname = "(PROGRAM NAME UNKNOWN)";

void
libmain(int argc, char **argv)
{
  800a70:	55                   	push   %ebp
  800a71:	89 e5                	mov    %esp,%ebp
  800a73:	56                   	push   %esi
  800a74:	53                   	push   %ebx
  800a75:	8b 75 08             	mov    0x8(%ebp),%esi
  800a78:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	// set env to point at our env structure in envs[].
	// LAB 3: Your code here.
        // seanyliu
	//env = 0;
        env = &envs[ENVX(sys_getenvid())];
  800a7b:	e8 d4 0a 00 00       	call   801554 <sys_getenvid>
  800a80:	25 ff 03 00 00       	and    $0x3ff,%eax
  800a85:	c1 e0 07             	shl    $0x7,%eax
  800a88:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  800a8d:	a3 54 e6 b3 00       	mov    %eax,0xb3e654

	// save the name of the program so that panic() can use it
	if (argc > 0)
  800a92:	85 f6                	test   %esi,%esi
  800a94:	7e 07                	jle    800a9d <libmain+0x2d>
		binaryname = argv[0];
  800a96:	8b 03                	mov    (%ebx),%eax
  800a98:	a3 00 80 81 00       	mov    %eax,0x818000

	// call user main routine
	umain(argc, argv);
  800a9d:	83 ec 08             	sub    $0x8,%esp
  800aa0:	53                   	push   %ebx
  800aa1:	56                   	push   %esi
  800aa2:	e8 30 fd ff ff       	call   8007d7 <umain>

	// exit gracefully
	exit();
  800aa7:	e8 08 00 00 00       	call   800ab4 <exit>
}
  800aac:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  800aaf:	5b                   	pop    %ebx
  800ab0:	5e                   	pop    %esi
  800ab1:	c9                   	leave  
  800ab2:	c3                   	ret    
	...

00800ab4 <exit>:
#include <inc/lib.h>

void
exit(void)
{
  800ab4:	55                   	push   %ebp
  800ab5:	89 e5                	mov    %esp,%ebp
  800ab7:	83 ec 08             	sub    $0x8,%esp
	close_all();
  800aba:	e8 59 14 00 00       	call   801f18 <close_all>
	sys_env_destroy(0);
  800abf:	83 ec 0c             	sub    $0xc,%esp
  800ac2:	6a 00                	push   $0x0
  800ac4:	e8 4a 0a 00 00       	call   801513 <sys_env_destroy>
}
  800ac9:	c9                   	leave  
  800aca:	c3                   	ret    
	...

00800acc <_panic>:
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  800acc:	55                   	push   %ebp
  800acd:	89 e5                	mov    %esp,%ebp
  800acf:	53                   	push   %ebx
  800ad0:	83 ec 04             	sub    $0x4,%esp
	va_list ap;

	va_start(ap, fmt);
  800ad3:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	if (argv0)
  800ad6:	83 3d 58 e6 b3 00 00 	cmpl   $0x0,0xb3e658
  800add:	74 16                	je     800af5 <_panic+0x29>
		cprintf("%s: ", argv0);
  800adf:	83 ec 08             	sub    $0x8,%esp
  800ae2:	ff 35 58 e6 b3 00    	pushl  0xb3e658
  800ae8:	68 9a 1c 81 00       	push   $0x811c9a
  800aed:	e8 ca 00 00 00       	call   800bbc <cprintf>
  800af2:	83 c4 10             	add    $0x10,%esp
	cprintf("user panic in %s at %s:%d: ", binaryname, file, line);
  800af5:	ff 75 0c             	pushl  0xc(%ebp)
  800af8:	ff 75 08             	pushl  0x8(%ebp)
  800afb:	ff 35 00 80 81 00    	pushl  0x818000
  800b01:	68 9f 1c 81 00       	push   $0x811c9f
  800b06:	e8 b1 00 00 00       	call   800bbc <cprintf>
	vcprintf(fmt, ap);
  800b0b:	83 c4 08             	add    $0x8,%esp
  800b0e:	53                   	push   %ebx
  800b0f:	ff 75 10             	pushl  0x10(%ebp)
  800b12:	e8 54 00 00 00       	call   800b6b <vcprintf>
	cprintf("\n");
  800b17:	c7 04 24 78 19 81 00 	movl   $0x811978,(%esp)
  800b1e:	e8 99 00 00 00       	call   800bbc <cprintf>

	// Cause a breakpoint exception
	while (1)
  800b23:	83 c4 10             	add    $0x10,%esp
		asm volatile("int3");
  800b26:	cc                   	int3   
  800b27:	eb fd                	jmp    800b26 <_panic+0x5a>
  800b29:	00 00                	add    %al,(%eax)
	...

00800b2c <putch>:


static void
putch(int ch, struct printbuf *b)
{
  800b2c:	55                   	push   %ebp
  800b2d:	89 e5                	mov    %esp,%ebp
  800b2f:	53                   	push   %ebx
  800b30:	83 ec 04             	sub    $0x4,%esp
  800b33:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  800b36:	8b 03                	mov    (%ebx),%eax
  800b38:	8b 55 08             	mov    0x8(%ebp),%edx
  800b3b:	88 54 18 08          	mov    %dl,0x8(%eax,%ebx,1)
  800b3f:	40                   	inc    %eax
  800b40:	89 03                	mov    %eax,(%ebx)
	if (b->idx == 256-1) {
  800b42:	3d ff 00 00 00       	cmp    $0xff,%eax
  800b47:	75 1a                	jne    800b63 <putch+0x37>
		sys_cputs(b->buf, b->idx);
  800b49:	83 ec 08             	sub    $0x8,%esp
  800b4c:	68 ff 00 00 00       	push   $0xff
  800b51:	8d 43 08             	lea    0x8(%ebx),%eax
  800b54:	50                   	push   %eax
  800b55:	e8 76 09 00 00       	call   8014d0 <sys_cputs>
		b->idx = 0;
  800b5a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  800b60:	83 c4 10             	add    $0x10,%esp
	}
	b->cnt++;
  800b63:	ff 43 04             	incl   0x4(%ebx)
}
  800b66:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  800b69:	c9                   	leave  
  800b6a:	c3                   	ret    

00800b6b <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  800b6b:	55                   	push   %ebp
  800b6c:	89 e5                	mov    %esp,%ebp
  800b6e:	81 ec 18 01 00 00    	sub    $0x118,%esp
	struct printbuf b;

	b.idx = 0;
  800b74:	c7 85 e8 fe ff ff 00 	movl   $0x0,0xfffffee8(%ebp)
  800b7b:	00 00 00 
	b.cnt = 0;
  800b7e:	c7 85 ec fe ff ff 00 	movl   $0x0,0xfffffeec(%ebp)
  800b85:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  800b88:	ff 75 0c             	pushl  0xc(%ebp)
  800b8b:	ff 75 08             	pushl  0x8(%ebp)
  800b8e:	8d 85 e8 fe ff ff    	lea    0xfffffee8(%ebp),%eax
  800b94:	50                   	push   %eax
  800b95:	68 2c 0b 80 00       	push   $0x800b2c
  800b9a:	e8 4f 01 00 00       	call   800cee <vprintfmt>
	sys_cputs(b.buf, b.idx);
  800b9f:	83 c4 08             	add    $0x8,%esp
  800ba2:	ff b5 e8 fe ff ff    	pushl  0xfffffee8(%ebp)
  800ba8:	8d 85 f0 fe ff ff    	lea    0xfffffef0(%ebp),%eax
  800bae:	50                   	push   %eax
  800baf:	e8 1c 09 00 00       	call   8014d0 <sys_cputs>

	return b.cnt;
  800bb4:	8b 85 ec fe ff ff    	mov    0xfffffeec(%ebp),%eax
}
  800bba:	c9                   	leave  
  800bbb:	c3                   	ret    

00800bbc <cprintf>:

int
cprintf(const char *fmt, ...)
{
  800bbc:	55                   	push   %ebp
  800bbd:	89 e5                	mov    %esp,%ebp
  800bbf:	83 ec 10             	sub    $0x10,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  800bc2:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  800bc5:	50                   	push   %eax
  800bc6:	ff 75 08             	pushl  0x8(%ebp)
  800bc9:	e8 9d ff ff ff       	call   800b6b <vcprintf>
	va_end(ap);

	return cnt;
}
  800bce:	c9                   	leave  
  800bcf:	c3                   	ret    

00800bd0 <printnum>:
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800bd0:	55                   	push   %ebp
  800bd1:	89 e5                	mov    %esp,%ebp
  800bd3:	57                   	push   %edi
  800bd4:	56                   	push   %esi
  800bd5:	53                   	push   %ebx
  800bd6:	83 ec 0c             	sub    $0xc,%esp
  800bd9:	8b 75 10             	mov    0x10(%ebp),%esi
  800bdc:	8b 7d 14             	mov    0x14(%ebp),%edi
  800bdf:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800be2:	8b 45 18             	mov    0x18(%ebp),%eax
  800be5:	ba 00 00 00 00       	mov    $0x0,%edx
  800bea:	39 fa                	cmp    %edi,%edx
  800bec:	77 39                	ja     800c27 <printnum+0x57>
  800bee:	72 04                	jb     800bf4 <printnum+0x24>
  800bf0:	39 f0                	cmp    %esi,%eax
  800bf2:	77 33                	ja     800c27 <printnum+0x57>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800bf4:	83 ec 04             	sub    $0x4,%esp
  800bf7:	ff 75 20             	pushl  0x20(%ebp)
  800bfa:	8d 43 ff             	lea    0xffffffff(%ebx),%eax
  800bfd:	50                   	push   %eax
  800bfe:	ff 75 18             	pushl  0x18(%ebp)
  800c01:	8b 45 18             	mov    0x18(%ebp),%eax
  800c04:	ba 00 00 00 00       	mov    $0x0,%edx
  800c09:	52                   	push   %edx
  800c0a:	50                   	push   %eax
  800c0b:	57                   	push   %edi
  800c0c:	56                   	push   %esi
  800c0d:	e8 4e 0a 01 00       	call   811660 <__udivdi3>
  800c12:	83 c4 10             	add    $0x10,%esp
  800c15:	52                   	push   %edx
  800c16:	50                   	push   %eax
  800c17:	ff 75 0c             	pushl  0xc(%ebp)
  800c1a:	ff 75 08             	pushl  0x8(%ebp)
  800c1d:	e8 ae ff ff ff       	call   800bd0 <printnum>
  800c22:	83 c4 20             	add    $0x20,%esp
  800c25:	eb 19                	jmp    800c40 <printnum+0x70>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  800c27:	4b                   	dec    %ebx
  800c28:	85 db                	test   %ebx,%ebx
  800c2a:	7e 14                	jle    800c40 <printnum+0x70>
  800c2c:	83 ec 08             	sub    $0x8,%esp
  800c2f:	ff 75 0c             	pushl  0xc(%ebp)
  800c32:	ff 75 20             	pushl  0x20(%ebp)
  800c35:	ff 55 08             	call   *0x8(%ebp)
  800c38:	83 c4 10             	add    $0x10,%esp
  800c3b:	4b                   	dec    %ebx
  800c3c:	85 db                	test   %ebx,%ebx
  800c3e:	7f ec                	jg     800c2c <printnum+0x5c>
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800c40:	83 ec 08             	sub    $0x8,%esp
  800c43:	ff 75 0c             	pushl  0xc(%ebp)
  800c46:	8b 45 18             	mov    0x18(%ebp),%eax
  800c49:	ba 00 00 00 00       	mov    $0x0,%edx
  800c4e:	83 ec 04             	sub    $0x4,%esp
  800c51:	52                   	push   %edx
  800c52:	50                   	push   %eax
  800c53:	57                   	push   %edi
  800c54:	56                   	push   %esi
  800c55:	e8 12 0b 01 00       	call   81176c <__umoddi3>
  800c5a:	83 c4 14             	add    $0x14,%esp
  800c5d:	0f be 80 b5 1d 81 00 	movsbl 0x811db5(%eax),%eax
  800c64:	50                   	push   %eax
  800c65:	ff 55 08             	call   *0x8(%ebp)
}
  800c68:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  800c6b:	5b                   	pop    %ebx
  800c6c:	5e                   	pop    %esi
  800c6d:	5f                   	pop    %edi
  800c6e:	c9                   	leave  
  800c6f:	c3                   	ret    

00800c70 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800c70:	55                   	push   %ebp
  800c71:	89 e5                	mov    %esp,%ebp
  800c73:	8b 4d 08             	mov    0x8(%ebp),%ecx
  800c76:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (lflag >= 2)
  800c79:	83 f8 01             	cmp    $0x1,%eax
  800c7c:	7e 0f                	jle    800c8d <getuint+0x1d>
		return va_arg(*ap, unsigned long long);
  800c7e:	8b 01                	mov    (%ecx),%eax
  800c80:	83 c0 08             	add    $0x8,%eax
  800c83:	89 01                	mov    %eax,(%ecx)
  800c85:	8b 50 fc             	mov    0xfffffffc(%eax),%edx
  800c88:	8b 40 f8             	mov    0xfffffff8(%eax),%eax
  800c8b:	eb 24                	jmp    800cb1 <getuint+0x41>
	else if (lflag)
  800c8d:	85 c0                	test   %eax,%eax
  800c8f:	74 11                	je     800ca2 <getuint+0x32>
		return va_arg(*ap, unsigned long);
  800c91:	8b 01                	mov    (%ecx),%eax
  800c93:	83 c0 04             	add    $0x4,%eax
  800c96:	89 01                	mov    %eax,(%ecx)
  800c98:	8b 40 fc             	mov    0xfffffffc(%eax),%eax
  800c9b:	ba 00 00 00 00       	mov    $0x0,%edx
  800ca0:	eb 0f                	jmp    800cb1 <getuint+0x41>
	else
		return va_arg(*ap, unsigned int);
  800ca2:	8b 01                	mov    (%ecx),%eax
  800ca4:	83 c0 04             	add    $0x4,%eax
  800ca7:	89 01                	mov    %eax,(%ecx)
  800ca9:	8b 40 fc             	mov    0xfffffffc(%eax),%eax
  800cac:	ba 00 00 00 00       	mov    $0x0,%edx
}
  800cb1:	c9                   	leave  
  800cb2:	c3                   	ret    

00800cb3 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800cb3:	55                   	push   %ebp
  800cb4:	89 e5                	mov    %esp,%ebp
  800cb6:	8b 55 08             	mov    0x8(%ebp),%edx
  800cb9:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (lflag >= 2)
  800cbc:	83 f8 01             	cmp    $0x1,%eax
  800cbf:	7e 0f                	jle    800cd0 <getint+0x1d>
		return va_arg(*ap, long long);
  800cc1:	8b 02                	mov    (%edx),%eax
  800cc3:	83 c0 08             	add    $0x8,%eax
  800cc6:	89 02                	mov    %eax,(%edx)
  800cc8:	8b 50 fc             	mov    0xfffffffc(%eax),%edx
  800ccb:	8b 40 f8             	mov    0xfffffff8(%eax),%eax
  800cce:	eb 1c                	jmp    800cec <getint+0x39>
	else if (lflag)
  800cd0:	85 c0                	test   %eax,%eax
  800cd2:	74 0d                	je     800ce1 <getint+0x2e>
		return va_arg(*ap, long);
  800cd4:	8b 02                	mov    (%edx),%eax
  800cd6:	83 c0 04             	add    $0x4,%eax
  800cd9:	89 02                	mov    %eax,(%edx)
  800cdb:	8b 40 fc             	mov    0xfffffffc(%eax),%eax
  800cde:	99                   	cltd   
  800cdf:	eb 0b                	jmp    800cec <getint+0x39>
	else
		return va_arg(*ap, int);
  800ce1:	8b 02                	mov    (%edx),%eax
  800ce3:	83 c0 04             	add    $0x4,%eax
  800ce6:	89 02                	mov    %eax,(%edx)
  800ce8:	8b 40 fc             	mov    0xfffffffc(%eax),%eax
  800ceb:	99                   	cltd   
}
  800cec:	c9                   	leave  
  800ced:	c3                   	ret    

00800cee <vprintfmt>:


// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800cee:	55                   	push   %ebp
  800cef:	89 e5                	mov    %esp,%ebp
  800cf1:	57                   	push   %edi
  800cf2:	56                   	push   %esi
  800cf3:	53                   	push   %ebx
  800cf4:	83 ec 1c             	sub    $0x1c,%esp
  800cf7:	8b 5d 10             	mov    0x10(%ebp),%ebx
	register const char *p;
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
			putch(ch, putdat);
  800cfa:	0f b6 13             	movzbl (%ebx),%edx
  800cfd:	43                   	inc    %ebx
  800cfe:	83 fa 25             	cmp    $0x25,%edx
  800d01:	74 1e                	je     800d21 <vprintfmt+0x33>
  800d03:	85 d2                	test   %edx,%edx
  800d05:	0f 84 d7 02 00 00    	je     800fe2 <vprintfmt+0x2f4>
  800d0b:	83 ec 08             	sub    $0x8,%esp
  800d0e:	ff 75 0c             	pushl  0xc(%ebp)
  800d11:	52                   	push   %edx
  800d12:	ff 55 08             	call   *0x8(%ebp)
  800d15:	83 c4 10             	add    $0x10,%esp
  800d18:	0f b6 13             	movzbl (%ebx),%edx
  800d1b:	43                   	inc    %ebx
  800d1c:	83 fa 25             	cmp    $0x25,%edx
  800d1f:	75 e2                	jne    800d03 <vprintfmt+0x15>
		}

		// Process a %-escape sequence
		padc = ' ';
  800d21:	c6 45 eb 20          	movb   $0x20,0xffffffeb(%ebp)
		width = -1;
  800d25:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,0xfffffff0(%ebp)
		precision = -1;
  800d2c:	be ff ff ff ff       	mov    $0xffffffff,%esi
		lflag = 0;
  800d31:	b9 00 00 00 00       	mov    $0x0,%ecx
		altflag = 0;
  800d36:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800d3d:	0f b6 13             	movzbl (%ebx),%edx
  800d40:	8d 42 dd             	lea    0xffffffdd(%edx),%eax
  800d43:	43                   	inc    %ebx
  800d44:	83 f8 55             	cmp    $0x55,%eax
  800d47:	0f 87 70 02 00 00    	ja     800fbd <vprintfmt+0x2cf>
  800d4d:	ff 24 85 3c 1e 81 00 	jmp    *0x811e3c(,%eax,4)

		// flag to pad on the right
		case '-':
			padc = '-';
  800d54:	c6 45 eb 2d          	movb   $0x2d,0xffffffeb(%ebp)
			goto reswitch;
  800d58:	eb e3                	jmp    800d3d <vprintfmt+0x4f>
			
		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800d5a:	c6 45 eb 30          	movb   $0x30,0xffffffeb(%ebp)
			goto reswitch;
  800d5e:	eb dd                	jmp    800d3d <vprintfmt+0x4f>

		// width field
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800d60:	be 00 00 00 00       	mov    $0x0,%esi
				precision = precision * 10 + ch - '0';
  800d65:	8d 04 b6             	lea    (%esi,%esi,4),%eax
  800d68:	8d 74 42 d0          	lea    0xffffffd0(%edx,%eax,2),%esi
				ch = *fmt;
  800d6c:	0f be 13             	movsbl (%ebx),%edx
				if (ch < '0' || ch > '9')
  800d6f:	8d 42 d0             	lea    0xffffffd0(%edx),%eax
  800d72:	83 f8 09             	cmp    $0x9,%eax
  800d75:	77 27                	ja     800d9e <vprintfmt+0xb0>
  800d77:	43                   	inc    %ebx
  800d78:	eb eb                	jmp    800d65 <vprintfmt+0x77>
					break;
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  800d7a:	83 45 14 04          	addl   $0x4,0x14(%ebp)
  800d7e:	8b 45 14             	mov    0x14(%ebp),%eax
  800d81:	8b 70 fc             	mov    0xfffffffc(%eax),%esi
			goto process_precision;
  800d84:	eb 18                	jmp    800d9e <vprintfmt+0xb0>

		case '.':
			if (width < 0)
  800d86:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  800d8a:	79 b1                	jns    800d3d <vprintfmt+0x4f>
				width = 0;
  800d8c:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
			goto reswitch;
  800d93:	eb a8                	jmp    800d3d <vprintfmt+0x4f>

		case '#':
			altflag = 1;
  800d95:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
			goto reswitch;
  800d9c:	eb 9f                	jmp    800d3d <vprintfmt+0x4f>

		process_precision:
			if (width < 0)
  800d9e:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  800da2:	79 99                	jns    800d3d <vprintfmt+0x4f>
				width = precision, precision = -1;
  800da4:	89 75 f0             	mov    %esi,0xfffffff0(%ebp)
  800da7:	be ff ff ff ff       	mov    $0xffffffff,%esi
			goto reswitch;
  800dac:	eb 8f                	jmp    800d3d <vprintfmt+0x4f>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  800dae:	41                   	inc    %ecx
			goto reswitch;
  800daf:	eb 8c                	jmp    800d3d <vprintfmt+0x4f>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  800db1:	83 ec 08             	sub    $0x8,%esp
  800db4:	ff 75 0c             	pushl  0xc(%ebp)
  800db7:	83 45 14 04          	addl   $0x4,0x14(%ebp)
  800dbb:	8b 45 14             	mov    0x14(%ebp),%eax
  800dbe:	ff 70 fc             	pushl  0xfffffffc(%eax)
  800dc1:	ff 55 08             	call   *0x8(%ebp)
			break;
  800dc4:	83 c4 10             	add    $0x10,%esp
  800dc7:	e9 2e ff ff ff       	jmp    800cfa <vprintfmt+0xc>

		// error message
		case 'e':
			err = va_arg(ap, int);
  800dcc:	83 45 14 04          	addl   $0x4,0x14(%ebp)
  800dd0:	8b 45 14             	mov    0x14(%ebp),%eax
  800dd3:	8b 40 fc             	mov    0xfffffffc(%eax),%eax
			if (err < 0)
  800dd6:	85 c0                	test   %eax,%eax
  800dd8:	79 02                	jns    800ddc <vprintfmt+0xee>
				err = -err;
  800dda:	f7 d8                	neg    %eax
			if (err > MAXERROR || (p = error_string[err]) == NULL)
  800ddc:	83 f8 0e             	cmp    $0xe,%eax
  800ddf:	7f 0b                	jg     800dec <vprintfmt+0xfe>
  800de1:	8b 3c 85 00 1e 81 00 	mov    0x811e00(,%eax,4),%edi
  800de8:	85 ff                	test   %edi,%edi
  800dea:	75 19                	jne    800e05 <vprintfmt+0x117>
				printfmt(putch, putdat, "error %d", err);
  800dec:	50                   	push   %eax
  800ded:	68 c6 1d 81 00       	push   $0x811dc6
  800df2:	ff 75 0c             	pushl  0xc(%ebp)
  800df5:	ff 75 08             	pushl  0x8(%ebp)
  800df8:	e8 ed 01 00 00       	call   800fea <printfmt>
  800dfd:	83 c4 10             	add    $0x10,%esp
  800e00:	e9 f5 fe ff ff       	jmp    800cfa <vprintfmt+0xc>
			else
				printfmt(putch, putdat, "%s", p);
  800e05:	57                   	push   %edi
  800e06:	68 69 22 81 00       	push   $0x812269
  800e0b:	ff 75 0c             	pushl  0xc(%ebp)
  800e0e:	ff 75 08             	pushl  0x8(%ebp)
  800e11:	e8 d4 01 00 00       	call   800fea <printfmt>
  800e16:	83 c4 10             	add    $0x10,%esp
			break;
  800e19:	e9 dc fe ff ff       	jmp    800cfa <vprintfmt+0xc>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  800e1e:	83 45 14 04          	addl   $0x4,0x14(%ebp)
  800e22:	8b 45 14             	mov    0x14(%ebp),%eax
  800e25:	8b 78 fc             	mov    0xfffffffc(%eax),%edi
  800e28:	85 ff                	test   %edi,%edi
  800e2a:	75 05                	jne    800e31 <vprintfmt+0x143>
				p = "(null)";
  800e2c:	bf cf 1d 81 00       	mov    $0x811dcf,%edi
			if (width > 0 && padc != '-')
  800e31:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  800e35:	7e 3b                	jle    800e72 <vprintfmt+0x184>
  800e37:	80 7d eb 2d          	cmpb   $0x2d,0xffffffeb(%ebp)
  800e3b:	74 35                	je     800e72 <vprintfmt+0x184>
				for (width -= strnlen(p, precision); width > 0; width--)
  800e3d:	83 ec 08             	sub    $0x8,%esp
  800e40:	56                   	push   %esi
  800e41:	57                   	push   %edi
  800e42:	e8 56 03 00 00       	call   80119d <strnlen>
  800e47:	29 45 f0             	sub    %eax,0xfffffff0(%ebp)
  800e4a:	83 c4 10             	add    $0x10,%esp
  800e4d:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  800e51:	7e 1f                	jle    800e72 <vprintfmt+0x184>
  800e53:	0f be 45 eb          	movsbl 0xffffffeb(%ebp),%eax
  800e57:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
					putch(padc, putdat);
  800e5a:	83 ec 08             	sub    $0x8,%esp
  800e5d:	ff 75 0c             	pushl  0xc(%ebp)
  800e60:	ff 75 e4             	pushl  0xffffffe4(%ebp)
  800e63:	ff 55 08             	call   *0x8(%ebp)
  800e66:	83 c4 10             	add    $0x10,%esp
  800e69:	ff 4d f0             	decl   0xfffffff0(%ebp)
  800e6c:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  800e70:	7f e8                	jg     800e5a <vprintfmt+0x16c>
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800e72:	0f be 17             	movsbl (%edi),%edx
  800e75:	47                   	inc    %edi
  800e76:	85 d2                	test   %edx,%edx
  800e78:	74 44                	je     800ebe <vprintfmt+0x1d0>
  800e7a:	85 f6                	test   %esi,%esi
  800e7c:	78 03                	js     800e81 <vprintfmt+0x193>
  800e7e:	4e                   	dec    %esi
  800e7f:	78 3d                	js     800ebe <vprintfmt+0x1d0>
				if (altflag && (ch < ' ' || ch > '~'))
  800e81:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  800e85:	74 18                	je     800e9f <vprintfmt+0x1b1>
  800e87:	8d 42 e0             	lea    0xffffffe0(%edx),%eax
  800e8a:	83 f8 5e             	cmp    $0x5e,%eax
  800e8d:	76 10                	jbe    800e9f <vprintfmt+0x1b1>
					putch('?', putdat);
  800e8f:	83 ec 08             	sub    $0x8,%esp
  800e92:	ff 75 0c             	pushl  0xc(%ebp)
  800e95:	6a 3f                	push   $0x3f
  800e97:	ff 55 08             	call   *0x8(%ebp)
  800e9a:	83 c4 10             	add    $0x10,%esp
  800e9d:	eb 0d                	jmp    800eac <vprintfmt+0x1be>
				else
					putch(ch, putdat);
  800e9f:	83 ec 08             	sub    $0x8,%esp
  800ea2:	ff 75 0c             	pushl  0xc(%ebp)
  800ea5:	52                   	push   %edx
  800ea6:	ff 55 08             	call   *0x8(%ebp)
  800ea9:	83 c4 10             	add    $0x10,%esp
  800eac:	ff 4d f0             	decl   0xfffffff0(%ebp)
  800eaf:	0f be 17             	movsbl (%edi),%edx
  800eb2:	47                   	inc    %edi
  800eb3:	85 d2                	test   %edx,%edx
  800eb5:	74 07                	je     800ebe <vprintfmt+0x1d0>
  800eb7:	85 f6                	test   %esi,%esi
  800eb9:	78 c6                	js     800e81 <vprintfmt+0x193>
  800ebb:	4e                   	dec    %esi
  800ebc:	79 c3                	jns    800e81 <vprintfmt+0x193>
			for (; width > 0; width--)
  800ebe:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  800ec2:	0f 8e 32 fe ff ff    	jle    800cfa <vprintfmt+0xc>
				putch(' ', putdat);
  800ec8:	83 ec 08             	sub    $0x8,%esp
  800ecb:	ff 75 0c             	pushl  0xc(%ebp)
  800ece:	6a 20                	push   $0x20
  800ed0:	ff 55 08             	call   *0x8(%ebp)
  800ed3:	83 c4 10             	add    $0x10,%esp
  800ed6:	ff 4d f0             	decl   0xfffffff0(%ebp)
  800ed9:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  800edd:	7f e9                	jg     800ec8 <vprintfmt+0x1da>
			break;
  800edf:	e9 16 fe ff ff       	jmp    800cfa <vprintfmt+0xc>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
  800ee4:	51                   	push   %ecx
  800ee5:	8d 45 14             	lea    0x14(%ebp),%eax
  800ee8:	50                   	push   %eax
  800ee9:	e8 c5 fd ff ff       	call   800cb3 <getint>
  800eee:	89 c6                	mov    %eax,%esi
  800ef0:	89 d7                	mov    %edx,%edi
			if ((long long) num < 0) {
  800ef2:	83 c4 08             	add    $0x8,%esp
  800ef5:	85 d2                	test   %edx,%edx
  800ef7:	79 15                	jns    800f0e <vprintfmt+0x220>
				putch('-', putdat);
  800ef9:	83 ec 08             	sub    $0x8,%esp
  800efc:	ff 75 0c             	pushl  0xc(%ebp)
  800eff:	6a 2d                	push   $0x2d
  800f01:	ff 55 08             	call   *0x8(%ebp)
				num = -(long long) num;
  800f04:	f7 de                	neg    %esi
  800f06:	83 d7 00             	adc    $0x0,%edi
  800f09:	f7 df                	neg    %edi
  800f0b:	83 c4 10             	add    $0x10,%esp
			}
			base = 10;
  800f0e:	ba 0a 00 00 00       	mov    $0xa,%edx
			goto number;
  800f13:	eb 75                	jmp    800f8a <vprintfmt+0x29c>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  800f15:	51                   	push   %ecx
  800f16:	8d 45 14             	lea    0x14(%ebp),%eax
  800f19:	50                   	push   %eax
  800f1a:	e8 51 fd ff ff       	call   800c70 <getuint>
  800f1f:	89 c6                	mov    %eax,%esi
  800f21:	89 d7                	mov    %edx,%edi
			base = 10;
  800f23:	ba 0a 00 00 00       	mov    $0xa,%edx
			goto number;
  800f28:	83 c4 08             	add    $0x8,%esp
  800f2b:	eb 5d                	jmp    800f8a <vprintfmt+0x29c>

		// (unsigned) octal
		case 'o':
                        /*
                        // Staff code below
			// Replace this with your code.
			putch('X', putdat);
			putch('X', putdat);
			putch('X', putdat);
			break;
                        */
                        // seanyliu
			num = getuint(&ap, lflag);
  800f2d:	51                   	push   %ecx
  800f2e:	8d 45 14             	lea    0x14(%ebp),%eax
  800f31:	50                   	push   %eax
  800f32:	e8 39 fd ff ff       	call   800c70 <getuint>
  800f37:	89 c6                	mov    %eax,%esi
  800f39:	89 d7                	mov    %edx,%edi
			base = 8;
  800f3b:	ba 08 00 00 00       	mov    $0x8,%edx
			goto number;
  800f40:	83 c4 08             	add    $0x8,%esp
  800f43:	eb 45                	jmp    800f8a <vprintfmt+0x29c>

		// pointer
		case 'p':
			putch('0', putdat);
  800f45:	83 ec 08             	sub    $0x8,%esp
  800f48:	ff 75 0c             	pushl  0xc(%ebp)
  800f4b:	6a 30                	push   $0x30
  800f4d:	ff 55 08             	call   *0x8(%ebp)
			putch('x', putdat);
  800f50:	83 c4 08             	add    $0x8,%esp
  800f53:	ff 75 0c             	pushl  0xc(%ebp)
  800f56:	6a 78                	push   $0x78
  800f58:	ff 55 08             	call   *0x8(%ebp)
			num = (unsigned long long)
  800f5b:	83 45 14 04          	addl   $0x4,0x14(%ebp)
  800f5f:	8b 45 14             	mov    0x14(%ebp),%eax
  800f62:	8b 70 fc             	mov    0xfffffffc(%eax),%esi
  800f65:	bf 00 00 00 00       	mov    $0x0,%edi
				(uintptr_t) va_arg(ap, void *);
			base = 16;
  800f6a:	ba 10 00 00 00       	mov    $0x10,%edx
			goto number;
  800f6f:	83 c4 10             	add    $0x10,%esp
  800f72:	eb 16                	jmp    800f8a <vprintfmt+0x29c>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  800f74:	51                   	push   %ecx
  800f75:	8d 45 14             	lea    0x14(%ebp),%eax
  800f78:	50                   	push   %eax
  800f79:	e8 f2 fc ff ff       	call   800c70 <getuint>
  800f7e:	89 c6                	mov    %eax,%esi
  800f80:	89 d7                	mov    %edx,%edi
			base = 16;
  800f82:	ba 10 00 00 00       	mov    $0x10,%edx
  800f87:	83 c4 08             	add    $0x8,%esp
		number:
			printnum(putch, putdat, num, base, width, padc);
  800f8a:	83 ec 04             	sub    $0x4,%esp
  800f8d:	0f be 45 eb          	movsbl 0xffffffeb(%ebp),%eax
  800f91:	50                   	push   %eax
  800f92:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  800f95:	52                   	push   %edx
  800f96:	57                   	push   %edi
  800f97:	56                   	push   %esi
  800f98:	ff 75 0c             	pushl  0xc(%ebp)
  800f9b:	ff 75 08             	pushl  0x8(%ebp)
  800f9e:	e8 2d fc ff ff       	call   800bd0 <printnum>
			break;
  800fa3:	83 c4 20             	add    $0x20,%esp
  800fa6:	e9 4f fd ff ff       	jmp    800cfa <vprintfmt+0xc>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  800fab:	83 ec 08             	sub    $0x8,%esp
  800fae:	ff 75 0c             	pushl  0xc(%ebp)
  800fb1:	52                   	push   %edx
  800fb2:	ff 55 08             	call   *0x8(%ebp)
			break;
  800fb5:	83 c4 10             	add    $0x10,%esp
  800fb8:	e9 3d fd ff ff       	jmp    800cfa <vprintfmt+0xc>
			
		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800fbd:	83 ec 08             	sub    $0x8,%esp
  800fc0:	ff 75 0c             	pushl  0xc(%ebp)
  800fc3:	6a 25                	push   $0x25
  800fc5:	ff 55 08             	call   *0x8(%ebp)
			for (fmt--; fmt[-1] != '%'; fmt--)
  800fc8:	4b                   	dec    %ebx
  800fc9:	83 c4 10             	add    $0x10,%esp
  800fcc:	80 7b ff 25          	cmpb   $0x25,0xffffffff(%ebx)
  800fd0:	0f 84 24 fd ff ff    	je     800cfa <vprintfmt+0xc>
  800fd6:	4b                   	dec    %ebx
  800fd7:	80 7b ff 25          	cmpb   $0x25,0xffffffff(%ebx)
  800fdb:	75 f9                	jne    800fd6 <vprintfmt+0x2e8>
				/* do nothing */;
			break;
  800fdd:	e9 18 fd ff ff       	jmp    800cfa <vprintfmt+0xc>
		}
	}
}
  800fe2:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  800fe5:	5b                   	pop    %ebx
  800fe6:	5e                   	pop    %esi
  800fe7:	5f                   	pop    %edi
  800fe8:	c9                   	leave  
  800fe9:	c3                   	ret    

00800fea <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800fea:	55                   	push   %ebp
  800feb:	89 e5                	mov    %esp,%ebp
  800fed:	83 ec 08             	sub    $0x8,%esp
	va_list ap;

	va_start(ap, fmt);
  800ff0:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  800ff3:	50                   	push   %eax
  800ff4:	ff 75 10             	pushl  0x10(%ebp)
  800ff7:	ff 75 0c             	pushl  0xc(%ebp)
  800ffa:	ff 75 08             	pushl  0x8(%ebp)
  800ffd:	e8 ec fc ff ff       	call   800cee <vprintfmt>
	va_end(ap);
}
  801002:	c9                   	leave  
  801003:	c3                   	ret    

00801004 <sprintputch>:

struct sprintbuf {
	char *buf;
	char *ebuf;
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  801004:	55                   	push   %ebp
  801005:	89 e5                	mov    %esp,%ebp
  801007:	8b 55 0c             	mov    0xc(%ebp),%edx
	b->cnt++;
  80100a:	ff 42 08             	incl   0x8(%edx)
	if (b->buf < b->ebuf)
  80100d:	8b 0a                	mov    (%edx),%ecx
  80100f:	3b 4a 04             	cmp    0x4(%edx),%ecx
  801012:	73 07                	jae    80101b <sprintputch+0x17>
		*b->buf++ = ch;
  801014:	8b 45 08             	mov    0x8(%ebp),%eax
  801017:	88 01                	mov    %al,(%ecx)
  801019:	ff 02                	incl   (%edx)
}
  80101b:	c9                   	leave  
  80101c:	c3                   	ret    

0080101d <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80101d:	55                   	push   %ebp
  80101e:	89 e5                	mov    %esp,%ebp
  801020:	83 ec 18             	sub    $0x18,%esp
  801023:	8b 55 08             	mov    0x8(%ebp),%edx
  801026:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	struct sprintbuf b = {buf, buf+n-1, 0};
  801029:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
  80102c:	8d 44 0a ff          	lea    0xffffffff(%edx,%ecx,1),%eax
  801030:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  801033:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)

	if (buf == NULL || n < 1)
  80103a:	85 d2                	test   %edx,%edx
  80103c:	74 04                	je     801042 <vsnprintf+0x25>
  80103e:	85 c9                	test   %ecx,%ecx
  801040:	7f 07                	jg     801049 <vsnprintf+0x2c>
		return -E_INVAL;
  801042:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  801047:	eb 1d                	jmp    801066 <vsnprintf+0x49>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  801049:	ff 75 14             	pushl  0x14(%ebp)
  80104c:	ff 75 10             	pushl  0x10(%ebp)
  80104f:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  801052:	50                   	push   %eax
  801053:	68 04 10 80 00       	push   $0x801004
  801058:	e8 91 fc ff ff       	call   800cee <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80105d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  801060:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  801063:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
}
  801066:	c9                   	leave  
  801067:	c3                   	ret    

00801068 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  801068:	55                   	push   %ebp
  801069:	89 e5                	mov    %esp,%ebp
  80106b:	83 ec 08             	sub    $0x8,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80106e:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  801071:	50                   	push   %eax
  801072:	ff 75 10             	pushl  0x10(%ebp)
  801075:	ff 75 0c             	pushl  0xc(%ebp)
  801078:	ff 75 08             	pushl  0x8(%ebp)
  80107b:	e8 9d ff ff ff       	call   80101d <vsnprintf>
	va_end(ap);

	return rc;
}
  801080:	c9                   	leave  
  801081:	c3                   	ret    
	...

00801084 <strtoint>:
// Takes in a string in the format 0x????.
// Assumes all letters are lower case.
// If invalid formatting, then returns -1
int
strtoint(char *string) {
  801084:	55                   	push   %ebp
  801085:	89 e5                	mov    %esp,%ebp
  801087:	56                   	push   %esi
  801088:	53                   	push   %ebx
  801089:	8b 75 08             	mov    0x8(%ebp),%esi
  int cidx = 0;
  int end = strlen(string)-1;
  80108c:	83 ec 0c             	sub    $0xc,%esp
  80108f:	56                   	push   %esi
  801090:	e8 ef 00 00 00       	call   801184 <strlen>
  char letter;
  int hexnum = 0;
  801095:	bb 00 00 00 00       	mov    $0x0,%ebx
  int multiplier = 1;
  80109a:	b9 01 00 00 00       	mov    $0x1,%ecx

  // pluck off characters from the end and
  // multiply by the right hex value.
  for (cidx = end; cidx > -1; cidx--) {
  80109f:	83 c4 10             	add    $0x10,%esp
  8010a2:	89 c2                	mov    %eax,%edx
  8010a4:	4a                   	dec    %edx
  8010a5:	0f 88 d0 00 00 00    	js     80117b <strtoint+0xf7>
    letter = string[cidx];
  8010ab:	8a 04 16             	mov    (%esi,%edx,1),%al
    if (cidx == 0) {
  8010ae:	85 d2                	test   %edx,%edx
  8010b0:	75 12                	jne    8010c4 <strtoint+0x40>
      if (letter != '0') {
  8010b2:	3c 30                	cmp    $0x30,%al
  8010b4:	0f 84 ba 00 00 00    	je     801174 <strtoint+0xf0>
        //cprintf("Error: not a hex address.\n");
        return -1;
  8010ba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8010bf:	e9 b9 00 00 00       	jmp    80117d <strtoint+0xf9>
      }
    } else if (cidx == 1) {
  8010c4:	83 fa 01             	cmp    $0x1,%edx
  8010c7:	75 12                	jne    8010db <strtoint+0x57>
      if (letter != 'x') {
  8010c9:	3c 78                	cmp    $0x78,%al
  8010cb:	0f 84 a3 00 00 00    	je     801174 <strtoint+0xf0>
        //cprintf("Error: not a hex address.\n");
        return -1;
  8010d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8010d6:	e9 a2 00 00 00       	jmp    80117d <strtoint+0xf9>
      }
    } else {
      switch (letter) {
  8010db:	0f be c0             	movsbl %al,%eax
  8010de:	83 e8 30             	sub    $0x30,%eax
  8010e1:	83 f8 36             	cmp    $0x36,%eax
  8010e4:	0f 87 80 00 00 00    	ja     80116a <strtoint+0xe6>
  8010ea:	ff 24 85 94 1f 81 00 	jmp    *0x811f94(,%eax,4)
        case '0':
          hexnum += 0 * multiplier;
          break;
        case '1':
          hexnum += 1 * multiplier;
  8010f1:	01 cb                	add    %ecx,%ebx
          break;
  8010f3:	eb 7c                	jmp    801171 <strtoint+0xed>
        case '2':
          hexnum += 2 * multiplier;
  8010f5:	8d 1c 4b             	lea    (%ebx,%ecx,2),%ebx
          break;
  8010f8:	eb 77                	jmp    801171 <strtoint+0xed>
        case '3':
          hexnum += 3 * multiplier;
  8010fa:	8d 04 49             	lea    (%ecx,%ecx,2),%eax
  8010fd:	01 c3                	add    %eax,%ebx
          break;
  8010ff:	eb 70                	jmp    801171 <strtoint+0xed>
        case '4':
          hexnum += 4 * multiplier;
  801101:	8d 1c 8b             	lea    (%ebx,%ecx,4),%ebx
          break;
  801104:	eb 6b                	jmp    801171 <strtoint+0xed>
        case '5':
          hexnum += 5 * multiplier;
  801106:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  801109:	01 c3                	add    %eax,%ebx
          break;
  80110b:	eb 64                	jmp    801171 <strtoint+0xed>
        case '6':
          hexnum += 6 * multiplier;
  80110d:	8d 04 49             	lea    (%ecx,%ecx,2),%eax
  801110:	8d 1c 43             	lea    (%ebx,%eax,2),%ebx
          break;
  801113:	eb 5c                	jmp    801171 <strtoint+0xed>
        case '7':
          hexnum += 7 * multiplier;
  801115:	8d 04 cd 00 00 00 00 	lea    0x0(,%ecx,8),%eax
  80111c:	29 c8                	sub    %ecx,%eax
  80111e:	01 c3                	add    %eax,%ebx
          break;
  801120:	eb 4f                	jmp    801171 <strtoint+0xed>
        case '8':
          hexnum += 8 * multiplier;
  801122:	8d 1c cb             	lea    (%ebx,%ecx,8),%ebx
          break;
  801125:	eb 4a                	jmp    801171 <strtoint+0xed>
        case '9':
          hexnum += 9 * multiplier;
  801127:	8d 04 c9             	lea    (%ecx,%ecx,8),%eax
  80112a:	01 c3                	add    %eax,%ebx
          break;
  80112c:	eb 43                	jmp    801171 <strtoint+0xed>
        case 'a':
          hexnum += 10 * multiplier;
  80112e:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  801131:	8d 1c 43             	lea    (%ebx,%eax,2),%ebx
          break;
  801134:	eb 3b                	jmp    801171 <strtoint+0xed>
        case 'b':
          hexnum += 11 * multiplier;
  801136:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  801139:	8d 04 41             	lea    (%ecx,%eax,2),%eax
  80113c:	01 c3                	add    %eax,%ebx
          break;
  80113e:	eb 31                	jmp    801171 <strtoint+0xed>
        case 'c':
          hexnum += 12 * multiplier;
  801140:	8d 04 49             	lea    (%ecx,%ecx,2),%eax
  801143:	8d 1c 83             	lea    (%ebx,%eax,4),%ebx
          break;
  801146:	eb 29                	jmp    801171 <strtoint+0xed>
        case 'd':
          hexnum += 13 * multiplier;
  801148:	8d 04 49             	lea    (%ecx,%ecx,2),%eax
  80114b:	8d 04 81             	lea    (%ecx,%eax,4),%eax
  80114e:	01 c3                	add    %eax,%ebx
          break;
  801150:	eb 1f                	jmp    801171 <strtoint+0xed>
        case 'e':
          hexnum += 14 * multiplier;
  801152:	8d 04 cd 00 00 00 00 	lea    0x0(,%ecx,8),%eax
  801159:	29 c8                	sub    %ecx,%eax
  80115b:	8d 1c 43             	lea    (%ebx,%eax,2),%ebx
          break;
  80115e:	eb 11                	jmp    801171 <strtoint+0xed>
        case 'f':
          hexnum += 15 * multiplier;
  801160:	8d 04 49             	lea    (%ecx,%ecx,2),%eax
  801163:	8d 04 80             	lea    (%eax,%eax,4),%eax
  801166:	01 c3                	add    %eax,%ebx
          break;
  801168:	eb 07                	jmp    801171 <strtoint+0xed>
        default:
          //cprintf("Error: not a hex address.\n");
          return -1;
  80116a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80116f:	eb 0c                	jmp    80117d <strtoint+0xf9>
          break;
      }
      multiplier = multiplier * 16;
  801171:	c1 e1 04             	shl    $0x4,%ecx
  801174:	4a                   	dec    %edx
  801175:	0f 89 30 ff ff ff    	jns    8010ab <strtoint+0x27>
    }
  }

  return hexnum;
  80117b:	89 d8                	mov    %ebx,%eax
}
  80117d:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  801180:	5b                   	pop    %ebx
  801181:	5e                   	pop    %esi
  801182:	c9                   	leave  
  801183:	c3                   	ret    

00801184 <strlen>:





int
strlen(const char *s)
{
  801184:	55                   	push   %ebp
  801185:	89 e5                	mov    %esp,%ebp
  801187:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80118a:	b8 00 00 00 00       	mov    $0x0,%eax
  80118f:	80 3a 00             	cmpb   $0x0,(%edx)
  801192:	74 07                	je     80119b <strlen+0x17>
		n++;
  801194:	40                   	inc    %eax
  801195:	42                   	inc    %edx
  801196:	80 3a 00             	cmpb   $0x0,(%edx)
  801199:	75 f9                	jne    801194 <strlen+0x10>
	return n;
}
  80119b:	c9                   	leave  
  80119c:	c3                   	ret    

0080119d <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80119d:	55                   	push   %ebp
  80119e:	89 e5                	mov    %esp,%ebp
  8011a0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8011a3:	8b 55 0c             	mov    0xc(%ebp),%edx
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  8011a6:	b8 00 00 00 00       	mov    $0x0,%eax
  8011ab:	85 d2                	test   %edx,%edx
  8011ad:	74 0f                	je     8011be <strnlen+0x21>
  8011af:	80 39 00             	cmpb   $0x0,(%ecx)
  8011b2:	74 0a                	je     8011be <strnlen+0x21>
		n++;
  8011b4:	40                   	inc    %eax
  8011b5:	41                   	inc    %ecx
  8011b6:	4a                   	dec    %edx
  8011b7:	74 05                	je     8011be <strnlen+0x21>
  8011b9:	80 39 00             	cmpb   $0x0,(%ecx)
  8011bc:	75 f6                	jne    8011b4 <strnlen+0x17>
	return n;
}
  8011be:	c9                   	leave  
  8011bf:	c3                   	ret    

008011c0 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  8011c0:	55                   	push   %ebp
  8011c1:	89 e5                	mov    %esp,%ebp
  8011c3:	53                   	push   %ebx
  8011c4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8011c7:	8b 55 0c             	mov    0xc(%ebp),%edx
	char *ret;

	ret = dst;
  8011ca:	89 cb                	mov    %ecx,%ebx
	while ((*dst++ = *src++) != '\0')
  8011cc:	8a 02                	mov    (%edx),%al
  8011ce:	42                   	inc    %edx
  8011cf:	88 01                	mov    %al,(%ecx)
  8011d1:	41                   	inc    %ecx
  8011d2:	84 c0                	test   %al,%al
  8011d4:	75 f6                	jne    8011cc <strcpy+0xc>
		/* do nothing */;
	return ret;
}
  8011d6:	89 d8                	mov    %ebx,%eax
  8011d8:	5b                   	pop    %ebx
  8011d9:	c9                   	leave  
  8011da:	c3                   	ret    

008011db <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  8011db:	55                   	push   %ebp
  8011dc:	89 e5                	mov    %esp,%ebp
  8011de:	57                   	push   %edi
  8011df:	56                   	push   %esi
  8011e0:	53                   	push   %ebx
  8011e1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8011e4:	8b 55 0c             	mov    0xc(%ebp),%edx
  8011e7:	8b 75 10             	mov    0x10(%ebp),%esi
	size_t i;
	char *ret;

	ret = dst;
  8011ea:	89 cf                	mov    %ecx,%edi
	for (i = 0; i < size; i++) {
  8011ec:	bb 00 00 00 00       	mov    $0x0,%ebx
  8011f1:	39 f3                	cmp    %esi,%ebx
  8011f3:	73 10                	jae    801205 <strncpy+0x2a>
		*dst++ = *src;
  8011f5:	8a 02                	mov    (%edx),%al
  8011f7:	88 01                	mov    %al,(%ecx)
  8011f9:	41                   	inc    %ecx
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  8011fa:	80 3a 01             	cmpb   $0x1,(%edx)
  8011fd:	83 da ff             	sbb    $0xffffffff,%edx
  801200:	43                   	inc    %ebx
  801201:	39 f3                	cmp    %esi,%ebx
  801203:	72 f0                	jb     8011f5 <strncpy+0x1a>
	}
	return ret;
}
  801205:	89 f8                	mov    %edi,%eax
  801207:	5b                   	pop    %ebx
  801208:	5e                   	pop    %esi
  801209:	5f                   	pop    %edi
  80120a:	c9                   	leave  
  80120b:	c3                   	ret    

0080120c <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80120c:	55                   	push   %ebp
  80120d:	89 e5                	mov    %esp,%ebp
  80120f:	56                   	push   %esi
  801210:	53                   	push   %ebx
  801211:	8b 5d 08             	mov    0x8(%ebp),%ebx
  801214:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801217:	8b 55 10             	mov    0x10(%ebp),%edx
	char *dst_in;

	dst_in = dst;
  80121a:	89 de                	mov    %ebx,%esi
	if (size > 0) {
  80121c:	85 d2                	test   %edx,%edx
  80121e:	74 19                	je     801239 <strlcpy+0x2d>
		while (--size > 0 && *src != '\0')
			*dst++ = *src++;
  801220:	4a                   	dec    %edx
  801221:	74 13                	je     801236 <strlcpy+0x2a>
  801223:	80 39 00             	cmpb   $0x0,(%ecx)
  801226:	74 0e                	je     801236 <strlcpy+0x2a>
  801228:	8a 01                	mov    (%ecx),%al
  80122a:	41                   	inc    %ecx
  80122b:	88 03                	mov    %al,(%ebx)
  80122d:	43                   	inc    %ebx
  80122e:	4a                   	dec    %edx
  80122f:	74 05                	je     801236 <strlcpy+0x2a>
  801231:	80 39 00             	cmpb   $0x0,(%ecx)
  801234:	75 f2                	jne    801228 <strlcpy+0x1c>
		*dst = '\0';
  801236:	c6 03 00             	movb   $0x0,(%ebx)
	}
	return dst - dst_in;
  801239:	89 d8                	mov    %ebx,%eax
  80123b:	29 f0                	sub    %esi,%eax
}
  80123d:	5b                   	pop    %ebx
  80123e:	5e                   	pop    %esi
  80123f:	c9                   	leave  
  801240:	c3                   	ret    

00801241 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  801241:	55                   	push   %ebp
  801242:	89 e5                	mov    %esp,%ebp
  801244:	8b 55 08             	mov    0x8(%ebp),%edx
  801247:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	while (*p && *p == *q)
		p++, q++;
  80124a:	80 3a 00             	cmpb   $0x0,(%edx)
  80124d:	74 13                	je     801262 <strcmp+0x21>
  80124f:	8a 02                	mov    (%edx),%al
  801251:	3a 01                	cmp    (%ecx),%al
  801253:	75 0d                	jne    801262 <strcmp+0x21>
  801255:	42                   	inc    %edx
  801256:	41                   	inc    %ecx
  801257:	80 3a 00             	cmpb   $0x0,(%edx)
  80125a:	74 06                	je     801262 <strcmp+0x21>
  80125c:	8a 02                	mov    (%edx),%al
  80125e:	3a 01                	cmp    (%ecx),%al
  801260:	74 f3                	je     801255 <strcmp+0x14>
	return (int) ((unsigned char) *p - (unsigned char) *q);
  801262:	0f b6 02             	movzbl (%edx),%eax
  801265:	0f b6 11             	movzbl (%ecx),%edx
  801268:	29 d0                	sub    %edx,%eax
}
  80126a:	c9                   	leave  
  80126b:	c3                   	ret    

0080126c <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80126c:	55                   	push   %ebp
  80126d:	89 e5                	mov    %esp,%ebp
  80126f:	53                   	push   %ebx
  801270:	8b 55 08             	mov    0x8(%ebp),%edx
  801273:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801276:	8b 4d 10             	mov    0x10(%ebp),%ecx
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
  801279:	85 c9                	test   %ecx,%ecx
  80127b:	74 1f                	je     80129c <strncmp+0x30>
  80127d:	80 3a 00             	cmpb   $0x0,(%edx)
  801280:	74 16                	je     801298 <strncmp+0x2c>
  801282:	8a 02                	mov    (%edx),%al
  801284:	3a 03                	cmp    (%ebx),%al
  801286:	75 10                	jne    801298 <strncmp+0x2c>
  801288:	42                   	inc    %edx
  801289:	43                   	inc    %ebx
  80128a:	49                   	dec    %ecx
  80128b:	74 0f                	je     80129c <strncmp+0x30>
  80128d:	80 3a 00             	cmpb   $0x0,(%edx)
  801290:	74 06                	je     801298 <strncmp+0x2c>
  801292:	8a 02                	mov    (%edx),%al
  801294:	3a 03                	cmp    (%ebx),%al
  801296:	74 f0                	je     801288 <strncmp+0x1c>
	if (n == 0)
  801298:	85 c9                	test   %ecx,%ecx
  80129a:	75 07                	jne    8012a3 <strncmp+0x37>
		return 0;
  80129c:	b8 00 00 00 00       	mov    $0x0,%eax
  8012a1:	eb 0a                	jmp    8012ad <strncmp+0x41>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  8012a3:	0f b6 12             	movzbl (%edx),%edx
  8012a6:	0f b6 03             	movzbl (%ebx),%eax
  8012a9:	29 c2                	sub    %eax,%edx
  8012ab:	89 d0                	mov    %edx,%eax
}
  8012ad:	5b                   	pop    %ebx
  8012ae:	c9                   	leave  
  8012af:	c3                   	ret    

008012b0 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  8012b0:	55                   	push   %ebp
  8012b1:	89 e5                	mov    %esp,%ebp
  8012b3:	8b 45 08             	mov    0x8(%ebp),%eax
  8012b6:	8a 55 0c             	mov    0xc(%ebp),%dl
	for (; *s; s++)
  8012b9:	80 38 00             	cmpb   $0x0,(%eax)
  8012bc:	74 0a                	je     8012c8 <strchr+0x18>
		if (*s == c)
  8012be:	38 10                	cmp    %dl,(%eax)
  8012c0:	74 0b                	je     8012cd <strchr+0x1d>
  8012c2:	40                   	inc    %eax
  8012c3:	80 38 00             	cmpb   $0x0,(%eax)
  8012c6:	75 f6                	jne    8012be <strchr+0xe>
			return (char *) s;
	return 0;
  8012c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8012cd:	c9                   	leave  
  8012ce:	c3                   	ret    

008012cf <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  8012cf:	55                   	push   %ebp
  8012d0:	89 e5                	mov    %esp,%ebp
  8012d2:	8b 45 08             	mov    0x8(%ebp),%eax
  8012d5:	8a 55 0c             	mov    0xc(%ebp),%dl
	for (; *s; s++)
  8012d8:	80 38 00             	cmpb   $0x0,(%eax)
  8012db:	74 0a                	je     8012e7 <strfind+0x18>
		if (*s == c)
  8012dd:	38 10                	cmp    %dl,(%eax)
  8012df:	74 06                	je     8012e7 <strfind+0x18>
  8012e1:	40                   	inc    %eax
  8012e2:	80 38 00             	cmpb   $0x0,(%eax)
  8012e5:	75 f6                	jne    8012dd <strfind+0xe>
			break;
	return (char *) s;
}
  8012e7:	c9                   	leave  
  8012e8:	c3                   	ret    

008012e9 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  8012e9:	55                   	push   %ebp
  8012ea:	89 e5                	mov    %esp,%ebp
  8012ec:	57                   	push   %edi
  8012ed:	8b 7d 08             	mov    0x8(%ebp),%edi
  8012f0:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
		return v;
  8012f3:	89 f8                	mov    %edi,%eax
  8012f5:	85 c9                	test   %ecx,%ecx
  8012f7:	74 40                	je     801339 <memset+0x50>
	if ((int)v%4 == 0 && n%4 == 0) {
  8012f9:	f7 c7 03 00 00 00    	test   $0x3,%edi
  8012ff:	75 30                	jne    801331 <memset+0x48>
  801301:	f6 c1 03             	test   $0x3,%cl
  801304:	75 2b                	jne    801331 <memset+0x48>
		c &= 0xFF;
  801306:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80130d:	8b 45 0c             	mov    0xc(%ebp),%eax
  801310:	c1 e0 18             	shl    $0x18,%eax
  801313:	8b 55 0c             	mov    0xc(%ebp),%edx
  801316:	c1 e2 10             	shl    $0x10,%edx
  801319:	09 d0                	or     %edx,%eax
  80131b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80131e:	c1 e2 08             	shl    $0x8,%edx
  801321:	09 d0                	or     %edx,%eax
  801323:	09 45 0c             	or     %eax,0xc(%ebp)
		asm volatile("cld; rep stosl\n"
  801326:	c1 e9 02             	shr    $0x2,%ecx
  801329:	8b 45 0c             	mov    0xc(%ebp),%eax
  80132c:	fc                   	cld    
  80132d:	f3 ab                	repz stos %eax,%es:(%edi)
  80132f:	eb 06                	jmp    801337 <memset+0x4e>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  801331:	8b 45 0c             	mov    0xc(%ebp),%eax
  801334:	fc                   	cld    
  801335:	f3 aa                	repz stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
  801337:	89 f8                	mov    %edi,%eax
}
  801339:	5f                   	pop    %edi
  80133a:	c9                   	leave  
  80133b:	c3                   	ret    

0080133c <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80133c:	55                   	push   %ebp
  80133d:	89 e5                	mov    %esp,%ebp
  80133f:	57                   	push   %edi
  801340:	56                   	push   %esi
  801341:	8b 45 08             	mov    0x8(%ebp),%eax
  801344:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;
	
	s = src;
  801347:	8b 75 0c             	mov    0xc(%ebp),%esi
	d = dst;
  80134a:	89 c7                	mov    %eax,%edi
	if (s < d && s + n > d) {
  80134c:	39 c6                	cmp    %eax,%esi
  80134e:	73 33                	jae    801383 <memmove+0x47>
  801350:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  801353:	39 c2                	cmp    %eax,%edx
  801355:	76 2c                	jbe    801383 <memmove+0x47>
		s += n;
  801357:	89 d6                	mov    %edx,%esi
		d += n;
  801359:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80135c:	f6 c2 03             	test   $0x3,%dl
  80135f:	75 1b                	jne    80137c <memmove+0x40>
  801361:	f7 c7 03 00 00 00    	test   $0x3,%edi
  801367:	75 13                	jne    80137c <memmove+0x40>
  801369:	f6 c1 03             	test   $0x3,%cl
  80136c:	75 0e                	jne    80137c <memmove+0x40>
			asm volatile("std; rep movsl\n"
  80136e:	83 ef 04             	sub    $0x4,%edi
  801371:	83 ee 04             	sub    $0x4,%esi
  801374:	c1 e9 02             	shr    $0x2,%ecx
  801377:	fd                   	std    
  801378:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
  80137a:	eb 27                	jmp    8013a3 <memmove+0x67>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80137c:	4f                   	dec    %edi
  80137d:	4e                   	dec    %esi
  80137e:	fd                   	std    
  80137f:	f3 a4                	repz movsb %ds:(%esi),%es:(%edi)
  801381:	eb 20                	jmp    8013a3 <memmove+0x67>
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  801383:	f7 c6 03 00 00 00    	test   $0x3,%esi
  801389:	75 15                	jne    8013a0 <memmove+0x64>
  80138b:	f7 c7 03 00 00 00    	test   $0x3,%edi
  801391:	75 0d                	jne    8013a0 <memmove+0x64>
  801393:	f6 c1 03             	test   $0x3,%cl
  801396:	75 08                	jne    8013a0 <memmove+0x64>
			asm volatile("cld; rep movsl\n"
  801398:	c1 e9 02             	shr    $0x2,%ecx
  80139b:	fc                   	cld    
  80139c:	f3 a5                	repz movsl %ds:(%esi),%es:(%edi)
  80139e:	eb 03                	jmp    8013a3 <memmove+0x67>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  8013a0:	fc                   	cld    
  8013a1:	f3 a4                	repz movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  8013a3:	5e                   	pop    %esi
  8013a4:	5f                   	pop    %edi
  8013a5:	c9                   	leave  
  8013a6:	c3                   	ret    

008013a7 <memcpy>:

#else

void *
memset(void *v, int c, size_t n)
{
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
		*p++ = c;

	return v;
}

/* no memcpy - use memmove instead */

void *
memmove(void *dst, const void *src, size_t n)
{
	const char *s;
	char *d;
	
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;

	return dst;
}
#endif

/* sigh - gcc emits references to this for structure assignments! */
/* it is *not* prototyped in inc/string.h - do not use directly. */
void *
memcpy(void *dst, void *src, size_t n)
{
  8013a7:	55                   	push   %ebp
  8013a8:	89 e5                	mov    %esp,%ebp
	return memmove(dst, src, n);
  8013aa:	ff 75 10             	pushl  0x10(%ebp)
  8013ad:	ff 75 0c             	pushl  0xc(%ebp)
  8013b0:	ff 75 08             	pushl  0x8(%ebp)
  8013b3:	e8 84 ff ff ff       	call   80133c <memmove>
}
  8013b8:	c9                   	leave  
  8013b9:	c3                   	ret    

008013ba <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  8013ba:	55                   	push   %ebp
  8013bb:	89 e5                	mov    %esp,%ebp
  8013bd:	53                   	push   %ebx
	const uint8_t *s1 = (const uint8_t *) v1;
  8013be:	8b 4d 08             	mov    0x8(%ebp),%ecx
	const uint8_t *s2 = (const uint8_t *) v2;
  8013c1:	8b 5d 0c             	mov    0xc(%ebp),%ebx

	while (n-- > 0) {
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
  8013c4:	8b 55 10             	mov    0x10(%ebp),%edx
  8013c7:	4a                   	dec    %edx
  8013c8:	83 fa ff             	cmp    $0xffffffff,%edx
  8013cb:	74 1a                	je     8013e7 <memcmp+0x2d>
  8013cd:	8a 01                	mov    (%ecx),%al
  8013cf:	3a 03                	cmp    (%ebx),%al
  8013d1:	74 0c                	je     8013df <memcmp+0x25>
  8013d3:	0f b6 d0             	movzbl %al,%edx
  8013d6:	0f b6 03             	movzbl (%ebx),%eax
  8013d9:	29 c2                	sub    %eax,%edx
  8013db:	89 d0                	mov    %edx,%eax
  8013dd:	eb 0d                	jmp    8013ec <memcmp+0x32>
  8013df:	41                   	inc    %ecx
  8013e0:	43                   	inc    %ebx
  8013e1:	4a                   	dec    %edx
  8013e2:	83 fa ff             	cmp    $0xffffffff,%edx
  8013e5:	75 e6                	jne    8013cd <memcmp+0x13>
	}

	return 0;
  8013e7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8013ec:	5b                   	pop    %ebx
  8013ed:	c9                   	leave  
  8013ee:	c3                   	ret    

008013ef <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  8013ef:	55                   	push   %ebp
  8013f0:	89 e5                	mov    %esp,%ebp
  8013f2:	8b 45 08             	mov    0x8(%ebp),%eax
  8013f5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  8013f8:	89 c2                	mov    %eax,%edx
  8013fa:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  8013fd:	39 d0                	cmp    %edx,%eax
  8013ff:	73 09                	jae    80140a <memfind+0x1b>
		if (*(const unsigned char *) s == (unsigned char) c)
  801401:	38 08                	cmp    %cl,(%eax)
  801403:	74 05                	je     80140a <memfind+0x1b>
  801405:	40                   	inc    %eax
  801406:	39 d0                	cmp    %edx,%eax
  801408:	72 f7                	jb     801401 <memfind+0x12>
			break;
	return (void *) s;
}
  80140a:	c9                   	leave  
  80140b:	c3                   	ret    

0080140c <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80140c:	55                   	push   %ebp
  80140d:	89 e5                	mov    %esp,%ebp
  80140f:	57                   	push   %edi
  801410:	56                   	push   %esi
  801411:	53                   	push   %ebx
  801412:	8b 55 08             	mov    0x8(%ebp),%edx
  801415:	8b 75 0c             	mov    0xc(%ebp),%esi
  801418:	8b 4d 10             	mov    0x10(%ebp),%ecx
	int neg = 0;
  80141b:	bf 00 00 00 00       	mov    $0x0,%edi
	long val = 0;
  801420:	bb 00 00 00 00       	mov    $0x0,%ebx

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
		s++;
  801425:	80 3a 20             	cmpb   $0x20,(%edx)
  801428:	74 05                	je     80142f <strtol+0x23>
  80142a:	80 3a 09             	cmpb   $0x9,(%edx)
  80142d:	75 0b                	jne    80143a <strtol+0x2e>
  80142f:	42                   	inc    %edx
  801430:	80 3a 20             	cmpb   $0x20,(%edx)
  801433:	74 fa                	je     80142f <strtol+0x23>
  801435:	80 3a 09             	cmpb   $0x9,(%edx)
  801438:	74 f5                	je     80142f <strtol+0x23>

	// plus/minus sign
	if (*s == '+')
  80143a:	80 3a 2b             	cmpb   $0x2b,(%edx)
  80143d:	75 03                	jne    801442 <strtol+0x36>
		s++;
  80143f:	42                   	inc    %edx
  801440:	eb 0b                	jmp    80144d <strtol+0x41>
	else if (*s == '-')
  801442:	80 3a 2d             	cmpb   $0x2d,(%edx)
  801445:	75 06                	jne    80144d <strtol+0x41>
		s++, neg = 1;
  801447:	42                   	inc    %edx
  801448:	bf 01 00 00 00       	mov    $0x1,%edi

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80144d:	85 c9                	test   %ecx,%ecx
  80144f:	74 05                	je     801456 <strtol+0x4a>
  801451:	83 f9 10             	cmp    $0x10,%ecx
  801454:	75 15                	jne    80146b <strtol+0x5f>
  801456:	80 3a 30             	cmpb   $0x30,(%edx)
  801459:	75 10                	jne    80146b <strtol+0x5f>
  80145b:	80 7a 01 78          	cmpb   $0x78,0x1(%edx)
  80145f:	75 0a                	jne    80146b <strtol+0x5f>
		s += 2, base = 16;
  801461:	83 c2 02             	add    $0x2,%edx
  801464:	b9 10 00 00 00       	mov    $0x10,%ecx
  801469:	eb 14                	jmp    80147f <strtol+0x73>
	else if (base == 0 && s[0] == '0')
  80146b:	85 c9                	test   %ecx,%ecx
  80146d:	75 10                	jne    80147f <strtol+0x73>
  80146f:	80 3a 30             	cmpb   $0x30,(%edx)
  801472:	75 05                	jne    801479 <strtol+0x6d>
		s++, base = 8;
  801474:	42                   	inc    %edx
  801475:	b1 08                	mov    $0x8,%cl
  801477:	eb 06                	jmp    80147f <strtol+0x73>
	else if (base == 0)
  801479:	85 c9                	test   %ecx,%ecx
  80147b:	75 02                	jne    80147f <strtol+0x73>
		base = 10;
  80147d:	b1 0a                	mov    $0xa,%cl

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  80147f:	8a 02                	mov    (%edx),%al
  801481:	83 e8 30             	sub    $0x30,%eax
  801484:	3c 09                	cmp    $0x9,%al
  801486:	77 08                	ja     801490 <strtol+0x84>
			dig = *s - '0';
  801488:	0f be 02             	movsbl (%edx),%eax
  80148b:	83 e8 30             	sub    $0x30,%eax
  80148e:	eb 20                	jmp    8014b0 <strtol+0xa4>
		else if (*s >= 'a' && *s <= 'z')
  801490:	8a 02                	mov    (%edx),%al
  801492:	83 e8 61             	sub    $0x61,%eax
  801495:	3c 19                	cmp    $0x19,%al
  801497:	77 08                	ja     8014a1 <strtol+0x95>
			dig = *s - 'a' + 10;
  801499:	0f be 02             	movsbl (%edx),%eax
  80149c:	83 e8 57             	sub    $0x57,%eax
  80149f:	eb 0f                	jmp    8014b0 <strtol+0xa4>
		else if (*s >= 'A' && *s <= 'Z')
  8014a1:	8a 02                	mov    (%edx),%al
  8014a3:	83 e8 41             	sub    $0x41,%eax
  8014a6:	3c 19                	cmp    $0x19,%al
  8014a8:	77 12                	ja     8014bc <strtol+0xb0>
			dig = *s - 'A' + 10;
  8014aa:	0f be 02             	movsbl (%edx),%eax
  8014ad:	83 e8 37             	sub    $0x37,%eax
		else
			break;
		if (dig >= base)
  8014b0:	39 c8                	cmp    %ecx,%eax
  8014b2:	7d 08                	jge    8014bc <strtol+0xb0>
			break;
		s++, val = (val * base) + dig;
  8014b4:	42                   	inc    %edx
  8014b5:	0f af d9             	imul   %ecx,%ebx
  8014b8:	01 c3                	add    %eax,%ebx
  8014ba:	eb c3                	jmp    80147f <strtol+0x73>
		// we don't properly detect overflow!
	}

	if (endptr)
  8014bc:	85 f6                	test   %esi,%esi
  8014be:	74 02                	je     8014c2 <strtol+0xb6>
		*endptr = (char *) s;
  8014c0:	89 16                	mov    %edx,(%esi)
	return (neg ? -val : val);
  8014c2:	89 d8                	mov    %ebx,%eax
  8014c4:	85 ff                	test   %edi,%edi
  8014c6:	74 02                	je     8014ca <strtol+0xbe>
  8014c8:	f7 d8                	neg    %eax
}
  8014ca:	5b                   	pop    %ebx
  8014cb:	5e                   	pop    %esi
  8014cc:	5f                   	pop    %edi
  8014cd:	c9                   	leave  
  8014ce:	c3                   	ret    
	...

008014d0 <sys_cputs>:
}

void
sys_cputs(const char *s, size_t len)
{
  8014d0:	55                   	push   %ebp
  8014d1:	89 e5                	mov    %esp,%ebp
  8014d3:	57                   	push   %edi
  8014d4:	56                   	push   %esi
  8014d5:	53                   	push   %ebx
  8014d6:	83 ec 04             	sub    $0x4,%esp
  8014d9:	8b 55 08             	mov    0x8(%ebp),%edx
  8014dc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8014df:	bf 00 00 00 00       	mov    $0x0,%edi
  8014e4:	89 f8                	mov    %edi,%eax
  8014e6:	89 fb                	mov    %edi,%ebx
  8014e8:	89 fe                	mov    %edi,%esi
  8014ea:	cd 30                	int    $0x30
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  8014ec:	83 c4 04             	add    $0x4,%esp
  8014ef:	5b                   	pop    %ebx
  8014f0:	5e                   	pop    %esi
  8014f1:	5f                   	pop    %edi
  8014f2:	c9                   	leave  
  8014f3:	c3                   	ret    

008014f4 <sys_cgetc>:

int
sys_cgetc(void)
{
  8014f4:	55                   	push   %ebp
  8014f5:	89 e5                	mov    %esp,%ebp
  8014f7:	57                   	push   %edi
  8014f8:	56                   	push   %esi
  8014f9:	53                   	push   %ebx
  8014fa:	b8 01 00 00 00       	mov    $0x1,%eax
  8014ff:	bf 00 00 00 00       	mov    $0x0,%edi
  801504:	89 fa                	mov    %edi,%edx
  801506:	89 f9                	mov    %edi,%ecx
  801508:	89 fb                	mov    %edi,%ebx
  80150a:	89 fe                	mov    %edi,%esi
  80150c:	cd 30                	int    $0x30
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80150e:	5b                   	pop    %ebx
  80150f:	5e                   	pop    %esi
  801510:	5f                   	pop    %edi
  801511:	c9                   	leave  
  801512:	c3                   	ret    

00801513 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  801513:	55                   	push   %ebp
  801514:	89 e5                	mov    %esp,%ebp
  801516:	57                   	push   %edi
  801517:	56                   	push   %esi
  801518:	53                   	push   %ebx
  801519:	83 ec 0c             	sub    $0xc,%esp
  80151c:	8b 55 08             	mov    0x8(%ebp),%edx
  80151f:	b8 03 00 00 00       	mov    $0x3,%eax
  801524:	bf 00 00 00 00       	mov    $0x0,%edi
  801529:	89 f9                	mov    %edi,%ecx
  80152b:	89 fb                	mov    %edi,%ebx
  80152d:	89 fe                	mov    %edi,%esi
  80152f:	cd 30                	int    $0x30
  801531:	85 c0                	test   %eax,%eax
  801533:	7e 17                	jle    80154c <sys_env_destroy+0x39>
  801535:	83 ec 0c             	sub    $0xc,%esp
  801538:	50                   	push   %eax
  801539:	6a 03                	push   $0x3
  80153b:	68 70 20 81 00       	push   $0x812070
  801540:	6a 23                	push   $0x23
  801542:	68 8d 20 81 00       	push   $0x81208d
  801547:	e8 80 f5 ff ff       	call   800acc <_panic>
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80154c:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80154f:	5b                   	pop    %ebx
  801550:	5e                   	pop    %esi
  801551:	5f                   	pop    %edi
  801552:	c9                   	leave  
  801553:	c3                   	ret    

00801554 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  801554:	55                   	push   %ebp
  801555:	89 e5                	mov    %esp,%ebp
  801557:	57                   	push   %edi
  801558:	56                   	push   %esi
  801559:	53                   	push   %ebx
  80155a:	b8 02 00 00 00       	mov    $0x2,%eax
  80155f:	bf 00 00 00 00       	mov    $0x0,%edi
  801564:	89 fa                	mov    %edi,%edx
  801566:	89 f9                	mov    %edi,%ecx
  801568:	89 fb                	mov    %edi,%ebx
  80156a:	89 fe                	mov    %edi,%esi
  80156c:	cd 30                	int    $0x30
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80156e:	5b                   	pop    %ebx
  80156f:	5e                   	pop    %esi
  801570:	5f                   	pop    %edi
  801571:	c9                   	leave  
  801572:	c3                   	ret    

00801573 <sys_yield>:

void
sys_yield(void)
{
  801573:	55                   	push   %ebp
  801574:	89 e5                	mov    %esp,%ebp
  801576:	57                   	push   %edi
  801577:	56                   	push   %esi
  801578:	53                   	push   %ebx
  801579:	b8 0b 00 00 00       	mov    $0xb,%eax
  80157e:	bf 00 00 00 00       	mov    $0x0,%edi
  801583:	89 fa                	mov    %edi,%edx
  801585:	89 f9                	mov    %edi,%ecx
  801587:	89 fb                	mov    %edi,%ebx
  801589:	89 fe                	mov    %edi,%esi
  80158b:	cd 30                	int    $0x30
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80158d:	5b                   	pop    %ebx
  80158e:	5e                   	pop    %esi
  80158f:	5f                   	pop    %edi
  801590:	c9                   	leave  
  801591:	c3                   	ret    

00801592 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  801592:	55                   	push   %ebp
  801593:	89 e5                	mov    %esp,%ebp
  801595:	57                   	push   %edi
  801596:	56                   	push   %esi
  801597:	53                   	push   %ebx
  801598:	83 ec 0c             	sub    $0xc,%esp
  80159b:	8b 55 08             	mov    0x8(%ebp),%edx
  80159e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8015a1:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8015a4:	b8 04 00 00 00       	mov    $0x4,%eax
  8015a9:	bf 00 00 00 00       	mov    $0x0,%edi
  8015ae:	89 fe                	mov    %edi,%esi
  8015b0:	cd 30                	int    $0x30
  8015b2:	85 c0                	test   %eax,%eax
  8015b4:	7e 17                	jle    8015cd <sys_page_alloc+0x3b>
  8015b6:	83 ec 0c             	sub    $0xc,%esp
  8015b9:	50                   	push   %eax
  8015ba:	6a 04                	push   $0x4
  8015bc:	68 70 20 81 00       	push   $0x812070
  8015c1:	6a 23                	push   $0x23
  8015c3:	68 8d 20 81 00       	push   $0x81208d
  8015c8:	e8 ff f4 ff ff       	call   800acc <_panic>
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  8015cd:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8015d0:	5b                   	pop    %ebx
  8015d1:	5e                   	pop    %esi
  8015d2:	5f                   	pop    %edi
  8015d3:	c9                   	leave  
  8015d4:	c3                   	ret    

008015d5 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  8015d5:	55                   	push   %ebp
  8015d6:	89 e5                	mov    %esp,%ebp
  8015d8:	57                   	push   %edi
  8015d9:	56                   	push   %esi
  8015da:	53                   	push   %ebx
  8015db:	83 ec 0c             	sub    $0xc,%esp
  8015de:	8b 55 08             	mov    0x8(%ebp),%edx
  8015e1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8015e4:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8015e7:	8b 7d 14             	mov    0x14(%ebp),%edi
  8015ea:	8b 75 18             	mov    0x18(%ebp),%esi
  8015ed:	b8 05 00 00 00       	mov    $0x5,%eax
  8015f2:	cd 30                	int    $0x30
  8015f4:	85 c0                	test   %eax,%eax
  8015f6:	7e 17                	jle    80160f <sys_page_map+0x3a>
  8015f8:	83 ec 0c             	sub    $0xc,%esp
  8015fb:	50                   	push   %eax
  8015fc:	6a 05                	push   $0x5
  8015fe:	68 70 20 81 00       	push   $0x812070
  801603:	6a 23                	push   $0x23
  801605:	68 8d 20 81 00       	push   $0x81208d
  80160a:	e8 bd f4 ff ff       	call   800acc <_panic>
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80160f:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  801612:	5b                   	pop    %ebx
  801613:	5e                   	pop    %esi
  801614:	5f                   	pop    %edi
  801615:	c9                   	leave  
  801616:	c3                   	ret    

00801617 <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  801617:	55                   	push   %ebp
  801618:	89 e5                	mov    %esp,%ebp
  80161a:	57                   	push   %edi
  80161b:	56                   	push   %esi
  80161c:	53                   	push   %ebx
  80161d:	83 ec 0c             	sub    $0xc,%esp
  801620:	8b 55 08             	mov    0x8(%ebp),%edx
  801623:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801626:	b8 06 00 00 00       	mov    $0x6,%eax
  80162b:	bf 00 00 00 00       	mov    $0x0,%edi
  801630:	89 fb                	mov    %edi,%ebx
  801632:	89 fe                	mov    %edi,%esi
  801634:	cd 30                	int    $0x30
  801636:	85 c0                	test   %eax,%eax
  801638:	7e 17                	jle    801651 <sys_page_unmap+0x3a>
  80163a:	83 ec 0c             	sub    $0xc,%esp
  80163d:	50                   	push   %eax
  80163e:	6a 06                	push   $0x6
  801640:	68 70 20 81 00       	push   $0x812070
  801645:	6a 23                	push   $0x23
  801647:	68 8d 20 81 00       	push   $0x81208d
  80164c:	e8 7b f4 ff ff       	call   800acc <_panic>
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  801651:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  801654:	5b                   	pop    %ebx
  801655:	5e                   	pop    %esi
  801656:	5f                   	pop    %edi
  801657:	c9                   	leave  
  801658:	c3                   	ret    

00801659 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  801659:	55                   	push   %ebp
  80165a:	89 e5                	mov    %esp,%ebp
  80165c:	57                   	push   %edi
  80165d:	56                   	push   %esi
  80165e:	53                   	push   %ebx
  80165f:	83 ec 0c             	sub    $0xc,%esp
  801662:	8b 55 08             	mov    0x8(%ebp),%edx
  801665:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801668:	b8 08 00 00 00       	mov    $0x8,%eax
  80166d:	bf 00 00 00 00       	mov    $0x0,%edi
  801672:	89 fb                	mov    %edi,%ebx
  801674:	89 fe                	mov    %edi,%esi
  801676:	cd 30                	int    $0x30
  801678:	85 c0                	test   %eax,%eax
  80167a:	7e 17                	jle    801693 <sys_env_set_status+0x3a>
  80167c:	83 ec 0c             	sub    $0xc,%esp
  80167f:	50                   	push   %eax
  801680:	6a 08                	push   $0x8
  801682:	68 70 20 81 00       	push   $0x812070
  801687:	6a 23                	push   $0x23
  801689:	68 8d 20 81 00       	push   $0x81208d
  80168e:	e8 39 f4 ff ff       	call   800acc <_panic>
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  801693:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  801696:	5b                   	pop    %ebx
  801697:	5e                   	pop    %esi
  801698:	5f                   	pop    %edi
  801699:	c9                   	leave  
  80169a:	c3                   	ret    

0080169b <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80169b:	55                   	push   %ebp
  80169c:	89 e5                	mov    %esp,%ebp
  80169e:	57                   	push   %edi
  80169f:	56                   	push   %esi
  8016a0:	53                   	push   %ebx
  8016a1:	83 ec 0c             	sub    $0xc,%esp
  8016a4:	8b 55 08             	mov    0x8(%ebp),%edx
  8016a7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8016aa:	b8 09 00 00 00       	mov    $0x9,%eax
  8016af:	bf 00 00 00 00       	mov    $0x0,%edi
  8016b4:	89 fb                	mov    %edi,%ebx
  8016b6:	89 fe                	mov    %edi,%esi
  8016b8:	cd 30                	int    $0x30
  8016ba:	85 c0                	test   %eax,%eax
  8016bc:	7e 17                	jle    8016d5 <sys_env_set_trapframe+0x3a>
  8016be:	83 ec 0c             	sub    $0xc,%esp
  8016c1:	50                   	push   %eax
  8016c2:	6a 09                	push   $0x9
  8016c4:	68 70 20 81 00       	push   $0x812070
  8016c9:	6a 23                	push   $0x23
  8016cb:	68 8d 20 81 00       	push   $0x81208d
  8016d0:	e8 f7 f3 ff ff       	call   800acc <_panic>
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  8016d5:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8016d8:	5b                   	pop    %ebx
  8016d9:	5e                   	pop    %esi
  8016da:	5f                   	pop    %edi
  8016db:	c9                   	leave  
  8016dc:	c3                   	ret    

008016dd <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  8016dd:	55                   	push   %ebp
  8016de:	89 e5                	mov    %esp,%ebp
  8016e0:	57                   	push   %edi
  8016e1:	56                   	push   %esi
  8016e2:	53                   	push   %ebx
  8016e3:	83 ec 0c             	sub    $0xc,%esp
  8016e6:	8b 55 08             	mov    0x8(%ebp),%edx
  8016e9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8016ec:	b8 0a 00 00 00       	mov    $0xa,%eax
  8016f1:	bf 00 00 00 00       	mov    $0x0,%edi
  8016f6:	89 fb                	mov    %edi,%ebx
  8016f8:	89 fe                	mov    %edi,%esi
  8016fa:	cd 30                	int    $0x30
  8016fc:	85 c0                	test   %eax,%eax
  8016fe:	7e 17                	jle    801717 <sys_env_set_pgfault_upcall+0x3a>
  801700:	83 ec 0c             	sub    $0xc,%esp
  801703:	50                   	push   %eax
  801704:	6a 0a                	push   $0xa
  801706:	68 70 20 81 00       	push   $0x812070
  80170b:	6a 23                	push   $0x23
  80170d:	68 8d 20 81 00       	push   $0x81208d
  801712:	e8 b5 f3 ff ff       	call   800acc <_panic>
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  801717:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80171a:	5b                   	pop    %ebx
  80171b:	5e                   	pop    %esi
  80171c:	5f                   	pop    %edi
  80171d:	c9                   	leave  
  80171e:	c3                   	ret    

0080171f <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80171f:	55                   	push   %ebp
  801720:	89 e5                	mov    %esp,%ebp
  801722:	57                   	push   %edi
  801723:	56                   	push   %esi
  801724:	53                   	push   %ebx
  801725:	8b 55 08             	mov    0x8(%ebp),%edx
  801728:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80172b:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80172e:	8b 7d 14             	mov    0x14(%ebp),%edi
  801731:	b8 0c 00 00 00       	mov    $0xc,%eax
  801736:	be 00 00 00 00       	mov    $0x0,%esi
  80173b:	cd 30                	int    $0x30
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80173d:	5b                   	pop    %ebx
  80173e:	5e                   	pop    %esi
  80173f:	5f                   	pop    %edi
  801740:	c9                   	leave  
  801741:	c3                   	ret    

00801742 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  801742:	55                   	push   %ebp
  801743:	89 e5                	mov    %esp,%ebp
  801745:	57                   	push   %edi
  801746:	56                   	push   %esi
  801747:	53                   	push   %ebx
  801748:	83 ec 0c             	sub    $0xc,%esp
  80174b:	8b 55 08             	mov    0x8(%ebp),%edx
  80174e:	b8 0d 00 00 00       	mov    $0xd,%eax
  801753:	bf 00 00 00 00       	mov    $0x0,%edi
  801758:	89 f9                	mov    %edi,%ecx
  80175a:	89 fb                	mov    %edi,%ebx
  80175c:	89 fe                	mov    %edi,%esi
  80175e:	cd 30                	int    $0x30
  801760:	85 c0                	test   %eax,%eax
  801762:	7e 17                	jle    80177b <sys_ipc_recv+0x39>
  801764:	83 ec 0c             	sub    $0xc,%esp
  801767:	50                   	push   %eax
  801768:	6a 0d                	push   $0xd
  80176a:	68 70 20 81 00       	push   $0x812070
  80176f:	6a 23                	push   $0x23
  801771:	68 8d 20 81 00       	push   $0x81208d
  801776:	e8 51 f3 ff ff       	call   800acc <_panic>
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80177b:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80177e:	5b                   	pop    %ebx
  80177f:	5e                   	pop    %esi
  801780:	5f                   	pop    %edi
  801781:	c9                   	leave  
  801782:	c3                   	ret    

00801783 <sys_transmit_packet>:

int
sys_transmit_packet(char* packet, int pktsize)
{
  801783:	55                   	push   %ebp
  801784:	89 e5                	mov    %esp,%ebp
  801786:	57                   	push   %edi
  801787:	56                   	push   %esi
  801788:	53                   	push   %ebx
  801789:	83 ec 0c             	sub    $0xc,%esp
  80178c:	8b 55 08             	mov    0x8(%ebp),%edx
  80178f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801792:	b8 10 00 00 00       	mov    $0x10,%eax
  801797:	bf 00 00 00 00       	mov    $0x0,%edi
  80179c:	89 fb                	mov    %edi,%ebx
  80179e:	89 fe                	mov    %edi,%esi
  8017a0:	cd 30                	int    $0x30
  8017a2:	85 c0                	test   %eax,%eax
  8017a4:	7e 17                	jle    8017bd <sys_transmit_packet+0x3a>
  8017a6:	83 ec 0c             	sub    $0xc,%esp
  8017a9:	50                   	push   %eax
  8017aa:	6a 10                	push   $0x10
  8017ac:	68 70 20 81 00       	push   $0x812070
  8017b1:	6a 23                	push   $0x23
  8017b3:	68 8d 20 81 00       	push   $0x81208d
  8017b8:	e8 0f f3 ff ff       	call   800acc <_panic>
	return syscall(SYS_transmit_packet, 1, (uint32_t) packet, pktsize, 0, 0, 0);
}
  8017bd:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8017c0:	5b                   	pop    %ebx
  8017c1:	5e                   	pop    %esi
  8017c2:	5f                   	pop    %edi
  8017c3:	c9                   	leave  
  8017c4:	c3                   	ret    

008017c5 <sys_receive_packet>:

int
sys_receive_packet(char* packet, int* size)
{
  8017c5:	55                   	push   %ebp
  8017c6:	89 e5                	mov    %esp,%ebp
  8017c8:	57                   	push   %edi
  8017c9:	56                   	push   %esi
  8017ca:	53                   	push   %ebx
  8017cb:	83 ec 0c             	sub    $0xc,%esp
  8017ce:	8b 55 08             	mov    0x8(%ebp),%edx
  8017d1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8017d4:	b8 11 00 00 00       	mov    $0x11,%eax
  8017d9:	bf 00 00 00 00       	mov    $0x0,%edi
  8017de:	89 fb                	mov    %edi,%ebx
  8017e0:	89 fe                	mov    %edi,%esi
  8017e2:	cd 30                	int    $0x30
  8017e4:	85 c0                	test   %eax,%eax
  8017e6:	7e 17                	jle    8017ff <sys_receive_packet+0x3a>
  8017e8:	83 ec 0c             	sub    $0xc,%esp
  8017eb:	50                   	push   %eax
  8017ec:	6a 11                	push   $0x11
  8017ee:	68 70 20 81 00       	push   $0x812070
  8017f3:	6a 23                	push   $0x23
  8017f5:	68 8d 20 81 00       	push   $0x81208d
  8017fa:	e8 cd f2 ff ff       	call   800acc <_panic>
	return syscall(SYS_receive_packet, 1, (uint32_t) packet, (uint32_t) size, 0, 0, 0);
}
  8017ff:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  801802:	5b                   	pop    %ebx
  801803:	5e                   	pop    %esi
  801804:	5f                   	pop    %edi
  801805:	c9                   	leave  
  801806:	c3                   	ret    

00801807 <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  801807:	55                   	push   %ebp
  801808:	89 e5                	mov    %esp,%ebp
  80180a:	57                   	push   %edi
  80180b:	56                   	push   %esi
  80180c:	53                   	push   %ebx
  80180d:	b8 0f 00 00 00       	mov    $0xf,%eax
  801812:	bf 00 00 00 00       	mov    $0x0,%edi
  801817:	89 fa                	mov    %edi,%edx
  801819:	89 f9                	mov    %edi,%ecx
  80181b:	89 fb                	mov    %edi,%ebx
  80181d:	89 fe                	mov    %edi,%esi
  80181f:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  801821:	5b                   	pop    %ebx
  801822:	5e                   	pop    %esi
  801823:	5f                   	pop    %edi
  801824:	c9                   	leave  
  801825:	c3                   	ret    

00801826 <sys_map_receive_buffers>:

// Lab 6: Challenge
int
sys_map_receive_buffers(char* first_buffer)
{
  801826:	55                   	push   %ebp
  801827:	89 e5                	mov    %esp,%ebp
  801829:	57                   	push   %edi
  80182a:	56                   	push   %esi
  80182b:	53                   	push   %ebx
  80182c:	83 ec 0c             	sub    $0xc,%esp
  80182f:	8b 55 08             	mov    0x8(%ebp),%edx
  801832:	b8 0e 00 00 00       	mov    $0xe,%eax
  801837:	bf 00 00 00 00       	mov    $0x0,%edi
  80183c:	89 f9                	mov    %edi,%ecx
  80183e:	89 fb                	mov    %edi,%ebx
  801840:	89 fe                	mov    %edi,%esi
  801842:	cd 30                	int    $0x30
  801844:	85 c0                	test   %eax,%eax
  801846:	7e 17                	jle    80185f <sys_map_receive_buffers+0x39>
  801848:	83 ec 0c             	sub    $0xc,%esp
  80184b:	50                   	push   %eax
  80184c:	6a 0e                	push   $0xe
  80184e:	68 70 20 81 00       	push   $0x812070
  801853:	6a 23                	push   $0x23
  801855:	68 8d 20 81 00       	push   $0x81208d
  80185a:	e8 6d f2 ff ff       	call   800acc <_panic>
	return syscall(SYS_map_receive_buffers, 1, (uint32_t) first_buffer, 0, 0, 0, 0);
}
  80185f:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  801862:	5b                   	pop    %ebx
  801863:	5e                   	pop    %esi
  801864:	5f                   	pop    %edi
  801865:	c9                   	leave  
  801866:	c3                   	ret    

00801867 <sys_receive_packet_zerocopy>:
int
sys_receive_packet_zerocopy(int* packetidx)
{
  801867:	55                   	push   %ebp
  801868:	89 e5                	mov    %esp,%ebp
  80186a:	57                   	push   %edi
  80186b:	56                   	push   %esi
  80186c:	53                   	push   %ebx
  80186d:	83 ec 0c             	sub    $0xc,%esp
  801870:	8b 55 08             	mov    0x8(%ebp),%edx
  801873:	b8 12 00 00 00       	mov    $0x12,%eax
  801878:	bf 00 00 00 00       	mov    $0x0,%edi
  80187d:	89 f9                	mov    %edi,%ecx
  80187f:	89 fb                	mov    %edi,%ebx
  801881:	89 fe                	mov    %edi,%esi
  801883:	cd 30                	int    $0x30
  801885:	85 c0                	test   %eax,%eax
  801887:	7e 17                	jle    8018a0 <sys_receive_packet_zerocopy+0x39>
  801889:	83 ec 0c             	sub    $0xc,%esp
  80188c:	50                   	push   %eax
  80188d:	6a 12                	push   $0x12
  80188f:	68 70 20 81 00       	push   $0x812070
  801894:	6a 23                	push   $0x23
  801896:	68 8d 20 81 00       	push   $0x81208d
  80189b:	e8 2c f2 ff ff       	call   800acc <_panic>
	return syscall(SYS_receive_packet_zerocopy, 1, (uint32_t) packetidx, 0, 0, 0, 0);
}
  8018a0:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8018a3:	5b                   	pop    %ebx
  8018a4:	5e                   	pop    %esi
  8018a5:	5f                   	pop    %edi
  8018a6:	c9                   	leave  
  8018a7:	c3                   	ret    

008018a8 <sys_env_set_priority>:

// Lab 4: Challenge
int
sys_env_set_priority(envid_t envid, int priority)
{
  8018a8:	55                   	push   %ebp
  8018a9:	89 e5                	mov    %esp,%ebp
  8018ab:	57                   	push   %edi
  8018ac:	56                   	push   %esi
  8018ad:	53                   	push   %ebx
  8018ae:	83 ec 0c             	sub    $0xc,%esp
  8018b1:	8b 55 08             	mov    0x8(%ebp),%edx
  8018b4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8018b7:	b8 13 00 00 00       	mov    $0x13,%eax
  8018bc:	bf 00 00 00 00       	mov    $0x0,%edi
  8018c1:	89 fb                	mov    %edi,%ebx
  8018c3:	89 fe                	mov    %edi,%esi
  8018c5:	cd 30                	int    $0x30
  8018c7:	85 c0                	test   %eax,%eax
  8018c9:	7e 17                	jle    8018e2 <sys_env_set_priority+0x3a>
  8018cb:	83 ec 0c             	sub    $0xc,%esp
  8018ce:	50                   	push   %eax
  8018cf:	6a 13                	push   $0x13
  8018d1:	68 70 20 81 00       	push   $0x812070
  8018d6:	6a 23                	push   $0x23
  8018d8:	68 8d 20 81 00       	push   $0x81208d
  8018dd:	e8 ea f1 ff ff       	call   800acc <_panic>
	return syscall(SYS_env_set_priority, 1, envid, priority, 0, 0, 0);
}
  8018e2:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8018e5:	5b                   	pop    %ebx
  8018e6:	5e                   	pop    %esi
  8018e7:	5f                   	pop    %edi
  8018e8:	c9                   	leave  
  8018e9:	c3                   	ret    
	...

008018ec <pgfault>:
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  8018ec:	55                   	push   %ebp
  8018ed:	89 e5                	mov    %esp,%ebp
  8018ef:	53                   	push   %ebx
  8018f0:	83 ec 04             	sub    $0x4,%esp
  8018f3:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  8018f6:	8b 18                	mov    (%eax),%ebx
	uint32_t err = utf->utf_err;
	int r;

	// Check that the faulting access was (1) a write, and (2) to a
	// copy-on-write page.  If not, panic.
	// Hint:
	//   Use the read-only page table mappings at vpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
        // seanyliu
        if (!(err & FEC_WR) || !(vpt[VPN(addr)] & PTE_COW)) {
  8018f8:	f6 40 04 02          	testb  $0x2,0x4(%eax)
  8018fc:	74 11                	je     80190f <pgfault+0x23>
  8018fe:	89 d8                	mov    %ebx,%eax
  801900:	c1 e8 0c             	shr    $0xc,%eax
  801903:	8b 04 85 00 00 40 ef 	mov    0xef400000(,%eax,4),%eax
  80190a:	f6 c4 08             	test   $0x8,%ah
  80190d:	75 14                	jne    801923 <pgfault+0x37>
          panic("pgfault, err != FEC_WR or not copy-on-write page");
  80190f:	83 ec 04             	sub    $0x4,%esp
  801912:	68 9c 20 81 00       	push   $0x81209c
  801917:	6a 1e                	push   $0x1e
  801919:	68 f0 20 81 00       	push   $0x8120f0
  80191e:	e8 a9 f1 ff ff       	call   800acc <_panic>
        }

	// Allocate a new page, map it at a temporary location (PFTEMP),
	// copy the data from the old page to the new page, then move the new
	// page to the old page's address.
	// Hint:
	//   You should make three system calls.
	//   No need to explicitly delete the old page's mapping.

	// LAB 4: Your code here.
        // seanyliu
        addr = ROUNDDOWN(addr, PGSIZE);
  801923:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
	// Allocate a new page, map it at a temporary location (PFTEMP),
        if ((r = sys_page_alloc(sys_getenvid(), (void *)PFTEMP, PTE_U | PTE_W | PTE_P)) < 0) {
  801929:	83 ec 04             	sub    $0x4,%esp
  80192c:	6a 07                	push   $0x7
  80192e:	68 00 f0 7f 00       	push   $0x7ff000
  801933:	83 ec 04             	sub    $0x4,%esp
  801936:	e8 19 fc ff ff       	call   801554 <sys_getenvid>
  80193b:	89 04 24             	mov    %eax,(%esp)
  80193e:	e8 4f fc ff ff       	call   801592 <sys_page_alloc>
  801943:	83 c4 10             	add    $0x10,%esp
  801946:	85 c0                	test   %eax,%eax
  801948:	79 12                	jns    80195c <pgfault+0x70>
          panic("pgfault: sys_page_alloc %d", r);
  80194a:	50                   	push   %eax
  80194b:	68 fb 20 81 00       	push   $0x8120fb
  801950:	6a 2d                	push   $0x2d
  801952:	68 f0 20 81 00       	push   $0x8120f0
  801957:	e8 70 f1 ff ff       	call   800acc <_panic>
        }
	// copy the data from the old page to the new page
        memmove(PFTEMP, addr, PGSIZE);
  80195c:	83 ec 04             	sub    $0x4,%esp
  80195f:	68 00 10 00 00       	push   $0x1000
  801964:	53                   	push   %ebx
  801965:	68 00 f0 7f 00       	push   $0x7ff000
  80196a:	e8 cd f9 ff ff       	call   80133c <memmove>
	// move the new page to the old page's address.
        if ((r = sys_page_map(sys_getenvid(), PFTEMP, sys_getenvid(), addr, PTE_U | PTE_W | PTE_P)) < 0) {
  80196f:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  801976:	53                   	push   %ebx
  801977:	83 ec 0c             	sub    $0xc,%esp
  80197a:	e8 d5 fb ff ff       	call   801554 <sys_getenvid>
  80197f:	83 c4 0c             	add    $0xc,%esp
  801982:	50                   	push   %eax
  801983:	68 00 f0 7f 00       	push   $0x7ff000
  801988:	83 ec 04             	sub    $0x4,%esp
  80198b:	e8 c4 fb ff ff       	call   801554 <sys_getenvid>
  801990:	89 04 24             	mov    %eax,(%esp)
  801993:	e8 3d fc ff ff       	call   8015d5 <sys_page_map>
  801998:	83 c4 20             	add    $0x20,%esp
  80199b:	85 c0                	test   %eax,%eax
  80199d:	79 12                	jns    8019b1 <pgfault+0xc5>
          panic("pgfault: sys_page_map %d", r);
  80199f:	50                   	push   %eax
  8019a0:	68 16 21 81 00       	push   $0x812116
  8019a5:	6a 33                	push   $0x33
  8019a7:	68 f0 20 81 00       	push   $0x8120f0
  8019ac:	e8 1b f1 ff ff       	call   800acc <_panic>
        }
        if ((r = sys_page_unmap(sys_getenvid(), PFTEMP)) < 0) {
  8019b1:	83 ec 08             	sub    $0x8,%esp
  8019b4:	68 00 f0 7f 00       	push   $0x7ff000
  8019b9:	83 ec 04             	sub    $0x4,%esp
  8019bc:	e8 93 fb ff ff       	call   801554 <sys_getenvid>
  8019c1:	89 04 24             	mov    %eax,(%esp)
  8019c4:	e8 4e fc ff ff       	call   801617 <sys_page_unmap>
  8019c9:	83 c4 10             	add    $0x10,%esp
  8019cc:	85 c0                	test   %eax,%eax
  8019ce:	79 12                	jns    8019e2 <pgfault+0xf6>
          panic("pgfault: sys_page_unmap %d", r);
  8019d0:	50                   	push   %eax
  8019d1:	68 2f 21 81 00       	push   $0x81212f
  8019d6:	6a 36                	push   $0x36
  8019d8:	68 f0 20 81 00       	push   $0x8120f0
  8019dd:	e8 ea f0 ff ff       	call   800acc <_panic>
        }

	//panic("pgfault not implemented");
}
  8019e2:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8019e5:	c9                   	leave  
  8019e6:	c3                   	ret    

008019e7 <duppage>:

//
// Map our virtual page pn (address pn*PGSIZE) into the target envid
// at the same virtual address.  If the page is writable or copy-on-write,
// the new mapping must be created copy-on-write, and then our mapping must be
// marked copy-on-write as well.  (Exercise: Why might we need to mark ours
// copy-on-write again if it was already copy-on-write at the beginning of
// this function?)
//
// Returns: 0 on success, < 0 on error.
// It is also OK to panic on error.
// 
static int
duppage(envid_t envid, unsigned pn)
{
  8019e7:	55                   	push   %ebp
  8019e8:	89 e5                	mov    %esp,%ebp
  8019ea:	53                   	push   %ebx
  8019eb:	83 ec 04             	sub    $0x4,%esp
  8019ee:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8019f1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	// LAB 4: Your code here.
        // seanyliu

        // LAB 7: add in a new if check
        if (vpt[pn] & PTE_SHARE) {
  8019f4:	ba 00 00 40 ef       	mov    $0xef400000,%edx
  8019f9:	8b 04 9a             	mov    (%edx,%ebx,4),%eax
  8019fc:	f6 c4 04             	test   $0x4,%ah
  8019ff:	74 36                	je     801a37 <duppage+0x50>
          if ((r = sys_page_map(sys_getenvid(), (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), vpt[pn] & PTE_USER)) < 0) {
  801a01:	83 ec 0c             	sub    $0xc,%esp
  801a04:	8b 04 9a             	mov    (%edx,%ebx,4),%eax
  801a07:	25 07 0e 00 00       	and    $0xe07,%eax
  801a0c:	50                   	push   %eax
  801a0d:	89 d8                	mov    %ebx,%eax
  801a0f:	c1 e0 0c             	shl    $0xc,%eax
  801a12:	50                   	push   %eax
  801a13:	51                   	push   %ecx
  801a14:	50                   	push   %eax
  801a15:	83 ec 04             	sub    $0x4,%esp
  801a18:	e8 37 fb ff ff       	call   801554 <sys_getenvid>
  801a1d:	89 04 24             	mov    %eax,(%esp)
  801a20:	e8 b0 fb ff ff       	call   8015d5 <sys_page_map>
  801a25:	83 c4 20             	add    $0x20,%esp
            return r;
  801a28:	89 c2                	mov    %eax,%edx
  801a2a:	85 c0                	test   %eax,%eax
  801a2c:	0f 88 c9 00 00 00    	js     801afb <duppage+0x114>
  801a32:	e9 bf 00 00 00       	jmp    801af6 <duppage+0x10f>
          }
        } else if (vpt[pn] & (PTE_W | PTE_COW)) {
  801a37:	8b 04 9d 00 00 40 ef 	mov    0xef400000(,%ebx,4),%eax
  801a3e:	a9 02 08 00 00       	test   $0x802,%eax
  801a43:	74 7b                	je     801ac0 <duppage+0xd9>
          // If the page is writable or copy-on-write, the new mapping must be created copy-on-write
          if ((r = sys_page_map(sys_getenvid(), (void *)(pn*PGSIZE), envid, (void *)(pn*PGSIZE), PTE_U | PTE_COW | PTE_P)) < 0) {
  801a45:	83 ec 0c             	sub    $0xc,%esp
  801a48:	68 05 08 00 00       	push   $0x805
  801a4d:	89 d8                	mov    %ebx,%eax
  801a4f:	c1 e0 0c             	shl    $0xc,%eax
  801a52:	50                   	push   %eax
  801a53:	51                   	push   %ecx
  801a54:	50                   	push   %eax
  801a55:	83 ec 04             	sub    $0x4,%esp
  801a58:	e8 f7 fa ff ff       	call   801554 <sys_getenvid>
  801a5d:	89 04 24             	mov    %eax,(%esp)
  801a60:	e8 70 fb ff ff       	call   8015d5 <sys_page_map>
  801a65:	83 c4 20             	add    $0x20,%esp
  801a68:	85 c0                	test   %eax,%eax
  801a6a:	79 12                	jns    801a7e <duppage+0x97>
            panic("duppage: sys_page_map %d", r);
  801a6c:	50                   	push   %eax
  801a6d:	68 4a 21 81 00       	push   $0x81214a
  801a72:	6a 56                	push   $0x56
  801a74:	68 f0 20 81 00       	push   $0x8120f0
  801a79:	e8 4e f0 ff ff       	call   800acc <_panic>
          }
          // and then our mapping must be marked copy-on-write as well
          //vpt[pn] = vpt[pn] | PTE_COW;
          if ((r = sys_page_map(sys_getenvid(), (void *)(pn*PGSIZE), sys_getenvid(), (void *)(pn*PGSIZE), PTE_U | PTE_COW | PTE_P)) < 0) {
  801a7e:	83 ec 0c             	sub    $0xc,%esp
  801a81:	68 05 08 00 00       	push   $0x805
  801a86:	c1 e3 0c             	shl    $0xc,%ebx
  801a89:	53                   	push   %ebx
  801a8a:	83 ec 0c             	sub    $0xc,%esp
  801a8d:	e8 c2 fa ff ff       	call   801554 <sys_getenvid>
  801a92:	83 c4 0c             	add    $0xc,%esp
  801a95:	50                   	push   %eax
  801a96:	53                   	push   %ebx
  801a97:	83 ec 04             	sub    $0x4,%esp
  801a9a:	e8 b5 fa ff ff       	call   801554 <sys_getenvid>
  801a9f:	89 04 24             	mov    %eax,(%esp)
  801aa2:	e8 2e fb ff ff       	call   8015d5 <sys_page_map>
  801aa7:	83 c4 20             	add    $0x20,%esp
  801aaa:	85 c0                	test   %eax,%eax
  801aac:	79 48                	jns    801af6 <duppage+0x10f>
            panic("duppage: sys_page_map %d", r);
  801aae:	50                   	push   %eax
  801aaf:	68 4a 21 81 00       	push   $0x81214a
  801ab4:	6a 5b                	push   $0x5b
  801ab6:	68 f0 20 81 00       	push   $0x8120f0
  801abb:	e8 0c f0 ff ff       	call   800acc <_panic>
          }
        } else {
          if ((r = sys_page_map(sys_getenvid(), (void *)(pn*PGSIZE), envid, (void *)(pn*PGSIZE), PTE_U | PTE_P)) < 0) {
  801ac0:	83 ec 0c             	sub    $0xc,%esp
  801ac3:	6a 05                	push   $0x5
  801ac5:	89 d8                	mov    %ebx,%eax
  801ac7:	c1 e0 0c             	shl    $0xc,%eax
  801aca:	50                   	push   %eax
  801acb:	51                   	push   %ecx
  801acc:	50                   	push   %eax
  801acd:	83 ec 04             	sub    $0x4,%esp
  801ad0:	e8 7f fa ff ff       	call   801554 <sys_getenvid>
  801ad5:	89 04 24             	mov    %eax,(%esp)
  801ad8:	e8 f8 fa ff ff       	call   8015d5 <sys_page_map>
  801add:	83 c4 20             	add    $0x20,%esp
  801ae0:	85 c0                	test   %eax,%eax
  801ae2:	79 12                	jns    801af6 <duppage+0x10f>
            panic("duppage: sys_page_map %d", r);
  801ae4:	50                   	push   %eax
  801ae5:	68 4a 21 81 00       	push   $0x81214a
  801aea:	6a 5f                	push   $0x5f
  801aec:	68 f0 20 81 00       	push   $0x8120f0
  801af1:	e8 d6 ef ff ff       	call   800acc <_panic>
          }
        }
	//panic("duppage not implemented");
	return 0;
  801af6:	ba 00 00 00 00       	mov    $0x0,%edx
}
  801afb:	89 d0                	mov    %edx,%eax
  801afd:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  801b00:	c9                   	leave  
  801b01:	c3                   	ret    

00801b02 <fork>:

//
// User-level fork with copy-on-write.
// Set up our page fault handler appropriately.
// Create a child.
// Copy our address space and page fault handler setup to the child.
// Then mark the child as runnable and return.
//
// Returns: child's envid to the parent, 0 to the child, < 0 on error.
// It is also OK to panic on error.
//
// Hint:
//   Use vpd, vpt, and duppage.
//   Remember to fix "env" and the user exception stack in the child process.
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//

envid_t
fork(void)
{
  801b02:	55                   	push   %ebp
  801b03:	89 e5                	mov    %esp,%ebp
  801b05:	57                   	push   %edi
  801b06:	56                   	push   %esi
  801b07:	53                   	push   %ebx
  801b08:	83 ec 18             	sub    $0x18,%esp
	// LAB 4: Your code here.
        // seanyliu
        int r;
        int pdidx = 0;
        int peidx = 0;
        envid_t childid;
        set_pgfault_handler(pgfault);
  801b0b:	68 ec 18 80 00       	push   $0x8018ec
  801b10:	e8 17 16 00 00       	call   80312c <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static __inline envid_t sys_exofork(void) __attribute__((always_inline));
static __inline envid_t
sys_exofork(void)
{
  801b15:	83 c4 10             	add    $0x10,%esp
	envid_t ret;
	__asm __volatile("int %2"
  801b18:	ba 07 00 00 00       	mov    $0x7,%edx
  801b1d:	89 d0                	mov    %edx,%eax
  801b1f:	cd 30                	int    $0x30
  801b21:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

        // create child environment
        childid = sys_exofork();
        if (childid < 0) {
  801b24:	85 c0                	test   %eax,%eax
  801b26:	79 15                	jns    801b3d <fork+0x3b>
          panic("fork: failed to create child %d", childid);
  801b28:	50                   	push   %eax
  801b29:	68 d0 20 81 00       	push   $0x8120d0
  801b2e:	68 85 00 00 00       	push   $0x85
  801b33:	68 f0 20 81 00       	push   $0x8120f0
  801b38:	e8 8f ef ff ff       	call   800acc <_panic>
        }
        if (childid == 0) {
          env = &envs[ENVX(sys_getenvid())];
          return 0;
        }

        // loop through pg dir, avoid user exception stack (which is immediately below UTOP
        for (pdidx = 0; pdidx < PDX(UTOP); pdidx++) {
  801b3d:	bf 00 00 00 00       	mov    $0x0,%edi
  801b42:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  801b46:	75 21                	jne    801b69 <fork+0x67>
  801b48:	e8 07 fa ff ff       	call   801554 <sys_getenvid>
  801b4d:	25 ff 03 00 00       	and    $0x3ff,%eax
  801b52:	c1 e0 07             	shl    $0x7,%eax
  801b55:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  801b5a:	a3 54 e6 b3 00       	mov    %eax,0xb3e654
  801b5f:	ba 00 00 00 00       	mov    $0x0,%edx
  801b64:	e9 fd 00 00 00       	jmp    801c66 <fork+0x164>
          // check if the pg is present
          if (!(vpd[pdidx] & PTE_P)) continue;
  801b69:	8b 04 bd 00 d0 7b ef 	mov    0xef7bd000(,%edi,4),%eax
  801b70:	a8 01                	test   $0x1,%al
  801b72:	74 5f                	je     801bd3 <fork+0xd1>

          // loop through pg table entries
          for (peidx = 0; (peidx < NPTENTRIES) && (pdidx*NPDENTRIES+peidx < (UXSTACKTOP - PGSIZE)/PGSIZE); peidx++) {
  801b74:	bb 00 00 00 00       	mov    $0x0,%ebx
  801b79:	89 f8                	mov    %edi,%eax
  801b7b:	c1 e0 0a             	shl    $0xa,%eax
  801b7e:	89 c2                	mov    %eax,%edx
  801b80:	3d fe eb 0e 00       	cmp    $0xeebfe,%eax
  801b85:	77 4c                	ja     801bd3 <fork+0xd1>
  801b87:	89 c6                	mov    %eax,%esi
            if (vpt[pdidx * NPTENTRIES + peidx] & PTE_P) {
  801b89:	01 da                	add    %ebx,%edx
  801b8b:	8b 04 95 00 00 40 ef 	mov    0xef400000(,%edx,4),%eax
  801b92:	a8 01                	test   $0x1,%al
  801b94:	74 28                	je     801bbe <fork+0xbc>
              if ((r = duppage(childid, pdidx * NPTENTRIES + peidx)) < 0) {
  801b96:	83 ec 08             	sub    $0x8,%esp
  801b99:	52                   	push   %edx
  801b9a:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  801b9d:	e8 45 fe ff ff       	call   8019e7 <duppage>
  801ba2:	83 c4 10             	add    $0x10,%esp
  801ba5:	85 c0                	test   %eax,%eax
  801ba7:	79 15                	jns    801bbe <fork+0xbc>
                panic("fork: duppage failed: %d", r);
  801ba9:	50                   	push   %eax
  801baa:	68 63 21 81 00       	push   $0x812163
  801baf:	68 95 00 00 00       	push   $0x95
  801bb4:	68 f0 20 81 00       	push   $0x8120f0
  801bb9:	e8 0e ef ff ff       	call   800acc <_panic>
  801bbe:	43                   	inc    %ebx
  801bbf:	81 fb ff 03 00 00    	cmp    $0x3ff,%ebx
  801bc5:	7f 0c                	jg     801bd3 <fork+0xd1>
  801bc7:	89 f2                	mov    %esi,%edx
  801bc9:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
  801bcc:	3d fe eb 0e 00       	cmp    $0xeebfe,%eax
  801bd1:	76 b6                	jbe    801b89 <fork+0x87>
  801bd3:	47                   	inc    %edi
  801bd4:	81 ff ba 03 00 00    	cmp    $0x3ba,%edi
  801bda:	76 8d                	jbe    801b69 <fork+0x67>
              }
            }
          }
        }

        // allocate fresh page in the child for exception stack.
        if ((r = sys_page_alloc(childid, (void *)(UXSTACKTOP - PGSIZE), PTE_U | PTE_P | PTE_W)) < 0) {
  801bdc:	83 ec 04             	sub    $0x4,%esp
  801bdf:	6a 07                	push   $0x7
  801be1:	68 00 f0 bf ee       	push   $0xeebff000
  801be6:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  801be9:	e8 a4 f9 ff ff       	call   801592 <sys_page_alloc>
  801bee:	83 c4 10             	add    $0x10,%esp
  801bf1:	85 c0                	test   %eax,%eax
  801bf3:	79 15                	jns    801c0a <fork+0x108>
          panic("fork: %d", r);
  801bf5:	50                   	push   %eax
  801bf6:	68 7c 21 81 00       	push   $0x81217c
  801bfb:	68 9d 00 00 00       	push   $0x9d
  801c00:	68 f0 20 81 00       	push   $0x8120f0
  801c05:	e8 c2 ee ff ff       	call   800acc <_panic>
        }

        // parent sets the user page fault entrypoint for the child to look like its own.
        if ((r = sys_env_set_pgfault_upcall(childid, env->env_pgfault_upcall)) < 0) {
  801c0a:	83 ec 08             	sub    $0x8,%esp
  801c0d:	a1 54 e6 b3 00       	mov    0xb3e654,%eax
  801c12:	8b 40 64             	mov    0x64(%eax),%eax
  801c15:	50                   	push   %eax
  801c16:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  801c19:	e8 bf fa ff ff       	call   8016dd <sys_env_set_pgfault_upcall>
  801c1e:	83 c4 10             	add    $0x10,%esp
  801c21:	85 c0                	test   %eax,%eax
  801c23:	79 15                	jns    801c3a <fork+0x138>
          panic("fork: %d", r);
  801c25:	50                   	push   %eax
  801c26:	68 7c 21 81 00       	push   $0x81217c
  801c2b:	68 a2 00 00 00       	push   $0xa2
  801c30:	68 f0 20 81 00       	push   $0x8120f0
  801c35:	e8 92 ee ff ff       	call   800acc <_panic>
        }

        // parent marks child runnable
        if ((r = sys_env_set_status(childid, ENV_RUNNABLE)) < 0) {
  801c3a:	83 ec 08             	sub    $0x8,%esp
  801c3d:	6a 01                	push   $0x1
  801c3f:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  801c42:	e8 12 fa ff ff       	call   801659 <sys_env_set_status>
  801c47:	83 c4 10             	add    $0x10,%esp
          panic("fork: %d", r);
        }

        return childid;       
  801c4a:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  801c4d:	85 c0                	test   %eax,%eax
  801c4f:	79 15                	jns    801c66 <fork+0x164>
  801c51:	50                   	push   %eax
  801c52:	68 7c 21 81 00       	push   $0x81217c
  801c57:	68 a7 00 00 00       	push   $0xa7
  801c5c:	68 f0 20 81 00       	push   $0x8120f0
  801c61:	e8 66 ee ff ff       	call   800acc <_panic>
 
	//panic("fork not implemented");
}
  801c66:	89 d0                	mov    %edx,%eax
  801c68:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  801c6b:	5b                   	pop    %ebx
  801c6c:	5e                   	pop    %esi
  801c6d:	5f                   	pop    %edi
  801c6e:	c9                   	leave  
  801c6f:	c3                   	ret    

00801c70 <sfork>:



// Challenge!
int
sfork(void)
{
  801c70:	55                   	push   %ebp
  801c71:	89 e5                	mov    %esp,%ebp
  801c73:	83 ec 0c             	sub    $0xc,%esp
	panic("sfork not implemented");
  801c76:	68 85 21 81 00       	push   $0x812185
  801c7b:	68 b5 00 00 00       	push   $0xb5
  801c80:	68 f0 20 81 00       	push   $0x8120f0
  801c85:	e8 42 ee ff ff       	call   800acc <_panic>
	...

00801c8c <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  801c8c:	55                   	push   %ebp
  801c8d:	89 e5                	mov    %esp,%ebp
  801c8f:	56                   	push   %esi
  801c90:	53                   	push   %ebx
  801c91:	8b 5d 08             	mov    0x8(%ebp),%ebx
  801c94:	8b 45 0c             	mov    0xc(%ebp),%eax
  801c97:	8b 75 10             	mov    0x10(%ebp),%esi
  // LAB 4: Your code here.
  //panic("ipc_recv not implemented");
  int r;
  if (pg == NULL) {
  801c9a:	85 c0                	test   %eax,%eax
  801c9c:	75 12                	jne    801cb0 <ipc_recv+0x24>
    r = sys_ipc_recv((void *)UTOP);
  801c9e:	83 ec 0c             	sub    $0xc,%esp
  801ca1:	68 00 00 c0 ee       	push   $0xeec00000
  801ca6:	e8 97 fa ff ff       	call   801742 <sys_ipc_recv>
  801cab:	83 c4 10             	add    $0x10,%esp
  801cae:	eb 0c                	jmp    801cbc <ipc_recv+0x30>
  } else {
    r = sys_ipc_recv(pg);
  801cb0:	83 ec 0c             	sub    $0xc,%esp
  801cb3:	50                   	push   %eax
  801cb4:	e8 89 fa ff ff       	call   801742 <sys_ipc_recv>
  801cb9:	83 c4 10             	add    $0x10,%esp
  }

  if (r < 0) {
    from_env_store = 0;
    perm_store = 0;
    return r;
  801cbc:	89 c2                	mov    %eax,%edx
  801cbe:	85 c0                	test   %eax,%eax
  801cc0:	78 24                	js     801ce6 <ipc_recv+0x5a>
  }

  if (from_env_store != NULL) {
  801cc2:	85 db                	test   %ebx,%ebx
  801cc4:	74 0a                	je     801cd0 <ipc_recv+0x44>
    *from_env_store = env->env_ipc_from;
  801cc6:	a1 54 e6 b3 00       	mov    0xb3e654,%eax
  801ccb:	8b 40 74             	mov    0x74(%eax),%eax
  801cce:	89 03                	mov    %eax,(%ebx)
  }
  if (perm_store != NULL) {
  801cd0:	85 f6                	test   %esi,%esi
  801cd2:	74 0a                	je     801cde <ipc_recv+0x52>
    *perm_store = env->env_ipc_perm;
  801cd4:	a1 54 e6 b3 00       	mov    0xb3e654,%eax
  801cd9:	8b 40 78             	mov    0x78(%eax),%eax
  801cdc:	89 06                	mov    %eax,(%esi)
  }

  return env->env_ipc_value;
  801cde:	a1 54 e6 b3 00       	mov    0xb3e654,%eax
  801ce3:	8b 50 70             	mov    0x70(%eax),%edx

}
  801ce6:	89 d0                	mov    %edx,%eax
  801ce8:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  801ceb:	5b                   	pop    %ebx
  801cec:	5e                   	pop    %esi
  801ced:	c9                   	leave  
  801cee:	c3                   	ret    

00801cef <ipc_send>:

// Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.
// This function keeps trying until it succeeds.
// It should panic() on any error other than -E_IPC_NOT_RECV.
//
// Hint:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  801cef:	55                   	push   %ebp
  801cf0:	89 e5                	mov    %esp,%ebp
  801cf2:	57                   	push   %edi
  801cf3:	56                   	push   %esi
  801cf4:	53                   	push   %ebx
  801cf5:	83 ec 0c             	sub    $0xc,%esp
  801cf8:	8b 7d 0c             	mov    0xc(%ebp),%edi
  801cfb:	8b 5d 10             	mov    0x10(%ebp),%ebx
  801cfe:	8b 75 14             	mov    0x14(%ebp),%esi
  // LAB 4: Your code here.
  // seanyliu
  //panic("ipc_send not implemented");
  int r;
  if (pg == NULL) {
  801d01:	85 db                	test   %ebx,%ebx
  801d03:	75 0a                	jne    801d0f <ipc_send+0x20>
    pg = (void *) UTOP;
  801d05:	bb 00 00 c0 ee       	mov    $0xeec00000,%ebx
    perm = 0;
  801d0a:	be 00 00 00 00       	mov    $0x0,%esi
  }
  while (1) {
    r = sys_ipc_try_send(to_env, val, pg, perm);
  801d0f:	56                   	push   %esi
  801d10:	53                   	push   %ebx
  801d11:	57                   	push   %edi
  801d12:	ff 75 08             	pushl  0x8(%ebp)
  801d15:	e8 05 fa ff ff       	call   80171f <sys_ipc_try_send>
    if (r == -E_IPC_NOT_RECV) {
  801d1a:	83 c4 10             	add    $0x10,%esp
  801d1d:	83 f8 f9             	cmp    $0xfffffff9,%eax
  801d20:	75 07                	jne    801d29 <ipc_send+0x3a>
      sys_yield();
  801d22:	e8 4c f8 ff ff       	call   801573 <sys_yield>
  801d27:	eb e6                	jmp    801d0f <ipc_send+0x20>
    }
    else if (r < 0) panic ("ipc_send: failed to send: %d", r);
  801d29:	85 c0                	test   %eax,%eax
  801d2b:	79 12                	jns    801d3f <ipc_send+0x50>
  801d2d:	50                   	push   %eax
  801d2e:	68 9b 21 81 00       	push   $0x81219b
  801d33:	6a 49                	push   $0x49
  801d35:	68 b8 21 81 00       	push   $0x8121b8
  801d3a:	e8 8d ed ff ff       	call   800acc <_panic>
    else break;
  }
}
  801d3f:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  801d42:	5b                   	pop    %ebx
  801d43:	5e                   	pop    %esi
  801d44:	5f                   	pop    %edi
  801d45:	c9                   	leave  
  801d46:	c3                   	ret    
	...

00801d48 <fd2data>:
 ********************************/

char*
fd2data(struct Fd *fd)
{
  801d48:	55                   	push   %ebp
  801d49:	89 e5                	mov    %esp,%ebp
  801d4b:	83 ec 14             	sub    $0x14,%esp
	return INDEX2DATA(fd2num(fd));
  801d4e:	ff 75 08             	pushl  0x8(%ebp)
  801d51:	e8 0a 00 00 00       	call   801d60 <fd2num>
  801d56:	c1 e0 16             	shl    $0x16,%eax
  801d59:	2d 00 00 00 30       	sub    $0x30000000,%eax
}
  801d5e:	c9                   	leave  
  801d5f:	c3                   	ret    

00801d60 <fd2num>:

int
fd2num(struct Fd *fd)
{
  801d60:	55                   	push   %ebp
  801d61:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  801d63:	8b 45 08             	mov    0x8(%ebp),%eax
  801d66:	05 00 00 40 30       	add    $0x30400000,%eax
  801d6b:	c1 e8 0c             	shr    $0xc,%eax
}
  801d6e:	c9                   	leave  
  801d6f:	c3                   	ret    

00801d70 <fd_alloc>:

// Finds the smallest i from 0 to MAXFD-1 that doesn't have
// its fd page mapped.
// Sets *fd_store to the corresponding fd page virtual address.
//
// fd_alloc does NOT actually allocate an fd page.
// It is up to the caller to allocate the page somehow.
// This means that if someone calls fd_alloc twice in a row
// without allocating the first page we return, we'll return the same
// page the second time.
//
// Hint: Use INDEX2FD.
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  801d70:	55                   	push   %ebp
  801d71:	89 e5                	mov    %esp,%ebp
  801d73:	57                   	push   %edi
  801d74:	56                   	push   %esi
  801d75:	53                   	push   %ebx
  801d76:	8b 7d 08             	mov    0x8(%ebp),%edi
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  801d79:	b9 00 00 00 00       	mov    $0x0,%ecx
  801d7e:	be 00 d0 7b ef       	mov    $0xef7bd000,%esi
  801d83:	bb 00 00 40 ef       	mov    $0xef400000,%ebx
		fd = INDEX2FD(i);
  801d88:	89 c8                	mov    %ecx,%eax
  801d8a:	c1 e0 0c             	shl    $0xc,%eax
  801d8d:	8d 90 00 00 c0 cf    	lea    0xcfc00000(%eax),%edx
		if ((vpd[PDX(fd)] & PTE_P) == 0 || (vpt[VPN(fd)] & PTE_P) == 0) {
  801d93:	89 d0                	mov    %edx,%eax
  801d95:	c1 e8 16             	shr    $0x16,%eax
  801d98:	8b 04 86             	mov    (%esi,%eax,4),%eax
  801d9b:	a8 01                	test   $0x1,%al
  801d9d:	74 0c                	je     801dab <fd_alloc+0x3b>
  801d9f:	89 d0                	mov    %edx,%eax
  801da1:	c1 e8 0c             	shr    $0xc,%eax
  801da4:	8b 04 83             	mov    (%ebx,%eax,4),%eax
  801da7:	a8 01                	test   $0x1,%al
  801da9:	75 09                	jne    801db4 <fd_alloc+0x44>
			*fd_store = fd;
  801dab:	89 17                	mov    %edx,(%edi)
			return 0;
  801dad:	b8 00 00 00 00       	mov    $0x0,%eax
  801db2:	eb 11                	jmp    801dc5 <fd_alloc+0x55>
  801db4:	41                   	inc    %ecx
  801db5:	83 f9 1f             	cmp    $0x1f,%ecx
  801db8:	7e ce                	jle    801d88 <fd_alloc+0x18>
		}
	}
	*fd_store = 0;
  801dba:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
	return -E_MAX_OPEN;
  801dc0:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
}
  801dc5:	5b                   	pop    %ebx
  801dc6:	5e                   	pop    %esi
  801dc7:	5f                   	pop    %edi
  801dc8:	c9                   	leave  
  801dc9:	c3                   	ret    

00801dca <fd_lookup>:

// Check that fdnum is in range and mapped.
// If it is, set *fd_store to the fd page virtual address.
//
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  801dca:	55                   	push   %ebp
  801dcb:	89 e5                	mov    %esp,%ebp
  801dcd:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
		if (debug)
			cprintf("[%08x] bad fd %d\n", env->env_id, fd);
		return -E_INVAL;
  801dd0:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  801dd5:	83 f8 1f             	cmp    $0x1f,%eax
  801dd8:	77 3a                	ja     801e14 <fd_lookup+0x4a>
	}
	fd = INDEX2FD(fdnum);
  801dda:	c1 e0 0c             	shl    $0xc,%eax
  801ddd:	8d 90 00 00 c0 cf    	lea    0xcfc00000(%eax),%edx
	if (!(vpd[PDX(fd)] & PTE_P) || !(vpt[VPN(fd)] & PTE_P)) {
  801de3:	89 d0                	mov    %edx,%eax
  801de5:	c1 e8 16             	shr    $0x16,%eax
  801de8:	8b 04 85 00 d0 7b ef 	mov    0xef7bd000(,%eax,4),%eax
  801def:	a8 01                	test   $0x1,%al
  801df1:	74 10                	je     801e03 <fd_lookup+0x39>
  801df3:	89 d0                	mov    %edx,%eax
  801df5:	c1 e8 0c             	shr    $0xc,%eax
  801df8:	8b 04 85 00 00 40 ef 	mov    0xef400000(,%eax,4),%eax
  801dff:	a8 01                	test   $0x1,%al
  801e01:	75 07                	jne    801e0a <fd_lookup+0x40>
		if (debug)
			cprintf("[%08x] closed fd %d\n", env->env_id, fd);
		return -E_INVAL;
  801e03:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  801e08:	eb 0a                	jmp    801e14 <fd_lookup+0x4a>
	}
	*fd_store = fd;
  801e0a:	8b 45 0c             	mov    0xc(%ebp),%eax
  801e0d:	89 10                	mov    %edx,(%eax)
	return 0;
  801e0f:	ba 00 00 00 00       	mov    $0x0,%edx
}
  801e14:	89 d0                	mov    %edx,%eax
  801e16:	c9                   	leave  
  801e17:	c3                   	ret    

00801e18 <fd_close>:

// Frees file descriptor 'fd' by closing the corresponding file
// and unmapping the file descriptor page.
// If 'must_exist' is 0, then fd can be a closed or nonexistent file
// descriptor; the function will return 0 and have no other effect.
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  801e18:	55                   	push   %ebp
  801e19:	89 e5                	mov    %esp,%ebp
  801e1b:	56                   	push   %esi
  801e1c:	53                   	push   %ebx
  801e1d:	83 ec 10             	sub    $0x10,%esp
  801e20:	8b 75 08             	mov    0x8(%ebp),%esi
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  801e23:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  801e26:	50                   	push   %eax
  801e27:	56                   	push   %esi
  801e28:	e8 33 ff ff ff       	call   801d60 <fd2num>
  801e2d:	89 04 24             	mov    %eax,(%esp)
  801e30:	e8 95 ff ff ff       	call   801dca <fd_lookup>
  801e35:	89 c3                	mov    %eax,%ebx
  801e37:	83 c4 08             	add    $0x8,%esp
  801e3a:	85 c0                	test   %eax,%eax
  801e3c:	78 05                	js     801e43 <fd_close+0x2b>
  801e3e:	3b 75 f4             	cmp    0xfffffff4(%ebp),%esi
  801e41:	74 0f                	je     801e52 <fd_close+0x3a>
	    || fd != fd2)
		return (must_exist ? r : 0);
  801e43:	89 d8                	mov    %ebx,%eax
  801e45:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  801e49:	75 3a                	jne    801e85 <fd_close+0x6d>
  801e4b:	b8 00 00 00 00       	mov    $0x0,%eax
  801e50:	eb 33                	jmp    801e85 <fd_close+0x6d>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0)
  801e52:	83 ec 08             	sub    $0x8,%esp
  801e55:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  801e58:	50                   	push   %eax
  801e59:	ff 36                	pushl  (%esi)
  801e5b:	e8 2c 00 00 00       	call   801e8c <dev_lookup>
  801e60:	89 c3                	mov    %eax,%ebx
  801e62:	83 c4 10             	add    $0x10,%esp
  801e65:	85 c0                	test   %eax,%eax
  801e67:	78 0f                	js     801e78 <fd_close+0x60>
		r = (*dev->dev_close)(fd);
  801e69:	83 ec 0c             	sub    $0xc,%esp
  801e6c:	56                   	push   %esi
  801e6d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  801e70:	ff 50 10             	call   *0x10(%eax)
  801e73:	89 c3                	mov    %eax,%ebx
  801e75:	83 c4 10             	add    $0x10,%esp
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  801e78:	83 ec 08             	sub    $0x8,%esp
  801e7b:	56                   	push   %esi
  801e7c:	6a 00                	push   $0x0
  801e7e:	e8 94 f7 ff ff       	call   801617 <sys_page_unmap>
	return r;
  801e83:	89 d8                	mov    %ebx,%eax
}
  801e85:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  801e88:	5b                   	pop    %ebx
  801e89:	5e                   	pop    %esi
  801e8a:	c9                   	leave  
  801e8b:	c3                   	ret    

00801e8c <dev_lookup>:


/******************
 * FILE FUNCTIONS *
 *                *
 ******************/

static struct Dev *devtab[] =
{
	&devfile,
	&devpipe,
	&devcons,
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  801e8c:	55                   	push   %ebp
  801e8d:	89 e5                	mov    %esp,%ebp
  801e8f:	56                   	push   %esi
  801e90:	53                   	push   %ebx
  801e91:	8b 5d 08             	mov    0x8(%ebp),%ebx
  801e94:	8b 75 0c             	mov    0xc(%ebp),%esi
	int i;
	for (i = 0; devtab[i]; i++)
  801e97:	ba 00 00 00 00       	mov    $0x0,%edx
  801e9c:	83 3d 04 80 81 00 00 	cmpl   $0x0,0x818004
  801ea3:	74 1c                	je     801ec1 <dev_lookup+0x35>
  801ea5:	b9 04 80 81 00       	mov    $0x818004,%ecx
		if (devtab[i]->dev_id == dev_id) {
  801eaa:	8b 04 91             	mov    (%ecx,%edx,4),%eax
  801ead:	39 18                	cmp    %ebx,(%eax)
  801eaf:	75 09                	jne    801eba <dev_lookup+0x2e>
			*dev = devtab[i];
  801eb1:	89 06                	mov    %eax,(%esi)
			return 0;
  801eb3:	b8 00 00 00 00       	mov    $0x0,%eax
  801eb8:	eb 29                	jmp    801ee3 <dev_lookup+0x57>
  801eba:	42                   	inc    %edx
  801ebb:	83 3c 91 00          	cmpl   $0x0,(%ecx,%edx,4)
  801ebf:	75 e9                	jne    801eaa <dev_lookup+0x1e>
		}
	cprintf("[%08x] unknown device type %d\n", env->env_id, dev_id);
  801ec1:	83 ec 04             	sub    $0x4,%esp
  801ec4:	53                   	push   %ebx
  801ec5:	a1 54 e6 b3 00       	mov    0xb3e654,%eax
  801eca:	8b 40 4c             	mov    0x4c(%eax),%eax
  801ecd:	50                   	push   %eax
  801ece:	68 c4 21 81 00       	push   $0x8121c4
  801ed3:	e8 e4 ec ff ff       	call   800bbc <cprintf>
	*dev = 0;
  801ed8:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	return -E_INVAL;
  801ede:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  801ee3:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  801ee6:	5b                   	pop    %ebx
  801ee7:	5e                   	pop    %esi
  801ee8:	c9                   	leave  
  801ee9:	c3                   	ret    

00801eea <close>:

int
close(int fdnum)
{
  801eea:	55                   	push   %ebp
  801eeb:	89 e5                	mov    %esp,%ebp
  801eed:	83 ec 08             	sub    $0x8,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  801ef0:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  801ef3:	50                   	push   %eax
  801ef4:	ff 75 08             	pushl  0x8(%ebp)
  801ef7:	e8 ce fe ff ff       	call   801dca <fd_lookup>
  801efc:	83 c4 08             	add    $0x8,%esp
		return r;
  801eff:	89 c2                	mov    %eax,%edx
  801f01:	85 c0                	test   %eax,%eax
  801f03:	78 0f                	js     801f14 <close+0x2a>
	else
		return fd_close(fd, 1);
  801f05:	83 ec 08             	sub    $0x8,%esp
  801f08:	6a 01                	push   $0x1
  801f0a:	ff 75 fc             	pushl  0xfffffffc(%ebp)
  801f0d:	e8 06 ff ff ff       	call   801e18 <fd_close>
  801f12:	89 c2                	mov    %eax,%edx
}
  801f14:	89 d0                	mov    %edx,%eax
  801f16:	c9                   	leave  
  801f17:	c3                   	ret    

00801f18 <close_all>:

void
close_all(void)
{
  801f18:	55                   	push   %ebp
  801f19:	89 e5                	mov    %esp,%ebp
  801f1b:	53                   	push   %ebx
  801f1c:	83 ec 04             	sub    $0x4,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  801f1f:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  801f24:	83 ec 0c             	sub    $0xc,%esp
  801f27:	53                   	push   %ebx
  801f28:	e8 bd ff ff ff       	call   801eea <close>
  801f2d:	83 c4 10             	add    $0x10,%esp
  801f30:	43                   	inc    %ebx
  801f31:	83 fb 1f             	cmp    $0x1f,%ebx
  801f34:	7e ee                	jle    801f24 <close_all+0xc>
}
  801f36:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  801f39:	c9                   	leave  
  801f3a:	c3                   	ret    

00801f3b <dup>:

// Make file descriptor 'newfdnum' a duplicate of file descriptor 'oldfdnum'.
// For instance, writing onto either file descriptor will affect the
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  801f3b:	55                   	push   %ebp
  801f3c:	89 e5                	mov    %esp,%ebp
  801f3e:	57                   	push   %edi
  801f3f:	56                   	push   %esi
  801f40:	53                   	push   %ebx
  801f41:	83 ec 0c             	sub    $0xc,%esp
	int i, r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  801f44:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  801f47:	50                   	push   %eax
  801f48:	ff 75 08             	pushl  0x8(%ebp)
  801f4b:	e8 7a fe ff ff       	call   801dca <fd_lookup>
  801f50:	89 c6                	mov    %eax,%esi
  801f52:	83 c4 08             	add    $0x8,%esp
  801f55:	85 f6                	test   %esi,%esi
  801f57:	0f 88 f8 00 00 00    	js     802055 <dup+0x11a>
		return r;
	close(newfdnum);
  801f5d:	83 ec 0c             	sub    $0xc,%esp
  801f60:	ff 75 0c             	pushl  0xc(%ebp)
  801f63:	e8 82 ff ff ff       	call   801eea <close>

	newfd = INDEX2FD(newfdnum);
  801f68:	8b 45 0c             	mov    0xc(%ebp),%eax
  801f6b:	c1 e0 0c             	shl    $0xc,%eax
  801f6e:	2d 00 00 40 30       	sub    $0x30400000,%eax
  801f73:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	ova = fd2data(oldfd);
  801f76:	83 c4 04             	add    $0x4,%esp
  801f79:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  801f7c:	e8 c7 fd ff ff       	call   801d48 <fd2data>
  801f81:	89 c7                	mov    %eax,%edi
	nva = fd2data(newfd);
  801f83:	83 c4 04             	add    $0x4,%esp
  801f86:	ff 75 e8             	pushl  0xffffffe8(%ebp)
  801f89:	e8 ba fd ff ff       	call   801d48 <fd2data>
  801f8e:	89 45 ec             	mov    %eax,0xffffffec(%ebp)

	if (vpd[PDX(ova)]) {
  801f91:	89 f8                	mov    %edi,%eax
  801f93:	c1 e8 16             	shr    $0x16,%eax
  801f96:	83 c4 10             	add    $0x10,%esp
  801f99:	8b 04 85 00 d0 7b ef 	mov    0xef7bd000(,%eax,4),%eax
  801fa0:	85 c0                	test   %eax,%eax
  801fa2:	74 48                	je     801fec <dup+0xb1>
		for (i = 0; i < PTSIZE; i += PGSIZE) {
  801fa4:	bb 00 00 00 00       	mov    $0x0,%ebx
			pte = vpt[VPN(ova + i)];
  801fa9:	8d 14 1f             	lea    (%edi,%ebx,1),%edx
  801fac:	89 d0                	mov    %edx,%eax
  801fae:	c1 e8 0c             	shr    $0xc,%eax
  801fb1:	8b 04 85 00 00 40 ef 	mov    0xef400000(,%eax,4),%eax
			if (pte&PTE_P) {
  801fb8:	a8 01                	test   $0x1,%al
  801fba:	74 22                	je     801fde <dup+0xa3>
				// should be no error here -- pd is already allocated
				if ((r = sys_page_map(0, ova + i, 0, nva + i, pte & PTE_USER)) < 0)
  801fbc:	83 ec 0c             	sub    $0xc,%esp
  801fbf:	25 07 0e 00 00       	and    $0xe07,%eax
  801fc4:	50                   	push   %eax
  801fc5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  801fc8:	01 d8                	add    %ebx,%eax
  801fca:	50                   	push   %eax
  801fcb:	6a 00                	push   $0x0
  801fcd:	52                   	push   %edx
  801fce:	6a 00                	push   $0x0
  801fd0:	e8 00 f6 ff ff       	call   8015d5 <sys_page_map>
  801fd5:	89 c6                	mov    %eax,%esi
  801fd7:	83 c4 20             	add    $0x20,%esp
  801fda:	85 c0                	test   %eax,%eax
  801fdc:	78 3f                	js     80201d <dup+0xe2>
  801fde:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  801fe4:	81 fb ff ff 3f 00    	cmp    $0x3fffff,%ebx
  801fea:	7e bd                	jle    801fa9 <dup+0x6e>
					goto err;
			}
		}
	}
	if ((r = sys_page_map(0, oldfd, 0, newfd, vpt[VPN(oldfd)] & PTE_USER)) < 0)
  801fec:	83 ec 0c             	sub    $0xc,%esp
  801fef:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  801ff2:	89 d0                	mov    %edx,%eax
  801ff4:	c1 e8 0c             	shr    $0xc,%eax
  801ff7:	8b 04 85 00 00 40 ef 	mov    0xef400000(,%eax,4),%eax
  801ffe:	25 07 0e 00 00       	and    $0xe07,%eax
  802003:	50                   	push   %eax
  802004:	ff 75 e8             	pushl  0xffffffe8(%ebp)
  802007:	6a 00                	push   $0x0
  802009:	52                   	push   %edx
  80200a:	6a 00                	push   $0x0
  80200c:	e8 c4 f5 ff ff       	call   8015d5 <sys_page_map>
  802011:	89 c6                	mov    %eax,%esi
  802013:	83 c4 20             	add    $0x20,%esp
		goto err;

	return newfdnum;
  802016:	8b 45 0c             	mov    0xc(%ebp),%eax
  802019:	85 f6                	test   %esi,%esi
  80201b:	79 38                	jns    802055 <dup+0x11a>

err:
	sys_page_unmap(0, newfd);
  80201d:	83 ec 08             	sub    $0x8,%esp
  802020:	ff 75 e8             	pushl  0xffffffe8(%ebp)
  802023:	6a 00                	push   $0x0
  802025:	e8 ed f5 ff ff       	call   801617 <sys_page_unmap>
	for (i = 0; i < PTSIZE; i += PGSIZE)
  80202a:	bb 00 00 00 00       	mov    $0x0,%ebx
  80202f:	83 c4 10             	add    $0x10,%esp
		sys_page_unmap(0, nva + i);
  802032:	83 ec 08             	sub    $0x8,%esp
  802035:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  802038:	01 d8                	add    %ebx,%eax
  80203a:	50                   	push   %eax
  80203b:	6a 00                	push   $0x0
  80203d:	e8 d5 f5 ff ff       	call   801617 <sys_page_unmap>
  802042:	83 c4 10             	add    $0x10,%esp
  802045:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80204b:	81 fb ff ff 3f 00    	cmp    $0x3fffff,%ebx
  802051:	7e df                	jle    802032 <dup+0xf7>
	return r;
  802053:	89 f0                	mov    %esi,%eax
}
  802055:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  802058:	5b                   	pop    %ebx
  802059:	5e                   	pop    %esi
  80205a:	5f                   	pop    %edi
  80205b:	c9                   	leave  
  80205c:	c3                   	ret    

0080205d <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80205d:	55                   	push   %ebp
  80205e:	89 e5                	mov    %esp,%ebp
  802060:	53                   	push   %ebx
  802061:	83 ec 14             	sub    $0x14,%esp
  802064:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802067:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  80206a:	50                   	push   %eax
  80206b:	53                   	push   %ebx
  80206c:	e8 59 fd ff ff       	call   801dca <fd_lookup>
  802071:	89 c2                	mov    %eax,%edx
  802073:	83 c4 08             	add    $0x8,%esp
  802076:	85 c0                	test   %eax,%eax
  802078:	78 1a                	js     802094 <read+0x37>
  80207a:	83 ec 08             	sub    $0x8,%esp
  80207d:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  802080:	50                   	push   %eax
  802081:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  802084:	ff 30                	pushl  (%eax)
  802086:	e8 01 fe ff ff       	call   801e8c <dev_lookup>
  80208b:	89 c2                	mov    %eax,%edx
  80208d:	83 c4 10             	add    $0x10,%esp
  802090:	85 c0                	test   %eax,%eax
  802092:	79 04                	jns    802098 <read+0x3b>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
  802094:	89 d0                	mov    %edx,%eax
  802096:	eb 50                	jmp    8020e8 <read+0x8b>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  802098:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  80209b:	8b 40 08             	mov    0x8(%eax),%eax
  80209e:	83 e0 03             	and    $0x3,%eax
  8020a1:	83 f8 01             	cmp    $0x1,%eax
  8020a4:	75 1e                	jne    8020c4 <read+0x67>
		cprintf("[%08x] read %d -- bad mode\n", env->env_id, fdnum); 
  8020a6:	83 ec 04             	sub    $0x4,%esp
  8020a9:	53                   	push   %ebx
  8020aa:	a1 54 e6 b3 00       	mov    0xb3e654,%eax
  8020af:	8b 40 4c             	mov    0x4c(%eax),%eax
  8020b2:	50                   	push   %eax
  8020b3:	68 05 22 81 00       	push   $0x812205
  8020b8:	e8 ff ea ff ff       	call   800bbc <cprintf>
		return -E_INVAL;
  8020bd:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8020c2:	eb 24                	jmp    8020e8 <read+0x8b>
	}
	r = (*dev->dev_read)(fd, buf, n, fd->fd_offset);
  8020c4:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  8020c7:	ff 70 04             	pushl  0x4(%eax)
  8020ca:	ff 75 10             	pushl  0x10(%ebp)
  8020cd:	ff 75 0c             	pushl  0xc(%ebp)
  8020d0:	50                   	push   %eax
  8020d1:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  8020d4:	ff 50 08             	call   *0x8(%eax)
  8020d7:	89 c2                	mov    %eax,%edx
	if (r >= 0)
  8020d9:	83 c4 10             	add    $0x10,%esp
  8020dc:	85 c0                	test   %eax,%eax
  8020de:	78 06                	js     8020e6 <read+0x89>
		fd->fd_offset += r;
  8020e0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  8020e3:	01 50 04             	add    %edx,0x4(%eax)
	return r;
  8020e6:	89 d0                	mov    %edx,%eax
}
  8020e8:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8020eb:	c9                   	leave  
  8020ec:	c3                   	ret    

008020ed <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  8020ed:	55                   	push   %ebp
  8020ee:	89 e5                	mov    %esp,%ebp
  8020f0:	57                   	push   %edi
  8020f1:	56                   	push   %esi
  8020f2:	53                   	push   %ebx
  8020f3:	83 ec 0c             	sub    $0xc,%esp
  8020f6:	8b 7d 0c             	mov    0xc(%ebp),%edi
  8020f9:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  8020fc:	bb 00 00 00 00       	mov    $0x0,%ebx
  802101:	39 f3                	cmp    %esi,%ebx
  802103:	73 25                	jae    80212a <readn+0x3d>
		m = read(fdnum, (char*)buf + tot, n - tot);
  802105:	83 ec 04             	sub    $0x4,%esp
  802108:	89 f0                	mov    %esi,%eax
  80210a:	29 d8                	sub    %ebx,%eax
  80210c:	50                   	push   %eax
  80210d:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
  802110:	50                   	push   %eax
  802111:	ff 75 08             	pushl  0x8(%ebp)
  802114:	e8 44 ff ff ff       	call   80205d <read>
		if (m < 0)
  802119:	83 c4 10             	add    $0x10,%esp
  80211c:	85 c0                	test   %eax,%eax
  80211e:	78 0c                	js     80212c <readn+0x3f>
			return m;
		if (m == 0)
  802120:	85 c0                	test   %eax,%eax
  802122:	74 06                	je     80212a <readn+0x3d>
  802124:	01 c3                	add    %eax,%ebx
  802126:	39 f3                	cmp    %esi,%ebx
  802128:	72 db                	jb     802105 <readn+0x18>
			break;
	}
	return tot;
  80212a:	89 d8                	mov    %ebx,%eax
}
  80212c:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80212f:	5b                   	pop    %ebx
  802130:	5e                   	pop    %esi
  802131:	5f                   	pop    %edi
  802132:	c9                   	leave  
  802133:	c3                   	ret    

00802134 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  802134:	55                   	push   %ebp
  802135:	89 e5                	mov    %esp,%ebp
  802137:	53                   	push   %ebx
  802138:	83 ec 14             	sub    $0x14,%esp
  80213b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80213e:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  802141:	50                   	push   %eax
  802142:	53                   	push   %ebx
  802143:	e8 82 fc ff ff       	call   801dca <fd_lookup>
  802148:	89 c2                	mov    %eax,%edx
  80214a:	83 c4 08             	add    $0x8,%esp
  80214d:	85 c0                	test   %eax,%eax
  80214f:	78 1a                	js     80216b <write+0x37>
  802151:	83 ec 08             	sub    $0x8,%esp
  802154:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  802157:	50                   	push   %eax
  802158:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  80215b:	ff 30                	pushl  (%eax)
  80215d:	e8 2a fd ff ff       	call   801e8c <dev_lookup>
  802162:	89 c2                	mov    %eax,%edx
  802164:	83 c4 10             	add    $0x10,%esp
  802167:	85 c0                	test   %eax,%eax
  802169:	79 04                	jns    80216f <write+0x3b>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
  80216b:	89 d0                	mov    %edx,%eax
  80216d:	eb 4b                	jmp    8021ba <write+0x86>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80216f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  802172:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  802176:	75 1e                	jne    802196 <write+0x62>
		cprintf("[%08x] write %d -- bad mode\n", env->env_id, fdnum);
  802178:	83 ec 04             	sub    $0x4,%esp
  80217b:	53                   	push   %ebx
  80217c:	a1 54 e6 b3 00       	mov    0xb3e654,%eax
  802181:	8b 40 4c             	mov    0x4c(%eax),%eax
  802184:	50                   	push   %eax
  802185:	68 21 22 81 00       	push   $0x812221
  80218a:	e8 2d ea ff ff       	call   800bbc <cprintf>
		return -E_INVAL;
  80218f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  802194:	eb 24                	jmp    8021ba <write+0x86>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	r = (*dev->dev_write)(fd, buf, n, fd->fd_offset);
  802196:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  802199:	ff 70 04             	pushl  0x4(%eax)
  80219c:	ff 75 10             	pushl  0x10(%ebp)
  80219f:	ff 75 0c             	pushl  0xc(%ebp)
  8021a2:	50                   	push   %eax
  8021a3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  8021a6:	ff 50 0c             	call   *0xc(%eax)
  8021a9:	89 c2                	mov    %eax,%edx
	if (r > 0)
  8021ab:	83 c4 10             	add    $0x10,%esp
  8021ae:	85 c0                	test   %eax,%eax
  8021b0:	7e 06                	jle    8021b8 <write+0x84>
		fd->fd_offset += r;
  8021b2:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  8021b5:	01 50 04             	add    %edx,0x4(%eax)
	return r;
  8021b8:	89 d0                	mov    %edx,%eax
}
  8021ba:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8021bd:	c9                   	leave  
  8021be:	c3                   	ret    

008021bf <seek>:

int
seek(int fdnum, off_t offset)
{
  8021bf:	55                   	push   %ebp
  8021c0:	89 e5                	mov    %esp,%ebp
  8021c2:	83 ec 04             	sub    $0x4,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8021c5:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  8021c8:	50                   	push   %eax
  8021c9:	ff 75 08             	pushl  0x8(%ebp)
  8021cc:	e8 f9 fb ff ff       	call   801dca <fd_lookup>
  8021d1:	83 c4 08             	add    $0x8,%esp
		return r;
  8021d4:	89 c2                	mov    %eax,%edx
  8021d6:	85 c0                	test   %eax,%eax
  8021d8:	78 0e                	js     8021e8 <seek+0x29>
	fd->fd_offset = offset;
  8021da:	8b 55 0c             	mov    0xc(%ebp),%edx
  8021dd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  8021e0:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  8021e3:	ba 00 00 00 00       	mov    $0x0,%edx
}
  8021e8:	89 d0                	mov    %edx,%eax
  8021ea:	c9                   	leave  
  8021eb:	c3                   	ret    

008021ec <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  8021ec:	55                   	push   %ebp
  8021ed:	89 e5                	mov    %esp,%ebp
  8021ef:	53                   	push   %ebx
  8021f0:	83 ec 14             	sub    $0x14,%esp
  8021f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  8021f6:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  8021f9:	50                   	push   %eax
  8021fa:	53                   	push   %ebx
  8021fb:	e8 ca fb ff ff       	call   801dca <fd_lookup>
  802200:	83 c4 08             	add    $0x8,%esp
  802203:	85 c0                	test   %eax,%eax
  802205:	78 4e                	js     802255 <ftruncate+0x69>
  802207:	83 ec 08             	sub    $0x8,%esp
  80220a:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  80220d:	50                   	push   %eax
  80220e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  802211:	ff 30                	pushl  (%eax)
  802213:	e8 74 fc ff ff       	call   801e8c <dev_lookup>
  802218:	83 c4 10             	add    $0x10,%esp
  80221b:	85 c0                	test   %eax,%eax
  80221d:	78 36                	js     802255 <ftruncate+0x69>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80221f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  802222:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  802226:	75 1e                	jne    802246 <ftruncate+0x5a>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  802228:	83 ec 04             	sub    $0x4,%esp
  80222b:	53                   	push   %ebx
  80222c:	a1 54 e6 b3 00       	mov    0xb3e654,%eax
  802231:	8b 40 4c             	mov    0x4c(%eax),%eax
  802234:	50                   	push   %eax
  802235:	68 e4 21 81 00       	push   $0x8121e4
  80223a:	e8 7d e9 ff ff       	call   800bbc <cprintf>
			env->env_id, fdnum); 
		return -E_INVAL;
  80223f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  802244:	eb 0f                	jmp    802255 <ftruncate+0x69>
	}
	return (*dev->dev_trunc)(fd, newsize);
  802246:	83 ec 08             	sub    $0x8,%esp
  802249:	ff 75 0c             	pushl  0xc(%ebp)
  80224c:	ff 75 f8             	pushl  0xfffffff8(%ebp)
  80224f:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  802252:	ff 50 1c             	call   *0x1c(%eax)
}
  802255:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  802258:	c9                   	leave  
  802259:	c3                   	ret    

0080225a <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  80225a:	55                   	push   %ebp
  80225b:	89 e5                	mov    %esp,%ebp
  80225d:	53                   	push   %ebx
  80225e:	83 ec 14             	sub    $0x14,%esp
  802261:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802264:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  802267:	50                   	push   %eax
  802268:	ff 75 08             	pushl  0x8(%ebp)
  80226b:	e8 5a fb ff ff       	call   801dca <fd_lookup>
  802270:	83 c4 08             	add    $0x8,%esp
  802273:	85 c0                	test   %eax,%eax
  802275:	78 42                	js     8022b9 <fstat+0x5f>
  802277:	83 ec 08             	sub    $0x8,%esp
  80227a:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  80227d:	50                   	push   %eax
  80227e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  802281:	ff 30                	pushl  (%eax)
  802283:	e8 04 fc ff ff       	call   801e8c <dev_lookup>
  802288:	83 c4 10             	add    $0x10,%esp
  80228b:	85 c0                	test   %eax,%eax
  80228d:	78 2a                	js     8022b9 <fstat+0x5f>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	stat->st_name[0] = 0;
  80228f:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  802292:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  802299:	00 00 00 
	stat->st_isdir = 0;
  80229c:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  8022a3:	00 00 00 
	stat->st_dev = dev;
  8022a6:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  8022a9:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  8022af:	83 ec 08             	sub    $0x8,%esp
  8022b2:	53                   	push   %ebx
  8022b3:	ff 75 f8             	pushl  0xfffffff8(%ebp)
  8022b6:	ff 50 14             	call   *0x14(%eax)
}
  8022b9:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8022bc:	c9                   	leave  
  8022bd:	c3                   	ret    

008022be <stat>:

int
stat(const char *path, struct Stat *stat)
{
  8022be:	55                   	push   %ebp
  8022bf:	89 e5                	mov    %esp,%ebp
  8022c1:	56                   	push   %esi
  8022c2:	53                   	push   %ebx
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  8022c3:	83 ec 08             	sub    $0x8,%esp
  8022c6:	6a 00                	push   $0x0
  8022c8:	ff 75 08             	pushl  0x8(%ebp)
  8022cb:	e8 28 00 00 00       	call   8022f8 <open>
  8022d0:	89 c6                	mov    %eax,%esi
  8022d2:	83 c4 10             	add    $0x10,%esp
  8022d5:	85 f6                	test   %esi,%esi
  8022d7:	78 18                	js     8022f1 <stat+0x33>
		return fd;
	r = fstat(fd, stat);
  8022d9:	83 ec 08             	sub    $0x8,%esp
  8022dc:	ff 75 0c             	pushl  0xc(%ebp)
  8022df:	56                   	push   %esi
  8022e0:	e8 75 ff ff ff       	call   80225a <fstat>
  8022e5:	89 c3                	mov    %eax,%ebx
	close(fd);
  8022e7:	89 34 24             	mov    %esi,(%esp)
  8022ea:	e8 fb fb ff ff       	call   801eea <close>
	return r;
  8022ef:	89 d8                	mov    %ebx,%eax
}
  8022f1:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  8022f4:	5b                   	pop    %ebx
  8022f5:	5e                   	pop    %esi
  8022f6:	c9                   	leave  
  8022f7:	c3                   	ret    

008022f8 <open>:
// Open a file (or directory),
// returning the file descriptor index on success, < 0 on failure.
int
open(const char *path, int mode)
{
  8022f8:	55                   	push   %ebp
  8022f9:	89 e5                	mov    %esp,%ebp
  8022fb:	53                   	push   %ebx
  8022fc:	83 ec 10             	sub    $0x10,%esp
	// Find an unused file descriptor page using fd_alloc.
	// Then send a message to the file server to open a file
	// using a function in fsipc.c.
	// (fd_alloc does not allocate a page, it just returns an
	// unused fd address.  Do you need to allocate a page?  Look
	// at fsipc.c if you aren't sure.)
	// Then map the file data (you may find fmap() helpful).
	// Return the file descriptor index.
	// If any step fails, use fd_close to free the file descriptor.

	// LAB 5: Your code here.
	// panic("open() unimplemented!");
        int r;
        struct Fd *fd_store;
        if ((r = fd_alloc(&fd_store)) < 0) {
  8022ff:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  802302:	50                   	push   %eax
  802303:	e8 68 fa ff ff       	call   801d70 <fd_alloc>
  802308:	89 c3                	mov    %eax,%ebx
  80230a:	83 c4 10             	add    $0x10,%esp
  80230d:	85 db                	test   %ebx,%ebx
  80230f:	78 36                	js     802347 <open+0x4f>
          return r;
        }
	// Do you need to allocate a page?  Look
        if ((r = fsipc_open(path, mode, fd_store)) < 0) {
  802311:	83 ec 04             	sub    $0x4,%esp
  802314:	ff 75 f8             	pushl  0xfffffff8(%ebp)
  802317:	ff 75 0c             	pushl  0xc(%ebp)
  80231a:	ff 75 08             	pushl  0x8(%ebp)
  80231d:	e8 1b 05 00 00       	call   80283d <fsipc_open>
  802322:	89 c3                	mov    %eax,%ebx
  802324:	83 c4 10             	add    $0x10,%esp
  802327:	85 c0                	test   %eax,%eax
  802329:	79 11                	jns    80233c <open+0x44>
          fd_close(fd_store, 0);
  80232b:	83 ec 08             	sub    $0x8,%esp
  80232e:	6a 00                	push   $0x0
  802330:	ff 75 f8             	pushl  0xfffffff8(%ebp)
  802333:	e8 e0 fa ff ff       	call   801e18 <fd_close>
          return r;
  802338:	89 d8                	mov    %ebx,%eax
  80233a:	eb 0b                	jmp    802347 <open+0x4f>
        }
        // Challenge 5:
        /*
        if ((r = fmap(fd_store, 0, fd_store->fd_file.file.f_size)) < 0) {
          fd_close(fd_store, 0);
          return r;
        }
        */
        return fd2num(fd_store);
  80233c:	83 ec 0c             	sub    $0xc,%esp
  80233f:	ff 75 f8             	pushl  0xfffffff8(%ebp)
  802342:	e8 19 fa ff ff       	call   801d60 <fd2num>
}
  802347:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80234a:	c9                   	leave  
  80234b:	c3                   	ret    

0080234c <file_close>:

// Clean up a file-server file descriptor.
// This function is called by fd_close.
static int
file_close(struct Fd *fd)
{
  80234c:	55                   	push   %ebp
  80234d:	89 e5                	mov    %esp,%ebp
  80234f:	53                   	push   %ebx
  802350:	83 ec 04             	sub    $0x4,%esp
  802353:	8b 5d 08             	mov    0x8(%ebp),%ebx
	// Unmap any data mapped for the file,
	// then tell the file server that we have closed the file
	// (to free up its resources).

	// LAB 5: Your code here.
	//panic("close() unimplemented!");
        int r;
        // should we set bool dirty to be 0 or 1?
        if ((r = funmap(fd, fd->fd_file.file.f_size, 0, 1)) < 0) {
  802356:	6a 01                	push   $0x1
  802358:	6a 00                	push   $0x0
  80235a:	ff b3 90 00 00 00    	pushl  0x90(%ebx)
  802360:	53                   	push   %ebx
  802361:	e8 e7 03 00 00       	call   80274d <funmap>
  802366:	83 c4 10             	add    $0x10,%esp
          return r;
  802369:	89 c2                	mov    %eax,%edx
  80236b:	85 c0                	test   %eax,%eax
  80236d:	78 19                	js     802388 <file_close+0x3c>
        }
        if ((r = fsipc_close(fd->fd_file.id)) < 0) {
  80236f:	83 ec 0c             	sub    $0xc,%esp
  802372:	ff 73 0c             	pushl  0xc(%ebx)
  802375:	e8 68 05 00 00       	call   8028e2 <fsipc_close>
  80237a:	83 c4 10             	add    $0x10,%esp
          return r;
  80237d:	89 c2                	mov    %eax,%edx
  80237f:	85 c0                	test   %eax,%eax
  802381:	78 05                	js     802388 <file_close+0x3c>
        }
        return 0;
  802383:	ba 00 00 00 00       	mov    $0x0,%edx
}
  802388:	89 d0                	mov    %edx,%eax
  80238a:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80238d:	c9                   	leave  
  80238e:	c3                   	ret    

0080238f <file_read>:

// Read 'n' bytes from 'fd' at the current seek position into 'buf'.
// Since files are memory-mapped, this amounts to a memmove()
// surrounded by a little red tape to handle the file size and seek pointer.
static ssize_t
file_read(struct Fd *fd, void *buf, size_t n, off_t offset)
{
  80238f:	55                   	push   %ebp
  802390:	89 e5                	mov    %esp,%ebp
  802392:	57                   	push   %edi
  802393:	56                   	push   %esi
  802394:	53                   	push   %ebx
  802395:	83 ec 0c             	sub    $0xc,%esp
  802398:	8b 75 10             	mov    0x10(%ebp),%esi
  80239b:	8b 7d 14             	mov    0x14(%ebp),%edi
	size_t size;

        // Challenge 5:
        int r;
        void* paddr;

	// avoid reading past the end of file
	size = fd->fd_file.file.f_size;
  80239e:	8b 45 08             	mov    0x8(%ebp),%eax
  8023a1:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
	if (offset > size)
		return 0;
  8023a7:	b9 00 00 00 00       	mov    $0x0,%ecx
  8023ac:	39 d7                	cmp    %edx,%edi
  8023ae:	0f 87 95 00 00 00    	ja     802449 <file_read+0xba>
	if (offset + n > size)
  8023b4:	8d 04 37             	lea    (%edi,%esi,1),%eax
  8023b7:	39 d0                	cmp    %edx,%eax
  8023b9:	76 04                	jbe    8023bf <file_read+0x30>
		n = size - offset;
  8023bb:	89 d6                	mov    %edx,%esi
  8023bd:	29 fe                	sub    %edi,%esi

        // Challenge 5
        // Check if the page is mapped yet
        for (paddr = fd2data(fd) + offset; paddr < (void*)(fd2data(fd) + offset + n); paddr += PGSIZE) {
  8023bf:	83 ec 0c             	sub    $0xc,%esp
  8023c2:	ff 75 08             	pushl  0x8(%ebp)
  8023c5:	e8 7e f9 ff ff       	call   801d48 <fd2data>
  8023ca:	89 c3                	mov    %eax,%ebx
  8023cc:	01 fb                	add    %edi,%ebx
  8023ce:	83 c4 10             	add    $0x10,%esp
  8023d1:	eb 41                	jmp    802414 <file_read+0x85>
	  if (!(vpd[PDX(paddr)] & PTE_P) || !(vpt[VPN(paddr)] & PTE_P)) {
  8023d3:	89 d8                	mov    %ebx,%eax
  8023d5:	c1 e8 16             	shr    $0x16,%eax
  8023d8:	8b 04 85 00 d0 7b ef 	mov    0xef7bd000(,%eax,4),%eax
  8023df:	a8 01                	test   $0x1,%al
  8023e1:	74 10                	je     8023f3 <file_read+0x64>
  8023e3:	89 d8                	mov    %ebx,%eax
  8023e5:	c1 e8 0c             	shr    $0xc,%eax
  8023e8:	8b 04 85 00 00 40 ef 	mov    0xef400000(,%eax,4),%eax
  8023ef:	a8 01                	test   $0x1,%al
  8023f1:	75 1b                	jne    80240e <file_read+0x7f>
            // page is not mapped, so map it!
            if ((r = fmap(fd, offset, offset + n)) < 0) {
  8023f3:	83 ec 04             	sub    $0x4,%esp
  8023f6:	8d 04 37             	lea    (%edi,%esi,1),%eax
  8023f9:	50                   	push   %eax
  8023fa:	57                   	push   %edi
  8023fb:	ff 75 08             	pushl  0x8(%ebp)
  8023fe:	e8 d4 02 00 00       	call   8026d7 <fmap>
  802403:	83 c4 10             	add    $0x10,%esp
              return r;
  802406:	89 c1                	mov    %eax,%ecx
  802408:	85 c0                	test   %eax,%eax
  80240a:	78 3d                	js     802449 <file_read+0xba>
  80240c:	eb 1c                	jmp    80242a <file_read+0x9b>
  80240e:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  802414:	83 ec 0c             	sub    $0xc,%esp
  802417:	ff 75 08             	pushl  0x8(%ebp)
  80241a:	e8 29 f9 ff ff       	call   801d48 <fd2data>
  80241f:	01 f8                	add    %edi,%eax
  802421:	01 f0                	add    %esi,%eax
  802423:	83 c4 10             	add    $0x10,%esp
  802426:	39 d8                	cmp    %ebx,%eax
  802428:	77 a9                	ja     8023d3 <file_read+0x44>
            }
            break;
          }
        }

	// read the data by copying from the file mapping
	memmove(buf, fd2data(fd) + offset, n);
  80242a:	83 ec 04             	sub    $0x4,%esp
  80242d:	56                   	push   %esi
  80242e:	83 ec 04             	sub    $0x4,%esp
  802431:	ff 75 08             	pushl  0x8(%ebp)
  802434:	e8 0f f9 ff ff       	call   801d48 <fd2data>
  802439:	83 c4 08             	add    $0x8,%esp
  80243c:	01 f8                	add    %edi,%eax
  80243e:	50                   	push   %eax
  80243f:	ff 75 0c             	pushl  0xc(%ebp)
  802442:	e8 f5 ee ff ff       	call   80133c <memmove>
	return n;
  802447:	89 f1                	mov    %esi,%ecx
}
  802449:	89 c8                	mov    %ecx,%eax
  80244b:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80244e:	5b                   	pop    %ebx
  80244f:	5e                   	pop    %esi
  802450:	5f                   	pop    %edi
  802451:	c9                   	leave  
  802452:	c3                   	ret    

00802453 <read_map>:

// Find the page that maps the file block starting at 'offset',
// and store its address in '*blk'.
int
read_map(int fdnum, off_t offset, void **blk)
{
  802453:	55                   	push   %ebp
  802454:	89 e5                	mov    %esp,%ebp
  802456:	56                   	push   %esi
  802457:	53                   	push   %ebx
  802458:	83 ec 18             	sub    $0x18,%esp
  80245b:	8b 75 0c             	mov    0xc(%ebp),%esi
	int r;
	char *va;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80245e:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  802461:	50                   	push   %eax
  802462:	ff 75 08             	pushl  0x8(%ebp)
  802465:	e8 60 f9 ff ff       	call   801dca <fd_lookup>
  80246a:	83 c4 10             	add    $0x10,%esp
		return r;
  80246d:	89 c2                	mov    %eax,%edx
  80246f:	85 c0                	test   %eax,%eax
  802471:	0f 88 9f 00 00 00    	js     802516 <read_map+0xc3>
	if (fd->fd_dev_id != devfile.dev_id)
  802477:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  80247a:	8b 00                	mov    (%eax),%eax
		return -E_INVAL;
  80247c:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  802481:	3b 05 20 80 81 00    	cmp    0x818020,%eax
  802487:	0f 85 89 00 00 00    	jne    802516 <read_map+0xc3>
	va = fd2data(fd) + offset;
  80248d:	83 ec 0c             	sub    $0xc,%esp
  802490:	ff 75 f4             	pushl  0xfffffff4(%ebp)
  802493:	e8 b0 f8 ff ff       	call   801d48 <fd2data>
  802498:	89 c3                	mov    %eax,%ebx
  80249a:	01 f3                	add    %esi,%ebx

	if (offset >= MAXFILESIZE)
  80249c:	83 c4 10             	add    $0x10,%esp
		return -E_NO_DISK;
  80249f:	ba f7 ff ff ff       	mov    $0xfffffff7,%edx
  8024a4:	81 fe ff ff 3f 00    	cmp    $0x3fffff,%esi
  8024aa:	7f 6a                	jg     802516 <read_map+0xc3>

        // Challenge 5
	if (!(vpd[PDX(va)] & PTE_P) || !(vpt[VPN(va)] & PTE_P)) {
  8024ac:	89 d8                	mov    %ebx,%eax
  8024ae:	c1 e8 16             	shr    $0x16,%eax
  8024b1:	8b 04 85 00 d0 7b ef 	mov    0xef7bd000(,%eax,4),%eax
  8024b8:	a8 01                	test   $0x1,%al
  8024ba:	74 10                	je     8024cc <read_map+0x79>
  8024bc:	89 d8                	mov    %ebx,%eax
  8024be:	c1 e8 0c             	shr    $0xc,%eax
  8024c1:	8b 04 85 00 00 40 ef 	mov    0xef400000(,%eax,4),%eax
  8024c8:	a8 01                	test   $0x1,%al
  8024ca:	75 19                	jne    8024e5 <read_map+0x92>
          // page is not mapped, so map it!
          if ((r = fmap(fd, offset, offset + 1)) < 0) {
  8024cc:	83 ec 04             	sub    $0x4,%esp
  8024cf:	8d 46 01             	lea    0x1(%esi),%eax
  8024d2:	50                   	push   %eax
  8024d3:	56                   	push   %esi
  8024d4:	ff 75 f4             	pushl  0xfffffff4(%ebp)
  8024d7:	e8 fb 01 00 00       	call   8026d7 <fmap>
  8024dc:	83 c4 10             	add    $0x10,%esp
            return r;
  8024df:	89 c2                	mov    %eax,%edx
  8024e1:	85 c0                	test   %eax,%eax
  8024e3:	78 31                	js     802516 <read_map+0xc3>
          }
        }

	if (!(vpd[PDX(va)] & PTE_P) || !(vpt[VPN(va)] & PTE_P))
  8024e5:	89 d8                	mov    %ebx,%eax
  8024e7:	c1 e8 16             	shr    $0x16,%eax
  8024ea:	8b 04 85 00 d0 7b ef 	mov    0xef7bd000(,%eax,4),%eax
  8024f1:	a8 01                	test   $0x1,%al
  8024f3:	74 10                	je     802505 <read_map+0xb2>
  8024f5:	89 d8                	mov    %ebx,%eax
  8024f7:	c1 e8 0c             	shr    $0xc,%eax
  8024fa:	8b 04 85 00 00 40 ef 	mov    0xef400000(,%eax,4),%eax
  802501:	a8 01                	test   $0x1,%al
  802503:	75 07                	jne    80250c <read_map+0xb9>
		return -E_NO_DISK;
  802505:	ba f7 ff ff ff       	mov    $0xfffffff7,%edx
  80250a:	eb 0a                	jmp    802516 <read_map+0xc3>

	*blk = (void*) va;
  80250c:	8b 45 10             	mov    0x10(%ebp),%eax
  80250f:	89 18                	mov    %ebx,(%eax)
	return 0;
  802511:	ba 00 00 00 00       	mov    $0x0,%edx
}
  802516:	89 d0                	mov    %edx,%eax
  802518:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80251b:	5b                   	pop    %ebx
  80251c:	5e                   	pop    %esi
  80251d:	c9                   	leave  
  80251e:	c3                   	ret    

0080251f <file_write>:

// Write 'n' bytes from 'buf' to 'fd' at the current seek position.
static ssize_t
file_write(struct Fd *fd, const void *buf, size_t n, off_t offset)
{
  80251f:	55                   	push   %ebp
  802520:	89 e5                	mov    %esp,%ebp
  802522:	57                   	push   %edi
  802523:	56                   	push   %esi
  802524:	53                   	push   %ebx
  802525:	83 ec 0c             	sub    $0xc,%esp
  802528:	8b 75 08             	mov    0x8(%ebp),%esi
  80252b:	8b 7d 14             	mov    0x14(%ebp),%edi
	int r;
	size_t tot;

        // Challenge 5:
        void* paddr;

	// don't write past the maximum file size
	tot = offset + n;
  80252e:	8b 45 10             	mov    0x10(%ebp),%eax
  802531:	8d 14 07             	lea    (%edi,%eax,1),%edx
	if (tot > MAXFILESIZE)
		return -E_NO_DISK;
  802534:	b9 f7 ff ff ff       	mov    $0xfffffff7,%ecx
  802539:	81 fa 00 00 40 00    	cmp    $0x400000,%edx
  80253f:	0f 87 bd 00 00 00    	ja     802602 <file_write+0xe3>

	// increase the file's size if necessary
	if (tot > fd->fd_file.file.f_size) {
  802545:	39 96 90 00 00 00    	cmp    %edx,0x90(%esi)
  80254b:	73 17                	jae    802564 <file_write+0x45>
		if ((r = file_trunc(fd, tot)) < 0)
  80254d:	83 ec 08             	sub    $0x8,%esp
  802550:	52                   	push   %edx
  802551:	56                   	push   %esi
  802552:	e8 fb 00 00 00       	call   802652 <file_trunc>
  802557:	83 c4 10             	add    $0x10,%esp
			return r;
  80255a:	89 c1                	mov    %eax,%ecx
  80255c:	85 c0                	test   %eax,%eax
  80255e:	0f 88 9e 00 00 00    	js     802602 <file_write+0xe3>
	}

        // Challenge 5:
        // Check if the page is mapped yet
        for (paddr = fd2data(fd) + offset; paddr < (void*)(fd2data(fd) + offset + n); paddr += PGSIZE) {
  802564:	83 ec 0c             	sub    $0xc,%esp
  802567:	56                   	push   %esi
  802568:	e8 db f7 ff ff       	call   801d48 <fd2data>
  80256d:	89 c3                	mov    %eax,%ebx
  80256f:	01 fb                	add    %edi,%ebx
  802571:	83 c4 10             	add    $0x10,%esp
  802574:	eb 42                	jmp    8025b8 <file_write+0x99>
	  if (!(vpd[PDX(paddr)] & PTE_P) || !(vpt[VPN(paddr)] & PTE_P)) {
  802576:	89 d8                	mov    %ebx,%eax
  802578:	c1 e8 16             	shr    $0x16,%eax
  80257b:	8b 04 85 00 d0 7b ef 	mov    0xef7bd000(,%eax,4),%eax
  802582:	a8 01                	test   $0x1,%al
  802584:	74 10                	je     802596 <file_write+0x77>
  802586:	89 d8                	mov    %ebx,%eax
  802588:	c1 e8 0c             	shr    $0xc,%eax
  80258b:	8b 04 85 00 00 40 ef 	mov    0xef400000(,%eax,4),%eax
  802592:	a8 01                	test   $0x1,%al
  802594:	75 1c                	jne    8025b2 <file_write+0x93>
            // page is not mapped, so map it!
            if ((r = fmap(fd, offset, offset + n)) < 0) {
  802596:	83 ec 04             	sub    $0x4,%esp
  802599:	8b 55 10             	mov    0x10(%ebp),%edx
  80259c:	8d 04 17             	lea    (%edi,%edx,1),%eax
  80259f:	50                   	push   %eax
  8025a0:	57                   	push   %edi
  8025a1:	56                   	push   %esi
  8025a2:	e8 30 01 00 00       	call   8026d7 <fmap>
  8025a7:	83 c4 10             	add    $0x10,%esp
              return r;
  8025aa:	89 c1                	mov    %eax,%ecx
  8025ac:	85 c0                	test   %eax,%eax
  8025ae:	78 52                	js     802602 <file_write+0xe3>
  8025b0:	eb 1b                	jmp    8025cd <file_write+0xae>
  8025b2:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  8025b8:	83 ec 0c             	sub    $0xc,%esp
  8025bb:	56                   	push   %esi
  8025bc:	e8 87 f7 ff ff       	call   801d48 <fd2data>
  8025c1:	01 f8                	add    %edi,%eax
  8025c3:	03 45 10             	add    0x10(%ebp),%eax
  8025c6:	83 c4 10             	add    $0x10,%esp
  8025c9:	39 d8                	cmp    %ebx,%eax
  8025cb:	77 a9                	ja     802576 <file_write+0x57>
            }
            break;
          }
        }

	// write the data
        cprintf("write write\n");
  8025cd:	83 ec 0c             	sub    $0xc,%esp
  8025d0:	68 3e 22 81 00       	push   $0x81223e
  8025d5:	e8 e2 e5 ff ff       	call   800bbc <cprintf>
	memmove(fd2data(fd) + offset, buf, n);
  8025da:	83 c4 0c             	add    $0xc,%esp
  8025dd:	ff 75 10             	pushl  0x10(%ebp)
  8025e0:	ff 75 0c             	pushl  0xc(%ebp)
  8025e3:	56                   	push   %esi
  8025e4:	e8 5f f7 ff ff       	call   801d48 <fd2data>
  8025e9:	01 f8                	add    %edi,%eax
  8025eb:	89 04 24             	mov    %eax,(%esp)
  8025ee:	e8 49 ed ff ff       	call   80133c <memmove>
        cprintf("write done\n");
  8025f3:	c7 04 24 4b 22 81 00 	movl   $0x81224b,(%esp)
  8025fa:	e8 bd e5 ff ff       	call   800bbc <cprintf>
	return n;
  8025ff:	8b 4d 10             	mov    0x10(%ebp),%ecx
}
  802602:	89 c8                	mov    %ecx,%eax
  802604:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  802607:	5b                   	pop    %ebx
  802608:	5e                   	pop    %esi
  802609:	5f                   	pop    %edi
  80260a:	c9                   	leave  
  80260b:	c3                   	ret    

0080260c <file_stat>:

static int
file_stat(struct Fd *fd, struct Stat *st)
{
  80260c:	55                   	push   %ebp
  80260d:	89 e5                	mov    %esp,%ebp
  80260f:	56                   	push   %esi
  802610:	53                   	push   %ebx
  802611:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802614:	8b 75 0c             	mov    0xc(%ebp),%esi
	strcpy(st->st_name, fd->fd_file.file.f_name);
  802617:	83 ec 08             	sub    $0x8,%esp
  80261a:	8d 43 10             	lea    0x10(%ebx),%eax
  80261d:	50                   	push   %eax
  80261e:	56                   	push   %esi
  80261f:	e8 9c eb ff ff       	call   8011c0 <strcpy>
	st->st_size = fd->fd_file.file.f_size;
  802624:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80262a:	89 86 80 00 00 00    	mov    %eax,0x80(%esi)
	st->st_isdir = (fd->fd_file.file.f_type == FTYPE_DIR);
  802630:	83 c4 10             	add    $0x10,%esp
  802633:	83 bb 94 00 00 00 01 	cmpl   $0x1,0x94(%ebx)
  80263a:	0f 94 c0             	sete   %al
  80263d:	0f b6 c0             	movzbl %al,%eax
  802640:	89 86 84 00 00 00    	mov    %eax,0x84(%esi)
	return 0;
}
  802646:	b8 00 00 00 00       	mov    $0x0,%eax
  80264b:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80264e:	5b                   	pop    %ebx
  80264f:	5e                   	pop    %esi
  802650:	c9                   	leave  
  802651:	c3                   	ret    

00802652 <file_trunc>:

// Truncate or extend an open file to 'size' bytes
static int
file_trunc(struct Fd *fd, off_t newsize)
{
  802652:	55                   	push   %ebp
  802653:	89 e5                	mov    %esp,%ebp
  802655:	57                   	push   %edi
  802656:	56                   	push   %esi
  802657:	53                   	push   %ebx
  802658:	83 ec 0c             	sub    $0xc,%esp
  80265b:	8b 75 08             	mov    0x8(%ebp),%esi
  80265e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	off_t oldsize;
	uint32_t fileid;

	if (newsize > MAXFILESIZE)
		return -E_NO_DISK;
  802661:	ba f7 ff ff ff       	mov    $0xfffffff7,%edx
  802666:	81 fb 00 00 40 00    	cmp    $0x400000,%ebx
  80266c:	7f 5f                	jg     8026cd <file_trunc+0x7b>

	fileid = fd->fd_file.id;
	oldsize = fd->fd_file.file.f_size;
  80266e:	8b be 90 00 00 00    	mov    0x90(%esi),%edi
	if ((r = fsipc_set_size(fileid, newsize)) < 0)
  802674:	83 ec 08             	sub    $0x8,%esp
  802677:	53                   	push   %ebx
  802678:	ff 76 0c             	pushl  0xc(%esi)
  80267b:	e8 3a 02 00 00       	call   8028ba <fsipc_set_size>
  802680:	83 c4 10             	add    $0x10,%esp
		return r;
  802683:	89 c2                	mov    %eax,%edx
  802685:	85 c0                	test   %eax,%eax
  802687:	78 44                	js     8026cd <file_trunc+0x7b>
	assert(fd->fd_file.file.f_size == newsize);
  802689:	39 9e 90 00 00 00    	cmp    %ebx,0x90(%esi)
  80268f:	74 19                	je     8026aa <file_trunc+0x58>
  802691:	68 78 22 81 00       	push   $0x812278
  802696:	68 57 22 81 00       	push   $0x812257
  80269b:	68 dc 00 00 00       	push   $0xdc
  8026a0:	68 6c 22 81 00       	push   $0x81226c
  8026a5:	e8 22 e4 ff ff       	call   800acc <_panic>

	if ((r = fmap(fd, oldsize, newsize)) < 0)
  8026aa:	83 ec 04             	sub    $0x4,%esp
  8026ad:	53                   	push   %ebx
  8026ae:	57                   	push   %edi
  8026af:	56                   	push   %esi
  8026b0:	e8 22 00 00 00       	call   8026d7 <fmap>
  8026b5:	83 c4 10             	add    $0x10,%esp
		return r;
  8026b8:	89 c2                	mov    %eax,%edx
  8026ba:	85 c0                	test   %eax,%eax
  8026bc:	78 0f                	js     8026cd <file_trunc+0x7b>
	funmap(fd, oldsize, newsize, 0);
  8026be:	6a 00                	push   $0x0
  8026c0:	53                   	push   %ebx
  8026c1:	57                   	push   %edi
  8026c2:	56                   	push   %esi
  8026c3:	e8 85 00 00 00       	call   80274d <funmap>

	return 0;
  8026c8:	ba 00 00 00 00       	mov    $0x0,%edx
}
  8026cd:	89 d0                	mov    %edx,%eax
  8026cf:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8026d2:	5b                   	pop    %ebx
  8026d3:	5e                   	pop    %esi
  8026d4:	5f                   	pop    %edi
  8026d5:	c9                   	leave  
  8026d6:	c3                   	ret    

008026d7 <fmap>:

// Call the file system server to obtain and map file pages
// when the size of the file as mapped in our memory increases.
// Harmlessly does nothing if oldsize >= newsize.
// Returns 0 on success, < 0 on error.
// If there is an error, unmaps any newly allocated pages.
//
// Hint: Use fd2data to get the start of the file mapping area for fd.
// Hint: You can use ROUNDUP to page-align offsets.
static int
fmap(struct Fd* fd, off_t oldsize, off_t newsize)
{
  8026d7:	55                   	push   %ebp
  8026d8:	89 e5                	mov    %esp,%ebp
  8026da:	57                   	push   %edi
  8026db:	56                   	push   %esi
  8026dc:	53                   	push   %ebx
  8026dd:	83 ec 0c             	sub    $0xc,%esp
  8026e0:	8b 7d 08             	mov    0x8(%ebp),%edi
  8026e3:	8b 75 10             	mov    0x10(%ebp),%esi
	// LAB 5: Your code here.
	//panic("fmap not implemented");
	//return -E_UNSPECIFIED;

	char *fma; // file mapping area
        int pidx;
        int r;
        if (oldsize < newsize) {
  8026e6:	39 75 0c             	cmp    %esi,0xc(%ebp)
  8026e9:	7d 55                	jge    802740 <fmap+0x69>
          fma = fd2data(fd);
  8026eb:	83 ec 0c             	sub    $0xc,%esp
  8026ee:	57                   	push   %edi
  8026ef:	e8 54 f6 ff ff       	call   801d48 <fd2data>
  8026f4:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
          for (pidx = ROUNDUP(oldsize, PGSIZE); pidx < newsize; pidx += PGSIZE) {
  8026f7:	83 c4 10             	add    $0x10,%esp
  8026fa:	8b 45 0c             	mov    0xc(%ebp),%eax
  8026fd:	05 ff 0f 00 00       	add    $0xfff,%eax
  802702:	89 c3                	mov    %eax,%ebx
  802704:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  80270a:	39 f3                	cmp    %esi,%ebx
  80270c:	7d 32                	jge    802740 <fmap+0x69>
            if ((r = fsipc_map(fd->fd_file.id, pidx, fma + pidx)) < 0) {
  80270e:	83 ec 04             	sub    $0x4,%esp
  802711:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  802714:	01 d8                	add    %ebx,%eax
  802716:	50                   	push   %eax
  802717:	53                   	push   %ebx
  802718:	ff 77 0c             	pushl  0xc(%edi)
  80271b:	e8 6f 01 00 00       	call   80288f <fsipc_map>
  802720:	83 c4 10             	add    $0x10,%esp
  802723:	85 c0                	test   %eax,%eax
  802725:	79 0f                	jns    802736 <fmap+0x5f>
              // unmap because of error
              funmap(fd, pidx, oldsize, 0);
  802727:	6a 00                	push   $0x0
  802729:	ff 75 0c             	pushl  0xc(%ebp)
  80272c:	53                   	push   %ebx
  80272d:	57                   	push   %edi
  80272e:	e8 1a 00 00 00       	call   80274d <funmap>
  802733:	83 c4 10             	add    $0x10,%esp
  802736:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80273c:	39 f3                	cmp    %esi,%ebx
  80273e:	7c ce                	jl     80270e <fmap+0x37>
            }
          }
        }

        return 0;
}
  802740:	b8 00 00 00 00       	mov    $0x0,%eax
  802745:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  802748:	5b                   	pop    %ebx
  802749:	5e                   	pop    %esi
  80274a:	5f                   	pop    %edi
  80274b:	c9                   	leave  
  80274c:	c3                   	ret    

0080274d <funmap>:

// Unmap any file pages that no longer represent valid file pages
// when the size of the file as mapped in our address space decreases.
// Harmlessly does nothing if newsize >= oldsize.
//
// Hint: Remember to call fsipc_dirty if dirty is true and PTE_D bit
// is set in the pagetable entry.
// Hint: Use fd2data to get the start of the file mapping area for fd.
// Hint: You can use ROUNDUP to page-align offsets.
static int
funmap(struct Fd* fd, off_t oldsize, off_t newsize, bool dirty)
{
  80274d:	55                   	push   %ebp
  80274e:	89 e5                	mov    %esp,%ebp
  802750:	57                   	push   %edi
  802751:	56                   	push   %esi
  802752:	53                   	push   %ebx
  802753:	83 ec 0c             	sub    $0xc,%esp
  802756:	8b 75 0c             	mov    0xc(%ebp),%esi
  802759:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 5: Your code here.
	//panic("funmap not implemented");
	//return -E_UNSPECIFIED;

	char *fma; // file mapping area
        int pidx;
        int r;
        if (newsize < oldsize) {
  80275c:	39 f3                	cmp    %esi,%ebx
  80275e:	0f 8d 80 00 00 00    	jge    8027e4 <funmap+0x97>
          fma = fd2data(fd);
  802764:	83 ec 0c             	sub    $0xc,%esp
  802767:	ff 75 08             	pushl  0x8(%ebp)
  80276a:	e8 d9 f5 ff ff       	call   801d48 <fd2data>
  80276f:	89 c7                	mov    %eax,%edi
          for (pidx = ROUNDUP(newsize, PGSIZE); pidx < oldsize; pidx += PGSIZE) {
  802771:	83 c4 10             	add    $0x10,%esp
  802774:	8d 83 ff 0f 00 00    	lea    0xfff(%ebx),%eax
  80277a:	89 c3                	mov    %eax,%ebx
  80277c:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  802782:	39 f3                	cmp    %esi,%ebx
  802784:	7d 5e                	jge    8027e4 <funmap+0x97>
            if (vpt[VPN(fma + pidx)] & PTE_P) { // present
  802786:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
  802789:	89 c2                	mov    %eax,%edx
  80278b:	c1 ea 0c             	shr    $0xc,%edx
  80278e:	8b 04 95 00 00 40 ef 	mov    0xef400000(,%edx,4),%eax
  802795:	a8 01                	test   $0x1,%al
  802797:	74 41                	je     8027da <funmap+0x8d>
              if (dirty) {
  802799:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  80279d:	74 21                	je     8027c0 <funmap+0x73>
                if (vpt[VPN(fma + pidx)] & PTE_D) {
  80279f:	8b 04 95 00 00 40 ef 	mov    0xef400000(,%edx,4),%eax
  8027a6:	a8 40                	test   $0x40,%al
  8027a8:	74 16                	je     8027c0 <funmap+0x73>
                  if ((r = fsipc_dirty(fd->fd_file.id, pidx)) < 0) {
  8027aa:	83 ec 08             	sub    $0x8,%esp
  8027ad:	53                   	push   %ebx
  8027ae:	8b 45 08             	mov    0x8(%ebp),%eax
  8027b1:	ff 70 0c             	pushl  0xc(%eax)
  8027b4:	e8 49 01 00 00       	call   802902 <fsipc_dirty>
  8027b9:	83 c4 10             	add    $0x10,%esp
  8027bc:	85 c0                	test   %eax,%eax
  8027be:	78 29                	js     8027e9 <funmap+0x9c>
                    return r;
                  }
                }
              }
              sys_page_unmap(sys_getenvid(), fma + pidx);
  8027c0:	83 ec 08             	sub    $0x8,%esp
  8027c3:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
  8027c6:	50                   	push   %eax
  8027c7:	83 ec 04             	sub    $0x4,%esp
  8027ca:	e8 85 ed ff ff       	call   801554 <sys_getenvid>
  8027cf:	89 04 24             	mov    %eax,(%esp)
  8027d2:	e8 40 ee ff ff       	call   801617 <sys_page_unmap>
  8027d7:	83 c4 10             	add    $0x10,%esp
  8027da:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  8027e0:	39 f3                	cmp    %esi,%ebx
  8027e2:	7c a2                	jl     802786 <funmap+0x39>
            }
          }
        }

        return 0;
  8027e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8027e9:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8027ec:	5b                   	pop    %ebx
  8027ed:	5e                   	pop    %esi
  8027ee:	5f                   	pop    %edi
  8027ef:	c9                   	leave  
  8027f0:	c3                   	ret    

008027f1 <remove>:

// Delete a file
int
remove(const char *path)
{
  8027f1:	55                   	push   %ebp
  8027f2:	89 e5                	mov    %esp,%ebp
  8027f4:	83 ec 14             	sub    $0x14,%esp
	return fsipc_remove(path);
  8027f7:	ff 75 08             	pushl  0x8(%ebp)
  8027fa:	e8 2b 01 00 00       	call   80292a <fsipc_remove>
}
  8027ff:	c9                   	leave  
  802800:	c3                   	ret    

00802801 <sync>:

// Synchronize disk with buffer cache
int
sync(void)
{
  802801:	55                   	push   %ebp
  802802:	89 e5                	mov    %esp,%ebp
  802804:	83 ec 08             	sub    $0x8,%esp
	return fsipc_sync();
  802807:	e8 64 01 00 00       	call   802970 <fsipc_sync>
}
  80280c:	c9                   	leave  
  80280d:	c3                   	ret    
	...

00802810 <fsipc>:
// *perm: permissions of received page.
// Returns 0 if successful, < 0 on failure.
static int
fsipc(unsigned type, void *fsreq, void *dstva, int *perm)
{
  802810:	55                   	push   %ebp
  802811:	89 e5                	mov    %esp,%ebp
  802813:	83 ec 08             	sub    $0x8,%esp
	envid_t whom;

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", env->env_id, type, fsipcbuf);

	ipc_send(envs[1].env_id, type, fsreq, PTE_P | PTE_W | PTE_U);
  802816:	6a 07                	push   $0x7
  802818:	ff 75 0c             	pushl  0xc(%ebp)
  80281b:	ff 75 08             	pushl  0x8(%ebp)
  80281e:	a1 cc 00 c0 ee       	mov    0xeec000cc,%eax
  802823:	50                   	push   %eax
  802824:	e8 c6 f4 ff ff       	call   801cef <ipc_send>
	return ipc_recv(&whom, dstva, perm);
  802829:	83 c4 0c             	add    $0xc,%esp
  80282c:	ff 75 14             	pushl  0x14(%ebp)
  80282f:	ff 75 10             	pushl  0x10(%ebp)
  802832:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  802835:	50                   	push   %eax
  802836:	e8 51 f4 ff ff       	call   801c8c <ipc_recv>
}
  80283b:	c9                   	leave  
  80283c:	c3                   	ret    

0080283d <fsipc_open>:

// Send file-open request to the file server.
// Includes 'path' and 'omode' in request,
// and on reply maps the returned file descriptor page
// at the address indicated by the caller in 'fd'.
// Returns 0 on success, < 0 on failure.
int
fsipc_open(const char *path, int omode, struct Fd *fd)
{
  80283d:	55                   	push   %ebp
  80283e:	89 e5                	mov    %esp,%ebp
  802840:	56                   	push   %esi
  802841:	53                   	push   %ebx
  802842:	83 ec 1c             	sub    $0x1c,%esp
  802845:	8b 75 08             	mov    0x8(%ebp),%esi
	int perm;
	struct Fsreq_open *req;

	req = (struct Fsreq_open*)fsipcbuf;
  802848:	bb 00 50 81 00       	mov    $0x815000,%ebx
	if (strlen(path) >= MAXPATHLEN)
  80284d:	56                   	push   %esi
  80284e:	e8 31 e9 ff ff       	call   801184 <strlen>
  802853:	83 c4 10             	add    $0x10,%esp
		return -E_BAD_PATH;
  802856:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
  80285b:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  802860:	7f 24                	jg     802886 <fsipc_open+0x49>
	strcpy(req->req_path, path);
  802862:	83 ec 08             	sub    $0x8,%esp
  802865:	56                   	push   %esi
  802866:	53                   	push   %ebx
  802867:	e8 54 e9 ff ff       	call   8011c0 <strcpy>
	req->req_omode = omode;
  80286c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80286f:	89 83 00 04 00 00    	mov    %eax,0x400(%ebx)

	return fsipc(FSREQ_OPEN, req, fd, &perm);
  802875:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  802878:	50                   	push   %eax
  802879:	ff 75 10             	pushl  0x10(%ebp)
  80287c:	53                   	push   %ebx
  80287d:	6a 01                	push   $0x1
  80287f:	e8 8c ff ff ff       	call   802810 <fsipc>
  802884:	89 c2                	mov    %eax,%edx
}
  802886:	89 d0                	mov    %edx,%eax
  802888:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80288b:	5b                   	pop    %ebx
  80288c:	5e                   	pop    %esi
  80288d:	c9                   	leave  
  80288e:	c3                   	ret    

0080288f <fsipc_map>:

// Make a map-block request to the file server.
// We send the fileid and the (byte) offset of the desired block in the file,
// and the server sends us back a mapping for a page containing that block.
// Returns 0 on success, < 0 on failure.
int
fsipc_map(int fileid, off_t offset, void *dstva)
{
  80288f:	55                   	push   %ebp
  802890:	89 e5                	mov    %esp,%ebp
  802892:	83 ec 08             	sub    $0x8,%esp
	// LAB 5: Your code here.
	//panic("fsipc_map not implemented");

	int perm;
	struct Fsreq_map *req;
	req = (struct Fsreq_map*)fsipcbuf;
        req->req_fileid = fileid;
  802895:	8b 45 08             	mov    0x8(%ebp),%eax
  802898:	a3 00 50 81 00       	mov    %eax,0x815000
        req->req_offset = offset;
  80289d:	8b 45 0c             	mov    0xc(%ebp),%eax
  8028a0:	a3 04 50 81 00       	mov    %eax,0x815004
	return fsipc(FSREQ_MAP, req, dstva, &perm);
  8028a5:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  8028a8:	50                   	push   %eax
  8028a9:	ff 75 10             	pushl  0x10(%ebp)
  8028ac:	68 00 50 81 00       	push   $0x815000
  8028b1:	6a 02                	push   $0x2
  8028b3:	e8 58 ff ff ff       	call   802810 <fsipc>

	//return -E_UNSPECIFIED;
}
  8028b8:	c9                   	leave  
  8028b9:	c3                   	ret    

008028ba <fsipc_set_size>:

// Make a set-file-size request to the file server.
int
fsipc_set_size(int fileid, off_t size)
{
  8028ba:	55                   	push   %ebp
  8028bb:	89 e5                	mov    %esp,%ebp
  8028bd:	83 ec 08             	sub    $0x8,%esp
	struct Fsreq_set_size *req;

	req = (struct Fsreq_set_size*) fsipcbuf;
	req->req_fileid = fileid;
  8028c0:	8b 45 08             	mov    0x8(%ebp),%eax
  8028c3:	a3 00 50 81 00       	mov    %eax,0x815000
	req->req_size = size;
  8028c8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8028cb:	a3 04 50 81 00       	mov    %eax,0x815004
	return fsipc(FSREQ_SET_SIZE, req, 0, 0);
  8028d0:	6a 00                	push   $0x0
  8028d2:	6a 00                	push   $0x0
  8028d4:	68 00 50 81 00       	push   $0x815000
  8028d9:	6a 03                	push   $0x3
  8028db:	e8 30 ff ff ff       	call   802810 <fsipc>
}
  8028e0:	c9                   	leave  
  8028e1:	c3                   	ret    

008028e2 <fsipc_close>:

// Make a file-close request to the file server.
// After this the fileid is invalid.
int
fsipc_close(int fileid)
{
  8028e2:	55                   	push   %ebp
  8028e3:	89 e5                	mov    %esp,%ebp
  8028e5:	83 ec 08             	sub    $0x8,%esp
	struct Fsreq_close *req;

	req = (struct Fsreq_close*) fsipcbuf;
	req->req_fileid = fileid;
  8028e8:	8b 45 08             	mov    0x8(%ebp),%eax
  8028eb:	a3 00 50 81 00       	mov    %eax,0x815000
	return fsipc(FSREQ_CLOSE, req, 0, 0);
  8028f0:	6a 00                	push   $0x0
  8028f2:	6a 00                	push   $0x0
  8028f4:	68 00 50 81 00       	push   $0x815000
  8028f9:	6a 04                	push   $0x4
  8028fb:	e8 10 ff ff ff       	call   802810 <fsipc>
}
  802900:	c9                   	leave  
  802901:	c3                   	ret    

00802902 <fsipc_dirty>:

// Ask the file server to mark a particular file block dirty.
int
fsipc_dirty(int fileid, off_t offset)
{
  802902:	55                   	push   %ebp
  802903:	89 e5                	mov    %esp,%ebp
  802905:	83 ec 08             	sub    $0x8,%esp
	// LAB 5: Your code here.
	//panic("fsipc_dirty not implemented");
	//return -E_UNSPECIFIED;

	int perm;
	struct Fsreq_dirty *req;
	req = (struct Fsreq_dirty*)fsipcbuf;
        req->req_fileid = fileid;
  802908:	8b 45 08             	mov    0x8(%ebp),%eax
  80290b:	a3 00 50 81 00       	mov    %eax,0x815000
        req->req_offset = offset;
  802910:	8b 45 0c             	mov    0xc(%ebp),%eax
  802913:	a3 04 50 81 00       	mov    %eax,0x815004
	return fsipc(FSREQ_DIRTY, req, 0, 0);
  802918:	6a 00                	push   $0x0
  80291a:	6a 00                	push   $0x0
  80291c:	68 00 50 81 00       	push   $0x815000
  802921:	6a 05                	push   $0x5
  802923:	e8 e8 fe ff ff       	call   802810 <fsipc>
}
  802928:	c9                   	leave  
  802929:	c3                   	ret    

0080292a <fsipc_remove>:

// Ask the file server to delete a file, given its pathname.
int
fsipc_remove(const char *path)
{
  80292a:	55                   	push   %ebp
  80292b:	89 e5                	mov    %esp,%ebp
  80292d:	56                   	push   %esi
  80292e:	53                   	push   %ebx
  80292f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct Fsreq_remove *req;

	req = (struct Fsreq_remove*) fsipcbuf;
  802932:	be 00 50 81 00       	mov    $0x815000,%esi
	if (strlen(path) >= MAXPATHLEN)
  802937:	83 ec 0c             	sub    $0xc,%esp
  80293a:	53                   	push   %ebx
  80293b:	e8 44 e8 ff ff       	call   801184 <strlen>
  802940:	83 c4 10             	add    $0x10,%esp
		return -E_BAD_PATH;
  802943:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
  802948:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  80294d:	7f 18                	jg     802967 <fsipc_remove+0x3d>
	strcpy(req->req_path, path);
  80294f:	83 ec 08             	sub    $0x8,%esp
  802952:	53                   	push   %ebx
  802953:	56                   	push   %esi
  802954:	e8 67 e8 ff ff       	call   8011c0 <strcpy>
	return fsipc(FSREQ_REMOVE, req, 0, 0);
  802959:	6a 00                	push   $0x0
  80295b:	6a 00                	push   $0x0
  80295d:	56                   	push   %esi
  80295e:	6a 06                	push   $0x6
  802960:	e8 ab fe ff ff       	call   802810 <fsipc>
  802965:	89 c2                	mov    %eax,%edx
}
  802967:	89 d0                	mov    %edx,%eax
  802969:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80296c:	5b                   	pop    %ebx
  80296d:	5e                   	pop    %esi
  80296e:	c9                   	leave  
  80296f:	c3                   	ret    

00802970 <fsipc_sync>:

// Ask the file server to update the disk
// by writing any dirty blocks in the buffer cache.
int
fsipc_sync(void)
{
  802970:	55                   	push   %ebp
  802971:	89 e5                	mov    %esp,%ebp
  802973:	83 ec 08             	sub    $0x8,%esp
	return fsipc(FSREQ_SYNC, fsipcbuf, 0, 0);
  802976:	6a 00                	push   $0x0
  802978:	6a 00                	push   $0x0
  80297a:	68 00 50 81 00       	push   $0x815000
  80297f:	6a 07                	push   $0x7
  802981:	e8 8a fe ff ff       	call   802810 <fsipc>
}
  802986:	c9                   	leave  
  802987:	c3                   	ret    

00802988 <isfree>:
static uint8_t *mptr;

static int
isfree(void *v, size_t n)
{
  802988:	55                   	push   %ebp
  802989:	89 e5                	mov    %esp,%ebp
  80298b:	56                   	push   %esi
  80298c:	53                   	push   %ebx
  80298d:	8b 45 08             	mov    0x8(%ebp),%eax
	uintptr_t va, end_va = (uintptr_t) v + n;
  802990:	89 c1                	mov    %eax,%ecx
  802992:	03 4d 0c             	add    0xc(%ebp),%ecx

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  802995:	89 c2                	mov    %eax,%edx
  802997:	39 c8                	cmp    %ecx,%eax
  802999:	73 3b                	jae    8029d6 <isfree+0x4e>
  80299b:	bb 00 d0 7b ef       	mov    $0xef7bd000,%ebx
  8029a0:	be 00 00 40 ef       	mov    $0xef400000,%esi
		if (va >= (uintptr_t) mend
  8029a5:	39 15 44 80 81 00    	cmp    %edx,0x818044
  8029ab:	76 18                	jbe    8029c5 <isfree+0x3d>
  8029ad:	89 d0                	mov    %edx,%eax
  8029af:	c1 e8 16             	shr    $0x16,%eax
  8029b2:	8b 04 83             	mov    (%ebx,%eax,4),%eax
  8029b5:	a8 01                	test   $0x1,%al
  8029b7:	74 13                	je     8029cc <isfree+0x44>
  8029b9:	89 d0                	mov    %edx,%eax
  8029bb:	c1 e8 0c             	shr    $0xc,%eax
  8029be:	8b 04 86             	mov    (%esi,%eax,4),%eax
  8029c1:	a8 01                	test   $0x1,%al
  8029c3:	74 07                	je     8029cc <isfree+0x44>
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[VPN(va)] & PTE_P)))
			return 0;
  8029c5:	b8 00 00 00 00       	mov    $0x0,%eax
  8029ca:	eb 0f                	jmp    8029db <isfree+0x53>
  8029cc:	81 c2 00 10 00 00    	add    $0x1000,%edx
  8029d2:	39 ca                	cmp    %ecx,%edx
  8029d4:	72 cf                	jb     8029a5 <isfree+0x1d>
	return 1;
  8029d6:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8029db:	5b                   	pop    %ebx
  8029dc:	5e                   	pop    %esi
  8029dd:	c9                   	leave  
  8029de:	c3                   	ret    

008029df <malloc>:

void*
malloc(size_t n)
{
  8029df:	55                   	push   %ebp
  8029e0:	89 e5                	mov    %esp,%ebp
  8029e2:	57                   	push   %edi
  8029e3:	56                   	push   %esi
  8029e4:	53                   	push   %ebx
  8029e5:	83 ec 0c             	sub    $0xc,%esp
  8029e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  8029eb:	83 3d 70 84 81 00 00 	cmpl   $0x0,0x818470
  8029f2:	75 0a                	jne    8029fe <malloc+0x1f>
		mptr = mbegin;
  8029f4:	a1 40 80 81 00       	mov    0x818040,%eax
  8029f9:	a3 70 84 81 00       	mov    %eax,0x818470

	n = ROUNDUP(n, 4);
  8029fe:	8d 43 03             	lea    0x3(%ebx),%eax
  802a01:	89 c3                	mov    %eax,%ebx
  802a03:	83 e3 fc             	and    $0xfffffffc,%ebx

	if (n >= MAXMALLOC)
		return 0;
  802a06:	b8 00 00 00 00       	mov    $0x0,%eax
  802a0b:	81 fb ff ff 0f 00    	cmp    $0xfffff,%ebx
  802a11:	0f 87 46 01 00 00    	ja     802b5d <malloc+0x17e>

	if ((uintptr_t) mptr % PGSIZE){
  802a17:	8b 0d 70 84 81 00    	mov    0x818470,%ecx
  802a1d:	f7 c1 ff 0f 00 00    	test   $0xfff,%ecx
  802a23:	74 5b                	je     802a80 <malloc+0xa1>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  802a25:	8d 81 ff 0f 00 00    	lea    0xfff(%ecx),%eax
  802a2b:	89 c6                	mov    %eax,%esi
  802a2d:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  802a33:	89 ca                	mov    %ecx,%edx
  802a35:	c1 ea 0c             	shr    $0xc,%edx
  802a38:	8d 44 0b 03          	lea    0x3(%ebx,%ecx,1),%eax
  802a3c:	c1 e8 0c             	shr    $0xc,%eax
  802a3f:	39 c2                	cmp    %eax,%edx
  802a41:	75 18                	jne    802a5b <malloc+0x7c>
			(*ref)++;
  802a43:	ff 46 fc             	incl   0xfffffffc(%esi)
			v = mptr;
  802a46:	8b 15 70 84 81 00    	mov    0x818470,%edx
			mptr += n;
  802a4c:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  802a4f:	a3 70 84 81 00       	mov    %eax,0x818470
			return v;
  802a54:	89 d0                	mov    %edx,%eax
  802a56:	e9 02 01 00 00       	jmp    802b5d <malloc+0x17e>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  802a5b:	83 ec 0c             	sub    $0xc,%esp
  802a5e:	ff 35 70 84 81 00    	pushl  0x818470
  802a64:	e8 fc 00 00 00       	call   802b65 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  802a69:	83 c4 10             	add    $0x10,%esp
  802a6c:	a1 70 84 81 00       	mov    0x818470,%eax
  802a71:	05 00 10 00 00       	add    $0x1000,%eax
  802a76:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  802a7b:	a3 70 84 81 00       	mov    %eax,0x818470
	}

	/*
	 * now we need to find some address space for this chunk.
	 * if it's less than a page we leave it open for allocation.
	 * runs of more than a page can't have ref counts so we 
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
  802a80:	be 00 00 00 00       	mov    $0x0,%esi
	while (1) {
		if (isfree(mptr, n + 4))
  802a85:	8d 43 04             	lea    0x4(%ebx),%eax
  802a88:	50                   	push   %eax
  802a89:	ff 35 70 84 81 00    	pushl  0x818470
  802a8f:	e8 f4 fe ff ff       	call   802988 <isfree>
  802a94:	83 c4 08             	add    $0x8,%esp
  802a97:	85 c0                	test   %eax,%eax
  802a99:	75 31                	jne    802acc <malloc+0xed>
			break;
		mptr += PGSIZE;
  802a9b:	a1 70 84 81 00       	mov    0x818470,%eax
  802aa0:	05 00 10 00 00       	add    $0x1000,%eax
  802aa5:	a3 70 84 81 00       	mov    %eax,0x818470
		if (mptr == mend) {
  802aaa:	3b 05 44 80 81 00    	cmp    0x818044,%eax
  802ab0:	75 d3                	jne    802a85 <malloc+0xa6>
			mptr = mbegin;
  802ab2:	a1 40 80 81 00       	mov    0x818040,%eax
  802ab7:	a3 70 84 81 00       	mov    %eax,0x818470
			if (++nwrap == 2)
  802abc:	46                   	inc    %esi
  802abd:	83 fe 02             	cmp    $0x2,%esi
  802ac0:	75 c3                	jne    802a85 <malloc+0xa6>
				return 0;	/* out of address space */
  802ac2:	b8 00 00 00 00       	mov    $0x0,%eax
  802ac7:	e9 91 00 00 00       	jmp    802b5d <malloc+0x17e>
		}
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  802acc:	be 00 00 00 00       	mov    $0x0,%esi
  802ad1:	8d 43 04             	lea    0x4(%ebx),%eax
  802ad4:	89 c2                	mov    %eax,%edx
  802ad6:	39 c6                	cmp    %eax,%esi
  802ad8:	73 64                	jae    802b3e <malloc+0x15f>
  802ada:	89 c7                	mov    %eax,%edi
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  802adc:	8d 86 00 10 00 00    	lea    0x1000(%esi),%eax
  802ae2:	39 d0                	cmp    %edx,%eax
  802ae4:	19 c0                	sbb    %eax,%eax
  802ae6:	25 00 04 00 00       	and    $0x400,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  802aeb:	83 ec 04             	sub    $0x4,%esp
  802aee:	83 c8 07             	or     $0x7,%eax
  802af1:	50                   	push   %eax
  802af2:	89 f0                	mov    %esi,%eax
  802af4:	03 05 70 84 81 00    	add    0x818470,%eax
  802afa:	50                   	push   %eax
  802afb:	6a 00                	push   $0x0
  802afd:	e8 90 ea ff ff       	call   801592 <sys_page_alloc>
  802b02:	83 c4 10             	add    $0x10,%esp
  802b05:	85 c0                	test   %eax,%eax
  802b07:	79 29                	jns    802b32 <malloc+0x153>
			for (; i >= 0; i -= PGSIZE)
  802b09:	85 f6                	test   %esi,%esi
  802b0b:	78 1e                	js     802b2b <malloc+0x14c>
				sys_page_unmap(0, mptr + i);
  802b0d:	83 ec 08             	sub    $0x8,%esp
  802b10:	89 f0                	mov    %esi,%eax
  802b12:	03 05 70 84 81 00    	add    0x818470,%eax
  802b18:	50                   	push   %eax
  802b19:	6a 00                	push   $0x0
  802b1b:	e8 f7 ea ff ff       	call   801617 <sys_page_unmap>
  802b20:	83 c4 10             	add    $0x10,%esp
  802b23:	81 ee 00 10 00 00    	sub    $0x1000,%esi
  802b29:	79 e2                	jns    802b0d <malloc+0x12e>
			return 0;	/* out of physical memory */
  802b2b:	b8 00 00 00 00       	mov    $0x0,%eax
  802b30:	eb 2b                	jmp    802b5d <malloc+0x17e>
  802b32:	81 c6 00 10 00 00    	add    $0x1000,%esi
  802b38:	89 fa                	mov    %edi,%edx
  802b3a:	39 fe                	cmp    %edi,%esi
  802b3c:	72 9e                	jb     802adc <malloc+0xfd>
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  802b3e:	89 f0                	mov    %esi,%eax
  802b40:	03 05 70 84 81 00    	add    0x818470,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  802b46:	c7 40 fc 02 00 00 00 	movl   $0x2,0xfffffffc(%eax)
	v = mptr;
  802b4d:	8b 15 70 84 81 00    	mov    0x818470,%edx
	mptr += n;
  802b53:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  802b56:	a3 70 84 81 00       	mov    %eax,0x818470
	return v;
  802b5b:	89 d0                	mov    %edx,%eax
}
  802b5d:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  802b60:	5b                   	pop    %ebx
  802b61:	5e                   	pop    %esi
  802b62:	5f                   	pop    %edi
  802b63:	c9                   	leave  
  802b64:	c3                   	ret    

00802b65 <free>:

void
free(void *v)
{
  802b65:	55                   	push   %ebp
  802b66:	89 e5                	mov    %esp,%ebp
  802b68:	53                   	push   %ebx
  802b69:	83 ec 04             	sub    $0x4,%esp
  802b6c:	8b 45 08             	mov    0x8(%ebp),%eax
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  802b6f:	85 c0                	test   %eax,%eax
  802b71:	0f 84 aa 00 00 00    	je     802c21 <free+0xbc>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  802b77:	39 05 40 80 81 00    	cmp    %eax,0x818040
  802b7d:	77 08                	ja     802b87 <free+0x22>
  802b7f:	3b 05 44 80 81 00    	cmp    0x818044,%eax
  802b85:	72 16                	jb     802b9d <free+0x38>
  802b87:	68 9c 22 81 00       	push   $0x81229c
  802b8c:	68 57 22 81 00       	push   $0x812257
  802b91:	6a 7a                	push   $0x7a
  802b93:	68 ca 22 81 00       	push   $0x8122ca
  802b98:	e8 2f df ff ff       	call   800acc <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  802b9d:	89 c3                	mov    %eax,%ebx
  802b9f:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (vpt[VPN(c)] & PTE_CONTINUED) {
		sys_page_unmap(0, c);
		c += PGSIZE;
		assert(mbegin <= c && c < mend);
  802ba5:	89 d8                	mov    %ebx,%eax
  802ba7:	c1 e8 0c             	shr    $0xc,%eax
  802baa:	8b 04 85 00 00 40 ef 	mov    0xef400000(,%eax,4),%eax
  802bb1:	f6 c4 04             	test   $0x4,%ah
  802bb4:	74 4e                	je     802c04 <free+0x9f>
  802bb6:	83 ec 08             	sub    $0x8,%esp
  802bb9:	53                   	push   %ebx
  802bba:	6a 00                	push   $0x0
  802bbc:	e8 56 ea ff ff       	call   801617 <sys_page_unmap>
  802bc1:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  802bc7:	83 c4 10             	add    $0x10,%esp
  802bca:	39 1d 40 80 81 00    	cmp    %ebx,0x818040
  802bd0:	77 08                	ja     802bda <free+0x75>
  802bd2:	3b 1d 44 80 81 00    	cmp    0x818044,%ebx
  802bd8:	72 19                	jb     802bf3 <free+0x8e>
  802bda:	68 d7 22 81 00       	push   $0x8122d7
  802bdf:	68 57 22 81 00       	push   $0x812257
  802be4:	68 81 00 00 00       	push   $0x81
  802be9:	68 ca 22 81 00       	push   $0x8122ca
  802bee:	e8 d9 de ff ff       	call   800acc <_panic>
  802bf3:	89 d8                	mov    %ebx,%eax
  802bf5:	c1 e8 0c             	shr    $0xc,%eax
  802bf8:	8b 04 85 00 00 40 ef 	mov    0xef400000(,%eax,4),%eax
  802bff:	f6 c4 04             	test   $0x4,%ah
  802c02:	75 b2                	jne    802bb6 <free+0x51>
	}

	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  802c04:	ff 8b fc 0f 00 00    	decl   0xffc(%ebx)
  802c0a:	83 bb fc 0f 00 00 00 	cmpl   $0x0,0xffc(%ebx)
  802c11:	75 0e                	jne    802c21 <free+0xbc>
		sys_page_unmap(0, c);	
  802c13:	83 ec 08             	sub    $0x8,%esp
  802c16:	53                   	push   %ebx
  802c17:	6a 00                	push   $0x0
  802c19:	e8 f9 e9 ff ff       	call   801617 <sys_page_unmap>
  802c1e:	83 c4 10             	add    $0x10,%esp
}
  802c21:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  802c24:	c9                   	leave  
  802c25:	c3                   	ret    
	...

00802c28 <pipe>:
};

int
pipe(int pfd[2])
{
  802c28:	55                   	push   %ebp
  802c29:	89 e5                	mov    %esp,%ebp
  802c2b:	57                   	push   %edi
  802c2c:	56                   	push   %esi
  802c2d:	53                   	push   %ebx
  802c2e:	83 ec 18             	sub    $0x18,%esp
  802c31:	8b 7d 08             	mov    0x8(%ebp),%edi
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  802c34:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  802c37:	50                   	push   %eax
  802c38:	e8 33 f1 ff ff       	call   801d70 <fd_alloc>
  802c3d:	89 c3                	mov    %eax,%ebx
  802c3f:	83 c4 10             	add    $0x10,%esp
  802c42:	85 c0                	test   %eax,%eax
  802c44:	0f 88 25 01 00 00    	js     802d6f <pipe+0x147>
  802c4a:	83 ec 04             	sub    $0x4,%esp
  802c4d:	68 07 04 00 00       	push   $0x407
  802c52:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  802c55:	6a 00                	push   $0x0
  802c57:	e8 36 e9 ff ff       	call   801592 <sys_page_alloc>
  802c5c:	89 c3                	mov    %eax,%ebx
  802c5e:	83 c4 10             	add    $0x10,%esp
  802c61:	85 c0                	test   %eax,%eax
  802c63:	0f 88 06 01 00 00    	js     802d6f <pipe+0x147>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  802c69:	83 ec 0c             	sub    $0xc,%esp
  802c6c:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  802c6f:	50                   	push   %eax
  802c70:	e8 fb f0 ff ff       	call   801d70 <fd_alloc>
  802c75:	89 c3                	mov    %eax,%ebx
  802c77:	83 c4 10             	add    $0x10,%esp
  802c7a:	85 c0                	test   %eax,%eax
  802c7c:	0f 88 dd 00 00 00    	js     802d5f <pipe+0x137>
  802c82:	83 ec 04             	sub    $0x4,%esp
  802c85:	68 07 04 00 00       	push   $0x407
  802c8a:	ff 75 ec             	pushl  0xffffffec(%ebp)
  802c8d:	6a 00                	push   $0x0
  802c8f:	e8 fe e8 ff ff       	call   801592 <sys_page_alloc>
  802c94:	89 c3                	mov    %eax,%ebx
  802c96:	83 c4 10             	add    $0x10,%esp
  802c99:	85 c0                	test   %eax,%eax
  802c9b:	0f 88 be 00 00 00    	js     802d5f <pipe+0x137>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  802ca1:	83 ec 0c             	sub    $0xc,%esp
  802ca4:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  802ca7:	e8 9c f0 ff ff       	call   801d48 <fd2data>
  802cac:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  802cae:	83 c4 0c             	add    $0xc,%esp
  802cb1:	68 07 04 00 00       	push   $0x407
  802cb6:	50                   	push   %eax
  802cb7:	6a 00                	push   $0x0
  802cb9:	e8 d4 e8 ff ff       	call   801592 <sys_page_alloc>
  802cbe:	89 c3                	mov    %eax,%ebx
  802cc0:	83 c4 10             	add    $0x10,%esp
  802cc3:	85 c0                	test   %eax,%eax
  802cc5:	0f 88 84 00 00 00    	js     802d4f <pipe+0x127>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  802ccb:	83 ec 0c             	sub    $0xc,%esp
  802cce:	68 07 04 00 00       	push   $0x407
  802cd3:	83 ec 0c             	sub    $0xc,%esp
  802cd6:	ff 75 ec             	pushl  0xffffffec(%ebp)
  802cd9:	e8 6a f0 ff ff       	call   801d48 <fd2data>
  802cde:	83 c4 10             	add    $0x10,%esp
  802ce1:	50                   	push   %eax
  802ce2:	6a 00                	push   $0x0
  802ce4:	56                   	push   %esi
  802ce5:	6a 00                	push   $0x0
  802ce7:	e8 e9 e8 ff ff       	call   8015d5 <sys_page_map>
  802cec:	89 c3                	mov    %eax,%ebx
  802cee:	83 c4 20             	add    $0x20,%esp
  802cf1:	85 c0                	test   %eax,%eax
  802cf3:	78 4c                	js     802d41 <pipe+0x119>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  802cf5:	8b 15 60 80 81 00    	mov    0x818060,%edx
  802cfb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  802cfe:	89 10                	mov    %edx,(%eax)
	fd0->fd_omode = O_RDONLY;
  802d00:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  802d03:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	fd1->fd_dev_id = devpipe.dev_id;
  802d0a:	8b 15 60 80 81 00    	mov    0x818060,%edx
  802d10:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  802d13:	89 10                	mov    %edx,(%eax)
	fd1->fd_omode = O_WRONLY;
  802d15:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  802d18:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", env->env_id, vpt[VPN(va)]);

	pfd[0] = fd2num(fd0);
  802d1f:	83 ec 0c             	sub    $0xc,%esp
  802d22:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  802d25:	e8 36 f0 ff ff       	call   801d60 <fd2num>
  802d2a:	89 07                	mov    %eax,(%edi)
	pfd[1] = fd2num(fd1);
  802d2c:	83 c4 04             	add    $0x4,%esp
  802d2f:	ff 75 ec             	pushl  0xffffffec(%ebp)
  802d32:	e8 29 f0 ff ff       	call   801d60 <fd2num>
  802d37:	89 47 04             	mov    %eax,0x4(%edi)
	return 0;
  802d3a:	b8 00 00 00 00       	mov    $0x0,%eax
  802d3f:	eb 30                	jmp    802d71 <pipe+0x149>

    err3:
	sys_page_unmap(0, va);
  802d41:	83 ec 08             	sub    $0x8,%esp
  802d44:	56                   	push   %esi
  802d45:	6a 00                	push   $0x0
  802d47:	e8 cb e8 ff ff       	call   801617 <sys_page_unmap>
  802d4c:	83 c4 10             	add    $0x10,%esp
    err2:
	sys_page_unmap(0, fd1);
  802d4f:	83 ec 08             	sub    $0x8,%esp
  802d52:	ff 75 ec             	pushl  0xffffffec(%ebp)
  802d55:	6a 00                	push   $0x0
  802d57:	e8 bb e8 ff ff       	call   801617 <sys_page_unmap>
  802d5c:	83 c4 10             	add    $0x10,%esp
    err1:
	sys_page_unmap(0, fd0);
  802d5f:	83 ec 08             	sub    $0x8,%esp
  802d62:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  802d65:	6a 00                	push   $0x0
  802d67:	e8 ab e8 ff ff       	call   801617 <sys_page_unmap>
  802d6c:	83 c4 10             	add    $0x10,%esp
    err:
	return r;
  802d6f:	89 d8                	mov    %ebx,%eax
}
  802d71:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  802d74:	5b                   	pop    %ebx
  802d75:	5e                   	pop    %esi
  802d76:	5f                   	pop    %edi
  802d77:	c9                   	leave  
  802d78:	c3                   	ret    

00802d79 <_pipeisclosed>:

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  802d79:	55                   	push   %ebp
  802d7a:	89 e5                	mov    %esp,%ebp
  802d7c:	57                   	push   %edi
  802d7d:	56                   	push   %esi
  802d7e:	53                   	push   %ebx
  802d7f:	83 ec 0c             	sub    $0xc,%esp
  802d82:	8b 7d 0c             	mov    0xc(%ebp),%edi
	int n, nn, ret;

	while (1) {
		n = env->env_runs;
  802d85:	a1 54 e6 b3 00       	mov    0xb3e654,%eax
  802d8a:	8b 70 58             	mov    0x58(%eax),%esi
		ret = pageref(fd) == pageref(p);
  802d8d:	83 ec 0c             	sub    $0xc,%esp
  802d90:	ff 75 08             	pushl  0x8(%ebp)
  802d93:	e8 48 04 00 00       	call   8031e0 <pageref>
  802d98:	89 c3                	mov    %eax,%ebx
  802d9a:	89 3c 24             	mov    %edi,(%esp)
  802d9d:	e8 3e 04 00 00       	call   8031e0 <pageref>
  802da2:	83 c4 10             	add    $0x10,%esp
  802da5:	39 c3                	cmp    %eax,%ebx
  802da7:	0f 94 c0             	sete   %al
  802daa:	0f b6 d0             	movzbl %al,%edx
		nn = env->env_runs;
  802dad:	8b 0d 54 e6 b3 00    	mov    0xb3e654,%ecx
  802db3:	8b 41 58             	mov    0x58(%ecx),%eax
		if (n == nn)
  802db6:	39 c6                	cmp    %eax,%esi
  802db8:	74 1b                	je     802dd5 <_pipeisclosed+0x5c>
			return ret;
		if (n != nn && ret == 1)
  802dba:	83 fa 01             	cmp    $0x1,%edx
  802dbd:	75 c6                	jne    802d85 <_pipeisclosed+0xc>
			cprintf("pipe race avoided\n", n, env->env_runs, ret);
  802dbf:	6a 01                	push   $0x1
  802dc1:	8b 41 58             	mov    0x58(%ecx),%eax
  802dc4:	50                   	push   %eax
  802dc5:	56                   	push   %esi
  802dc6:	68 f4 22 81 00       	push   $0x8122f4
  802dcb:	e8 ec dd ff ff       	call   800bbc <cprintf>
  802dd0:	83 c4 10             	add    $0x10,%esp
  802dd3:	eb b0                	jmp    802d85 <_pipeisclosed+0xc>
	}
}
  802dd5:	89 d0                	mov    %edx,%eax
  802dd7:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  802dda:	5b                   	pop    %ebx
  802ddb:	5e                   	pop    %esi
  802ddc:	5f                   	pop    %edi
  802ddd:	c9                   	leave  
  802dde:	c3                   	ret    

00802ddf <pipeisclosed>:

int
pipeisclosed(int fdnum)
{
  802ddf:	55                   	push   %ebp
  802de0:	89 e5                	mov    %esp,%ebp
  802de2:	83 ec 10             	sub    $0x10,%esp
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  802de5:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  802de8:	50                   	push   %eax
  802de9:	ff 75 08             	pushl  0x8(%ebp)
  802dec:	e8 d9 ef ff ff       	call   801dca <fd_lookup>
  802df1:	83 c4 10             	add    $0x10,%esp
		return r;
  802df4:	89 c2                	mov    %eax,%edx
  802df6:	85 c0                	test   %eax,%eax
  802df8:	78 19                	js     802e13 <pipeisclosed+0x34>
	p = (struct Pipe*) fd2data(fd);
  802dfa:	83 ec 0c             	sub    $0xc,%esp
  802dfd:	ff 75 fc             	pushl  0xfffffffc(%ebp)
  802e00:	e8 43 ef ff ff       	call   801d48 <fd2data>
	return _pipeisclosed(fd, p);
  802e05:	83 c4 08             	add    $0x8,%esp
  802e08:	50                   	push   %eax
  802e09:	ff 75 fc             	pushl  0xfffffffc(%ebp)
  802e0c:	e8 68 ff ff ff       	call   802d79 <_pipeisclosed>
  802e11:	89 c2                	mov    %eax,%edx
}
  802e13:	89 d0                	mov    %edx,%eax
  802e15:	c9                   	leave  
  802e16:	c3                   	ret    

00802e17 <piperead>:

static ssize_t
piperead(struct Fd *fd, void *vbuf, size_t n, off_t offset)
{
  802e17:	55                   	push   %ebp
  802e18:	89 e5                	mov    %esp,%ebp
  802e1a:	57                   	push   %edi
  802e1b:	56                   	push   %esi
  802e1c:	53                   	push   %ebx
  802e1d:	83 ec 18             	sub    $0x18,%esp
  802e20:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	(void) offset;	// shut up compiler

	p = (struct Pipe*)fd2data(fd);
  802e23:	57                   	push   %edi
  802e24:	e8 1f ef ff ff       	call   801d48 <fd2data>
  802e29:	89 c3                	mov    %eax,%ebx
	if (debug)
  802e2b:	83 c4 10             	add    $0x10,%esp
		cprintf("[%08x] piperead %08x %d rpos %d wpos %d\n",
			env->env_id, vpt[VPN(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  802e2e:	8b 45 0c             	mov    0xc(%ebp),%eax
  802e31:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	for (i = 0; i < n; i++) {
  802e34:	be 00 00 00 00       	mov    $0x0,%esi
  802e39:	3b 75 10             	cmp    0x10(%ebp),%esi
  802e3c:	73 55                	jae    802e93 <piperead+0x7c>
		while (p->p_rpos == p->p_wpos) {
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
				return i;
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("piperead yield\n");
			sys_yield();
  802e3e:	8b 03                	mov    (%ebx),%eax
  802e40:	3b 43 04             	cmp    0x4(%ebx),%eax
  802e43:	75 2c                	jne    802e71 <piperead+0x5a>
  802e45:	85 f6                	test   %esi,%esi
  802e47:	74 04                	je     802e4d <piperead+0x36>
  802e49:	89 f0                	mov    %esi,%eax
  802e4b:	eb 48                	jmp    802e95 <piperead+0x7e>
  802e4d:	83 ec 08             	sub    $0x8,%esp
  802e50:	53                   	push   %ebx
  802e51:	57                   	push   %edi
  802e52:	e8 22 ff ff ff       	call   802d79 <_pipeisclosed>
  802e57:	83 c4 10             	add    $0x10,%esp
  802e5a:	85 c0                	test   %eax,%eax
  802e5c:	74 07                	je     802e65 <piperead+0x4e>
  802e5e:	b8 00 00 00 00       	mov    $0x0,%eax
  802e63:	eb 30                	jmp    802e95 <piperead+0x7e>
  802e65:	e8 09 e7 ff ff       	call   801573 <sys_yield>
  802e6a:	8b 03                	mov    (%ebx),%eax
  802e6c:	3b 43 04             	cmp    0x4(%ebx),%eax
  802e6f:	74 d4                	je     802e45 <piperead+0x2e>
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  802e71:	8b 13                	mov    (%ebx),%edx
  802e73:	89 d0                	mov    %edx,%eax
  802e75:	85 d2                	test   %edx,%edx
  802e77:	79 03                	jns    802e7c <piperead+0x65>
  802e79:	8d 42 1f             	lea    0x1f(%edx),%eax
  802e7c:	83 e0 e0             	and    $0xffffffe0,%eax
  802e7f:	29 c2                	sub    %eax,%edx
  802e81:	8a 44 13 08          	mov    0x8(%ebx,%edx,1),%al
  802e85:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  802e88:	88 04 32             	mov    %al,(%edx,%esi,1)
		p->p_rpos++;
  802e8b:	ff 03                	incl   (%ebx)
  802e8d:	46                   	inc    %esi
  802e8e:	3b 75 10             	cmp    0x10(%ebp),%esi
  802e91:	72 ab                	jb     802e3e <piperead+0x27>
	}
	return i;
  802e93:	89 f0                	mov    %esi,%eax
}
  802e95:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  802e98:	5b                   	pop    %ebx
  802e99:	5e                   	pop    %esi
  802e9a:	5f                   	pop    %edi
  802e9b:	c9                   	leave  
  802e9c:	c3                   	ret    

00802e9d <pipewrite>:

static ssize_t
pipewrite(struct Fd *fd, const void *vbuf, size_t n, off_t offset)
{
  802e9d:	55                   	push   %ebp
  802e9e:	89 e5                	mov    %esp,%ebp
  802ea0:	57                   	push   %edi
  802ea1:	56                   	push   %esi
  802ea2:	53                   	push   %ebx
  802ea3:	83 ec 18             	sub    $0x18,%esp
  802ea6:	8b 7d 08             	mov    0x8(%ebp),%edi
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	(void) offset;	// shut up compiler

	p = (struct Pipe*) fd2data(fd);
  802ea9:	57                   	push   %edi
  802eaa:	e8 99 ee ff ff       	call   801d48 <fd2data>
  802eaf:	89 c3                	mov    %eax,%ebx
	if (debug)
  802eb1:	83 c4 10             	add    $0x10,%esp
		cprintf("[%08x] pipewrite %08x %d rpos %d wpos %d\n",
			env->env_id, vpt[VPN(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  802eb4:	8b 45 0c             	mov    0xc(%ebp),%eax
  802eb7:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	for (i = 0; i < n; i++) {
  802eba:	be 00 00 00 00       	mov    $0x0,%esi
  802ebf:	3b 75 10             	cmp    0x10(%ebp),%esi
  802ec2:	73 55                	jae    802f19 <pipewrite+0x7c>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("pipewrite yield\n");
			sys_yield();
  802ec4:	8b 03                	mov    (%ebx),%eax
  802ec6:	83 c0 20             	add    $0x20,%eax
  802ec9:	39 43 04             	cmp    %eax,0x4(%ebx)
  802ecc:	72 27                	jb     802ef5 <pipewrite+0x58>
  802ece:	83 ec 08             	sub    $0x8,%esp
  802ed1:	53                   	push   %ebx
  802ed2:	57                   	push   %edi
  802ed3:	e8 a1 fe ff ff       	call   802d79 <_pipeisclosed>
  802ed8:	83 c4 10             	add    $0x10,%esp
  802edb:	85 c0                	test   %eax,%eax
  802edd:	74 07                	je     802ee6 <pipewrite+0x49>
  802edf:	b8 00 00 00 00       	mov    $0x0,%eax
  802ee4:	eb 35                	jmp    802f1b <pipewrite+0x7e>
  802ee6:	e8 88 e6 ff ff       	call   801573 <sys_yield>
  802eeb:	8b 03                	mov    (%ebx),%eax
  802eed:	83 c0 20             	add    $0x20,%eax
  802ef0:	39 43 04             	cmp    %eax,0x4(%ebx)
  802ef3:	73 d9                	jae    802ece <pipewrite+0x31>
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  802ef5:	8b 53 04             	mov    0x4(%ebx),%edx
  802ef8:	89 d0                	mov    %edx,%eax
  802efa:	85 d2                	test   %edx,%edx
  802efc:	79 03                	jns    802f01 <pipewrite+0x64>
  802efe:	8d 42 1f             	lea    0x1f(%edx),%eax
  802f01:	83 e0 e0             	and    $0xffffffe0,%eax
  802f04:	29 c2                	sub    %eax,%edx
  802f06:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  802f09:	8a 04 31             	mov    (%ecx,%esi,1),%al
  802f0c:	88 44 13 08          	mov    %al,0x8(%ebx,%edx,1)
		p->p_wpos++;
  802f10:	ff 43 04             	incl   0x4(%ebx)
  802f13:	46                   	inc    %esi
  802f14:	3b 75 10             	cmp    0x10(%ebp),%esi
  802f17:	72 ab                	jb     802ec4 <pipewrite+0x27>
	}
	
	return i;
  802f19:	89 f0                	mov    %esi,%eax
}
  802f1b:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  802f1e:	5b                   	pop    %ebx
  802f1f:	5e                   	pop    %esi
  802f20:	5f                   	pop    %edi
  802f21:	c9                   	leave  
  802f22:	c3                   	ret    

00802f23 <pipestat>:

static int
pipestat(struct Fd *fd, struct Stat *stat)
{
  802f23:	55                   	push   %ebp
  802f24:	89 e5                	mov    %esp,%ebp
  802f26:	56                   	push   %esi
  802f27:	53                   	push   %ebx
  802f28:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  802f2b:	83 ec 0c             	sub    $0xc,%esp
  802f2e:	ff 75 08             	pushl  0x8(%ebp)
  802f31:	e8 12 ee ff ff       	call   801d48 <fd2data>
  802f36:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  802f38:	83 c4 08             	add    $0x8,%esp
  802f3b:	68 07 23 81 00       	push   $0x812307
  802f40:	53                   	push   %ebx
  802f41:	e8 7a e2 ff ff       	call   8011c0 <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  802f46:	8b 46 04             	mov    0x4(%esi),%eax
  802f49:	2b 06                	sub    (%esi),%eax
  802f4b:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  802f51:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  802f58:	00 00 00 
	stat->st_dev = &devpipe;
  802f5b:	c7 83 88 00 00 00 60 	movl   $0x818060,0x88(%ebx)
  802f62:	80 81 00 
	return 0;
}
  802f65:	b8 00 00 00 00       	mov    $0x0,%eax
  802f6a:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  802f6d:	5b                   	pop    %ebx
  802f6e:	5e                   	pop    %esi
  802f6f:	c9                   	leave  
  802f70:	c3                   	ret    

00802f71 <pipeclose>:

static int
pipeclose(struct Fd *fd)
{
  802f71:	55                   	push   %ebp
  802f72:	89 e5                	mov    %esp,%ebp
  802f74:	53                   	push   %ebx
  802f75:	83 ec 0c             	sub    $0xc,%esp
  802f78:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  802f7b:	53                   	push   %ebx
  802f7c:	6a 00                	push   $0x0
  802f7e:	e8 94 e6 ff ff       	call   801617 <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  802f83:	89 1c 24             	mov    %ebx,(%esp)
  802f86:	e8 bd ed ff ff       	call   801d48 <fd2data>
  802f8b:	83 c4 08             	add    $0x8,%esp
  802f8e:	50                   	push   %eax
  802f8f:	6a 00                	push   $0x0
  802f91:	e8 81 e6 ff ff       	call   801617 <sys_page_unmap>
}
  802f96:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  802f99:	c9                   	leave  
  802f9a:	c3                   	ret    
	...

00802f9c <cputchar>:
#include <inc/lib.h>

void
cputchar(int ch)
{
  802f9c:	55                   	push   %ebp
  802f9d:	89 e5                	mov    %esp,%ebp
  802f9f:	83 ec 10             	sub    $0x10,%esp
	char c = ch;
  802fa2:	8b 45 08             	mov    0x8(%ebp),%eax
  802fa5:	88 45 ff             	mov    %al,0xffffffff(%ebp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  802fa8:	6a 01                	push   $0x1
  802faa:	8d 45 ff             	lea    0xffffffff(%ebp),%eax
  802fad:	50                   	push   %eax
  802fae:	e8 1d e5 ff ff       	call   8014d0 <sys_cputs>
}
  802fb3:	c9                   	leave  
  802fb4:	c3                   	ret    

00802fb5 <getchar>:

int
getchar(void)
{
  802fb5:	55                   	push   %ebp
  802fb6:	89 e5                	mov    %esp,%ebp
  802fb8:	83 ec 0c             	sub    $0xc,%esp
	unsigned char c;
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  802fbb:	6a 01                	push   $0x1
  802fbd:	8d 45 ff             	lea    0xffffffff(%ebp),%eax
  802fc0:	50                   	push   %eax
  802fc1:	6a 00                	push   $0x0
  802fc3:	e8 95 f0 ff ff       	call   80205d <read>
	if (r < 0)
  802fc8:	83 c4 10             	add    $0x10,%esp
		return r;
  802fcb:	89 c2                	mov    %eax,%edx
  802fcd:	85 c0                	test   %eax,%eax
  802fcf:	78 0d                	js     802fde <getchar+0x29>
	if (r < 1)
		return -E_EOF;
  802fd1:	ba f8 ff ff ff       	mov    $0xfffffff8,%edx
  802fd6:	85 c0                	test   %eax,%eax
  802fd8:	7e 04                	jle    802fde <getchar+0x29>
	return c;
  802fda:	0f b6 55 ff          	movzbl 0xffffffff(%ebp),%edx
}
  802fde:	89 d0                	mov    %edx,%eax
  802fe0:	c9                   	leave  
  802fe1:	c3                   	ret    

00802fe2 <iscons>:


// "Real" console file descriptor implementation.
// The putchar/getchar functions above will still come here by default,
// but now can be redirected to files, pipes, etc., via the fd layer.

static ssize_t cons_read(struct Fd*, void*, size_t, off_t);
static ssize_t cons_write(struct Fd*, const void*, size_t, off_t);
static int cons_close(struct Fd*);
static int cons_stat(struct Fd*, struct Stat*);

struct Dev devcons =
{
	.dev_id =	'c',
	.dev_name =	"cons",
	.dev_read =	cons_read,
	.dev_write =	cons_write,
	.dev_close =	cons_close,
	.dev_stat =	cons_stat
};

int
iscons(int fdnum)
{
  802fe2:	55                   	push   %ebp
  802fe3:	89 e5                	mov    %esp,%ebp
  802fe5:	83 ec 10             	sub    $0x10,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  802fe8:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  802feb:	50                   	push   %eax
  802fec:	ff 75 08             	pushl  0x8(%ebp)
  802fef:	e8 d6 ed ff ff       	call   801dca <fd_lookup>
  802ff4:	83 c4 10             	add    $0x10,%esp
		return r;
  802ff7:	89 c2                	mov    %eax,%edx
  802ff9:	85 c0                	test   %eax,%eax
  802ffb:	78 11                	js     80300e <iscons+0x2c>
	return fd->fd_dev_id == devcons.dev_id;
  802ffd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  803000:	8b 00                	mov    (%eax),%eax
  803002:	3b 05 80 80 81 00    	cmp    0x818080,%eax
  803008:	0f 94 c0             	sete   %al
  80300b:	0f b6 d0             	movzbl %al,%edx
}
  80300e:	89 d0                	mov    %edx,%eax
  803010:	c9                   	leave  
  803011:	c3                   	ret    

00803012 <opencons>:

int
opencons(void)
{
  803012:	55                   	push   %ebp
  803013:	89 e5                	mov    %esp,%ebp
  803015:	83 ec 14             	sub    $0x14,%esp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  803018:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  80301b:	50                   	push   %eax
  80301c:	e8 4f ed ff ff       	call   801d70 <fd_alloc>
  803021:	83 c4 10             	add    $0x10,%esp
		return r;
  803024:	89 c2                	mov    %eax,%edx
  803026:	85 c0                	test   %eax,%eax
  803028:	78 3c                	js     803066 <opencons+0x54>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  80302a:	83 ec 04             	sub    $0x4,%esp
  80302d:	68 07 04 00 00       	push   $0x407
  803032:	ff 75 fc             	pushl  0xfffffffc(%ebp)
  803035:	6a 00                	push   $0x0
  803037:	e8 56 e5 ff ff       	call   801592 <sys_page_alloc>
  80303c:	83 c4 10             	add    $0x10,%esp
		return r;
  80303f:	89 c2                	mov    %eax,%edx
  803041:	85 c0                	test   %eax,%eax
  803043:	78 21                	js     803066 <opencons+0x54>
	fd->fd_dev_id = devcons.dev_id;
  803045:	a1 80 80 81 00       	mov    0x818080,%eax
  80304a:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  80304d:	89 02                	mov    %eax,(%edx)
	fd->fd_omode = O_RDWR;
  80304f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  803052:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  803059:	83 ec 0c             	sub    $0xc,%esp
  80305c:	ff 75 fc             	pushl  0xfffffffc(%ebp)
  80305f:	e8 fc ec ff ff       	call   801d60 <fd2num>
  803064:	89 c2                	mov    %eax,%edx
}
  803066:	89 d0                	mov    %edx,%eax
  803068:	c9                   	leave  
  803069:	c3                   	ret    

0080306a <cons_read>:

ssize_t
cons_read(struct Fd *fd, void *vbuf, size_t n, off_t offset)
{
  80306a:	55                   	push   %ebp
  80306b:	89 e5                	mov    %esp,%ebp
  80306d:	83 ec 08             	sub    $0x8,%esp
	int c;

	USED(offset);

	if (n == 0)
		return 0;
  803070:	b8 00 00 00 00       	mov    $0x0,%eax
  803075:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  803079:	74 2a                	je     8030a5 <cons_read+0x3b>
  80307b:	eb 05                	jmp    803082 <cons_read+0x18>

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  80307d:	e8 f1 e4 ff ff       	call   801573 <sys_yield>
  803082:	e8 6d e4 ff ff       	call   8014f4 <sys_cgetc>
  803087:	89 c2                	mov    %eax,%edx
  803089:	85 c0                	test   %eax,%eax
  80308b:	74 f0                	je     80307d <cons_read+0x13>
	if (c < 0)
  80308d:	85 d2                	test   %edx,%edx
  80308f:	78 14                	js     8030a5 <cons_read+0x3b>
		return c;
	if (c == 0x04)	// ctl-d is eof
		return 0;
  803091:	b8 00 00 00 00       	mov    $0x0,%eax
  803096:	83 fa 04             	cmp    $0x4,%edx
  803099:	74 0a                	je     8030a5 <cons_read+0x3b>
	*(char*)vbuf = c;
  80309b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80309e:	88 10                	mov    %dl,(%eax)
	return 1;
  8030a0:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8030a5:	c9                   	leave  
  8030a6:	c3                   	ret    

008030a7 <cons_write>:

ssize_t
cons_write(struct Fd *fd, const void *vbuf, size_t n, off_t offset)
{
  8030a7:	55                   	push   %ebp
  8030a8:	89 e5                	mov    %esp,%ebp
  8030aa:	57                   	push   %edi
  8030ab:	56                   	push   %esi
  8030ac:	53                   	push   %ebx
  8030ad:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
  8030b3:	8b 7d 10             	mov    0x10(%ebp),%edi
	int tot, m;
	char buf[128];

	USED(offset);

	// mistake: have to nul-terminate arg to sys_cputs, 
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  8030b6:	be 00 00 00 00       	mov    $0x0,%esi
  8030bb:	39 fe                	cmp    %edi,%esi
  8030bd:	73 3d                	jae    8030fc <cons_write+0x55>
		m = n - tot;
  8030bf:	89 fb                	mov    %edi,%ebx
  8030c1:	29 f3                	sub    %esi,%ebx
		if (m > sizeof(buf) - 1)
  8030c3:	83 fb 7f             	cmp    $0x7f,%ebx
  8030c6:	76 05                	jbe    8030cd <cons_write+0x26>
			m = sizeof(buf) - 1;
  8030c8:	bb 7f 00 00 00       	mov    $0x7f,%ebx
		memmove(buf, (char*)vbuf + tot, m);
  8030cd:	83 ec 04             	sub    $0x4,%esp
  8030d0:	53                   	push   %ebx
  8030d1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8030d4:	01 f0                	add    %esi,%eax
  8030d6:	50                   	push   %eax
  8030d7:	8d 85 68 ff ff ff    	lea    0xffffff68(%ebp),%eax
  8030dd:	50                   	push   %eax
  8030de:	e8 59 e2 ff ff       	call   80133c <memmove>
		sys_cputs(buf, m);
  8030e3:	83 c4 08             	add    $0x8,%esp
  8030e6:	53                   	push   %ebx
  8030e7:	8d 85 68 ff ff ff    	lea    0xffffff68(%ebp),%eax
  8030ed:	50                   	push   %eax
  8030ee:	e8 dd e3 ff ff       	call   8014d0 <sys_cputs>
  8030f3:	83 c4 10             	add    $0x10,%esp
  8030f6:	01 de                	add    %ebx,%esi
  8030f8:	39 fe                	cmp    %edi,%esi
  8030fa:	72 c3                	jb     8030bf <cons_write+0x18>
	}
	return tot;
}
  8030fc:	89 f0                	mov    %esi,%eax
  8030fe:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  803101:	5b                   	pop    %ebx
  803102:	5e                   	pop    %esi
  803103:	5f                   	pop    %edi
  803104:	c9                   	leave  
  803105:	c3                   	ret    

00803106 <cons_close>:

int
cons_close(struct Fd *fd)
{
  803106:	55                   	push   %ebp
  803107:	89 e5                	mov    %esp,%ebp
	USED(fd);

	return 0;
}
  803109:	b8 00 00 00 00       	mov    $0x0,%eax
  80310e:	c9                   	leave  
  80310f:	c3                   	ret    

00803110 <cons_stat>:

int
cons_stat(struct Fd *fd, struct Stat *stat)
{
  803110:	55                   	push   %ebp
  803111:	89 e5                	mov    %esp,%ebp
  803113:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<cons>");
  803116:	68 13 23 81 00       	push   $0x812313
  80311b:	ff 75 0c             	pushl  0xc(%ebp)
  80311e:	e8 9d e0 ff ff       	call   8011c0 <strcpy>
	return 0;
}
  803123:	b8 00 00 00 00       	mov    $0x0,%eax
  803128:	c9                   	leave  
  803129:	c3                   	ret    
	...

0080312c <set_pgfault_handler>:
//

void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  80312c:	55                   	push   %ebp
  80312d:	89 e5                	mov    %esp,%ebp
  80312f:	83 ec 08             	sub    $0x8,%esp
	int r;

	if (_pgfault_handler == 0) {
  803132:	83 3d 5c e6 b3 00 00 	cmpl   $0x0,0xb3e65c
  803139:	75 68                	jne    8031a3 <set_pgfault_handler+0x77>
		// First time through!
		// LAB 4: Your code here.
                // seanyliu
                if ((r = sys_page_alloc(sys_getenvid(), (void *)(UXSTACKTOP - PGSIZE), PTE_U | PTE_W | PTE_P)) < 0) {
  80313b:	83 ec 04             	sub    $0x4,%esp
  80313e:	6a 07                	push   $0x7
  803140:	68 00 f0 bf ee       	push   $0xeebff000
  803145:	83 ec 04             	sub    $0x4,%esp
  803148:	e8 07 e4 ff ff       	call   801554 <sys_getenvid>
  80314d:	89 04 24             	mov    %eax,(%esp)
  803150:	e8 3d e4 ff ff       	call   801592 <sys_page_alloc>
  803155:	83 c4 10             	add    $0x10,%esp
  803158:	85 c0                	test   %eax,%eax
  80315a:	79 14                	jns    803170 <set_pgfault_handler+0x44>
                  panic("set_pgfault_handler could not sys_page_alloc");
  80315c:	83 ec 04             	sub    $0x4,%esp
  80315f:	68 1c 23 81 00       	push   $0x81231c
  803164:	6a 21                	push   $0x21
  803166:	68 7d 23 81 00       	push   $0x81237d
  80316b:	e8 5c d9 ff ff       	call   800acc <_panic>
                }
                if ((r = sys_env_set_pgfault_upcall(sys_getenvid(), &_pgfault_upcall)) < 0) {
  803170:	83 ec 08             	sub    $0x8,%esp
  803173:	68 b0 31 80 00       	push   $0x8031b0
  803178:	83 ec 04             	sub    $0x4,%esp
  80317b:	e8 d4 e3 ff ff       	call   801554 <sys_getenvid>
  803180:	89 04 24             	mov    %eax,(%esp)
  803183:	e8 55 e5 ff ff       	call   8016dd <sys_env_set_pgfault_upcall>
  803188:	83 c4 10             	add    $0x10,%esp
  80318b:	85 c0                	test   %eax,%eax
  80318d:	79 14                	jns    8031a3 <set_pgfault_handler+0x77>
                  panic("set_pgfault_handler could not set pgfault upcall");
  80318f:	83 ec 04             	sub    $0x4,%esp
  803192:	68 4c 23 81 00       	push   $0x81234c
  803197:	6a 24                	push   $0x24
  803199:	68 7d 23 81 00       	push   $0x81237d
  80319e:	e8 29 d9 ff ff       	call   800acc <_panic>
                }
                
		//panic("set_pgfault_handler not implemented");
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  8031a3:	8b 45 08             	mov    0x8(%ebp),%eax
  8031a6:	a3 5c e6 b3 00       	mov    %eax,0xb3e65c
}
  8031ab:	c9                   	leave  
  8031ac:	c3                   	ret    
  8031ad:	00 00                	add    %al,(%eax)
	...

008031b0 <_pgfault_upcall>:
.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  8031b0:	54                   	push   %esp
	movl _pgfault_handler, %eax
  8031b1:	a1 5c e6 b3 00       	mov    0xb3e65c,%eax
	call *%eax
  8031b6:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  8031b8:	83 c4 04             	add    $0x4,%esp
	
	// Now the C page fault handler has returned and you must return
	// to the trap time state.
	// Push trap-time %eip onto the trap-time stack.
	//
	// Explanation:
	//   We must prepare the trap-time stack for our eventual return to
	//   re-execute the instruction that faulted.
	//   Unfortunately, we can't return directly from the exception stack:
	//   We can't call 'jmp', since that requires that we load the address
	//   into a register, and all registers must have their trap-time
	//   values after the return.
	//   We can't call 'ret' from the exception stack either, since if we
	//   did, %esp would have the wrong value.
	//   So instead, we push the trap-time %eip onto the *trap-time* stack!
	//   Below we'll switch to that stack and call 'ret', which will
	//   restore %eip to its pre-fault value.
	//
	//   In the case of a recursive fault on the exception stack,
	//   note that the word we're pushing now will fit in the
	//   blank word that the kernel reserved for us.
	//
	// Hints:
	//   What registers are available for intermediate calculations?
	//
	// LAB 4: Your code here.
        // seanyliu
	// Push trap-time %eip onto the trap-time stack.
        // obtain the trape-time %esp
        movl 12*4(%esp), %eax
  8031bb:	8b 44 24 30          	mov    0x30(%esp),%eax
        // obtain the trap-time %eip
        movl 10*4(%esp), %ebx // 10*4 because u read memory upward
  8031bf:	8b 5c 24 28          	mov    0x28(%esp),%ebx
        // push on the value
        movl %ebx, -4(%eax) // move down esp and fill in the value (writes upward)
  8031c3:	89 58 fc             	mov    %ebx,0xfffffffc(%eax)

	// Restore the trap-time registers.
	// LAB 4: Your code here.
	addl $4, %esp // skip fault_va
  8031c6:	83 c4 04             	add    $0x4,%esp
	addl $4, %esp // skip tf_err (error code)
  8031c9:	83 c4 04             	add    $0x4,%esp

        // pre-subtract 4 from the esp
        // not allowed to perform computations after eflags
        // because this changes eflags!
        // obtain the esp to be popped
        movl 10*4(%esp), %eax // 10*4 because u read memory upward
  8031cc:	8b 44 24 28          	mov    0x28(%esp),%eax
          // PushRegs = 8, eip=1, eflags=1
        subl $4, %eax
  8031d0:	83 e8 04             	sub    $0x4,%eax
        movl %eax, 10*4(%esp)
  8031d3:	89 44 24 28          	mov    %eax,0x28(%esp)

        popal // pop the PushRegs
  8031d7:	61                   	popa   

	// Restore eflags from the stack.
	// LAB 4: Your code here.
	addl $4, %esp // skip eip
  8031d8:	83 c4 04             	add    $0x4,%esp

        // not allowed to perform computations after eflags
        // because this changes eflags!
        popfl // pop eflags
  8031db:	9d                   	popf   

	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
        popl %esp
  8031dc:	5c                   	pop    %esp
	// In the case of a recursive fault on the exception stack,
	// note that the word we're pushing now will fit in the
	// blank word that the kernel reserved for us.
        // canNOT perform this operation!!! no math after popfl!
        //subl $4, %esp

	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
        ret
  8031dd:	c3                   	ret    
	...

008031e0 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  8031e0:	55                   	push   %ebp
  8031e1:	89 e5                	mov    %esp,%ebp
  8031e3:	8b 4d 08             	mov    0x8(%ebp),%ecx
	pte_t pte;

	if (!(vpd[PDX(v)] & PTE_P))
  8031e6:	89 c8                	mov    %ecx,%eax
  8031e8:	c1 e8 16             	shr    $0x16,%eax
  8031eb:	8b 04 85 00 d0 7b ef 	mov    0xef7bd000(,%eax,4),%eax
		return 0;
  8031f2:	ba 00 00 00 00       	mov    $0x0,%edx
  8031f7:	a8 01                	test   $0x1,%al
  8031f9:	74 28                	je     803223 <pageref+0x43>
	pte = vpt[VPN(v)];
  8031fb:	89 c8                	mov    %ecx,%eax
  8031fd:	c1 e8 0c             	shr    $0xc,%eax
  803200:	8b 04 85 00 00 40 ef 	mov    0xef400000(,%eax,4),%eax
	if (!(pte & PTE_P))
		return 0;
  803207:	ba 00 00 00 00       	mov    $0x0,%edx
  80320c:	a8 01                	test   $0x1,%al
  80320e:	74 13                	je     803223 <pageref+0x43>
	return pages[PPN(pte)].pp_ref;
  803210:	c1 e8 0c             	shr    $0xc,%eax
  803213:	8d 04 40             	lea    (%eax,%eax,2),%eax
  803216:	c1 e0 02             	shl    $0x2,%eax
  803219:	66 8b 80 08 00 00 ef 	mov    0xef000008(%eax),%ax
  803220:	0f b7 d0             	movzwl %ax,%edx
}
  803223:	89 d0                	mov    %edx,%eax
  803225:	c9                   	leave  
  803226:	c3                   	ret    
	...

00803228 <lwip_socket_init>:
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  803228:	55                   	push   %ebp
  803229:	89 e5                	mov    %esp,%ebp
  80322b:	83 ec 14             	sub    $0x14,%esp
  socksem   = sys_sem_new(1);
  80322e:	6a 01                	push   $0x1
  803230:	e8 34 9c 00 00       	call   80ce69 <sys_sem_new>
  803235:	a3 04 87 81 00       	mov    %eax,0x818704
  selectsem = sys_sem_new(1);
  80323a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803241:	e8 23 9c 00 00       	call   80ce69 <sys_sem_new>
  803246:	a3 08 87 81 00       	mov    %eax,0x818708
}
  80324b:	c9                   	leave  
  80324c:	c3                   	ret    

0080324d <get_socket>:

/**
 * Map a externally used socket index to the internal socket representation.
 *
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  80324d:	55                   	push   %ebp
  80324e:	89 e5                	mov    %esp,%ebp
  803250:	8b 45 08             	mov    0x8(%ebp),%eax
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  803253:	83 f8 1f             	cmp    $0x1f,%eax
  803256:	76 11                	jbe    803269 <get_socket+0x1c>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  803258:	c7 05 00 e6 b3 00 09 	movl   $0x9,0xb3e600
  80325f:	00 00 00 
    return NULL;
  803262:	ba 00 00 00 00       	mov    $0x0,%edx
  803267:	eb 24                	jmp    80328d <get_socket+0x40>
  }

  sock = &sockets[s];
  803269:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80326c:	c1 e0 02             	shl    $0x2,%eax
  80326f:	8d 90 80 84 81 00    	lea    0x818480(%eax),%edx

  if (!sock->conn) {
  803275:	83 b8 80 84 81 00 00 	cmpl   $0x0,0x818480(%eax)
  80327c:	75 0f                	jne    80328d <get_socket+0x40>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  80327e:	c7 05 00 e6 b3 00 09 	movl   $0x9,0xb3e600
  803285:	00 00 00 
    return NULL;
  803288:	ba 00 00 00 00       	mov    $0x0,%edx
  }

  return sock;
}
  80328d:	89 d0                	mov    %edx,%eax
  80328f:	c9                   	leave  
  803290:	c3                   	ret    

00803291 <alloc_socket>:

/**
 * Allocate a new socket for a given netconn.
 *
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  803291:	55                   	push   %ebp
  803292:	89 e5                	mov    %esp,%ebp
  803294:	53                   	push   %ebx
  803295:	83 ec 10             	sub    $0x10,%esp
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  803298:	ff 35 04 87 81 00    	pushl  0x818704
  80329e:	e8 a6 4b 00 00       	call   807e49 <sys_sem_wait>

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  8032a3:	bb 00 00 00 00       	mov    $0x0,%ebx
  8032a8:	83 c4 10             	add    $0x10,%esp
    if (!sockets[i].conn) {
  8032ab:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  8032ae:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  8032b5:	83 ba 80 84 81 00 00 	cmpl   $0x0,0x818480(%edx)
  8032bc:	75 53                	jne    803311 <alloc_socket+0x80>
      sockets[i].conn       = newconn;
  8032be:	8b 45 08             	mov    0x8(%ebp),%eax
  8032c1:	89 82 80 84 81 00    	mov    %eax,0x818480(%edx)
      sockets[i].lastdata   = NULL;
  8032c7:	c7 82 84 84 81 00 00 	movl   $0x0,0x818484(%edx)
  8032ce:	00 00 00 
      sockets[i].lastoffset = 0;
  8032d1:	66 c7 82 88 84 81 00 	movw   $0x0,0x818488(%edx)
  8032d8:	00 00 
      sockets[i].rcvevent   = 0;
  8032da:	66 c7 82 8a 84 81 00 	movw   $0x0,0x81848a(%edx)
  8032e1:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  8032e3:	66 c7 82 8c 84 81 00 	movw   $0x1,0x81848c(%edx)
  8032ea:	01 00 
      sockets[i].flags      = 0;
  8032ec:	66 c7 82 8e 84 81 00 	movw   $0x0,0x81848e(%edx)
  8032f3:	00 00 
      sockets[i].err        = 0;
  8032f5:	c7 82 90 84 81 00 00 	movl   $0x0,0x818490(%edx)
  8032fc:	00 00 00 
      sys_sem_signal(socksem);
  8032ff:	83 ec 0c             	sub    $0xc,%esp
  803302:	ff 35 04 87 81 00    	pushl  0x818704
  803308:	e8 6d 9c 00 00       	call   80cf7a <sys_sem_signal>
      return i;
  80330d:	89 d8                	mov    %ebx,%eax
  80330f:	eb 19                	jmp    80332a <alloc_socket+0x99>
  803311:	43                   	inc    %ebx
  803312:	83 fb 1f             	cmp    $0x1f,%ebx
  803315:	7e 94                	jle    8032ab <alloc_socket+0x1a>
    }
  }
  sys_sem_signal(socksem);
  803317:	83 ec 0c             	sub    $0xc,%esp
  80331a:	ff 35 04 87 81 00    	pushl  0x818704
  803320:	e8 55 9c 00 00       	call   80cf7a <sys_sem_signal>
  return -1;
  803325:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80332a:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80332d:	c9                   	leave  
  80332e:	c3                   	ret    

0080332f <lwip_accept>:

/* Below this, the well-known socket functions are implemented.
 * Use google.com or opengroup.org to get a good description :-)
 *
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80332f:	55                   	push   %ebp
  803330:	89 e5                	mov    %esp,%ebp
  803332:	57                   	push   %edi
  803333:	56                   	push   %esi
  803334:	53                   	push   %ebx
  803335:	83 ec 2c             	sub    $0x2c,%esp
  803338:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock, *nsock;
  struct netconn *newconn;
  struct ip_addr naddr;
  u16_t port;
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  80333b:	ff 75 08             	pushl  0x8(%ebp)
  80333e:	e8 0a ff ff ff       	call   80324d <get_socket>
  803343:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  if (!sock)
  803346:	83 c4 04             	add    $0x4,%esp
    return -1;
  803349:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80334e:	83 7d cc 00          	cmpl   $0x0,0xffffffcc(%ebp)
  803352:	0f 84 c3 01 00 00    	je     80351b <lwip_accept+0x1ec>

  newconn = netconn_accept(sock->conn);
  803358:	83 ec 0c             	sub    $0xc,%esp
  80335b:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  80335e:	ff 30                	pushl  (%eax)
  803360:	e8 4b ab 00 00       	call   80deb0 <netconn_accept>
  803365:	89 c7                	mov    %eax,%edi
  if (!newconn) {
  803367:	83 c4 10             	add    $0x10,%esp
  80336a:	85 c0                	test   %eax,%eax
  80336c:	75 3c                	jne    8033aa <lwip_accept+0x7b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  80336e:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
  803371:	8b 02                	mov    (%edx),%eax
  803373:	0f be 48 0c          	movsbl 0xc(%eax),%ecx
  803377:	89 c8                	mov    %ecx,%eax
  803379:	f7 d8                	neg    %eax
  80337b:	ba 05 00 00 00       	mov    $0x5,%edx
  803380:	83 f8 0e             	cmp    $0xe,%eax
  803383:	77 0f                	ja     803394 <lwip_accept+0x65>
  803385:	8d 04 8d 00 00 00 00 	lea    0x0(,%ecx,4),%eax
  80338c:	f7 d8                	neg    %eax
  80338e:	8b 90 a0 23 81 00    	mov    0x8123a0(%eax),%edx
  803394:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  803397:	89 50 10             	mov    %edx,0x10(%eax)
  80339a:	89 15 00 e6 b3 00    	mov    %edx,0xb3e600
    return -1;
  8033a0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8033a5:	e9 71 01 00 00       	jmp    80351b <lwip_accept+0x1ec>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  8033aa:	6a 00                	push   $0x0
  8033ac:	8d 45 d6             	lea    0xffffffd6(%ebp),%eax
  8033af:	50                   	push   %eax
  8033b0:	8d 45 d0             	lea    0xffffffd0(%ebp),%eax
  8033b3:	50                   	push   %eax
  8033b4:	57                   	push   %edi
  8033b5:	e8 40 a9 00 00       	call   80dcfa <netconn_getaddr>
  8033ba:	88 c3                	mov    %al,%bl
  if (err != ERR_OK) {
  8033bc:	83 c4 10             	add    $0x10,%esp
  8033bf:	84 c0                	test   %al,%al
  8033c1:	74 42                	je     803405 <lwip_accept+0xd6>
    netconn_delete(newconn);
  8033c3:	83 ec 0c             	sub    $0xc,%esp
  8033c6:	57                   	push   %edi
  8033c7:	e8 c4 a8 00 00       	call   80dc90 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  8033cc:	83 c4 10             	add    $0x10,%esp
  8033cf:	0f be cb             	movsbl %bl,%ecx
  8033d2:	89 c8                	mov    %ecx,%eax
  8033d4:	f7 d8                	neg    %eax
  8033d6:	ba 05 00 00 00       	mov    $0x5,%edx
  8033db:	83 f8 0e             	cmp    $0xe,%eax
  8033de:	77 0f                	ja     8033ef <lwip_accept+0xc0>
  8033e0:	8d 04 8d 00 00 00 00 	lea    0x0(,%ecx,4),%eax
  8033e7:	f7 d8                	neg    %eax
  8033e9:	8b 90 a0 23 81 00    	mov    0x8123a0(%eax),%edx
  8033ef:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  8033f2:	89 50 10             	mov    %edx,0x10(%eax)
  8033f5:	89 15 00 e6 b3 00    	mov    %edx,0xb3e600
    return -1;
  8033fb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803400:	e9 16 01 00 00       	jmp    80351b <lwip_accept+0x1ec>
  }

  memset(&sin, 0, sizeof(sin));
  803405:	83 ec 04             	sub    $0x4,%esp
  803408:	6a 10                	push   $0x10
  80340a:	6a 00                	push   $0x0
  80340c:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  80340f:	50                   	push   %eax
  803410:	e8 d4 de ff ff       	call   8012e9 <memset>
  sin.sin_len = sizeof(sin);
  803415:	c6 45 d8 10          	movb   $0x10,0xffffffd8(%ebp)
  sin.sin_family = AF_INET;
  803419:	c6 45 d9 02          	movb   $0x2,0xffffffd9(%ebp)
  sin.sin_port = htons(port);
  80341d:	0f b7 45 d6          	movzwl 0xffffffd6(%ebp),%eax
  803421:	89 04 24             	mov    %eax,(%esp)
  803424:	e8 36 72 00 00       	call   80a65f <htons>
  803429:	66 89 45 da          	mov    %ax,0xffffffda(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  80342d:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  803430:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)

  if (*addrlen > sizeof(sin))
  803433:	83 c4 10             	add    $0x10,%esp
  803436:	83 3e 10             	cmpl   $0x10,(%esi)
  803439:	76 06                	jbe    803441 <lwip_accept+0x112>
    *addrlen = sizeof(sin);
  80343b:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(addr, &sin, *addrlen);
  803441:	83 ec 04             	sub    $0x4,%esp
  803444:	ff 36                	pushl  (%esi)
  803446:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  803449:	50                   	push   %eax
  80344a:	ff 75 0c             	pushl  0xc(%ebp)
  80344d:	e8 55 df ff ff       	call   8013a7 <memcpy>

  newsock = alloc_socket(newconn);
  803452:	89 3c 24             	mov    %edi,(%esp)
  803455:	e8 37 fe ff ff       	call   803291 <alloc_socket>
  80345a:	89 c6                	mov    %eax,%esi
  if (newsock == -1) {
  80345c:	83 c4 10             	add    $0x10,%esp
  80345f:	83 f8 ff             	cmp    $0xffffffff,%eax
  803462:	75 2a                	jne    80348e <lwip_accept+0x15f>
    netconn_delete(newconn);
  803464:	83 ec 0c             	sub    $0xc,%esp
  803467:	57                   	push   %edi
  803468:	e8 23 a8 00 00       	call   80dc90 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  80346d:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
  803470:	c7 42 10 17 00 00 00 	movl   $0x17,0x10(%edx)
  803477:	c7 05 00 e6 b3 00 17 	movl   $0x17,0xb3e600
  80347e:	00 00 00 
  803481:	83 c4 10             	add    $0x10,%esp
    return -1;
  803484:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803489:	e9 8d 00 00 00       	jmp    80351b <lwip_accept+0x1ec>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  80348e:	83 f8 1f             	cmp    $0x1f,%eax
  803491:	76 17                	jbe    8034aa <lwip_accept+0x17b>
  803493:	83 ec 04             	sub    $0x4,%esp
  803496:	68 dc 23 81 00       	push   $0x8123dc
  80349b:	68 25 01 00 00       	push   $0x125
  8034a0:	68 f1 23 81 00       	push   $0x8123f1
  8034a5:	e8 22 d6 ff ff       	call   800acc <_panic>
  newconn->callback = event_callback;
  8034aa:	c7 47 2c 9c 41 80 00 	movl   $0x80419c,0x2c(%edi)
  nsock = &sockets[newsock];
  8034b1:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8034b4:	8d 1c 85 80 84 81 00 	lea    0x818480(,%eax,4),%ebx
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);
  8034bb:	85 db                	test   %ebx,%ebx
  8034bd:	75 17                	jne    8034d6 <lwip_accept+0x1a7>
  8034bf:	83 ec 04             	sub    $0x4,%esp
  8034c2:	68 08 24 81 00       	push   $0x812408
  8034c7:	68 28 01 00 00       	push   $0x128
  8034cc:	68 f1 23 81 00       	push   $0x8123f1
  8034d1:	e8 f6 d5 ff ff       	call   800acc <_panic>

  sys_sem_wait(socksem);
  8034d6:	83 ec 0c             	sub    $0xc,%esp
  8034d9:	ff 35 04 87 81 00    	pushl  0x818704
  8034df:	e8 65 49 00 00       	call   807e49 <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  8034e4:	66 8b 43 0a          	mov    0xa(%ebx),%ax
  8034e8:	66 2b 47 1c          	sub    0x1c(%edi),%ax
  8034ec:	48                   	dec    %eax
  8034ed:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  newconn->socket = newsock;
  8034f1:	89 77 1c             	mov    %esi,0x1c(%edi)
  sys_sem_signal(socksem);
  8034f4:	83 c4 04             	add    $0x4,%esp
  8034f7:	ff 35 04 87 81 00    	pushl  0x818704
  8034fd:	e8 78 9a 00 00       	call   80cf7a <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  803502:	83 c4 10             	add    $0x10,%esp
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  803505:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  803508:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  80350f:	c7 05 00 e6 b3 00 00 	movl   $0x0,0xb3e600
  803516:	00 00 00 
  return newsock;
  803519:	89 f0                	mov    %esi,%eax
}
  80351b:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80351e:	5b                   	pop    %ebx
  80351f:	5e                   	pop    %esi
  803520:	5f                   	pop    %edi
  803521:	c9                   	leave  
  803522:	c3                   	ret    

00803523 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  803523:	55                   	push   %ebp
  803524:	89 e5                	mov    %esp,%ebp
  803526:	56                   	push   %esi
  803527:	53                   	push   %ebx
  803528:	83 ec 10             	sub    $0x10,%esp
  80352b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  80352e:	ff 75 08             	pushl  0x8(%ebp)
  803531:	e8 17 fd ff ff       	call   80324d <get_socket>
  803536:	89 c6                	mov    %eax,%esi
  if (!sock)
  803538:	83 c4 04             	add    $0x4,%esp
    return -1;
  80353b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803540:	85 f6                	test   %esi,%esi
  803542:	0f 84 95 00 00 00    	je     8035dd <lwip_bind+0xba>

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  803548:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  80354c:	75 06                	jne    803554 <lwip_bind+0x31>
  80354e:	80 7b 01 02          	cmpb   $0x2,0x1(%ebx)
  803552:	74 17                	je     80356b <lwip_bind+0x48>
  803554:	83 ec 04             	sub    $0x4,%esp
  803557:	68 1f 24 81 00       	push   $0x81241f
  80355c:	68 4a 01 00 00       	push   $0x14a
  803561:	68 f1 23 81 00       	push   $0x8123f1
  803566:	e8 61 d5 ff ff       	call   800acc <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  80356b:	8b 43 04             	mov    0x4(%ebx),%eax
  80356e:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  local_port = ((struct sockaddr_in *)name)->sin_port;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  803571:	83 ec 0c             	sub    $0xc,%esp
  803574:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  803578:	50                   	push   %eax
  803579:	e8 f7 70 00 00       	call   80a675 <ntohs>
  80357e:	83 c4 0c             	add    $0xc,%esp
  803581:	0f b7 c0             	movzwl %ax,%eax
  803584:	50                   	push   %eax
  803585:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  803588:	50                   	push   %eax
  803589:	ff 36                	pushl  (%esi)
  80358b:	e8 f6 a7 00 00       	call   80dd86 <netconn_bind>

  if (err != ERR_OK) {
  803590:	83 c4 10             	add    $0x10,%esp
  803593:	84 c0                	test   %al,%al
  803595:	74 30                	je     8035c7 <lwip_bind+0xa4>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  803597:	0f be c8             	movsbl %al,%ecx
  80359a:	89 c8                	mov    %ecx,%eax
  80359c:	f7 d8                	neg    %eax
  80359e:	ba 05 00 00 00       	mov    $0x5,%edx
  8035a3:	83 f8 0e             	cmp    $0xe,%eax
  8035a6:	77 0f                	ja     8035b7 <lwip_bind+0x94>
  8035a8:	8d 04 8d 00 00 00 00 	lea    0x0(,%ecx,4),%eax
  8035af:	f7 d8                	neg    %eax
  8035b1:	8b 90 a0 23 81 00    	mov    0x8123a0(%eax),%edx
  8035b7:	89 56 10             	mov    %edx,0x10(%esi)
  8035ba:	89 15 00 e6 b3 00    	mov    %edx,0xb3e600
    return -1;
  8035c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8035c5:	eb 16                	jmp    8035dd <lwip_bind+0xba>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8035c7:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8035ce:	c7 05 00 e6 b3 00 00 	movl   $0x0,0xb3e600
  8035d5:	00 00 00 
  return 0;
  8035d8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8035dd:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  8035e0:	5b                   	pop    %ebx
  8035e1:	5e                   	pop    %esi
  8035e2:	c9                   	leave  
  8035e3:	c3                   	ret    

008035e4 <lwip_close>:

int
lwip_close(int s)
{
  8035e4:	55                   	push   %ebp
  8035e5:	89 e5                	mov    %esp,%ebp
  8035e7:	53                   	push   %ebx
  8035e8:	83 ec 04             	sub    $0x4,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  8035eb:	ff 75 08             	pushl  0x8(%ebp)
  8035ee:	e8 5a fc ff ff       	call   80324d <get_socket>
  8035f3:	89 c3                	mov    %eax,%ebx
  if (!sock) {
  8035f5:	83 c4 04             	add    $0x4,%esp
    return -1;
  8035f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8035fd:	85 db                	test   %ebx,%ebx
  8035ff:	74 66                	je     803667 <lwip_close+0x83>
  }

  netconn_delete(sock->conn);
  803601:	83 ec 0c             	sub    $0xc,%esp
  803604:	ff 33                	pushl  (%ebx)
  803606:	e8 85 a6 00 00       	call   80dc90 <netconn_delete>

  sys_sem_wait(socksem);
  80360b:	83 c4 04             	add    $0x4,%esp
  80360e:	ff 35 04 87 81 00    	pushl  0x818704
  803614:	e8 30 48 00 00       	call   807e49 <sys_sem_wait>
  if (sock->lastdata) {
  803619:	83 c4 10             	add    $0x10,%esp
  80361c:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  803620:	74 0e                	je     803630 <lwip_close+0x4c>
    netbuf_delete(sock->lastdata);
  803622:	83 ec 0c             	sub    $0xc,%esp
  803625:	ff 73 04             	pushl  0x4(%ebx)
  803628:	e8 b6 19 00 00       	call   804fe3 <netbuf_delete>
  80362d:	83 c4 10             	add    $0x10,%esp
  }
  sock->lastdata   = NULL;
  803630:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  803637:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  80363d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  803643:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80364a:	c7 05 00 e6 b3 00 00 	movl   $0x0,0xb3e600
  803651:	00 00 00 
  sys_sem_signal(socksem);
  803654:	83 ec 0c             	sub    $0xc,%esp
  803657:	ff 35 04 87 81 00    	pushl  0x818704
  80365d:	e8 18 99 00 00       	call   80cf7a <sys_sem_signal>
  return 0;
  803662:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803667:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80366a:	c9                   	leave  
  80366b:	c3                   	ret    

0080366c <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80366c:	55                   	push   %ebp
  80366d:	89 e5                	mov    %esp,%ebp
  80366f:	56                   	push   %esi
  803670:	53                   	push   %ebx
  803671:	83 ec 10             	sub    $0x10,%esp
  803674:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  803677:	ff 75 08             	pushl  0x8(%ebp)
  80367a:	e8 ce fb ff ff       	call   80324d <get_socket>
  80367f:	89 c6                	mov    %eax,%esi
  if (!sock)
  803681:	83 c4 04             	add    $0x4,%esp
    return -1;
  803684:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803689:	85 f6                	test   %esi,%esi
  80368b:	0f 84 aa 00 00 00    	je     80373b <lwip_connect+0xcf>

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  803691:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  803695:	75 06                	jne    80369d <lwip_connect+0x31>
  803697:	80 7b 01 02          	cmpb   $0x2,0x1(%ebx)
  80369b:	74 17                	je     8036b4 <lwip_connect+0x48>
  80369d:	83 ec 04             	sub    $0x4,%esp
  8036a0:	68 3a 24 81 00       	push   $0x81243a
  8036a5:	68 86 01 00 00       	push   $0x186
  8036aa:	68 f1 23 81 00       	push   $0x8123f1
  8036af:	e8 18 d4 ff ff       	call   800acc <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  if (((struct sockaddr_in *)name)->sin_family == AF_UNSPEC) {
  8036b4:	80 7b 01 00          	cmpb   $0x0,0x1(%ebx)
  8036b8:	75 0f                	jne    8036c9 <lwip_connect+0x5d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
  8036ba:	83 ec 0c             	sub    $0xc,%esp
  8036bd:	ff 36                	pushl  (%esi)
  8036bf:	e8 64 a7 00 00       	call   80de28 <netconn_disconnect>
  8036c4:	83 c4 10             	add    $0x10,%esp
  8036c7:	eb 28                	jmp    8036f1 <lwip_connect+0x85>
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8036c9:	8b 43 04             	mov    0x4(%ebx),%eax
  8036cc:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    remote_port = ((struct sockaddr_in *)name)->sin_port;

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  8036cf:	83 ec 0c             	sub    $0xc,%esp
  8036d2:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  8036d6:	50                   	push   %eax
  8036d7:	e8 99 6f 00 00       	call   80a675 <ntohs>
  8036dc:	83 c4 0c             	add    $0xc,%esp
  8036df:	0f b7 c0             	movzwl %ax,%eax
  8036e2:	50                   	push   %eax
  8036e3:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  8036e6:	50                   	push   %eax
  8036e7:	ff 36                	pushl  (%esi)
  8036e9:	e8 e9 a6 00 00       	call   80ddd7 <netconn_connect>
  8036ee:	83 c4 10             	add    $0x10,%esp
  }

  if (err != ERR_OK) {
  8036f1:	84 c0                	test   %al,%al
  8036f3:	74 30                	je     803725 <lwip_connect+0xb9>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8036f5:	0f be c8             	movsbl %al,%ecx
  8036f8:	89 c8                	mov    %ecx,%eax
  8036fa:	f7 d8                	neg    %eax
  8036fc:	ba 05 00 00 00       	mov    $0x5,%edx
  803701:	83 f8 0e             	cmp    $0xe,%eax
  803704:	77 0f                	ja     803715 <lwip_connect+0xa9>
  803706:	8d 04 8d 00 00 00 00 	lea    0x0(,%ecx,4),%eax
  80370d:	f7 d8                	neg    %eax
  80370f:	8b 90 a0 23 81 00    	mov    0x8123a0(%eax),%edx
  803715:	89 56 10             	mov    %edx,0x10(%esi)
  803718:	89 15 00 e6 b3 00    	mov    %edx,0xb3e600
    return -1;
  80371e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803723:	eb 16                	jmp    80373b <lwip_connect+0xcf>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  803725:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  80372c:	c7 05 00 e6 b3 00 00 	movl   $0x0,0xb3e600
  803733:	00 00 00 
  return 0;
  803736:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80373b:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80373e:	5b                   	pop    %ebx
  80373f:	5e                   	pop    %esi
  803740:	c9                   	leave  
  803741:	c3                   	ret    

00803742 <lwip_listen>:

/**
 * Set a socket into listen mode.
 * The socket may not have been used for another connection previously.
 *
 * @param s the socket to set to listening mode
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  803742:	55                   	push   %ebp
  803743:	89 e5                	mov    %esp,%ebp
  803745:	56                   	push   %esi
  803746:	53                   	push   %ebx
  803747:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  80374a:	ff 75 08             	pushl  0x8(%ebp)
  80374d:	e8 fb fa ff ff       	call   80324d <get_socket>
  803752:	89 c6                	mov    %eax,%esi
  if (!sock)
  803754:	83 c4 04             	add    $0x4,%esp
    return -1;
  803757:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80375c:	85 f6                	test   %esi,%esi
  80375e:	74 71                	je     8037d1 <lwip_listen+0x8f>

  /* limit the "backlog" parameter to fit in an u8_t */
  if (backlog < 0) {
  803760:	85 db                	test   %ebx,%ebx
  803762:	79 05                	jns    803769 <lwip_listen+0x27>
    backlog = 0;
  803764:	bb 00 00 00 00       	mov    $0x0,%ebx
  }
  if (backlog > 0xff) {
  803769:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  80376f:	7e 05                	jle    803776 <lwip_listen+0x34>
    backlog = 0xff;
  803771:	bb ff 00 00 00       	mov    $0xff,%ebx
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  803776:	83 ec 08             	sub    $0x8,%esp
  803779:	0f b6 c3             	movzbl %bl,%eax
  80377c:	50                   	push   %eax
  80377d:	ff 36                	pushl  (%esi)
  80377f:	e8 e8 a6 00 00       	call   80de6c <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  803784:	83 c4 10             	add    $0x10,%esp
  803787:	84 c0                	test   %al,%al
  803789:	74 30                	je     8037bb <lwip_listen+0x79>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  80378b:	0f be c8             	movsbl %al,%ecx
  80378e:	89 c8                	mov    %ecx,%eax
  803790:	f7 d8                	neg    %eax
  803792:	ba 05 00 00 00       	mov    $0x5,%edx
  803797:	83 f8 0e             	cmp    $0xe,%eax
  80379a:	77 0f                	ja     8037ab <lwip_listen+0x69>
  80379c:	8d 04 8d 00 00 00 00 	lea    0x0(,%ecx,4),%eax
  8037a3:	f7 d8                	neg    %eax
  8037a5:	8b 90 a0 23 81 00    	mov    0x8123a0(%eax),%edx
  8037ab:	89 56 10             	mov    %edx,0x10(%esi)
  8037ae:	89 15 00 e6 b3 00    	mov    %edx,0xb3e600
    return -1;
  8037b4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8037b9:	eb 16                	jmp    8037d1 <lwip_listen+0x8f>
  }

  sock_set_errno(sock, 0);
  8037bb:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8037c2:	c7 05 00 e6 b3 00 00 	movl   $0x0,0xb3e600
  8037c9:	00 00 00 
  return 0;
  8037cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8037d1:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  8037d4:	5b                   	pop    %ebx
  8037d5:	5e                   	pop    %esi
  8037d6:	c9                   	leave  
  8037d7:	c3                   	ret    

008037d8 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  8037d8:	55                   	push   %ebp
  8037d9:	89 e5                	mov    %esp,%ebp
  8037db:	57                   	push   %edi
  8037dc:	56                   	push   %esi
  8037dd:	53                   	push   %ebx
  8037de:	83 ec 2c             	sub    $0x2c,%esp
  struct lwip_socket *sock;
  struct netbuf      *buf;
  u16_t               buflen, copylen, off = 0;
  8037e1:	66 c7 45 d2 00 00    	movw   $0x0,0xffffffd2(%ebp)
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;
  8037e7:	c6 45 d1 00          	movb   $0x0,0xffffffd1(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  8037eb:	ff 75 08             	pushl  0x8(%ebp)
  8037ee:	e8 5a fa ff ff       	call   80324d <get_socket>
  8037f3:	89 c6                	mov    %eax,%esi
  if (!sock)
  8037f5:	83 c4 04             	add    $0x4,%esp
    return -1;
  8037f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8037fd:	85 f6                	test   %esi,%esi
  8037ff:	0f 84 12 02 00 00    	je     803a17 <lwip_recvfrom+0x23f>

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  803805:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
  803809:	74 08                	je     803813 <lwip_recvfrom+0x3b>
      buf = sock->lastdata;
  80380b:	8b 7e 04             	mov    0x4(%esi),%edi
  80380e:	e9 8d 00 00 00       	jmp    8038a0 <lwip_recvfrom+0xc8>
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  803813:	f6 45 14 08          	testb  $0x8,0x14(%ebp)
  803817:	75 06                	jne    80381f <lwip_recvfrom+0x47>
  803819:	f6 46 0f 08          	testb  $0x8,0xf(%esi)
  80381d:	74 22                	je     803841 <lwip_recvfrom+0x69>
  80381f:	66 83 7e 0a 00       	cmpw   $0x0,0xa(%esi)
  803824:	75 1b                	jne    803841 <lwip_recvfrom+0x69>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  803826:	c7 46 10 0b 00 00 00 	movl   $0xb,0x10(%esi)
  80382d:	c7 05 00 e6 b3 00 0b 	movl   $0xb,0xb3e600
  803834:	00 00 00 
        return -1;
  803837:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80383c:	e9 d6 01 00 00       	jmp    803a17 <lwip_recvfrom+0x23f>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  803841:	83 ec 0c             	sub    $0xc,%esp
  803844:	ff 36                	pushl  (%esi)
  803846:	e8 d7 a6 00 00       	call   80df22 <netconn_recv>
  80384b:	89 c7                	mov    %eax,%edi
  80384d:	89 46 04             	mov    %eax,0x4(%esi)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));
  803850:	83 c4 10             	add    $0x10,%esp

      if (!buf) {
  803853:	85 c0                	test   %eax,%eax
  803855:	75 49                	jne    8038a0 <lwip_recvfrom+0xc8>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  803857:	8b 06                	mov    (%esi),%eax
  803859:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80385d:	74 0b                	je     80386a <lwip_recvfrom+0x92>
  80385f:	ba 6e 00 00 00       	mov    $0x6e,%edx
  803864:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  803868:	74 23                	je     80388d <lwip_recvfrom+0xb5>
  80386a:	8b 06                	mov    (%esi),%eax
  80386c:	0f be 48 0c          	movsbl 0xc(%eax),%ecx
  803870:	89 c8                	mov    %ecx,%eax
  803872:	f7 d8                	neg    %eax
  803874:	ba 05 00 00 00       	mov    $0x5,%edx
  803879:	83 f8 0e             	cmp    $0xe,%eax
  80387c:	77 0f                	ja     80388d <lwip_recvfrom+0xb5>
  80387e:	8d 04 8d 00 00 00 00 	lea    0x0(,%ecx,4),%eax
  803885:	f7 d8                	neg    %eax
  803887:	8b 90 a0 23 81 00    	mov    0x8123a0(%eax),%edx
  80388d:	89 56 10             	mov    %edx,0x10(%esi)
  803890:	89 15 00 e6 b3 00    	mov    %edx,0xb3e600
        return 0;
  803896:	b8 00 00 00 00       	mov    $0x0,%eax
  80389b:	e9 77 01 00 00       	jmp    803a17 <lwip_recvfrom+0x23f>
      }
    }

    buflen = netbuf_len(buf);
  8038a0:	8b 07                	mov    (%edi),%eax
  8038a2:	66 8b 58 08          	mov    0x8(%eax),%bx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  8038a6:	66 2b 5e 08          	sub    0x8(%esi),%bx

    if (len > buflen) {
  8038aa:	0f b7 c3             	movzwl %bx,%eax
      copylen = buflen;
  8038ad:	66 89 5d d4          	mov    %bx,0xffffffd4(%ebp)
  8038b1:	3b 45 10             	cmp    0x10(%ebp),%eax
  8038b4:	7c 07                	jl     8038bd <lwip_recvfrom+0xe5>
    } else {
      copylen = len;
  8038b6:	8b 45 10             	mov    0x10(%ebp),%eax
  8038b9:	66 89 45 d4          	mov    %ax,0xffffffd4(%ebp)
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  8038bd:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8038c1:	50                   	push   %eax
  8038c2:	0f b7 45 d4          	movzwl 0xffffffd4(%ebp),%eax
  8038c6:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  8038c9:	50                   	push   %eax
  8038ca:	0f b7 45 d2          	movzwl 0xffffffd2(%ebp),%eax
  8038ce:	03 45 0c             	add    0xc(%ebp),%eax
  8038d1:	50                   	push   %eax
  8038d2:	ff 37                	pushl  (%edi)
  8038d4:	e8 fe 43 00 00       	call   807cd7 <pbuf_copy_partial>

    off += copylen;
  8038d9:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  8038dc:	66 01 45 d2          	add    %ax,0xffffffd2(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8038e0:	83 c4 04             	add    $0x4,%esp
  8038e3:	ff 36                	pushl  (%esi)
  8038e5:	e8 e8 a3 00 00       	call   80dcd2 <netconn_type>
  8038ea:	83 c4 10             	add    $0x10,%esp
  8038ed:	83 f8 10             	cmp    $0x10,%eax
  8038f0:	75 21                	jne    803913 <lwip_recvfrom+0x13b>
      len -= copylen;
  8038f2:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  8038f5:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8038f8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8038fc:	7e 0f                	jle    80390d <lwip_recvfrom+0x135>
  8038fe:	8b 07                	mov    (%edi),%eax
  803900:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  803904:	75 07                	jne    80390d <lwip_recvfrom+0x135>
  803906:	66 83 7e 0a 00       	cmpw   $0x0,0xa(%esi)
  80390b:	75 0a                	jne    803917 <lwip_recvfrom+0x13f>
        done = 1;
  80390d:	c6 45 d1 01          	movb   $0x1,0xffffffd1(%ebp)
  803911:	eb 04                	jmp    803917 <lwip_recvfrom+0x13f>
      }
    } else {
      done = 1;
  803913:	c6 45 d1 01          	movb   $0x1,0xffffffd1(%ebp)
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  803917:	f6 45 14 01          	testb  $0x1,0x14(%ebp)
  80391b:	75 3b                	jne    803958 <lwip_recvfrom+0x180>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  80391d:	8b 06                	mov    (%esi),%eax
  80391f:	83 38 10             	cmpl   $0x10,(%eax)
  803922:	75 19                	jne    80393d <lwip_recvfrom+0x165>
  803924:	0f b7 c3             	movzwl %bx,%eax
  803927:	0f b7 55 d4          	movzwl 0xffffffd4(%ebp),%edx
  80392b:	29 d0                	sub    %edx,%eax
  80392d:	85 c0                	test   %eax,%eax
  80392f:	7e 0c                	jle    80393d <lwip_recvfrom+0x165>
        sock->lastdata = buf;
  803931:	89 7e 04             	mov    %edi,0x4(%esi)
        sock->lastoffset += copylen;
  803934:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  803937:	66 01 46 08          	add    %ax,0x8(%esi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  80393b:	eb 1f                	jmp    80395c <lwip_recvfrom+0x184>
      } else {
        sock->lastdata = NULL;
  80393d:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
        sock->lastoffset = 0;
  803944:	66 c7 46 08 00 00    	movw   $0x0,0x8(%esi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  80394a:	83 ec 0c             	sub    $0xc,%esp
  80394d:	57                   	push   %edi
  80394e:	e8 90 16 00 00       	call   804fe3 <netbuf_delete>
  803953:	83 c4 10             	add    $0x10,%esp
  803956:	eb 04                	jmp    80395c <lwip_recvfrom+0x184>
      }
    } else {
      done = 1;
  803958:	c6 45 d1 01          	movb   $0x1,0xffffffd1(%ebp)
    }
  } while (!done);
  80395c:	80 7d d1 00          	cmpb   $0x0,0xffffffd1(%ebp)
  803960:	0f 84 9f fe ff ff    	je     803805 <lwip_recvfrom+0x2d>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  803966:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  80396a:	0f 84 92 00 00 00    	je     803a02 <lwip_recvfrom+0x22a>
  803970:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  803974:	0f 84 88 00 00 00    	je     803a02 <lwip_recvfrom+0x22a>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80397a:	83 ec 0c             	sub    $0xc,%esp
  80397d:	ff 36                	pushl  (%esi)
  80397f:	e8 4e a3 00 00       	call   80dcd2 <netconn_type>
  803984:	83 c4 10             	add    $0x10,%esp
  803987:	83 f8 10             	cmp    $0x10,%eax
  80398a:	75 16                	jne    8039a2 <lwip_recvfrom+0x1ca>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  80398c:	8d 5d dc             	lea    0xffffffdc(%ebp),%ebx
      netconn_getaddr(sock->conn, addr, &port, 0);
  80398f:	6a 00                	push   $0x0
  803991:	8d 45 d6             	lea    0xffffffd6(%ebp),%eax
  803994:	50                   	push   %eax
  803995:	53                   	push   %ebx
  803996:	ff 36                	pushl  (%esi)
  803998:	e8 5d a3 00 00       	call   80dcfa <netconn_getaddr>
  80399d:	83 c4 10             	add    $0x10,%esp
  8039a0:	eb 0b                	jmp    8039ad <lwip_recvfrom+0x1d5>
    } else {
      addr = netbuf_fromaddr(buf);
  8039a2:	8b 5f 08             	mov    0x8(%edi),%ebx
      port = netbuf_fromport(buf);
  8039a5:	66 8b 47 0c          	mov    0xc(%edi),%ax
  8039a9:	66 89 45 d6          	mov    %ax,0xffffffd6(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  8039ad:	83 ec 04             	sub    $0x4,%esp
  8039b0:	6a 10                	push   $0x10
  8039b2:	6a 00                	push   $0x0
  8039b4:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  8039b7:	50                   	push   %eax
  8039b8:	e8 2c d9 ff ff       	call   8012e9 <memset>
    sin.sin_len = sizeof(sin);
  8039bd:	c6 45 d8 10          	movb   $0x10,0xffffffd8(%ebp)
    sin.sin_family = AF_INET;
  8039c1:	c6 45 d9 02          	movb   $0x2,0xffffffd9(%ebp)
    sin.sin_port = htons(port);
  8039c5:	0f b7 45 d6          	movzwl 0xffffffd6(%ebp),%eax
  8039c9:	89 04 24             	mov    %eax,(%esp)
  8039cc:	e8 8e 6c 00 00       	call   80a65f <htons>
  8039d1:	66 89 45 da          	mov    %ax,0xffffffda(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  8039d5:	8b 03                	mov    (%ebx),%eax
  8039d7:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)

    if (*fromlen > sizeof(sin))
  8039da:	83 c4 10             	add    $0x10,%esp
  8039dd:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8039e0:	83 38 10             	cmpl   $0x10,(%eax)
  8039e3:	76 06                	jbe    8039eb <lwip_recvfrom+0x213>
      *fromlen = sizeof(sin);
  8039e5:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

    SMEMCPY(from, &sin, *fromlen);
  8039eb:	83 ec 04             	sub    $0x4,%esp
  8039ee:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8039f1:	ff 30                	pushl  (%eax)
  8039f3:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  8039f6:	50                   	push   %eax
  8039f7:	ff 75 18             	pushl  0x18(%ebp)
  8039fa:	e8 a8 d9 ff ff       	call   8013a7 <memcpy>

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): addr=", s));
  8039ff:	83 c4 10             	add    $0x10,%esp
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
  } else {
#if SOCKETS_DEBUG
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
      netconn_getaddr(sock->conn, addr, &port, 0);
    } else {
      addr = netbuf_fromaddr(buf);
      port = netbuf_fromport(buf);
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  803a02:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  803a09:	c7 05 00 e6 b3 00 00 	movl   $0x0,0xb3e600
  803a10:	00 00 00 
  return off;
  803a13:	0f b7 45 d2          	movzwl 0xffffffd2(%ebp),%eax
}
  803a17:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  803a1a:	5b                   	pop    %ebx
  803a1b:	5e                   	pop    %esi
  803a1c:	5f                   	pop    %edi
  803a1d:	c9                   	leave  
  803a1e:	c3                   	ret    

00803a1f <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  803a1f:	55                   	push   %ebp
  803a20:	89 e5                	mov    %esp,%ebp
  803a22:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  803a25:	6a 00                	push   $0x0
  803a27:	6a 00                	push   $0x0
  803a29:	6a 00                	push   $0x0
  803a2b:	ff 75 10             	pushl  0x10(%ebp)
  803a2e:	ff 75 0c             	pushl  0xc(%ebp)
  803a31:	ff 75 08             	pushl  0x8(%ebp)
  803a34:	e8 9f fd ff ff       	call   8037d8 <lwip_recvfrom>
}
  803a39:	c9                   	leave  
  803a3a:	c3                   	ret    

00803a3b <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  803a3b:	55                   	push   %ebp
  803a3c:	89 e5                	mov    %esp,%ebp
  803a3e:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  803a41:	6a 00                	push   $0x0
  803a43:	6a 00                	push   $0x0
  803a45:	ff 75 14             	pushl  0x14(%ebp)
  803a48:	ff 75 10             	pushl  0x10(%ebp)
  803a4b:	ff 75 0c             	pushl  0xc(%ebp)
  803a4e:	ff 75 08             	pushl  0x8(%ebp)
  803a51:	e8 82 fd ff ff       	call   8037d8 <lwip_recvfrom>
}
  803a56:	c9                   	leave  
  803a57:	c3                   	ret    

00803a58 <lwip_send>:

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  803a58:	55                   	push   %ebp
  803a59:	89 e5                	mov    %esp,%ebp
  803a5b:	57                   	push   %edi
  803a5c:	56                   	push   %esi
  803a5d:	53                   	push   %ebx
  803a5e:	83 ec 0c             	sub    $0xc,%esp
  803a61:	8b 7d 10             	mov    0x10(%ebp),%edi
  803a64:	8b 75 14             	mov    0x14(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  803a67:	ff 75 08             	pushl  0x8(%ebp)
  803a6a:	e8 de f7 ff ff       	call   80324d <get_socket>
  803a6f:	89 c3                	mov    %eax,%ebx
  if (!sock)
  803a71:	83 c4 04             	add    $0x4,%esp
    return -1;
  803a74:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803a79:	85 db                	test   %ebx,%ebx
  803a7b:	74 77                	je     803af4 <lwip_send+0x9c>

  if (sock->conn->type!=NETCONN_TCP) {
  803a7d:	8b 03                	mov    (%ebx),%eax
  803a7f:	83 38 10             	cmpl   $0x10,(%eax)
  803a82:	74 16                	je     803a9a <lwip_send+0x42>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  803a84:	83 ec 08             	sub    $0x8,%esp
  803a87:	6a 00                	push   $0x0
  803a89:	6a 00                	push   $0x0
  803a8b:	56                   	push   %esi
  803a8c:	57                   	push   %edi
  803a8d:	ff 75 0c             	pushl  0xc(%ebp)
  803a90:	ff 75 08             	pushl  0x8(%ebp)
  803a93:	e8 64 00 00 00       	call   803afc <lwip_sendto>
  803a98:	eb 5a                	jmp    803af4 <lwip_send+0x9c>
#else
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  803a9a:	89 f0                	mov    %esi,%eax
  803a9c:	c1 e8 04             	shr    $0x4,%eax
  803a9f:	83 e0 01             	and    $0x1,%eax
  803aa2:	83 f8 01             	cmp    $0x1,%eax
  803aa5:	19 c0                	sbb    %eax,%eax
  803aa7:	83 e0 fe             	and    $0xfffffffe,%eax
  803aaa:	83 c0 03             	add    $0x3,%eax
  803aad:	50                   	push   %eax
  803aae:	57                   	push   %edi
  803aaf:	ff 75 0c             	pushl  0xc(%ebp)
  803ab2:	ff 33                	pushl  (%ebx)
  803ab4:	e8 7c a6 00 00       	call   80e135 <netconn_write>
  803ab9:	89 c6                	mov    %eax,%esi

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  803abb:	83 c4 10             	add    $0x10,%esp
  sock_set_errno(sock, err_to_errno(err));
  803abe:	0f be c8             	movsbl %al,%ecx
  803ac1:	89 c8                	mov    %ecx,%eax
  803ac3:	f7 d8                	neg    %eax
  803ac5:	ba 05 00 00 00       	mov    $0x5,%edx
  803aca:	83 f8 0e             	cmp    $0xe,%eax
  803acd:	77 0f                	ja     803ade <lwip_send+0x86>
  803acf:	8d 04 8d 00 00 00 00 	lea    0x0(,%ecx,4),%eax
  803ad6:	f7 d8                	neg    %eax
  803ad8:	8b 90 a0 23 81 00    	mov    0x8123a0(%eax),%edx
  803ade:	89 53 10             	mov    %edx,0x10(%ebx)
  803ae1:	89 15 00 e6 b3 00    	mov    %edx,0xb3e600
  return (err==ERR_OK?size:-1);
  803ae7:	89 f8                	mov    %edi,%eax
  803ae9:	89 f2                	mov    %esi,%edx
  803aeb:	84 d2                	test   %dl,%dl
  803aed:	74 05                	je     803af4 <lwip_send+0x9c>
  803aef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  803af4:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  803af7:	5b                   	pop    %ebx
  803af8:	5e                   	pop    %esi
  803af9:	5f                   	pop    %edi
  803afa:	c9                   	leave  
  803afb:	c3                   	ret    

00803afc <lwip_sendto>:

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  803afc:	55                   	push   %ebp
  803afd:	89 e5                	mov    %esp,%ebp
  803aff:	57                   	push   %edi
  803b00:	56                   	push   %esi
  803b01:	53                   	push   %ebx
  803b02:	83 ec 2c             	sub    $0x2c,%esp
  803b05:	8b 7d 08             	mov    0x8(%ebp),%edi
  803b08:	8b 5d 18             	mov    0x18(%ebp),%ebx
  struct lwip_socket *sock;
  struct ip_addr remote_addr;
  int err;
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  803b0b:	57                   	push   %edi
  803b0c:	e8 3c f7 ff ff       	call   80324d <get_socket>
  803b11:	89 c6                	mov    %eax,%esi
  if (!sock)
  803b13:	83 c4 04             	add    $0x4,%esp
    return -1;
  803b16:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803b1b:	85 f6                	test   %esi,%esi
  803b1d:	0f 84 25 01 00 00    	je     803c48 <lwip_sendto+0x14c>

  if (sock->conn->type==NETCONN_TCP) {
  803b23:	8b 06                	mov    (%esi),%eax
  803b25:	83 38 10             	cmpl   $0x10,(%eax)
  803b28:	75 14                	jne    803b3e <lwip_sendto+0x42>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  803b2a:	ff 75 14             	pushl  0x14(%ebp)
  803b2d:	ff 75 10             	pushl  0x10(%ebp)
  803b30:	ff 75 0c             	pushl  0xc(%ebp)
  803b33:	57                   	push   %edi
  803b34:	e8 1f ff ff ff       	call   803a58 <lwip_send>
  803b39:	e9 0a 01 00 00       	jmp    803c48 <lwip_sendto+0x14c>
#else
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  803b3e:	81 7d 10 ff ff 00 00 	cmpl   $0xffff,0x10(%ebp)
  803b45:	76 17                	jbe    803b5e <lwip_sendto+0x62>
  803b47:	83 ec 04             	sub    $0x4,%esp
  803b4a:	68 90 24 81 00       	push   $0x812490
  803b4f:	68 97 02 00 00       	push   $0x297
  803b54:	68 f1 23 81 00       	push   $0x8123f1
  803b59:	e8 6e cf ff ff       	call   800acc <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  803b5e:	85 db                	test   %ebx,%ebx
  803b60:	75 06                	jne    803b68 <lwip_sendto+0x6c>
  803b62:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  803b66:	74 23                	je     803b8b <lwip_sendto+0x8f>
  803b68:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  803b6c:	75 06                	jne    803b74 <lwip_sendto+0x78>
  803b6e:	80 7b 01 02          	cmpb   $0x2,0x1(%ebx)
  803b72:	74 17                	je     803b8b <lwip_sendto+0x8f>
  803b74:	83 ec 04             	sub    $0x4,%esp
  803b77:	68 58 24 81 00       	push   $0x812458
  803b7c:	68 9b 02 00 00       	push   $0x29b
  803b81:	68 f1 23 81 00       	push   $0x8123f1
  803b86:	e8 41 cf ff ff       	call   800acc <_panic>
             ((tolen == sizeof(struct sockaddr_in)) &&
             ((((struct sockaddr_in *)to)->sin_family) == AF_INET))),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

#if LWIP_TCPIP_CORE_LOCKING
  /* Should only be consider like a sample or a simple way to experiment this option (no check of "to" field...) */
  { struct pbuf* p;
  
    p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
    if (p == NULL) {
      err = ERR_MEM;
    } else {
      p->payload = (void*)data;
      p->len = p->tot_len = size;
      
      remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
      
      LOCK_TCPIP_CORE();
      if (sock->conn->type==NETCONN_RAW) {
        err = sock->conn->err = raw_sendto(sock->conn->pcb.raw, p, &remote_addr);
      } else {
        err = sock->conn->err = udp_sendto(sock->conn->pcb.udp, p, &remote_addr, ntohs(((struct sockaddr_in *)to)->sin_port));
      }
      UNLOCK_TCPIP_CORE();
      
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  803b8b:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  803b92:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  if (to) {
  803b99:	85 db                	test   %ebx,%ebx
  803b9b:	74 22                	je     803bbf <lwip_sendto+0xc3>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  803b9d:	8b 43 04             	mov    0x4(%ebx),%eax
  803ba0:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  803ba3:	83 ec 0c             	sub    $0xc,%esp
  803ba6:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  803baa:	50                   	push   %eax
  803bab:	e8 c5 6a 00 00       	call   80a675 <ntohs>
    buf.addr         = &remote_addr;
  803bb0:	8d 55 d4             	lea    0xffffffd4(%ebp),%edx
  803bb3:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
    buf.port         = remote_port;
  803bb6:	66 89 45 e4          	mov    %ax,0xffffffe4(%ebp)
  803bba:	83 c4 10             	add    $0x10,%esp
  803bbd:	eb 14                	jmp    803bd3 <lwip_sendto+0xd7>
  } else {
    remote_addr.addr = 0;
  803bbf:	c7 45 d4 00 00 00 00 	movl   $0x0,0xffffffd4(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  803bc6:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
    buf.port         = 0;
  803bcd:	66 c7 45 e4 00 00    	movw   $0x0,0xffffffe4(%ebp)
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_sendto(%d, data=%p, size=%d, flags=0x%x to=",
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  803bd3:	83 ec 04             	sub    $0x4,%esp
  803bd6:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  803bda:	50                   	push   %eax
  803bdb:	ff 75 0c             	pushl  0xc(%ebp)
  803bde:	8d 7d d8             	lea    0xffffffd8(%ebp),%edi
  803be1:	57                   	push   %edi
  803be2:	e8 01 15 00 00       	call   8050e8 <netbuf_ref>
  803be7:	0f be d8             	movsbl %al,%ebx
  803bea:	83 c4 10             	add    $0x10,%esp
  803bed:	85 db                	test   %ebx,%ebx
  803bef:	75 11                	jne    803c02 <lwip_sendto+0x106>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  803bf1:	83 ec 08             	sub    $0x8,%esp
  803bf4:	57                   	push   %edi
  803bf5:	ff 36                	pushl  (%esi)
  803bf7:	e8 ef a4 00 00       	call   80e0eb <netconn_send>
  803bfc:	0f be d8             	movsbl %al,%ebx
  803bff:	83 c4 10             	add    $0x10,%esp
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  803c02:	83 7d d8 00          	cmpl   $0x0,0xffffffd8(%ebp)
  803c06:	74 0e                	je     803c16 <lwip_sendto+0x11a>
    pbuf_free(buf.p);
  803c08:	83 ec 0c             	sub    $0xc,%esp
  803c0b:	ff 75 d8             	pushl  0xffffffd8(%ebp)
  803c0e:	e8 06 3d 00 00       	call   807919 <pbuf_free>
  803c13:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  803c16:	89 d8                	mov    %ebx,%eax
  803c18:	f7 d8                	neg    %eax
  803c1a:	ba 05 00 00 00       	mov    $0x5,%edx
  803c1f:	83 f8 0e             	cmp    $0xe,%eax
  803c22:	77 0f                	ja     803c33 <lwip_sendto+0x137>
  803c24:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
  803c2b:	f7 d8                	neg    %eax
  803c2d:	8b 90 a0 23 81 00    	mov    0x8123a0(%eax),%edx
  803c33:	89 56 10             	mov    %edx,0x10(%esi)
  803c36:	89 15 00 e6 b3 00    	mov    %edx,0xb3e600
  return (err==ERR_OK?size:-1);
  803c3c:	8b 45 10             	mov    0x10(%ebp),%eax
  803c3f:	85 db                	test   %ebx,%ebx
  803c41:	74 05                	je     803c48 <lwip_sendto+0x14c>
  803c43:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  803c48:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  803c4b:	5b                   	pop    %ebx
  803c4c:	5e                   	pop    %esi
  803c4d:	5f                   	pop    %edi
  803c4e:	c9                   	leave  
  803c4f:	c3                   	ret    

00803c50 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
  803c50:	55                   	push   %ebp
  803c51:	89 e5                	mov    %esp,%ebp
  803c53:	53                   	push   %ebx
  803c54:	83 ec 04             	sub    $0x4,%esp
  803c57:	8b 55 0c             	mov    0xc(%ebp),%edx
  803c5a:	8b 45 10             	mov    0x10(%ebp),%eax
  struct netconn *conn;
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  803c5d:	83 fa 02             	cmp    $0x2,%edx
  803c60:	74 2b                	je     803c8d <lwip_socket+0x3d>
  803c62:	83 fa 02             	cmp    $0x2,%edx
  803c65:	7f 07                	jg     803c6e <lwip_socket+0x1e>
  803c67:	83 fa 01             	cmp    $0x1,%edx
  803c6a:	74 46                	je     803cb2 <lwip_socket+0x62>
  803c6c:	eb 5c                	jmp    803cca <lwip_socket+0x7a>
  803c6e:	83 fa 03             	cmp    $0x3,%edx
  803c71:	75 57                	jne    803cca <lwip_socket+0x7a>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  803c73:	83 ec 04             	sub    $0x4,%esp
  803c76:	68 9c 41 80 00       	push   $0x80419c
  803c7b:	0f b6 c0             	movzbl %al,%eax
  803c7e:	50                   	push   %eax
  803c7f:	6a 40                	push   $0x40
  803c81:	e8 26 9f 00 00       	call   80dbac <netconn_new_with_proto_and_callback>
  803c86:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
  803c88:	83 c4 10             	add    $0x10,%esp
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  803c8b:	eb 4e                	jmp    803cdb <lwip_socket+0x8b>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  803c8d:	83 ec 04             	sub    $0x4,%esp
  803c90:	68 9c 41 80 00       	push   $0x80419c
  803c95:	6a 00                	push   $0x0
  803c97:	3d 88 00 00 00       	cmp    $0x88,%eax
  803c9c:	0f 94 c0             	sete   %al
  803c9f:	0f b6 c0             	movzbl %al,%eax
  803ca2:	83 c0 20             	add    $0x20,%eax
  803ca5:	50                   	push   %eax
  803ca6:	e8 01 9f 00 00       	call   80dbac <netconn_new_with_proto_and_callback>
  803cab:	89 c3                	mov    %eax,%ebx
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
  803cad:	83 c4 10             	add    $0x10,%esp
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  803cb0:	eb 29                	jmp    803cdb <lwip_socket+0x8b>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  803cb2:	83 ec 04             	sub    $0x4,%esp
  803cb5:	68 9c 41 80 00       	push   $0x80419c
  803cba:	6a 00                	push   $0x0
  803cbc:	6a 10                	push   $0x10
  803cbe:	e8 e9 9e 00 00       	call   80dbac <netconn_new_with_proto_and_callback>
  803cc3:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
  803cc5:	83 c4 10             	add    $0x10,%esp
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  803cc8:	eb 11                	jmp    803cdb <lwip_socket+0x8b>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  803cca:	c7 05 00 e6 b3 00 16 	movl   $0x16,0xb3e600
  803cd1:	00 00 00 
    return -1;
  803cd4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803cd9:	eb 4d                	jmp    803d28 <lwip_socket+0xd8>
  }

  if (!conn) {
  803cdb:	85 db                	test   %ebx,%ebx
  803cdd:	75 11                	jne    803cf0 <lwip_socket+0xa0>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  803cdf:	c7 05 00 e6 b3 00 69 	movl   $0x69,0xb3e600
  803ce6:	00 00 00 
    return -1;
  803ce9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803cee:	eb 38                	jmp    803d28 <lwip_socket+0xd8>
  }

  i = alloc_socket(conn);
  803cf0:	83 ec 0c             	sub    $0xc,%esp
  803cf3:	53                   	push   %ebx
  803cf4:	e8 98 f5 ff ff       	call   803291 <alloc_socket>

  if (i == -1) {
  803cf9:	83 c4 10             	add    $0x10,%esp
  803cfc:	83 f8 ff             	cmp    $0xffffffff,%eax
  803cff:	75 1a                	jne    803d1b <lwip_socket+0xcb>
    netconn_delete(conn);
  803d01:	83 ec 0c             	sub    $0xc,%esp
  803d04:	53                   	push   %ebx
  803d05:	e8 86 9f 00 00       	call   80dc90 <netconn_delete>
    set_errno(ENFILE);
  803d0a:	c7 05 00 e6 b3 00 17 	movl   $0x17,0xb3e600
  803d11:	00 00 00 
    return -1;
  803d14:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803d19:	eb 0d                	jmp    803d28 <lwip_socket+0xd8>
  }
  conn->socket = i;
  803d1b:	89 43 1c             	mov    %eax,0x1c(%ebx)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  803d1e:	c7 05 00 e6 b3 00 00 	movl   $0x0,0xb3e600
  803d25:	00 00 00 
  return i;
}
  803d28:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  803d2b:	c9                   	leave  
  803d2c:	c3                   	ret    

00803d2d <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  803d2d:	55                   	push   %ebp
  803d2e:	89 e5                	mov    %esp,%ebp
  803d30:	83 ec 08             	sub    $0x8,%esp
  return lwip_send(s, data, size, 0);
  803d33:	6a 00                	push   $0x0
  803d35:	ff 75 10             	pushl  0x10(%ebp)
  803d38:	ff 75 0c             	pushl  0xc(%ebp)
  803d3b:	ff 75 08             	pushl  0x8(%ebp)
  803d3e:	e8 15 fd ff ff       	call   803a58 <lwip_send>
}
  803d43:	c9                   	leave  
  803d44:	c3                   	ret    

00803d45 <lwip_selscan>:

/**
 * Go through the readset and writeset lists and see which socket of the sockets
 * set in the sets has events. On return, readset, writeset and exceptset have
 * the sockets enabled that had events.
 *
 * exceptset is not used for now!!!
 *
 * @param maxfdp1 the highest socket index in the sets
 * @param readset in: set of sockets to check for read events;
 *                out: set of sockets that had read events
 * @param writeset in: set of sockets to check for write events;
 *                 out: set of sockets that had write events
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  803d45:	55                   	push   %ebp
  803d46:	89 e5                	mov    %esp,%ebp
  803d48:	57                   	push   %edi
  803d49:	56                   	push   %esi
  803d4a:	53                   	push   %ebx
  803d4b:	83 ec 10             	sub    $0x10,%esp
  803d4e:	8b 7d 08             	mov    0x8(%ebp),%edi
  int i, nready = 0;
  803d51:	be 00 00 00 00       	mov    $0x0,%esi
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  803d56:	6a 04                	push   $0x4
  803d58:	6a 00                	push   $0x0
  803d5a:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  803d5d:	50                   	push   %eax
  803d5e:	e8 86 d5 ff ff       	call   8012e9 <memset>
  FD_ZERO(&lwriteset);
  803d63:	83 c4 0c             	add    $0xc,%esp
  803d66:	6a 04                	push   $0x4
  803d68:	6a 00                	push   $0x0
  803d6a:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  803d6d:	50                   	push   %eax
  803d6e:	e8 76 d5 ff ff       	call   8012e9 <memset>
  FD_ZERO(&lexceptset);
  803d73:	83 c4 0c             	add    $0xc,%esp
  803d76:	6a 04                	push   $0x4
  803d78:	6a 00                	push   $0x0
  803d7a:	8d 45 e8             	lea    0xffffffe8(%ebp),%eax
  803d7d:	50                   	push   %eax
  803d7e:	e8 66 d5 ff ff       	call   8012e9 <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  803d83:	bb 00 00 00 00       	mov    $0x0,%ebx
  803d88:	83 c4 10             	add    $0x10,%esp
  803d8b:	39 fe                	cmp    %edi,%esi
  803d8d:	0f 8d b1 00 00 00    	jge    803e44 <lwip_selscan+0xff>
    if (FD_ISSET(i, readset)) {
  803d93:	89 d8                	mov    %ebx,%eax
  803d95:	85 db                	test   %ebx,%ebx
  803d97:	79 03                	jns    803d9c <lwip_selscan+0x57>
  803d99:	8d 43 07             	lea    0x7(%ebx),%eax
  803d9c:	c1 f8 03             	sar    $0x3,%eax
  803d9f:	8b 55 0c             	mov    0xc(%ebp),%edx
  803da2:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
  803da6:	89 d9                	mov    %ebx,%ecx
  803da8:	83 e1 07             	and    $0x7,%ecx
  803dab:	d3 f8                	sar    %cl,%eax
  803dad:	a8 01                	test   $0x1,%al
  803daf:	74 39                	je     803dea <lwip_selscan+0xa5>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  803db1:	53                   	push   %ebx
  803db2:	e8 96 f4 ff ff       	call   80324d <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  803db7:	83 c4 04             	add    $0x4,%esp
  803dba:	85 c0                	test   %eax,%eax
  803dbc:	74 2c                	je     803dea <lwip_selscan+0xa5>
  803dbe:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  803dc2:	75 07                	jne    803dcb <lwip_selscan+0x86>
  803dc4:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  803dc9:	74 1f                	je     803dea <lwip_selscan+0xa5>
        FD_SET(i, &lreadset);
  803dcb:	89 d8                	mov    %ebx,%eax
  803dcd:	85 db                	test   %ebx,%ebx
  803dcf:	79 03                	jns    803dd4 <lwip_selscan+0x8f>
  803dd1:	8d 43 07             	lea    0x7(%ebx),%eax
  803dd4:	89 c2                	mov    %eax,%edx
  803dd6:	c1 fa 03             	sar    $0x3,%edx
  803dd9:	89 d9                	mov    %ebx,%ecx
  803ddb:	83 e1 07             	and    $0x7,%ecx
  803dde:	b8 01 00 00 00       	mov    $0x1,%eax
  803de3:	d3 e0                	shl    %cl,%eax
  803de5:	08 44 15 f0          	or     %al,0xfffffff0(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  803de9:	46                   	inc    %esi
      }
    }
    if (FD_ISSET(i, writeset)) {
  803dea:	89 d8                	mov    %ebx,%eax
  803dec:	85 db                	test   %ebx,%ebx
  803dee:	79 03                	jns    803df3 <lwip_selscan+0xae>
  803df0:	8d 43 07             	lea    0x7(%ebx),%eax
  803df3:	c1 f8 03             	sar    $0x3,%eax
  803df6:	8b 55 10             	mov    0x10(%ebp),%edx
  803df9:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
  803dfd:	89 d9                	mov    %ebx,%ecx
  803dff:	83 e1 07             	and    $0x7,%ecx
  803e02:	d3 f8                	sar    %cl,%eax
  803e04:	a8 01                	test   $0x1,%al
  803e06:	74 33                	je     803e3b <lwip_selscan+0xf6>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  803e08:	53                   	push   %ebx
  803e09:	e8 3f f4 ff ff       	call   80324d <get_socket>
      if (p_sock && p_sock->sendevent) {
  803e0e:	83 c4 04             	add    $0x4,%esp
  803e11:	85 c0                	test   %eax,%eax
  803e13:	74 26                	je     803e3b <lwip_selscan+0xf6>
  803e15:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  803e1a:	74 1f                	je     803e3b <lwip_selscan+0xf6>
        FD_SET(i, &lwriteset);
  803e1c:	89 d8                	mov    %ebx,%eax
  803e1e:	85 db                	test   %ebx,%ebx
  803e20:	79 03                	jns    803e25 <lwip_selscan+0xe0>
  803e22:	8d 43 07             	lea    0x7(%ebx),%eax
  803e25:	89 c2                	mov    %eax,%edx
  803e27:	c1 fa 03             	sar    $0x3,%edx
  803e2a:	89 d9                	mov    %ebx,%ecx
  803e2c:	83 e1 07             	and    $0x7,%ecx
  803e2f:	b8 01 00 00 00       	mov    $0x1,%eax
  803e34:	d3 e0                	shl    %cl,%eax
  803e36:	08 44 15 ec          	or     %al,0xffffffec(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  803e3a:	46                   	inc    %esi
  803e3b:	43                   	inc    %ebx
  803e3c:	39 fb                	cmp    %edi,%ebx
  803e3e:	0f 8c 4f ff ff ff    	jl     803d93 <lwip_selscan+0x4e>
      }
    }
  }
  *readset = lreadset;
  803e44:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  803e47:	8b 55 0c             	mov    0xc(%ebp),%edx
  803e4a:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  803e4c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  803e4f:	8b 55 10             	mov    0x10(%ebp),%edx
  803e52:	89 02                	mov    %eax,(%edx)
  FD_ZERO(exceptset);
  803e54:	83 ec 04             	sub    $0x4,%esp
  803e57:	6a 04                	push   $0x4
  803e59:	6a 00                	push   $0x0
  803e5b:	ff 75 14             	pushl  0x14(%ebp)
  803e5e:	e8 86 d4 ff ff       	call   8012e9 <memset>
  
  return nready;
}
  803e63:	89 f0                	mov    %esi,%eax
  803e65:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  803e68:	5b                   	pop    %ebx
  803e69:	5e                   	pop    %esi
  803e6a:	5f                   	pop    %edi
  803e6b:	c9                   	leave  
  803e6c:	c3                   	ret    

00803e6d <lwip_select>:


/**
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  803e6d:	55                   	push   %ebp
  803e6e:	89 e5                	mov    %esp,%ebp
  803e70:	57                   	push   %edi
  803e71:	56                   	push   %esi
  803e72:	53                   	push   %ebx
  803e73:	83 ec 48             	sub    $0x48,%esp
  803e76:	8b 7d 0c             	mov    0xc(%ebp),%edi
  803e79:	8b 75 18             	mov    0x18(%ebp),%esi
  int i;
  int nready;
  fd_set lreadset, lwriteset, lexceptset;
  u32_t msectimeout;
  struct lwip_select_cb select_cb;
  struct lwip_select_cb *p_selcb;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  803e7c:	c7 45 c8 00 00 00 00 	movl   $0x0,0xffffffc8(%ebp)
  select_cb.readset = readset;
  803e83:	89 7d cc             	mov    %edi,0xffffffcc(%ebp)
  select_cb.writeset = writeset;
  803e86:	8b 45 10             	mov    0x10(%ebp),%eax
  803e89:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
  select_cb.exceptset = exceptset;
  803e8c:	8b 55 14             	mov    0x14(%ebp),%edx
  803e8f:	89 55 d4             	mov    %edx,0xffffffd4(%ebp)
  select_cb.sem_signalled = 0;
  803e92:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  803e99:	ff 35 08 87 81 00    	pushl  0x818708
  803e9f:	e8 a5 3f 00 00       	call   807e49 <sys_sem_wait>

  if (readset)
  803ea4:	83 c4 10             	add    $0x10,%esp
  803ea7:	85 ff                	test   %edi,%edi
  803ea9:	74 07                	je     803eb2 <lwip_select+0x45>
    lreadset = *readset;
  803eab:	8b 07                	mov    (%edi),%eax
  803ead:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
  803eb0:	eb 13                	jmp    803ec5 <lwip_select+0x58>
  else
    FD_ZERO(&lreadset);
  803eb2:	83 ec 04             	sub    $0x4,%esp
  803eb5:	6a 04                	push   $0x4
  803eb7:	6a 00                	push   $0x0
  803eb9:	8d 45 c4             	lea    0xffffffc4(%ebp),%eax
  803ebc:	50                   	push   %eax
  803ebd:	e8 27 d4 ff ff       	call   8012e9 <memset>
  803ec2:	83 c4 10             	add    $0x10,%esp
  if (writeset)
  803ec5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  803ec9:	74 0a                	je     803ed5 <lwip_select+0x68>
    lwriteset = *writeset;
  803ecb:	8b 55 10             	mov    0x10(%ebp),%edx
  803ece:	8b 02                	mov    (%edx),%eax
  803ed0:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
  803ed3:	eb 13                	jmp    803ee8 <lwip_select+0x7b>
  else
    FD_ZERO(&lwriteset);
  803ed5:	83 ec 04             	sub    $0x4,%esp
  803ed8:	6a 04                	push   $0x4
  803eda:	6a 00                	push   $0x0
  803edc:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
  803edf:	50                   	push   %eax
  803ee0:	e8 04 d4 ff ff       	call   8012e9 <memset>
  803ee5:	83 c4 10             	add    $0x10,%esp
  if (exceptset)
  803ee8:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  803eec:	74 0a                	je     803ef8 <lwip_select+0x8b>
    lexceptset = *exceptset;
  803eee:	8b 55 14             	mov    0x14(%ebp),%edx
  803ef1:	8b 02                	mov    (%edx),%eax
  803ef3:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
  803ef6:	eb 13                	jmp    803f0b <lwip_select+0x9e>
  else
    FD_ZERO(&lexceptset);
  803ef8:	83 ec 04             	sub    $0x4,%esp
  803efb:	6a 04                	push   $0x4
  803efd:	6a 00                	push   $0x0
  803eff:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
  803f02:	50                   	push   %eax
  803f03:	e8 e1 d3 ff ff       	call   8012e9 <memset>
  803f08:	83 c4 10             	add    $0x10,%esp

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  803f0b:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
  803f0e:	50                   	push   %eax
  803f0f:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
  803f12:	50                   	push   %eax
  803f13:	8d 45 c4             	lea    0xffffffc4(%ebp),%eax
  803f16:	50                   	push   %eax
  803f17:	ff 75 08             	pushl  0x8(%ebp)
  803f1a:	e8 26 fe ff ff       	call   803d45 <lwip_selscan>
  803f1f:	89 c3                	mov    %eax,%ebx

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  803f21:	83 c4 10             	add    $0x10,%esp
  803f24:	85 c0                	test   %eax,%eax
  803f26:	0f 85 26 02 00 00    	jne    804152 <lwip_select+0x2e5>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  803f2c:	85 f6                	test   %esi,%esi
  803f2e:	74 74                	je     803fa4 <lwip_select+0x137>
  803f30:	83 3e 00             	cmpl   $0x0,(%esi)
  803f33:	75 6f                	jne    803fa4 <lwip_select+0x137>
  803f35:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
  803f39:	75 69                	jne    803fa4 <lwip_select+0x137>
      sys_sem_signal(selectsem);
  803f3b:	83 ec 0c             	sub    $0xc,%esp
  803f3e:	ff 35 08 87 81 00    	pushl  0x818708
  803f44:	e8 31 90 00 00       	call   80cf7a <sys_sem_signal>
      if (readset)
  803f49:	83 c4 10             	add    $0x10,%esp
  803f4c:	85 ff                	test   %edi,%edi
  803f4e:	74 10                	je     803f60 <lwip_select+0xf3>
        FD_ZERO(readset);
  803f50:	83 ec 04             	sub    $0x4,%esp
  803f53:	6a 04                	push   $0x4
  803f55:	6a 00                	push   $0x0
  803f57:	57                   	push   %edi
  803f58:	e8 8c d3 ff ff       	call   8012e9 <memset>
  803f5d:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  803f60:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  803f64:	74 12                	je     803f78 <lwip_select+0x10b>
        FD_ZERO(writeset);
  803f66:	83 ec 04             	sub    $0x4,%esp
  803f69:	6a 04                	push   $0x4
  803f6b:	6a 00                	push   $0x0
  803f6d:	ff 75 10             	pushl  0x10(%ebp)
  803f70:	e8 74 d3 ff ff       	call   8012e9 <memset>
  803f75:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  803f78:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  803f7c:	74 12                	je     803f90 <lwip_select+0x123>
        FD_ZERO(exceptset);
  803f7e:	83 ec 04             	sub    $0x4,%esp
  803f81:	6a 04                	push   $0x4
  803f83:	6a 00                	push   $0x0
  803f85:	ff 75 14             	pushl  0x14(%ebp)
  803f88:	e8 5c d3 ff ff       	call   8012e9 <memset>
  803f8d:	83 c4 10             	add    $0x10,%esp
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  803f90:	c7 05 00 e6 b3 00 00 	movl   $0x0,0xb3e600
  803f97:	00 00 00 
  
      return 0;
  803f9a:	b8 00 00 00 00       	mov    $0x0,%eax
  803f9f:	e9 f0 01 00 00       	jmp    804194 <lwip_select+0x327>
    }
    
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  803fa4:	83 ec 0c             	sub    $0xc,%esp
  803fa7:	6a 00                	push   $0x0
  803fa9:	e8 bb 8e 00 00       	call   80ce69 <sys_sem_new>
  803fae:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  803fb1:	a1 00 87 81 00       	mov    0x818700,%eax
  803fb6:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
    select_cb_list = &select_cb;
  803fb9:	8d 45 c8             	lea    0xffffffc8(%ebp),%eax
  803fbc:	a3 00 87 81 00       	mov    %eax,0x818700
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  803fc1:	83 c4 04             	add    $0x4,%esp
  803fc4:	ff 35 08 87 81 00    	pushl  0x818708
  803fca:	e8 ab 8f 00 00       	call   80cf7a <sys_sem_signal>
    
    /* Now just wait to be woken */
    if (timeout == 0)
  803fcf:	83 c4 10             	add    $0x10,%esp
      /* Wait forever */
      msectimeout = 0;
  803fd2:	b8 00 00 00 00       	mov    $0x0,%eax
  803fd7:	85 f6                	test   %esi,%esi
  803fd9:	74 2e                	je     804009 <lwip_select+0x19c>
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  803fdb:	8b 0e                	mov    (%esi),%ecx
  803fdd:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  803fe0:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  803fe3:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  803fe6:	8b 5e 04             	mov    0x4(%esi),%ebx
  803fe9:	81 c3 f4 01 00 00    	add    $0x1f4,%ebx
  803fef:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  803ff4:	f7 eb                	imul   %ebx
  803ff6:	89 d0                	mov    %edx,%eax
  803ff8:	c1 f8 06             	sar    $0x6,%eax
  803ffb:	c1 fb 1f             	sar    $0x1f,%ebx
  803ffe:	29 d8                	sub    %ebx,%eax
  804000:	8d 04 c8             	lea    (%eax,%ecx,8),%eax
      if(msectimeout == 0)
  804003:	85 c0                	test   %eax,%eax
  804005:	75 02                	jne    804009 <lwip_select+0x19c>
        msectimeout = 1;
  804007:	b0 01                	mov    $0x1,%al
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  804009:	83 ec 08             	sub    $0x8,%esp
  80400c:	50                   	push   %eax
  80400d:	ff 75 dc             	pushl  0xffffffdc(%ebp)
  804010:	e8 28 40 00 00       	call   80803d <sys_sem_wait_timeout>
  804015:	89 c3                	mov    %eax,%ebx
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  804017:	83 c4 04             	add    $0x4,%esp
  80401a:	ff 35 08 87 81 00    	pushl  0x818708
  804020:	e8 24 3e 00 00       	call   807e49 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  804025:	8d 45 c8             	lea    0xffffffc8(%ebp),%eax
  804028:	83 c4 10             	add    $0x10,%esp
  80402b:	3b 05 00 87 81 00    	cmp    0x818700,%eax
  804031:	75 11                	jne    804044 <lwip_select+0x1d7>
      select_cb_list = select_cb.next;
  804033:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
  804036:	a3 00 87 81 00       	mov    %eax,0x818700
  80403b:	eb 1e                	jmp    80405b <lwip_select+0x1ee>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
          p_selcb->next = select_cb.next;
  80403d:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
  804040:	89 02                	mov    %eax,(%edx)
          break;
  804042:	eb 17                	jmp    80405b <lwip_select+0x1ee>
  804044:	8b 15 00 87 81 00    	mov    0x818700,%edx
  80404a:	85 d2                	test   %edx,%edx
  80404c:	74 0d                	je     80405b <lwip_select+0x1ee>
  80404e:	8d 45 c8             	lea    0xffffffc8(%ebp),%eax
  804051:	39 02                	cmp    %eax,(%edx)
  804053:	74 e8                	je     80403d <lwip_select+0x1d0>
  804055:	8b 12                	mov    (%edx),%edx
  804057:	85 d2                	test   %edx,%edx
  804059:	75 f6                	jne    804051 <lwip_select+0x1e4>
        }
      }
    
    sys_sem_signal(selectsem);
  80405b:	83 ec 0c             	sub    $0xc,%esp
  80405e:	ff 35 08 87 81 00    	pushl  0x818708
  804064:	e8 11 8f 00 00       	call   80cf7a <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  804069:	83 c4 04             	add    $0x4,%esp
  80406c:	ff 75 dc             	pushl  0xffffffdc(%ebp)
  80406f:	e8 8b 8e 00 00       	call   80ceff <sys_sem_free>
    if (i == 0)  {
  804074:	83 c4 10             	add    $0x10,%esp
  804077:	85 db                	test   %ebx,%ebx
  804079:	75 58                	jne    8040d3 <lwip_select+0x266>
      /* Timeout */
      if (readset)
  80407b:	85 ff                	test   %edi,%edi
  80407d:	74 10                	je     80408f <lwip_select+0x222>
        FD_ZERO(readset);
  80407f:	83 ec 04             	sub    $0x4,%esp
  804082:	6a 04                	push   $0x4
  804084:	6a 00                	push   $0x0
  804086:	57                   	push   %edi
  804087:	e8 5d d2 ff ff       	call   8012e9 <memset>
  80408c:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  80408f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  804093:	74 12                	je     8040a7 <lwip_select+0x23a>
        FD_ZERO(writeset);
  804095:	83 ec 04             	sub    $0x4,%esp
  804098:	6a 04                	push   $0x4
  80409a:	6a 00                	push   $0x0
  80409c:	ff 75 10             	pushl  0x10(%ebp)
  80409f:	e8 45 d2 ff ff       	call   8012e9 <memset>
  8040a4:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  8040a7:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  8040ab:	74 12                	je     8040bf <lwip_select+0x252>
        FD_ZERO(exceptset);
  8040ad:	83 ec 04             	sub    $0x4,%esp
  8040b0:	6a 04                	push   $0x4
  8040b2:	6a 00                	push   $0x0
  8040b4:	ff 75 14             	pushl  0x14(%ebp)
  8040b7:	e8 2d d2 ff ff       	call   8012e9 <memset>
  8040bc:	83 c4 10             	add    $0x10,%esp
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  8040bf:	c7 05 00 e6 b3 00 00 	movl   $0x0,0xb3e600
  8040c6:	00 00 00 
  
      return 0;
  8040c9:	b8 00 00 00 00       	mov    $0x0,%eax
  8040ce:	e9 c1 00 00 00       	jmp    804194 <lwip_select+0x327>
    }
    
    if (readset)
  8040d3:	85 ff                	test   %edi,%edi
  8040d5:	74 07                	je     8040de <lwip_select+0x271>
      lreadset = *readset;
  8040d7:	8b 07                	mov    (%edi),%eax
  8040d9:	89 45 c4             	mov    %eax,0xffffffc4(%ebp)
  8040dc:	eb 13                	jmp    8040f1 <lwip_select+0x284>
    else
      FD_ZERO(&lreadset);
  8040de:	83 ec 04             	sub    $0x4,%esp
  8040e1:	6a 04                	push   $0x4
  8040e3:	6a 00                	push   $0x0
  8040e5:	8d 45 c4             	lea    0xffffffc4(%ebp),%eax
  8040e8:	50                   	push   %eax
  8040e9:	e8 fb d1 ff ff       	call   8012e9 <memset>
  8040ee:	83 c4 10             	add    $0x10,%esp
    if (writeset)
  8040f1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8040f5:	74 0a                	je     804101 <lwip_select+0x294>
      lwriteset = *writeset;
  8040f7:	8b 55 10             	mov    0x10(%ebp),%edx
  8040fa:	8b 02                	mov    (%edx),%eax
  8040fc:	89 45 c0             	mov    %eax,0xffffffc0(%ebp)
  8040ff:	eb 13                	jmp    804114 <lwip_select+0x2a7>
    else
      FD_ZERO(&lwriteset);
  804101:	83 ec 04             	sub    $0x4,%esp
  804104:	6a 04                	push   $0x4
  804106:	6a 00                	push   $0x0
  804108:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
  80410b:	50                   	push   %eax
  80410c:	e8 d8 d1 ff ff       	call   8012e9 <memset>
  804111:	83 c4 10             	add    $0x10,%esp
    if (exceptset)
  804114:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  804118:	74 0a                	je     804124 <lwip_select+0x2b7>
      lexceptset = *exceptset;
  80411a:	8b 55 14             	mov    0x14(%ebp),%edx
  80411d:	8b 02                	mov    (%edx),%eax
  80411f:	89 45 bc             	mov    %eax,0xffffffbc(%ebp)
  804122:	eb 13                	jmp    804137 <lwip_select+0x2ca>
    else
      FD_ZERO(&lexceptset);
  804124:	83 ec 04             	sub    $0x4,%esp
  804127:	6a 04                	push   $0x4
  804129:	6a 00                	push   $0x0
  80412b:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
  80412e:	50                   	push   %eax
  80412f:	e8 b5 d1 ff ff       	call   8012e9 <memset>
  804134:	83 c4 10             	add    $0x10,%esp
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  804137:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
  80413a:	50                   	push   %eax
  80413b:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
  80413e:	50                   	push   %eax
  80413f:	8d 45 c4             	lea    0xffffffc4(%ebp),%eax
  804142:	50                   	push   %eax
  804143:	ff 75 08             	pushl  0x8(%ebp)
  804146:	e8 fa fb ff ff       	call   803d45 <lwip_selscan>
  80414b:	89 c3                	mov    %eax,%ebx
  80414d:	83 c4 10             	add    $0x10,%esp
  804150:	eb 11                	jmp    804163 <lwip_select+0x2f6>
  } else
    sys_sem_signal(selectsem);
  804152:	83 ec 0c             	sub    $0xc,%esp
  804155:	ff 35 08 87 81 00    	pushl  0x818708
  80415b:	e8 1a 8e 00 00       	call   80cf7a <sys_sem_signal>
  804160:	83 c4 10             	add    $0x10,%esp
  
  if (readset)
  804163:	85 ff                	test   %edi,%edi
  804165:	74 05                	je     80416c <lwip_select+0x2ff>
    *readset = lreadset;
  804167:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
  80416a:	89 07                	mov    %eax,(%edi)
  if (writeset)
  80416c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  804170:	74 08                	je     80417a <lwip_select+0x30d>
    *writeset = lwriteset;
  804172:	8b 45 c0             	mov    0xffffffc0(%ebp),%eax
  804175:	8b 55 10             	mov    0x10(%ebp),%edx
  804178:	89 02                	mov    %eax,(%edx)
  if (exceptset)
  80417a:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  80417e:	74 08                	je     804188 <lwip_select+0x31b>
    *exceptset = lexceptset;
  804180:	8b 45 bc             	mov    0xffffffbc(%ebp),%eax
  804183:	8b 55 14             	mov    0x14(%ebp),%edx
  804186:	89 02                	mov    %eax,(%edx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  804188:	c7 05 00 e6 b3 00 00 	movl   $0x0,0xb3e600
  80418f:	00 00 00 
  
  return nready;
  804192:	89 d8                	mov    %ebx,%eax
}
  804194:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  804197:	5b                   	pop    %ebx
  804198:	5e                   	pop    %esi
  804199:	5f                   	pop    %edi
  80419a:	c9                   	leave  
  80419b:	c3                   	ret    

0080419c <event_callback>:

/**
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  80419c:	55                   	push   %ebp
  80419d:	89 e5                	mov    %esp,%ebp
  80419f:	57                   	push   %edi
  8041a0:	56                   	push   %esi
  8041a1:	53                   	push   %ebx
  8041a2:	83 ec 0c             	sub    $0xc,%esp
  8041a5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  int s;
  struct lwip_socket *sock;
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  8041a8:	85 db                	test   %ebx,%ebx
  8041aa:	0f 84 8e 01 00 00    	je     80433e <event_callback+0x1a2>
    s = conn->socket;
  8041b0:	8b 73 1c             	mov    0x1c(%ebx),%esi
    if (s < 0) {
  8041b3:	85 f6                	test   %esi,%esi
  8041b5:	79 44                	jns    8041fb <event_callback+0x5f>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  8041b7:	83 ec 0c             	sub    $0xc,%esp
  8041ba:	ff 35 04 87 81 00    	pushl  0x818704
  8041c0:	e8 84 3c 00 00       	call   807e49 <sys_sem_wait>
      if (conn->socket < 0) {
  8041c5:	83 c4 10             	add    $0x10,%esp
  8041c8:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  8041cc:	79 1c                	jns    8041ea <event_callback+0x4e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  8041ce:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8041d2:	75 03                	jne    8041d7 <event_callback+0x3b>
          conn->socket--;
  8041d4:	ff 4b 1c             	decl   0x1c(%ebx)
        }
        sys_sem_signal(socksem);
  8041d7:	83 ec 0c             	sub    $0xc,%esp
  8041da:	ff 35 04 87 81 00    	pushl  0x818704
  8041e0:	e8 95 8d 00 00       	call   80cf7a <sys_sem_signal>
        return;
  8041e5:	e9 54 01 00 00       	jmp    80433e <event_callback+0x1a2>
      }
      sys_sem_signal(socksem);
  8041ea:	83 ec 0c             	sub    $0xc,%esp
  8041ed:	ff 35 04 87 81 00    	pushl  0x818704
  8041f3:	e8 82 8d 00 00       	call   80cf7a <sys_sem_signal>
  8041f8:	83 c4 10             	add    $0x10,%esp
    }

    sock = get_socket(s);
  8041fb:	56                   	push   %esi
  8041fc:	e8 4c f0 ff ff       	call   80324d <get_socket>
  804201:	89 c7                	mov    %eax,%edi
    if (!sock) {
  804203:	83 c4 04             	add    $0x4,%esp
  804206:	85 c0                	test   %eax,%eax
  804208:	0f 84 30 01 00 00    	je     80433e <event_callback+0x1a2>
      return;
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  80420e:	83 ec 0c             	sub    $0xc,%esp
  804211:	ff 35 08 87 81 00    	pushl  0x818708
  804217:	e8 2d 3c 00 00       	call   807e49 <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  80421c:	83 c4 10             	add    $0x10,%esp
  80421f:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  804223:	74 1a                	je     80423f <event_callback+0xa3>
  804225:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  804229:	72 0e                	jb     804239 <event_callback+0x9d>
  80422b:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
  80422f:	74 14                	je     804245 <event_callback+0xa9>
  804231:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
  804235:	74 16                	je     80424d <event_callback+0xb1>
  804237:	eb 1c                	jmp    804255 <event_callback+0xb9>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  804239:	66 ff 47 0a          	incw   0xa(%edi)
      break;
  80423d:	eb 2d                	jmp    80426c <event_callback+0xd0>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  80423f:	66 ff 4f 0a          	decw   0xa(%edi)
      break;
  804243:	eb 27                	jmp    80426c <event_callback+0xd0>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  804245:	66 c7 47 0c 01 00    	movw   $0x1,0xc(%edi)
      break;
  80424b:	eb 1f                	jmp    80426c <event_callback+0xd0>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  80424d:	66 c7 47 0c 00 00    	movw   $0x0,0xc(%edi)
      break;
  804253:	eb 17                	jmp    80426c <event_callback+0xd0>
    default:
      LWIP_ASSERT("unknown event", 0);
  804255:	83 ec 04             	sub    $0x4,%esp
  804258:	68 75 24 81 00       	push   $0x812475
  80425d:	68 17 04 00 00       	push   $0x417
  804262:	68 f1 23 81 00       	push   $0x8123f1
  804267:	e8 60 c8 ff ff       	call   800acc <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  80426c:	83 ec 0c             	sub    $0xc,%esp
  80426f:	ff 35 08 87 81 00    	pushl  0x818708
  804275:	e8 00 8d 00 00       	call   80cf7a <sys_sem_signal>

  /* Now decide if anyone is waiting for this socket */
  /* NOTE: This code is written this way to protect the select link list
     but to avoid a deadlock situation by releasing socksem before
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
  80427a:	83 c4 10             	add    $0x10,%esp
  80427d:	89 f0                	mov    %esi,%eax
  80427f:	83 e0 07             	and    $0x7,%eax
  804282:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    sys_sem_wait(selectsem);
  804285:	83 ec 0c             	sub    $0xc,%esp
  804288:	ff 35 08 87 81 00    	pushl  0x818708
  80428e:	e8 b6 3b 00 00       	call   807e49 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  804293:	8b 1d 00 87 81 00    	mov    0x818700,%ebx
  804299:	83 c4 10             	add    $0x10,%esp
  80429c:	85 db                	test   %ebx,%ebx
  80429e:	0f 84 89 00 00 00    	je     80432d <event_callback+0x191>
  8042a4:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
      if (scb->sem_signalled == 0) {
  8042a7:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8042ab:	75 4c                	jne    8042f9 <event_callback+0x15d>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  8042ad:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  8042b1:	74 20                	je     8042d3 <event_callback+0x137>
  8042b3:	8b 53 04             	mov    0x4(%ebx),%edx
  8042b6:	89 f0                	mov    %esi,%eax
  8042b8:	85 f6                	test   %esi,%esi
  8042ba:	79 03                	jns    8042bf <event_callback+0x123>
  8042bc:	8d 46 07             	lea    0x7(%esi),%eax
  8042bf:	c1 f8 03             	sar    $0x3,%eax
  8042c2:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
  8042c6:	d3 f8                	sar    %cl,%eax
  8042c8:	a8 01                	test   $0x1,%al
  8042ca:	74 07                	je     8042d3 <event_callback+0x137>
          if (sock->rcvevent)
  8042cc:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  8042d1:	75 2e                	jne    804301 <event_callback+0x165>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  8042d3:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  8042d7:	74 20                	je     8042f9 <event_callback+0x15d>
  8042d9:	8b 53 08             	mov    0x8(%ebx),%edx
  8042dc:	89 f0                	mov    %esi,%eax
  8042de:	85 f6                	test   %esi,%esi
  8042e0:	79 03                	jns    8042e5 <event_callback+0x149>
  8042e2:	8d 46 07             	lea    0x7(%esi),%eax
  8042e5:	c1 f8 03             	sar    $0x3,%eax
  8042e8:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
  8042ec:	d3 f8                	sar    %cl,%eax
  8042ee:	a8 01                	test   $0x1,%al
  8042f0:	74 07                	je     8042f9 <event_callback+0x15d>
          if (sock->sendevent)
  8042f2:	66 83 7f 0c 00       	cmpw   $0x0,0xc(%edi)
  8042f7:	75 08                	jne    804301 <event_callback+0x165>
  8042f9:	8b 1b                	mov    (%ebx),%ebx
  8042fb:	85 db                	test   %ebx,%ebx
  8042fd:	75 a8                	jne    8042a7 <event_callback+0x10b>
  8042ff:	eb 2c                	jmp    80432d <event_callback+0x191>
            break;
      }
    }
    if (scb) {
  804301:	85 db                	test   %ebx,%ebx
  804303:	74 28                	je     80432d <event_callback+0x191>
      scb->sem_signalled = 1;
  804305:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  80430c:	83 ec 0c             	sub    $0xc,%esp
  80430f:	ff 35 08 87 81 00    	pushl  0x818708
  804315:	e8 60 8c 00 00       	call   80cf7a <sys_sem_signal>
      sys_sem_signal(scb->sem);
  80431a:	83 c4 04             	add    $0x4,%esp
  80431d:	ff 73 14             	pushl  0x14(%ebx)
  804320:	e8 55 8c 00 00       	call   80cf7a <sys_sem_signal>
  804325:	83 c4 10             	add    $0x10,%esp
  804328:	e9 58 ff ff ff       	jmp    804285 <event_callback+0xe9>
    } else {
      sys_sem_signal(selectsem);
  80432d:	83 ec 0c             	sub    $0xc,%esp
  804330:	ff 35 08 87 81 00    	pushl  0x818708
  804336:	e8 3f 8c 00 00       	call   80cf7a <sys_sem_signal>
      break;
  80433b:	83 c4 10             	add    $0x10,%esp
    }
  }
}
  80433e:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  804341:	5b                   	pop    %ebx
  804342:	5e                   	pop    %esi
  804343:	5f                   	pop    %edi
  804344:	c9                   	leave  
  804345:	c3                   	ret    

00804346 <lwip_shutdown>:

/**
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  804346:	55                   	push   %ebp
  804347:	89 e5                	mov    %esp,%ebp
  804349:	83 ec 14             	sub    $0x14,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  80434c:	ff 75 08             	pushl  0x8(%ebp)
  80434f:	e8 90 f2 ff ff       	call   8035e4 <lwip_close>
}
  804354:	c9                   	leave  
  804355:	c3                   	ret    

00804356 <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  804356:	55                   	push   %ebp
  804357:	89 e5                	mov    %esp,%ebp
  804359:	57                   	push   %edi
  80435a:	56                   	push   %esi
  80435b:	53                   	push   %ebx
  80435c:	83 ec 2c             	sub    $0x2c,%esp
  80435f:	8b 7d 10             	mov    0x10(%ebp),%edi
  804362:	0f b6 75 14          	movzbl 0x14(%ebp),%esi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  804366:	ff 75 08             	pushl  0x8(%ebp)
  804369:	e8 df ee ff ff       	call   80324d <get_socket>
  80436e:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804370:	83 c4 04             	add    $0x4,%esp
    return -1;
  804373:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804378:	85 db                	test   %ebx,%ebx
  80437a:	74 7c                	je     8043f8 <lwip_getaddrname+0xa2>

  memset(&sin, 0, sizeof(sin));
  80437c:	83 ec 04             	sub    $0x4,%esp
  80437f:	6a 10                	push   $0x10
  804381:	6a 00                	push   $0x0
  804383:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  804386:	50                   	push   %eax
  804387:	e8 5d cf ff ff       	call   8012e9 <memset>
  sin.sin_len = sizeof(sin);
  80438c:	c6 45 d8 10          	movb   $0x10,0xffffffd8(%ebp)
  sin.sin_family = AF_INET;
  804390:	c6 45 d9 02          	movb   $0x2,0xffffffd9(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  804394:	89 f2                	mov    %esi,%edx
  804396:	0f b6 c2             	movzbl %dl,%eax
  804399:	50                   	push   %eax
  80439a:	8d 45 da             	lea    0xffffffda(%ebp),%eax
  80439d:	50                   	push   %eax
  80439e:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
  8043a1:	50                   	push   %eax
  8043a2:	ff 33                	pushl  (%ebx)
  8043a4:	e8 51 99 00 00       	call   80dcfa <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  8043a9:	83 c4 14             	add    $0x14,%esp
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  8043ac:	0f b7 45 da          	movzwl 0xffffffda(%ebp),%eax
  8043b0:	50                   	push   %eax
  8043b1:	e8 a9 62 00 00       	call   80a65f <htons>
  8043b6:	66 89 45 da          	mov    %ax,0xffffffda(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  8043ba:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  8043bd:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)

  if (*namelen > sizeof(sin))
  8043c0:	83 c4 10             	add    $0x10,%esp
  8043c3:	83 3f 10             	cmpl   $0x10,(%edi)
  8043c6:	76 06                	jbe    8043ce <lwip_getaddrname+0x78>
    *namelen = sizeof(sin);
  8043c8:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(name, &sin, *namelen);
  8043ce:	83 ec 04             	sub    $0x4,%esp
  8043d1:	ff 37                	pushl  (%edi)
  8043d3:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  8043d6:	50                   	push   %eax
  8043d7:	ff 75 0c             	pushl  0xc(%ebp)
  8043da:	e8 c8 cf ff ff       	call   8013a7 <memcpy>
  sock_set_errno(sock, 0);
  8043df:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8043e6:	c7 05 00 e6 b3 00 00 	movl   $0x0,0xb3e600
  8043ed:	00 00 00 
  8043f0:	83 c4 10             	add    $0x10,%esp
  return 0;
  8043f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8043f8:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8043fb:	5b                   	pop    %ebx
  8043fc:	5e                   	pop    %esi
  8043fd:	5f                   	pop    %edi
  8043fe:	c9                   	leave  
  8043ff:	c3                   	ret    

00804400 <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  804400:	55                   	push   %ebp
  804401:	89 e5                	mov    %esp,%ebp
  804403:	83 ec 08             	sub    $0x8,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  804406:	6a 00                	push   $0x0
  804408:	ff 75 10             	pushl  0x10(%ebp)
  80440b:	ff 75 0c             	pushl  0xc(%ebp)
  80440e:	ff 75 08             	pushl  0x8(%ebp)
  804411:	e8 40 ff ff ff       	call   804356 <lwip_getaddrname>
}
  804416:	c9                   	leave  
  804417:	c3                   	ret    

00804418 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  804418:	55                   	push   %ebp
  804419:	89 e5                	mov    %esp,%ebp
  80441b:	83 ec 08             	sub    $0x8,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  80441e:	6a 01                	push   $0x1
  804420:	ff 75 10             	pushl  0x10(%ebp)
  804423:	ff 75 0c             	pushl  0xc(%ebp)
  804426:	ff 75 08             	pushl  0x8(%ebp)
  804429:	e8 28 ff ff ff       	call   804356 <lwip_getaddrname>
}
  80442e:	c9                   	leave  
  80442f:	c3                   	ret    

00804430 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  804430:	55                   	push   %ebp
  804431:	89 e5                	mov    %esp,%ebp
  804433:	57                   	push   %edi
  804434:	56                   	push   %esi
  804435:	53                   	push   %ebx
  804436:	83 ec 2c             	sub    $0x2c,%esp
  804439:	8b 7d 0c             	mov    0xc(%ebp),%edi
  err_t err = ERR_OK;
  80443c:	be 00 00 00 00       	mov    $0x0,%esi
  struct lwip_socket *sock = get_socket(s);
  804441:	ff 75 08             	pushl  0x8(%ebp)
  804444:	e8 04 ee ff ff       	call   80324d <get_socket>
  804449:	89 c3                	mov    %eax,%ebx
  struct lwip_setgetsockopt_data data;

  if (!sock)
  80444b:	83 c4 04             	add    $0x4,%esp
    return -1;
  80444e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  804453:	85 c0                	test   %eax,%eax
  804455:	0f 84 8a 01 00 00    	je     8045e5 <lwip_getsockopt+0x1b5>

  if ((NULL == optval) || (NULL == optlen)) {
  80445b:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  80445f:	74 06                	je     804467 <lwip_getsockopt+0x37>
  804461:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  804465:	75 1b                	jne    804482 <lwip_getsockopt+0x52>
    sock_set_errno(sock, EFAULT);
  804467:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  80446e:	c7 05 00 e6 b3 00 0e 	movl   $0xe,0xb3e600
  804475:	00 00 00 
    return -1;
  804478:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80447d:	e9 63 01 00 00       	jmp    8045e5 <lwip_getsockopt+0x1b5>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  804482:	83 ff 06             	cmp    $0x6,%edi
  804485:	0f 84 b2 00 00 00    	je     80453d <lwip_getsockopt+0x10d>
  80448b:	83 ff 06             	cmp    $0x6,%edi
  80448e:	7f 0d                	jg     80449d <lwip_getsockopt+0x6d>
  804490:	85 ff                	test   %edi,%edi
  804492:	0f 84 86 00 00 00    	je     80451e <lwip_getsockopt+0xee>
  804498:	e9 cf 00 00 00       	jmp    80456c <lwip_getsockopt+0x13c>
  80449d:	81 ff ff 0f 00 00    	cmp    $0xfff,%edi
  8044a3:	0f 85 c3 00 00 00    	jne    80456c <lwip_getsockopt+0x13c>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8044a9:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  8044ad:	74 31                	je     8044e0 <lwip_getsockopt+0xb0>
  8044af:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  8044b3:	7f 0e                	jg     8044c3 <lwip_getsockopt+0x93>
  8044b5:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  8044b9:	74 25                	je     8044e0 <lwip_getsockopt+0xb0>
  8044bb:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  8044bf:	74 1f                	je     8044e0 <lwip_getsockopt+0xb0>
  8044c1:	eb 54                	jmp    804517 <lwip_getsockopt+0xe7>
  8044c3:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  8044ca:	7c 4b                	jl     804517 <lwip_getsockopt+0xe7>
  8044cc:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  8044d3:	7e 0b                	jle    8044e0 <lwip_getsockopt+0xb0>
  8044d5:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  8044dc:	74 15                	je     8044f3 <lwip_getsockopt+0xc3>
  8044de:	eb 37                	jmp    804517 <lwip_getsockopt+0xe7>
       
    case SO_ACCEPTCONN:
    case SO_BROADCAST:
    /* UNIMPL case SO_DEBUG: */
    /* UNIMPL case SO_DONTROUTE: */
    case SO_ERROR:
    case SO_KEEPALIVE:
    /* UNIMPL case SO_CONTIMEO: */
    /* UNIMPL case SO_SNDTIMEO: */
#if LWIP_SO_RCVTIMEO
    case SO_RCVTIMEO:
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
    case SO_RCVBUF:
#endif /* LWIP_SO_RCVBUF */
    /* UNIMPL case SO_OOBINLINE: */
    /* UNIMPL case SO_SNDBUF: */
    /* UNIMPL case SO_RCVLOWAT: */
    /* UNIMPL case SO_SNDLOWAT: */
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  8044e0:	8b 45 18             	mov    0x18(%ebp),%eax
  8044e3:	83 38 03             	cmpl   $0x3,(%eax)
  8044e6:	0f 87 85 00 00 00    	ja     804571 <lwip_getsockopt+0x141>
        err = EINVAL;
  8044ec:	be 16 00 00 00       	mov    $0x16,%esi
      }
      break;
  8044f1:	eb 7e                	jmp    804571 <lwip_getsockopt+0x141>

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
  8044f3:	8b 55 18             	mov    0x18(%ebp),%edx
  8044f6:	83 3a 03             	cmpl   $0x3,(%edx)
  8044f9:	77 05                	ja     804500 <lwip_getsockopt+0xd0>
        err = EINVAL;
  8044fb:	be 16 00 00 00       	mov    $0x16,%esi
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  804500:	8b 03                	mov    (%ebx),%eax
  804502:	83 38 20             	cmpl   $0x20,(%eax)
  804505:	75 09                	jne    804510 <lwip_getsockopt+0xe0>
  804507:	8b 40 08             	mov    0x8(%eax),%eax
  80450a:	f6 40 10 02          	testb  $0x2,0x10(%eax)
  80450e:	74 61                	je     804571 <lwip_getsockopt+0x141>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  804510:	be 61 00 00 00       	mov    $0x61,%esi
      }
#endif /* LWIP_UDP */
      break;
  804515:	eb 5a                	jmp    804571 <lwip_getsockopt+0x141>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  804517:	be 5c 00 00 00       	mov    $0x5c,%esi
    }  /* switch (optname) */
    break;
  80451c:	eb 53                	jmp    804571 <lwip_getsockopt+0x141>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  80451e:	8b 45 10             	mov    0x10(%ebp),%eax
  804521:	48                   	dec    %eax
  804522:	83 f8 01             	cmp    $0x1,%eax
  804525:	77 0f                	ja     804536 <lwip_getsockopt+0x106>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  804527:	8b 45 18             	mov    0x18(%ebp),%eax
  80452a:	83 38 03             	cmpl   $0x3,(%eax)
  80452d:	77 42                	ja     804571 <lwip_getsockopt+0x141>
        err = EINVAL;
  80452f:	be 16 00 00 00       	mov    $0x16,%esi
      }
      break;
  804534:	eb 3b                	jmp    804571 <lwip_getsockopt+0x141>
#if LWIP_IGMP
    case IP_MULTICAST_TTL:
      if (*optlen < sizeof(u8_t)) {
        err = EINVAL;
      }
      break;
    case IP_MULTICAST_IF:
      if (*optlen < sizeof(struct in_addr)) {
        err = EINVAL;
      }
      break;
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  804536:	be 5c 00 00 00       	mov    $0x5c,%esi
    }  /* switch (optname) */
    break;
  80453b:	eb 34                	jmp    804571 <lwip_getsockopt+0x141>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  80453d:	8b 55 18             	mov    0x18(%ebp),%edx
  804540:	83 3a 03             	cmpl   $0x3,(%edx)
  804543:	77 07                	ja     80454c <lwip_getsockopt+0x11c>
      err = EINVAL;
  804545:	be 16 00 00 00       	mov    $0x16,%esi
      break;
  80454a:	eb 25                	jmp    804571 <lwip_getsockopt+0x141>
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  80454c:	8b 00                	mov    (%eax),%eax
      return 0;
  80454e:	ba 00 00 00 00       	mov    $0x0,%edx
  804553:	83 38 10             	cmpl   $0x10,(%eax)
  804556:	0f 85 89 00 00 00    	jne    8045e5 <lwip_getsockopt+0x1b5>

    switch (optname) {
  80455c:	8b 45 10             	mov    0x10(%ebp),%eax
  80455f:	48                   	dec    %eax
  804560:	83 f8 01             	cmp    $0x1,%eax
  804563:	76 0c                	jbe    804571 <lwip_getsockopt+0x141>
    case TCP_NODELAY:
    case TCP_KEEPALIVE:
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  804565:	be 5c 00 00 00       	mov    $0x5c,%esi
    }  /* switch (optname) */
    break;
  80456a:	eb 05                	jmp    804571 <lwip_getsockopt+0x141>
#endif /* LWIP_TCP */
#if LWIP_UDP && LWIP_UDPLITE
/* Level: IPPROTO_UDPLITE */
  case IPPROTO_UDPLITE:
    if (*optlen < sizeof(int)) {
      err = EINVAL;
      break;
    }
    
    /* If this is no UDP lite socket, ignore any options. */
    if (sock->conn->type != NETCONN_UDPLITE)
      return 0;

    switch (optname) {
    case UDPLITE_SEND_CSCOV:
    case UDPLITE_RECV_CSCOV:
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  80456c:	be 5c 00 00 00       	mov    $0x5c,%esi
  }  /* switch */

   
  if (err != ERR_OK) {
  804571:	89 f0                	mov    %esi,%eax
  804573:	84 c0                	test   %al,%al
  804575:	74 12                	je     804589 <lwip_getsockopt+0x159>
    sock_set_errno(sock, err);
  804577:	0f be c0             	movsbl %al,%eax
  80457a:	89 43 10             	mov    %eax,0x10(%ebx)
  80457d:	a3 00 e6 b3 00       	mov    %eax,0xb3e600
    return -1;
  804582:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  804587:	eb 5c                	jmp    8045e5 <lwip_getsockopt+0x1b5>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  804589:	89 5d c8             	mov    %ebx,0xffffffc8(%ebp)
  data.level = level;
  80458c:	89 7d d0             	mov    %edi,0xffffffd0(%ebp)
  data.optname = optname;
  80458f:	8b 55 10             	mov    0x10(%ebp),%edx
  804592:	89 55 d4             	mov    %edx,0xffffffd4(%ebp)
  data.optval = optval;
  804595:	8b 45 14             	mov    0x14(%ebp),%eax
  804598:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  data.optlen = optlen;
  80459b:	8b 55 18             	mov    0x18(%ebp),%edx
  80459e:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
  data.err = err;
  8045a1:	89 f0                	mov    %esi,%eax
  8045a3:	88 45 e0             	mov    %al,0xffffffe0(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  8045a6:	83 ec 04             	sub    $0x4,%esp
  8045a9:	6a 01                	push   $0x1
  8045ab:	8d 45 c8             	lea    0xffffffc8(%ebp),%eax
  8045ae:	50                   	push   %eax
  8045af:	68 ef 45 80 00       	push   $0x8045ef
  8045b4:	e8 32 08 00 00       	call   804deb <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  8045b9:	83 c4 08             	add    $0x8,%esp
  8045bc:	6a 00                	push   $0x0
  8045be:	8b 03                	mov    (%ebx),%eax
  8045c0:	ff 70 10             	pushl  0x10(%eax)
  8045c3:	e8 14 8a 00 00       	call   80cfdc <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  8045c8:	0f b6 75 e0          	movzbl 0xffffffe0(%ebp),%esi

  sock_set_errno(sock, err);
  8045cc:	89 f2                	mov    %esi,%edx
  8045ce:	0f be c2             	movsbl %dl,%eax
  8045d1:	89 43 10             	mov    %eax,0x10(%ebx)
  8045d4:	a3 00 e6 b3 00       	mov    %eax,0xb3e600
  8045d9:	83 c4 10             	add    $0x10,%esp
  return err ? -1 : 0;
  8045dc:	80 fa 01             	cmp    $0x1,%dl
  8045df:	19 c0                	sbb    %eax,%eax
  8045e1:	89 c2                	mov    %eax,%edx
  8045e3:	f7 d2                	not    %edx
}
  8045e5:	89 d0                	mov    %edx,%eax
  8045e7:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8045ea:	5b                   	pop    %ebx
  8045eb:	5e                   	pop    %esi
  8045ec:	5f                   	pop    %edi
  8045ed:	c9                   	leave  
  8045ee:	c3                   	ret    

008045ef <lwip_getsockopt_internal>:

static void
lwip_getsockopt_internal(void *arg)
{
  8045ef:	55                   	push   %ebp
  8045f0:	89 e5                	mov    %esp,%ebp
  8045f2:	56                   	push   %esi
  8045f3:	53                   	push   %ebx
  8045f4:	8b 45 08             	mov    0x8(%ebp),%eax
  struct lwip_socket *sock;
#ifdef LWIP_DEBUG
  int s;
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  8045f7:	85 c0                	test   %eax,%eax
  8045f9:	75 17                	jne    804612 <lwip_getsockopt_internal+0x23>
  8045fb:	83 ec 04             	sub    $0x4,%esp
  8045fe:	68 83 24 81 00       	push   $0x812483
  804603:	68 38 05 00 00       	push   $0x538
  804608:	68 f1 23 81 00       	push   $0x8123f1
  80460d:	e8 ba c4 ff ff       	call   800acc <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  804612:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  804614:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  804617:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  80461a:	8b 70 10             	mov    0x10(%eax),%esi

  switch (level) {
  80461d:	83 fa 06             	cmp    $0x6,%edx
  804620:	0f 84 39 01 00 00    	je     80475f <lwip_getsockopt_internal+0x170>
  804626:	83 fa 06             	cmp    $0x6,%edx
  804629:	7f 0d                	jg     804638 <lwip_getsockopt_internal+0x49>
  80462b:	85 d2                	test   %edx,%edx
  80462d:	0f 84 08 01 00 00    	je     80473b <lwip_getsockopt_internal+0x14c>
  804633:	e9 50 01 00 00       	jmp    804788 <lwip_getsockopt_internal+0x199>
  804638:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  80463e:	0f 85 44 01 00 00    	jne    804788 <lwip_getsockopt_internal+0x199>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  804644:	83 f9 20             	cmp    $0x20,%ecx
  804647:	74 42                	je     80468b <lwip_getsockopt_internal+0x9c>
  804649:	83 f9 20             	cmp    $0x20,%ecx
  80464c:	7f 0f                	jg     80465d <lwip_getsockopt_internal+0x6e>
  80464e:	83 f9 02             	cmp    $0x2,%ecx
  804651:	74 38                	je     80468b <lwip_getsockopt_internal+0x9c>
  804653:	83 f9 08             	cmp    $0x8,%ecx
  804656:	74 33                	je     80468b <lwip_getsockopt_internal+0x9c>
  804658:	e9 2b 01 00 00       	jmp    804788 <lwip_getsockopt_internal+0x199>
  80465d:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  804663:	74 38                	je     80469d <lwip_getsockopt_internal+0xae>
  804665:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  80466b:	7f 0d                	jg     80467a <lwip_getsockopt_internal+0x8b>
  80466d:	81 f9 07 10 00 00    	cmp    $0x1007,%ecx
  804673:	74 73                	je     8046e8 <lwip_getsockopt_internal+0xf9>
  804675:	e9 0e 01 00 00       	jmp    804788 <lwip_getsockopt_internal+0x199>
  80467a:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  804680:	0f 84 a2 00 00 00    	je     804728 <lwip_getsockopt_internal+0x139>
  804686:	e9 fd 00 00 00       	jmp    804788 <lwip_getsockopt_internal+0x199>

    /* The option flags */
    case SO_ACCEPTCONN:
    case SO_BROADCAST:
    /* UNIMPL case SO_DEBUG: */
    /* UNIMPL case SO_DONTROUTE: */
    case SO_KEEPALIVE:
    /* UNIMPL case SO_OOBINCLUDE: */
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  80468b:	8b 03                	mov    (%ebx),%eax
  80468d:	8b 40 08             	mov    0x8(%eax),%eax
  804690:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  804694:	21 c8                	and    %ecx,%eax
  804696:	89 06                	mov    %eax,(%esi)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  804698:	e9 eb 00 00 00       	jmp    804788 <lwip_getsockopt_internal+0x199>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  80469d:	8b 03                	mov    (%ebx),%eax
  80469f:	8b 00                	mov    (%eax),%eax
  8046a1:	25 f0 00 00 00       	and    $0xf0,%eax
  8046a6:	83 f8 20             	cmp    $0x20,%eax
  8046a9:	74 27                	je     8046d2 <lwip_getsockopt_internal+0xe3>
  8046ab:	83 f8 20             	cmp    $0x20,%eax
  8046ae:	77 07                	ja     8046b7 <lwip_getsockopt_internal+0xc8>
  8046b0:	83 f8 10             	cmp    $0x10,%eax
  8046b3:	74 12                	je     8046c7 <lwip_getsockopt_internal+0xd8>
  8046b5:	eb 26                	jmp    8046dd <lwip_getsockopt_internal+0xee>
  8046b7:	83 f8 40             	cmp    $0x40,%eax
  8046ba:	75 21                	jne    8046dd <lwip_getsockopt_internal+0xee>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  8046bc:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
        break;
  8046c2:	e9 c1 00 00 00       	jmp    804788 <lwip_getsockopt_internal+0x199>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  8046c7:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
        break;
  8046cd:	e9 b6 00 00 00       	jmp    804788 <lwip_getsockopt_internal+0x199>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  8046d2:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
        break;
  8046d8:	e9 ab 00 00 00       	jmp    804788 <lwip_getsockopt_internal+0x199>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  8046dd:	8b 03                	mov    (%ebx),%eax
  8046df:	8b 00                	mov    (%eax),%eax
  8046e1:	89 06                	mov    %eax,(%esi)
        LWIP_DEBUGF(SOCKETS_DEBUG,
                    ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
                    s, *(int *)optval));
      }  /* switch (sock->conn->type) */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;
  8046e3:	e9 a0 00 00 00       	jmp    804788 <lwip_getsockopt_internal+0x199>

    case SO_ERROR:
      if (sock->err == 0) {
  8046e8:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8046ec:	75 2c                	jne    80471a <lwip_getsockopt_internal+0x12b>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  8046ee:	8b 03                	mov    (%ebx),%eax
  8046f0:	0f be 48 0c          	movsbl 0xc(%eax),%ecx
  8046f4:	89 c8                	mov    %ecx,%eax
  8046f6:	f7 d8                	neg    %eax
  8046f8:	ba 05 00 00 00       	mov    $0x5,%edx
  8046fd:	83 f8 0e             	cmp    $0xe,%eax
  804700:	77 0f                	ja     804711 <lwip_getsockopt_internal+0x122>
  804702:	8d 04 8d 00 00 00 00 	lea    0x0(,%ecx,4),%eax
  804709:	f7 d8                	neg    %eax
  80470b:	8b 90 a0 23 81 00    	mov    0x8123a0(%eax),%edx
  804711:	89 53 10             	mov    %edx,0x10(%ebx)
  804714:	89 15 00 e6 b3 00    	mov    %edx,0xb3e600
      } 
      *(int *)optval = sock->err;
  80471a:	8b 43 10             	mov    0x10(%ebx),%eax
  80471d:	89 06                	mov    %eax,(%esi)
      sock->err = 0;
  80471f:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  804726:	eb 60                	jmp    804788 <lwip_getsockopt_internal+0x199>

#if LWIP_SO_RCVTIMEO
    case SO_RCVTIMEO:
      *(int *)optval = sock->conn->recv_timeout;
      break;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
    case SO_RCVBUF:
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  804728:	8b 03                	mov    (%ebx),%eax
  80472a:	8b 40 08             	mov    0x8(%eax),%eax
  80472d:	f6 40 10 01          	testb  $0x1,0x10(%eax)
  804731:	0f 95 c0             	setne  %al
  804734:	0f b6 c0             	movzbl %al,%eax
  804737:	89 06                	mov    %eax,(%esi)
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  804739:	eb 4d                	jmp    804788 <lwip_getsockopt_internal+0x199>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  80473b:	83 f9 01             	cmp    $0x1,%ecx
  80473e:	74 12                	je     804752 <lwip_getsockopt_internal+0x163>
  804740:	83 f9 02             	cmp    $0x2,%ecx
  804743:	75 43                	jne    804788 <lwip_getsockopt_internal+0x199>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  804745:	8b 03                	mov    (%ebx),%eax
  804747:	8b 40 08             	mov    0x8(%eax),%eax
  80474a:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  80474e:	89 06                	mov    %eax,(%esi)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  804750:	eb 36                	jmp    804788 <lwip_getsockopt_internal+0x199>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  804752:	8b 03                	mov    (%ebx),%eax
  804754:	8b 40 08             	mov    0x8(%eax),%eax
  804757:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  80475b:	89 06                	mov    %eax,(%esi)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
#if LWIP_IGMP
    case IP_MULTICAST_TTL:
      *(u8_t*)optval = sock->conn->pcb.ip->ttl;
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_TTL) = %d\n",
                  s, *(int *)optval));
      break;
    case IP_MULTICAST_IF:
      ((struct in_addr*) optval)->s_addr = sock->conn->pcb.udp->multicast_ip.addr;
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  80475d:	eb 29                	jmp    804788 <lwip_getsockopt_internal+0x199>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  80475f:	83 f9 01             	cmp    $0x1,%ecx
  804762:	74 07                	je     80476b <lwip_getsockopt_internal+0x17c>
  804764:	83 f9 02             	cmp    $0x2,%ecx
  804767:	74 12                	je     80477b <lwip_getsockopt_internal+0x18c>
  804769:	eb 1d                	jmp    804788 <lwip_getsockopt_internal+0x199>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  80476b:	8b 03                	mov    (%ebx),%eax
  80476d:	8b 40 08             	mov    0x8(%eax),%eax
  804770:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  804774:	83 e0 40             	and    $0x40,%eax
  804777:	89 06                	mov    %eax,(%esi)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  804779:	eb 0d                	jmp    804788 <lwip_getsockopt_internal+0x199>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  80477b:	8b 03                	mov    (%ebx),%eax
  80477d:	8b 40 08             	mov    0x8(%eax),%eax
  804780:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  804786:	89 06                	mov    %eax,(%esi)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",
                  s, *(int *)optval));
      break;

#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
      *(int*)optval = (int)(sock->conn->pcb.tcp->keep_idle/1000);
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPIDLE) = %d\n",
                  s, *(int *)optval));
      break;
    case TCP_KEEPINTVL:
      *(int*)optval = (int)(sock->conn->pcb.tcp->keep_intvl/1000);
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPINTVL) = %d\n",
                  s, *(int *)optval));
      break;
    case TCP_KEEPCNT:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_cnt;
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPCNT) = %d\n",
                  s, *(int *)optval));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
#endif /* LWIP_TCP */
#if LWIP_UDP && LWIP_UDPLITE
  /* Level: IPPROTO_UDPLITE */
  case IPPROTO_UDPLITE:
    switch (optname) {
    case UDPLITE_SEND_CSCOV:
      *(int*)optval = sock->conn->pcb.udp->chksum_len_tx;
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV) = %d\n",
                  s, (*(int*)optval)) );
      break;
    case UDPLITE_RECV_CSCOV:
      *(int*)optval = sock->conn->pcb.udp->chksum_len_rx;
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV) = %d\n",
                  s, (*(int*)optval)) );
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  804788:	83 ec 0c             	sub    $0xc,%esp
  80478b:	8b 03                	mov    (%ebx),%eax
  80478d:	ff 70 10             	pushl  0x10(%eax)
  804790:	e8 e5 87 00 00       	call   80cf7a <sys_sem_signal>
}
  804795:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  804798:	5b                   	pop    %ebx
  804799:	5e                   	pop    %esi
  80479a:	c9                   	leave  
  80479b:	c3                   	ret    

0080479c <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  80479c:	55                   	push   %ebp
  80479d:	89 e5                	mov    %esp,%ebp
  80479f:	57                   	push   %edi
  8047a0:	56                   	push   %esi
  8047a1:	53                   	push   %ebx
  8047a2:	83 ec 2c             	sub    $0x2c,%esp
  8047a5:	8b 75 0c             	mov    0xc(%ebp),%esi
  8047a8:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  8047ab:	ff 75 08             	pushl  0x8(%ebp)
  8047ae:	e8 9a ea ff ff       	call   80324d <get_socket>
  8047b3:	89 c3                	mov    %eax,%ebx
  int err = ERR_OK;
  8047b5:	ba 00 00 00 00       	mov    $0x0,%edx
  struct lwip_setgetsockopt_data data;

  if (!sock)
  8047ba:	83 c4 04             	add    $0x4,%esp
    return -1;
  8047bd:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  8047c2:	85 c0                	test   %eax,%eax
  8047c4:	0f 84 45 01 00 00    	je     80490f <lwip_setsockopt+0x173>

  if (NULL == optval) {
  8047ca:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  8047ce:	75 1b                	jne    8047eb <lwip_setsockopt+0x4f>
    sock_set_errno(sock, EFAULT);
  8047d0:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  8047d7:	c7 05 00 e6 b3 00 0e 	movl   $0xe,0xb3e600
  8047de:	00 00 00 
    return -1;
  8047e1:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  8047e6:	e9 24 01 00 00       	jmp    80490f <lwip_setsockopt+0x173>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  8047eb:	83 fe 06             	cmp    $0x6,%esi
  8047ee:	0f 84 87 00 00 00    	je     80487b <lwip_setsockopt+0xdf>
  8047f4:	83 fe 06             	cmp    $0x6,%esi
  8047f7:	7f 09                	jg     804802 <lwip_setsockopt+0x66>
  8047f9:	85 f6                	test   %esi,%esi
  8047fb:	74 62                	je     80485f <lwip_setsockopt+0xc3>
  8047fd:	e9 a1 00 00 00       	jmp    8048a3 <lwip_setsockopt+0x107>
  804802:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  804808:	0f 85 95 00 00 00    	jne    8048a3 <lwip_setsockopt+0x107>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80480e:	83 ff 20             	cmp    $0x20,%edi
  804811:	74 16                	je     804829 <lwip_setsockopt+0x8d>
  804813:	83 ff 20             	cmp    $0x20,%edi
  804816:	7f 07                	jg     80481f <lwip_setsockopt+0x83>
  804818:	83 ff 08             	cmp    $0x8,%edi
  80481b:	74 0c                	je     804829 <lwip_setsockopt+0x8d>
  80481d:	eb 39                	jmp    804858 <lwip_setsockopt+0xbc>
  80481f:	81 ff 0a 10 00 00    	cmp    $0x100a,%edi
  804825:	74 0f                	je     804836 <lwip_setsockopt+0x9a>
  804827:	eb 2f                	jmp    804858 <lwip_setsockopt+0xbc>

    case SO_BROADCAST:
    /* UNIMPL case SO_DEBUG: */
    /* UNIMPL case SO_DONTROUTE: */
    case SO_KEEPALIVE:
    /* UNIMPL case case SO_CONTIMEO: */
    /* UNIMPL case case SO_SNDTIMEO: */
#if LWIP_SO_RCVTIMEO
    case SO_RCVTIMEO:
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
    case SO_RCVBUF:
#endif /* LWIP_SO_RCVBUF */
    /* UNIMPL case SO_OOBINLINE: */
    /* UNIMPL case SO_SNDBUF: */
    /* UNIMPL case SO_RCVLOWAT: */
    /* UNIMPL case SO_SNDLOWAT: */
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  804829:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80482d:	77 79                	ja     8048a8 <lwip_setsockopt+0x10c>
        err = EINVAL;
  80482f:	ba 16 00 00 00       	mov    $0x16,%edx
      }
      break;
  804834:	eb 72                	jmp    8048a8 <lwip_setsockopt+0x10c>
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
  804836:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80483a:	77 05                	ja     804841 <lwip_setsockopt+0xa5>
        err = EINVAL;
  80483c:	ba 16 00 00 00       	mov    $0x16,%edx
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  804841:	8b 03                	mov    (%ebx),%eax
  804843:	83 38 20             	cmpl   $0x20,(%eax)
  804846:	75 09                	jne    804851 <lwip_setsockopt+0xb5>
  804848:	8b 40 08             	mov    0x8(%eax),%eax
  80484b:	f6 40 10 02          	testb  $0x2,0x10(%eax)
  80484f:	74 57                	je     8048a8 <lwip_setsockopt+0x10c>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  804851:	ba 61 00 00 00       	mov    $0x61,%edx
      }
#endif /* LWIP_UDP */
      break;
  804856:	eb 50                	jmp    8048a8 <lwip_setsockopt+0x10c>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  804858:	ba 5c 00 00 00       	mov    $0x5c,%edx
    }  /* switch (optname) */
    break;
  80485d:	eb 49                	jmp    8048a8 <lwip_setsockopt+0x10c>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  80485f:	8d 47 ff             	lea    0xffffffff(%edi),%eax
  804862:	83 f8 01             	cmp    $0x1,%eax
  804865:	77 0d                	ja     804874 <lwip_setsockopt+0xd8>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  804867:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80486b:	77 3b                	ja     8048a8 <lwip_setsockopt+0x10c>
        err = EINVAL;
  80486d:	ba 16 00 00 00       	mov    $0x16,%edx
      }
      break;
  804872:	eb 34                	jmp    8048a8 <lwip_setsockopt+0x10c>
#if LWIP_IGMP
    case IP_MULTICAST_TTL:
      if (optlen < sizeof(u8_t)) {
        err = EINVAL;
      }
      if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
        err = EAFNOSUPPORT;
      }
      break;
    case IP_MULTICAST_IF:
      if (optlen < sizeof(struct in_addr)) {
        err = EINVAL;
      }
      if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
        err = EAFNOSUPPORT;
      }
      break;
    case IP_ADD_MEMBERSHIP:
    case IP_DROP_MEMBERSHIP:
      if (optlen < sizeof(struct ip_mreq)) {
        err = EINVAL;
      }
      if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
        err = EAFNOSUPPORT;
      }
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  804874:	ba 5c 00 00 00       	mov    $0x5c,%edx
    }  /* switch (optname) */
    break;
  804879:	eb 2d                	jmp    8048a8 <lwip_setsockopt+0x10c>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  80487b:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80487f:	77 07                	ja     804888 <lwip_setsockopt+0xec>
      err = EINVAL;
  804881:	ba 16 00 00 00       	mov    $0x16,%edx
      break;
  804886:	eb 20                	jmp    8048a8 <lwip_setsockopt+0x10c>
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  804888:	8b 00                	mov    (%eax),%eax
      return 0;
  80488a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80488f:	83 38 10             	cmpl   $0x10,(%eax)
  804892:	75 7b                	jne    80490f <lwip_setsockopt+0x173>

    switch (optname) {
  804894:	8d 47 ff             	lea    0xffffffff(%edi),%eax
  804897:	83 f8 01             	cmp    $0x1,%eax
  80489a:	76 0c                	jbe    8048a8 <lwip_setsockopt+0x10c>
    case TCP_NODELAY:
    case TCP_KEEPALIVE:
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  80489c:	ba 5c 00 00 00       	mov    $0x5c,%edx
    }  /* switch (optname) */
    break;
  8048a1:	eb 05                	jmp    8048a8 <lwip_setsockopt+0x10c>
#endif /* LWIP_TCP */
#if LWIP_UDP && LWIP_UDPLITE
/* Level: IPPROTO_UDPLITE */
  case IPPROTO_UDPLITE:
    if (optlen < sizeof(int)) {
      err = EINVAL;
      break;
    }

    /* If this is no UDP lite socket, ignore any options. */
    if (sock->conn->type != NETCONN_UDPLITE)
      return 0;

    switch (optname) {
    case UDPLITE_SEND_CSCOV:
    case UDPLITE_RECV_CSCOV:
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  8048a3:	ba 5c 00 00 00       	mov    $0x5c,%edx
  }  /* switch (level) */


  if (err != ERR_OK) {
  8048a8:	85 d2                	test   %edx,%edx
  8048aa:	74 10                	je     8048bc <lwip_setsockopt+0x120>
    sock_set_errno(sock, err);
  8048ac:	89 53 10             	mov    %edx,0x10(%ebx)
  8048af:	89 15 00 e6 b3 00    	mov    %edx,0xb3e600
    return -1;
  8048b5:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  8048ba:	eb 53                	jmp    80490f <lwip_setsockopt+0x173>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  8048bc:	89 5d c8             	mov    %ebx,0xffffffc8(%ebp)
  data.level = level;
  8048bf:	89 75 d0             	mov    %esi,0xffffffd0(%ebp)
  data.optname = optname;
  8048c2:	89 7d d4             	mov    %edi,0xffffffd4(%ebp)
  data.optval = (void*)optval;
  8048c5:	8b 45 14             	mov    0x14(%ebp),%eax
  8048c8:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  data.optlen = &optlen;
  8048cb:	8d 45 18             	lea    0x18(%ebp),%eax
  8048ce:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  data.err = err;
  8048d1:	88 55 e0             	mov    %dl,0xffffffe0(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  8048d4:	83 ec 04             	sub    $0x4,%esp
  8048d7:	6a 01                	push   $0x1
  8048d9:	8d 45 c8             	lea    0xffffffc8(%ebp),%eax
  8048dc:	50                   	push   %eax
  8048dd:	68 19 49 80 00       	push   $0x804919
  8048e2:	e8 04 05 00 00       	call   804deb <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  8048e7:	83 c4 08             	add    $0x8,%esp
  8048ea:	6a 00                	push   $0x0
  8048ec:	8b 03                	mov    (%ebx),%eax
  8048ee:	ff 70 10             	pushl  0x10(%eax)
  8048f1:	e8 e6 86 00 00       	call   80cfdc <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  8048f6:	0f be 55 e0          	movsbl 0xffffffe0(%ebp),%edx

  sock_set_errno(sock, err);
  8048fa:	89 53 10             	mov    %edx,0x10(%ebx)
  8048fd:	89 15 00 e6 b3 00    	mov    %edx,0xb3e600
  804903:	83 c4 10             	add    $0x10,%esp
  return err ? -1 : 0;
  804906:	83 fa 01             	cmp    $0x1,%edx
  804909:	19 c0                	sbb    %eax,%eax
  80490b:	89 c1                	mov    %eax,%ecx
  80490d:	f7 d1                	not    %ecx
}
  80490f:	89 c8                	mov    %ecx,%eax
  804911:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  804914:	5b                   	pop    %ebx
  804915:	5e                   	pop    %esi
  804916:	5f                   	pop    %edi
  804917:	c9                   	leave  
  804918:	c3                   	ret    

00804919 <lwip_setsockopt_internal>:

static void
lwip_setsockopt_internal(void *arg)
{
  804919:	55                   	push   %ebp
  80491a:	89 e5                	mov    %esp,%ebp
  80491c:	56                   	push   %esi
  80491d:	53                   	push   %ebx
  80491e:	8b 45 08             	mov    0x8(%ebp),%eax
  struct lwip_socket *sock;
#ifdef LWIP_DEBUG
  int s;
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  804921:	85 c0                	test   %eax,%eax
  804923:	75 17                	jne    80493c <lwip_setsockopt_internal+0x23>
  804925:	83 ec 04             	sub    $0x4,%esp
  804928:	68 83 24 81 00       	push   $0x812483
  80492d:	68 ae 06 00 00       	push   $0x6ae
  804932:	68 f1 23 81 00       	push   $0x8123f1
  804937:	e8 90 c1 ff ff       	call   800acc <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  80493c:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  80493e:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  804941:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  804944:	8b 70 10             	mov    0x10(%eax),%esi

  switch (level) {
  804947:	83 fa 06             	cmp    $0x6,%edx
  80494a:	0f 84 9a 00 00 00    	je     8049ea <lwip_setsockopt_internal+0xd1>
  804950:	83 fa 06             	cmp    $0x6,%edx
  804953:	7f 09                	jg     80495e <lwip_setsockopt_internal+0x45>
  804955:	85 d2                	test   %edx,%edx
  804957:	74 6f                	je     8049c8 <lwip_setsockopt_internal+0xaf>
  804959:	e9 c0 00 00 00       	jmp    804a1e <lwip_setsockopt_internal+0x105>
  80495e:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  804964:	0f 85 b4 00 00 00    	jne    804a1e <lwip_setsockopt_internal+0x105>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80496a:	83 f9 20             	cmp    $0x20,%ecx
  80496d:	74 1c                	je     80498b <lwip_setsockopt_internal+0x72>
  80496f:	83 f9 20             	cmp    $0x20,%ecx
  804972:	7f 0a                	jg     80497e <lwip_setsockopt_internal+0x65>
  804974:	83 f9 08             	cmp    $0x8,%ecx
  804977:	74 12                	je     80498b <lwip_setsockopt_internal+0x72>
  804979:	e9 a0 00 00 00       	jmp    804a1e <lwip_setsockopt_internal+0x105>
  80497e:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  804984:	74 27                	je     8049ad <lwip_setsockopt_internal+0x94>
  804986:	e9 93 00 00 00       	jmp    804a1e <lwip_setsockopt_internal+0x105>

    /* The option flags */
    case SO_BROADCAST:
    /* UNIMPL case SO_DEBUG: */
    /* UNIMPL case SO_DONTROUTE: */
    case SO_KEEPALIVE:
    /* UNIMPL case SO_OOBINCLUDE: */
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  80498b:	83 3e 00             	cmpl   $0x0,(%esi)
  80498e:	74 0e                	je     80499e <lwip_setsockopt_internal+0x85>
        sock->conn->pcb.ip->so_options |= optname;
  804990:	8b 03                	mov    (%ebx),%eax
  804992:	8b 40 08             	mov    0x8(%eax),%eax
  804995:	66 09 48 08          	or     %cx,0x8(%eax)
  804999:	e9 80 00 00 00       	jmp    804a1e <lwip_setsockopt_internal+0x105>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  80499e:	8b 03                	mov    (%ebx),%eax
  8049a0:	8b 50 08             	mov    0x8(%eax),%edx
  8049a3:	89 c8                	mov    %ecx,%eax
  8049a5:	f7 d0                	not    %eax
  8049a7:	66 21 42 08          	and    %ax,0x8(%edx)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
  8049ab:	eb 71                	jmp    804a1e <lwip_setsockopt_internal+0x105>
#if LWIP_SO_RCVTIMEO
    case SO_RCVTIMEO:
      sock->conn->recv_timeout = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
    case SO_RCVBUF:
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  8049ad:	83 3e 00             	cmpl   $0x0,(%esi)
  8049b0:	74 0b                	je     8049bd <lwip_setsockopt_internal+0xa4>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  8049b2:	8b 03                	mov    (%ebx),%eax
  8049b4:	8b 40 08             	mov    0x8(%eax),%eax
  8049b7:	80 48 10 01          	orb    $0x1,0x10(%eax)
  8049bb:	eb 61                	jmp    804a1e <lwip_setsockopt_internal+0x105>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  8049bd:	8b 03                	mov    (%ebx),%eax
  8049bf:	8b 40 08             	mov    0x8(%eax),%eax
  8049c2:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
      }
      break;
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
  8049c6:	eb 56                	jmp    804a1e <lwip_setsockopt_internal+0x105>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8049c8:	83 f9 01             	cmp    $0x1,%ecx
  8049cb:	74 11                	je     8049de <lwip_setsockopt_internal+0xc5>
  8049cd:	83 f9 02             	cmp    $0x2,%ecx
  8049d0:	75 4c                	jne    804a1e <lwip_setsockopt_internal+0x105>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  8049d2:	8b 03                	mov    (%ebx),%eax
  8049d4:	8b 50 08             	mov    0x8(%eax),%edx
  8049d7:	8b 06                	mov    (%esi),%eax
  8049d9:	88 42 0b             	mov    %al,0xb(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  8049dc:	eb 40                	jmp    804a1e <lwip_setsockopt_internal+0x105>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  8049de:	8b 03                	mov    (%ebx),%eax
  8049e0:	8b 50 08             	mov    0x8(%eax),%edx
  8049e3:	8b 06                	mov    (%esi),%eax
  8049e5:	88 42 0a             	mov    %al,0xa(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
#if LWIP_IGMP
    case IP_MULTICAST_TTL:
      sock->conn->pcb.udp->ttl = (u8_t)(*(u8_t*)optval);
      break;
    case IP_MULTICAST_IF:
      sock->conn->pcb.udp->multicast_ip.addr = ((struct in_addr*) optval)->s_addr;
      break;
    case IP_ADD_MEMBERSHIP:
    case IP_DROP_MEMBERSHIP:
      {
        /* If this is a TCP or a RAW socket, ignore these options. */
        struct ip_mreq *imr = (struct ip_mreq *)optval;
        if(optname == IP_ADD_MEMBERSHIP){
          data->err = igmp_joingroup((struct ip_addr*)&(imr->imr_interface.s_addr), (struct ip_addr*)&(imr->imr_multiaddr.s_addr));
        } else {
          data->err = igmp_leavegroup((struct ip_addr*)&(imr->imr_interface.s_addr), (struct ip_addr*)&(imr->imr_multiaddr.s_addr));
        }
        if(data->err != ERR_OK) {
          data->err = EADDRNOTAVAIL;
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  8049e8:	eb 34                	jmp    804a1e <lwip_setsockopt_internal+0x105>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  8049ea:	83 f9 01             	cmp    $0x1,%ecx
  8049ed:	74 07                	je     8049f6 <lwip_setsockopt_internal+0xdd>
  8049ef:	83 f9 02             	cmp    $0x2,%ecx
  8049f2:	74 1d                	je     804a11 <lwip_setsockopt_internal+0xf8>
  8049f4:	eb 28                	jmp    804a1e <lwip_setsockopt_internal+0x105>
    case TCP_NODELAY:
      if (*(int*)optval) {
  8049f6:	83 3e 00             	cmpl   $0x0,(%esi)
  8049f9:	74 0b                	je     804a06 <lwip_setsockopt_internal+0xed>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  8049fb:	8b 03                	mov    (%ebx),%eax
  8049fd:	8b 40 08             	mov    0x8(%eax),%eax
  804a00:	80 48 20 40          	orb    $0x40,0x20(%eax)
  804a04:	eb 18                	jmp    804a1e <lwip_setsockopt_internal+0x105>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  804a06:	8b 03                	mov    (%ebx),%eax
  804a08:	8b 40 08             	mov    0x8(%eax),%eax
  804a0b:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
  804a0f:	eb 0d                	jmp    804a1e <lwip_setsockopt_internal+0x105>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  804a11:	8b 03                	mov    (%ebx),%eax
  804a13:	8b 50 08             	mov    0x8(%eax),%edx
  804a16:	8b 06                	mov    (%esi),%eax
  804a18:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %lu\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;

#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
      sock->conn->pcb.tcp->keep_idle = 1000*(u32_t)(*(int*)optval);
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPIDLE) -> %lu\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
    case TCP_KEEPINTVL:
      sock->conn->pcb.tcp->keep_intvl = 1000*(u32_t)(*(int*)optval);
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPINTVL) -> %lu\n",
                  s, sock->conn->pcb.tcp->keep_intvl));
      break;
    case TCP_KEEPCNT:
      sock->conn->pcb.tcp->keep_cnt = (u32_t)(*(int*)optval);
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) -> %lu\n",
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
#endif /* LWIP_TCP*/
#if LWIP_UDP && LWIP_UDPLITE
  /* Level: IPPROTO_UDPLITE */
  case IPPROTO_UDPLITE:
    switch (optname) {
    case UDPLITE_SEND_CSCOV:
      if ((*(int*)optval != 0) && (*(int*)optval < 8)) {
        /* don't allow illegal values! */
        sock->conn->pcb.udp->chksum_len_tx = 8;
      } else {
        sock->conn->pcb.udp->chksum_len_tx = *(int*)optval;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV) -> %d\n",
                  s, (*(int*)optval)) );
      break;
    case UDPLITE_RECV_CSCOV:
      if ((*(int*)optval != 0) && (*(int*)optval < 8)) {
        /* don't allow illegal values! */
        sock->conn->pcb.udp->chksum_len_rx = 8;
      } else {
        sock->conn->pcb.udp->chksum_len_rx = *(int*)optval;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV) -> %d\n",
                  s, (*(int*)optval)) );
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  804a1e:	83 ec 0c             	sub    $0xc,%esp
  804a21:	8b 03                	mov    (%ebx),%eax
  804a23:	ff 70 10             	pushl  0x10(%eax)
  804a26:	e8 4f 85 00 00       	call   80cf7a <sys_sem_signal>
}
  804a2b:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  804a2e:	5b                   	pop    %ebx
  804a2f:	5e                   	pop    %esi
  804a30:	c9                   	leave  
  804a31:	c3                   	ret    

00804a32 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  804a32:	55                   	push   %ebp
  804a33:	89 e5                	mov    %esp,%ebp
  804a35:	56                   	push   %esi
  804a36:	53                   	push   %ebx
  804a37:	8b 75 0c             	mov    0xc(%ebp),%esi
  804a3a:	8b 5d 10             	mov    0x10(%ebp),%ebx
  struct lwip_socket *sock = get_socket(s);
  804a3d:	ff 75 08             	pushl  0x8(%ebp)
  804a40:	e8 08 e8 ff ff       	call   80324d <get_socket>
  804a45:	89 c2                	mov    %eax,%edx
  u16_t buflen = 0;

  if (!sock)
  804a47:	83 c4 04             	add    $0x4,%esp
    return -1;
  804a4a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804a4f:	85 d2                	test   %edx,%edx
  804a51:	0f 84 ae 00 00 00    	je     804b05 <lwip_ioctl+0xd3>

  switch (cmd) {
  804a57:	81 fe 7e 66 04 80    	cmp    $0x8004667e,%esi
  804a5d:	74 61                	je     804ac0 <lwip_ioctl+0x8e>
  804a5f:	81 fe 7f 66 04 40    	cmp    $0x4004667f,%esi
  804a65:	0f 85 84 00 00 00    	jne    804aef <lwip_ioctl+0xbd>
  case FIONREAD:
    if (!argp) {
  804a6b:	85 db                	test   %ebx,%ebx
  804a6d:	75 18                	jne    804a87 <lwip_ioctl+0x55>
      sock_set_errno(sock, EINVAL);
  804a6f:	c7 42 10 16 00 00 00 	movl   $0x16,0x10(%edx)
  804a76:	c7 05 00 e6 b3 00 16 	movl   $0x16,0xb3e600
  804a7d:	00 00 00 
      return -1;
  804a80:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804a85:	eb 7e                	jmp    804b05 <lwip_ioctl+0xd3>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  804a87:	8b 02                	mov    (%edx),%eax
  804a89:	66 8b 48 20          	mov    0x20(%eax),%cx
  804a8d:	66 89 0b             	mov    %cx,(%ebx)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  804a90:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
  804a94:	74 12                	je     804aa8 <lwip_ioctl+0x76>
      buflen = netbuf_len(sock->lastdata);
  804a96:	8b 42 04             	mov    0x4(%edx),%eax
  804a99:	8b 00                	mov    (%eax),%eax
  804a9b:	66 8b 40 08          	mov    0x8(%eax),%ax
      buflen -= sock->lastoffset;
  804a9f:	66 2b 42 08          	sub    0x8(%edx),%ax

      *((u16_t*)argp) += buflen;
  804aa3:	01 c8                	add    %ecx,%eax
  804aa5:	66 89 03             	mov    %ax,(%ebx)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  804aa8:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
  804aaf:	c7 05 00 e6 b3 00 00 	movl   $0x0,0xb3e600
  804ab6:	00 00 00 
    return 0;
  804ab9:	b8 00 00 00 00       	mov    $0x0,%eax
  804abe:	eb 45                	jmp    804b05 <lwip_ioctl+0xd3>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  804ac0:	85 db                	test   %ebx,%ebx
  804ac2:	74 0d                	je     804ad1 <lwip_ioctl+0x9f>
  804ac4:	83 3b 00             	cmpl   $0x0,(%ebx)
  804ac7:	74 08                	je     804ad1 <lwip_ioctl+0x9f>
      sock->flags |= O_NONBLOCK;
  804ac9:	66 81 4a 0e 00 08    	orw    $0x800,0xe(%edx)
  804acf:	eb 06                	jmp    804ad7 <lwip_ioctl+0xa5>
    else
      sock->flags &= ~O_NONBLOCK;
  804ad1:	66 81 62 0e ff f7    	andw   $0xf7ff,0xe(%edx)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  804ad7:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
  804ade:	c7 05 00 e6 b3 00 00 	movl   $0x0,0xb3e600
  804ae5:	00 00 00 
    return 0;
  804ae8:	b8 00 00 00 00       	mov    $0x0,%eax
  804aed:	eb 16                	jmp    804b05 <lwip_ioctl+0xd3>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  804aef:	c7 42 10 26 00 00 00 	movl   $0x26,0x10(%edx)
  804af6:	c7 05 00 e6 b3 00 26 	movl   $0x26,0xb3e600
  804afd:	00 00 00 
    return -1;
  804b00:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  } /* switch (cmd) */
}
  804b05:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  804b08:	5b                   	pop    %ebx
  804b09:	5e                   	pop    %esi
  804b0a:	c9                   	leave  
  804b0b:	c3                   	ret    

00804b0c <tcpip_tcp_timer>:
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  804b0c:	55                   	push   %ebp
  804b0d:	89 e5                	mov    %esp,%ebp
  804b0f:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  804b12:	e8 b1 35 00 00       	call   8080c8 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  804b17:	83 3d 68 e6 b3 00 00 	cmpl   $0x0,0xb3e668
  804b1e:	75 09                	jne    804b29 <tcpip_tcp_timer+0x1d>
  804b20:	83 3d 7c e6 b3 00 00 	cmpl   $0x0,0xb3e67c
  804b27:	74 19                	je     804b42 <tcpip_tcp_timer+0x36>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  804b29:	83 ec 04             	sub    $0x4,%esp
  804b2c:	6a 00                	push   $0x0
  804b2e:	68 0c 4b 80 00       	push   $0x804b0c
  804b33:	68 fa 00 00 00       	push   $0xfa
  804b38:	e8 9f 33 00 00       	call   807edc <sys_timeout>
  804b3d:	83 c4 10             	add    $0x10,%esp
  804b40:	eb 0a                	jmp    804b4c <tcpip_tcp_timer+0x40>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  804b42:	c7 05 14 87 81 00 00 	movl   $0x0,0x818714
  804b49:	00 00 00 
  }
}
  804b4c:	c9                   	leave  
  804b4d:	c3                   	ret    

00804b4e <tcp_timer_needed>:

#if !NO_SYS
/**
 * Called from TCP_REG when registering a new PCB:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  804b4e:	55                   	push   %ebp
  804b4f:	89 e5                	mov    %esp,%ebp
  804b51:	83 ec 08             	sub    $0x8,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  804b54:	83 3d 14 87 81 00 00 	cmpl   $0x0,0x818714
  804b5b:	75 33                	jne    804b90 <tcp_timer_needed+0x42>
  804b5d:	83 3d 68 e6 b3 00 00 	cmpl   $0x0,0xb3e668
  804b64:	75 09                	jne    804b6f <tcp_timer_needed+0x21>
  804b66:	83 3d 7c e6 b3 00 00 	cmpl   $0x0,0xb3e67c
  804b6d:	74 21                	je     804b90 <tcp_timer_needed+0x42>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  804b6f:	c7 05 14 87 81 00 01 	movl   $0x1,0x818714
  804b76:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  804b79:	83 ec 04             	sub    $0x4,%esp
  804b7c:	6a 00                	push   $0x0
  804b7e:	68 0c 4b 80 00       	push   $0x804b0c
  804b83:	68 fa 00 00 00       	push   $0xfa
  804b88:	e8 4f 33 00 00       	call   807edc <sys_timeout>
  804b8d:	83 c4 10             	add    $0x10,%esp
  }
}
  804b90:	c9                   	leave  
  804b91:	c3                   	ret    

00804b92 <ip_reass_timer>:
#endif /* !NO_SYS */
#endif /* LWIP_TCP */

#if IP_REASSEMBLY
/**
 * Timer callback function that calls ip_reass_tmr() and reschedules itself.
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  804b92:	55                   	push   %ebp
  804b93:	89 e5                	mov    %esp,%ebp
  804b95:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  804b98:	e8 ab 4b 00 00       	call   809748 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  804b9d:	83 ec 04             	sub    $0x4,%esp
  804ba0:	6a 00                	push   $0x0
  804ba2:	68 92 4b 80 00       	push   $0x804b92
  804ba7:	68 e8 03 00 00       	push   $0x3e8
  804bac:	e8 2b 33 00 00       	call   807edc <sys_timeout>
}
  804bb1:	c9                   	leave  
  804bb2:	c3                   	ret    

00804bb3 <arp_timer>:
#endif /* IP_REASSEMBLY */

#if LWIP_ARP
/**
 * Timer callback function that calls etharp_tmr() and reschedules itself.
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  804bb3:	55                   	push   %ebp
  804bb4:	89 e5                	mov    %esp,%ebp
  804bb6:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  804bb9:	e8 33 72 00 00       	call   80bdf1 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  804bbe:	83 ec 04             	sub    $0x4,%esp
  804bc1:	6a 00                	push   $0x0
  804bc3:	68 b3 4b 80 00       	push   $0x804bb3
  804bc8:	68 88 13 00 00       	push   $0x1388
  804bcd:	e8 0a 33 00 00       	call   807edc <sys_timeout>
}
  804bd2:	c9                   	leave  
  804bd3:	c3                   	ret    

00804bd4 <dhcp_timer_coarse>:
#endif /* LWIP_ARP */

#if LWIP_DHCP
/**
 * Timer callback function that calls dhcp_coarse_tmr() and reschedules itself.
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  804bd4:	55                   	push   %ebp
  804bd5:	89 e5                	mov    %esp,%ebp
  804bd7:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  804bda:	e8 67 09 00 00       	call   805546 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  804bdf:	83 ec 04             	sub    $0x4,%esp
  804be2:	6a 00                	push   $0x0
  804be4:	68 d4 4b 80 00       	push   $0x804bd4
  804be9:	68 60 ea 00 00       	push   $0xea60
  804bee:	e8 e9 32 00 00       	call   807edc <sys_timeout>
}
  804bf3:	c9                   	leave  
  804bf4:	c3                   	ret    

00804bf5 <dhcp_timer_fine>:

/**
 * Timer callback function that calls dhcp_fine_tmr() and reschedules itself.
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  804bf5:	55                   	push   %ebp
  804bf6:	89 e5                	mov    %esp,%ebp
  804bf8:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  804bfb:	e8 9e 09 00 00       	call   80559e <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  804c00:	83 ec 04             	sub    $0x4,%esp
  804c03:	6a 00                	push   $0x0
  804c05:	68 f5 4b 80 00       	push   $0x804bf5
  804c0a:	68 f4 01 00 00       	push   $0x1f4
  804c0f:	e8 c8 32 00 00       	call   807edc <sys_timeout>
}
  804c14:	c9                   	leave  
  804c15:	c3                   	ret    

00804c16 <tcpip_thread>:
#endif /* LWIP_DHCP */

#if LWIP_AUTOIP
/**
 * Timer callback function that calls autoip_tmr() and reschedules itself.
 *
 * @param arg unused argument
 */
static void
autoip_timer(void *arg)
{
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: autoip_tmr()\n"));
  autoip_tmr();
  sys_timeout(AUTOIP_TMR_INTERVAL, autoip_timer, NULL);
}
#endif /* LWIP_AUTOIP */

#if LWIP_IGMP
/**
 * Timer callback function that calls igmp_tmr() and reschedules itself.
 *
 * @param arg unused argument
 */
static void
igmp_timer(void *arg)
{
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: igmp_tmr()\n"));
  igmp_tmr();
  sys_timeout(IGMP_TMR_INTERVAL, igmp_timer, NULL);
}
#endif /* LWIP_IGMP */

#if LWIP_DNS
/**
 * Timer callback function that calls dns_tmr() and reschedules itself.
 *
 * @param arg unused argument
 */
static void
dns_timer(void *arg)
{
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dns_tmr()\n"));
  dns_tmr();
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
}
#endif /* LWIP_DNS */

/**
 * The main lwIP thread. This thread has exclusive access to lwIP core functions
 * (unless access to them is not locked). Other threads communicate with this
 * thread using message boxes.
 *
 * It also starts all the timers to make sure they are running in the right
 * thread context.
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  804c16:	55                   	push   %ebp
  804c17:	89 e5                	mov    %esp,%ebp
  804c19:	83 ec 0c             	sub    $0xc,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  804c1c:	6a 00                	push   $0x0
  804c1e:	68 92 4b 80 00       	push   $0x804b92
  804c23:	68 e8 03 00 00       	push   $0x3e8
  804c28:	e8 af 32 00 00       	call   807edc <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  804c2d:	83 c4 0c             	add    $0xc,%esp
  804c30:	6a 00                	push   $0x0
  804c32:	68 b3 4b 80 00       	push   $0x804bb3
  804c37:	68 88 13 00 00       	push   $0x1388
  804c3c:	e8 9b 32 00 00       	call   807edc <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  804c41:	83 c4 0c             	add    $0xc,%esp
  804c44:	6a 00                	push   $0x0
  804c46:	68 d4 4b 80 00       	push   $0x804bd4
  804c4b:	68 60 ea 00 00       	push   $0xea60
  804c50:	e8 87 32 00 00       	call   807edc <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  804c55:	83 c4 0c             	add    $0xc,%esp
  804c58:	6a 00                	push   $0x0
  804c5a:	68 f5 4b 80 00       	push   $0x804bf5
  804c5f:	68 f4 01 00 00       	push   $0x1f4
  804c64:	e8 73 32 00 00       	call   807edc <sys_timeout>
#endif /* LWIP_DHCP */
#if LWIP_AUTOIP
  sys_timeout(AUTOIP_TMR_INTERVAL, autoip_timer, NULL);
#endif /* LWIP_AUTOIP */
#if LWIP_IGMP
  sys_timeout(IGMP_TMR_INTERVAL, igmp_timer, NULL);
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  804c69:	83 c4 10             	add    $0x10,%esp
  804c6c:	83 3d 0c 87 81 00 00 	cmpl   $0x0,0x81870c
  804c73:	74 12                	je     804c87 <tcpip_thread+0x71>
    tcpip_init_done(tcpip_init_done_arg);
  804c75:	83 ec 0c             	sub    $0xc,%esp
  804c78:	ff 35 10 87 81 00    	pushl  0x818710
  804c7e:	ff 15 0c 87 81 00    	call   *0x81870c
  804c84:	83 c4 10             	add    $0x10,%esp
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  804c87:	83 ec 08             	sub    $0x8,%esp
  804c8a:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  804c8d:	50                   	push   %eax
  804c8e:	ff 35 a0 80 81 00    	pushl  0x8180a0
  804c94:	e8 17 31 00 00       	call   807db0 <sys_mbox_fetch>
    switch (msg->type) {
  804c99:	83 c4 10             	add    $0x10,%esp
  804c9c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  804c9f:	8b 00                	mov    (%eax),%eax
  804ca1:	83 f8 01             	cmp    $0x1,%eax
  804ca4:	74 25                	je     804ccb <tcpip_thread+0xb5>
  804ca6:	83 f8 01             	cmp    $0x1,%eax
  804ca9:	72 0c                	jb     804cb7 <tcpip_thread+0xa1>
  804cab:	83 f8 02             	cmp    $0x2,%eax
  804cae:	74 61                	je     804d11 <tcpip_thread+0xfb>
  804cb0:	83 f8 03             	cmp    $0x3,%eax
  804cb3:	74 7d                	je     804d32 <tcpip_thread+0x11c>
  804cb5:	eb d0                	jmp    804c87 <tcpip_thread+0x71>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  804cb7:	83 ec 0c             	sub    $0xc,%esp
  804cba:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  804cbd:	8b 50 08             	mov    0x8(%eax),%edx
  804cc0:	8d 42 04             	lea    0x4(%edx),%eax
  804cc3:	50                   	push   %eax
  804cc4:	ff 12                	call   *(%edx)
      break;
  804cc6:	83 c4 10             	add    $0x10,%esp
  804cc9:	eb bc                	jmp    804c87 <tcpip_thread+0x71>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  804ccb:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  804cce:	8b 42 0c             	mov    0xc(%edx),%eax
  804cd1:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  804cd5:	74 11                	je     804ce8 <tcpip_thread+0xd2>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  804cd7:	83 ec 08             	sub    $0x8,%esp
  804cda:	50                   	push   %eax
  804cdb:	ff 72 08             	pushl  0x8(%edx)
  804cde:	e8 7b 7d 00 00       	call   80ca5e <ethernet_input>
  804ce3:	83 c4 10             	add    $0x10,%esp
  804ce6:	eb 14                	jmp    804cfc <tcpip_thread+0xe6>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  804ce8:	83 ec 08             	sub    $0x8,%esp
  804ceb:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  804cee:	ff 70 0c             	pushl  0xc(%eax)
  804cf1:	ff 70 08             	pushl  0x8(%eax)
  804cf4:	e8 66 45 00 00       	call   80925f <ip_input>
  804cf9:	83 c4 10             	add    $0x10,%esp
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  804cfc:	83 ec 08             	sub    $0x8,%esp
  804cff:	ff 75 fc             	pushl  0xfffffffc(%ebp)
  804d02:	6a 09                	push   $0x9
  804d04:	e8 e8 24 00 00       	call   8071f1 <memp_free>
      break;
  804d09:	83 c4 10             	add    $0x10,%esp
  804d0c:	e9 76 ff ff ff       	jmp    804c87 <tcpip_thread+0x71>

#if LWIP_NETIF_API
    case TCPIP_MSG_NETIFAPI:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: Netif API message %p\n", (void *)msg));
      msg->msg.netifapimsg->function(&(msg->msg.netifapimsg->msg));
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  804d11:	83 ec 0c             	sub    $0xc,%esp
  804d14:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  804d17:	ff 70 0c             	pushl  0xc(%eax)
  804d1a:	ff 50 08             	call   *0x8(%eax)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  804d1d:	83 c4 08             	add    $0x8,%esp
  804d20:	ff 75 fc             	pushl  0xfffffffc(%ebp)
  804d23:	6a 08                	push   $0x8
  804d25:	e8 c7 24 00 00       	call   8071f1 <memp_free>
      break;
  804d2a:	83 c4 10             	add    $0x10,%esp
  804d2d:	e9 55 ff ff ff       	jmp    804c87 <tcpip_thread+0x71>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  804d32:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  804d35:	83 78 08 ff          	cmpl   $0xffffffff,0x8(%eax)
  804d39:	74 16                	je     804d51 <tcpip_thread+0x13b>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  804d3b:	83 ec 04             	sub    $0x4,%esp
  804d3e:	ff 70 10             	pushl  0x10(%eax)
  804d41:	ff 70 0c             	pushl  0xc(%eax)
  804d44:	ff 70 08             	pushl  0x8(%eax)
  804d47:	e8 90 31 00 00       	call   807edc <sys_timeout>
  804d4c:	83 c4 10             	add    $0x10,%esp
  804d4f:	eb 14                	jmp    804d65 <tcpip_thread+0x14f>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  804d51:	83 ec 08             	sub    $0x8,%esp
  804d54:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  804d57:	ff 70 10             	pushl  0x10(%eax)
  804d5a:	ff 70 0c             	pushl  0xc(%eax)
  804d5d:	e8 3d 32 00 00       	call   807f9f <sys_untimeout>
  804d62:	83 c4 10             	add    $0x10,%esp
      memp_free(MEMP_TCPIP_MSG_API, msg);
  804d65:	83 ec 08             	sub    $0x8,%esp
  804d68:	ff 75 fc             	pushl  0xfffffffc(%ebp)
  804d6b:	6a 08                	push   $0x8
  804d6d:	e8 7f 24 00 00       	call   8071f1 <memp_free>
      break;
  804d72:	83 c4 10             	add    $0x10,%esp
  804d75:	e9 0d ff ff ff       	jmp    804c87 <tcpip_thread+0x71>

00804d7a <tcpip_input>:

    default:
      break;
    }
  }
}

/**
 * Pass a received packet to tcpip_thread for input processing
 *
 * @param p the received packet, p->payload pointing to the Ethernet header or
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  804d7a:	55                   	push   %ebp
  804d7b:	89 e5                	mov    %esp,%ebp
  804d7d:	53                   	push   %ebx
  804d7e:	83 ec 04             	sub    $0x4,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
    if (msg == NULL) {
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
    msg->msg.inp.p = p;
    msg->msg.inp.netif = inp;
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
      return ERR_MEM;
    }
    return ERR_OK;
  }
  return ERR_VAL;
  804d81:	ba f7 ff ff ff       	mov    $0xfffffff7,%edx
  804d86:	83 3d a0 80 81 00 ff 	cmpl   $0xffffffff,0x8180a0
  804d8d:	74 55                	je     804de4 <tcpip_input+0x6a>
  804d8f:	83 ec 0c             	sub    $0xc,%esp
  804d92:	6a 09                	push   $0x9
  804d94:	e8 fe 23 00 00       	call   807197 <memp_malloc>
  804d99:	89 c3                	mov    %eax,%ebx
  804d9b:	83 c4 10             	add    $0x10,%esp
  804d9e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  804da3:	85 c0                	test   %eax,%eax
  804da5:	74 3d                	je     804de4 <tcpip_input+0x6a>
  804da7:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  804dad:	8b 45 08             	mov    0x8(%ebp),%eax
  804db0:	89 43 08             	mov    %eax,0x8(%ebx)
  804db3:	8b 45 0c             	mov    0xc(%ebp),%eax
  804db6:	89 43 0c             	mov    %eax,0xc(%ebx)
  804db9:	83 ec 08             	sub    $0x8,%esp
  804dbc:	53                   	push   %ebx
  804dbd:	ff 35 a0 80 81 00    	pushl  0x8180a0
  804dc3:	e8 ca 7f 00 00       	call   80cd92 <sys_mbox_trypost>
  804dc8:	83 c4 10             	add    $0x10,%esp
  804dcb:	ba 00 00 00 00       	mov    $0x0,%edx
  804dd0:	84 c0                	test   %al,%al
  804dd2:	74 10                	je     804de4 <tcpip_input+0x6a>
  804dd4:	83 ec 08             	sub    $0x8,%esp
  804dd7:	53                   	push   %ebx
  804dd8:	6a 09                	push   $0x9
  804dda:	e8 12 24 00 00       	call   8071f1 <memp_free>
  804ddf:	ba ff ff ff ff       	mov    $0xffffffff,%edx
}
  804de4:	89 d0                	mov    %edx,%eax
  804de6:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  804de9:	c9                   	leave  
  804dea:	c3                   	ret    

00804deb <tcpip_callback_with_block>:

/**
 * Call a specific function in the thread context of
 * tcpip_thread for easy access synchronization.
 * A function called in that way may access lwIP core code
 * without fearing concurrent access.
 *
 * @param f the function to call
 * @param ctx parameter passed to f
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  804deb:	55                   	push   %ebp
  804dec:	89 e5                	mov    %esp,%ebp
  804dee:	53                   	push   %ebx
  804def:	83 ec 04             	sub    $0x4,%esp
  804df2:	8a 45 10             	mov    0x10(%ebp),%al
  804df5:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
    msg->msg.cb.f = f;
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(mbox, msg);
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
  804df8:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  804dfd:	83 3d a0 80 81 00 ff 	cmpl   $0xffffffff,0x8180a0
  804e04:	74 71                	je     804e77 <tcpip_callback_with_block+0x8c>
  804e06:	83 ec 0c             	sub    $0xc,%esp
  804e09:	6a 08                	push   $0x8
  804e0b:	e8 87 23 00 00       	call   807197 <memp_malloc>
  804e10:	89 c3                	mov    %eax,%ebx
  804e12:	83 c4 10             	add    $0x10,%esp
  804e15:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804e1a:	85 db                	test   %ebx,%ebx
  804e1c:	74 59                	je     804e77 <tcpip_callback_with_block+0x8c>
  804e1e:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
  804e24:	8b 45 08             	mov    0x8(%ebp),%eax
  804e27:	89 43 08             	mov    %eax,0x8(%ebx)
  804e2a:	8b 45 0c             	mov    0xc(%ebp),%eax
  804e2d:	89 43 0c             	mov    %eax,0xc(%ebx)
  804e30:	80 7d fb 00          	cmpb   $0x0,0xfffffffb(%ebp)
  804e34:	74 14                	je     804e4a <tcpip_callback_with_block+0x5f>
  804e36:	83 ec 08             	sub    $0x8,%esp
  804e39:	53                   	push   %ebx
  804e3a:	ff 35 a0 80 81 00    	pushl  0x8180a0
  804e40:	e8 1d 7f 00 00       	call   80cd62 <sys_mbox_post>
  804e45:	83 c4 10             	add    $0x10,%esp
  804e48:	eb 28                	jmp    804e72 <tcpip_callback_with_block+0x87>
  804e4a:	83 ec 08             	sub    $0x8,%esp
  804e4d:	53                   	push   %ebx
  804e4e:	ff 35 a0 80 81 00    	pushl  0x8180a0
  804e54:	e8 39 7f 00 00       	call   80cd92 <sys_mbox_trypost>
  804e59:	83 c4 10             	add    $0x10,%esp
  804e5c:	84 c0                	test   %al,%al
  804e5e:	74 12                	je     804e72 <tcpip_callback_with_block+0x87>
  804e60:	83 ec 08             	sub    $0x8,%esp
  804e63:	53                   	push   %ebx
  804e64:	6a 08                	push   $0x8
  804e66:	e8 86 23 00 00       	call   8071f1 <memp_free>
  804e6b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804e70:	eb 05                	jmp    804e77 <tcpip_callback_with_block+0x8c>
  804e72:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804e77:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  804e7a:	c9                   	leave  
  804e7b:	c3                   	ret    

00804e7c <tcpip_timeout>:

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  804e7c:	55                   	push   %ebp
  804e7d:	89 e5                	mov    %esp,%ebp
  804e7f:	83 ec 08             	sub    $0x8,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
    msg->msg.tmo.msecs = msecs;
    msg->msg.tmo.h = h;
    msg->msg.tmo.arg = arg;
    sys_mbox_post(mbox, msg);
    return ERR_OK;
  }
  return ERR_VAL;
  804e82:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  804e87:	83 3d a0 80 81 00 ff 	cmpl   $0xffffffff,0x8180a0
  804e8e:	74 44                	je     804ed4 <tcpip_timeout+0x58>
  804e90:	83 ec 0c             	sub    $0xc,%esp
  804e93:	6a 08                	push   $0x8
  804e95:	e8 fd 22 00 00       	call   807197 <memp_malloc>
  804e9a:	89 c2                	mov    %eax,%edx
  804e9c:	83 c4 10             	add    $0x10,%esp
  804e9f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804ea4:	85 d2                	test   %edx,%edx
  804ea6:	74 2c                	je     804ed4 <tcpip_timeout+0x58>
  804ea8:	c7 02 03 00 00 00    	movl   $0x3,(%edx)
  804eae:	8b 45 08             	mov    0x8(%ebp),%eax
  804eb1:	89 42 08             	mov    %eax,0x8(%edx)
  804eb4:	8b 45 0c             	mov    0xc(%ebp),%eax
  804eb7:	89 42 0c             	mov    %eax,0xc(%edx)
  804eba:	8b 45 10             	mov    0x10(%ebp),%eax
  804ebd:	89 42 10             	mov    %eax,0x10(%edx)
  804ec0:	83 ec 08             	sub    $0x8,%esp
  804ec3:	52                   	push   %edx
  804ec4:	ff 35 a0 80 81 00    	pushl  0x8180a0
  804eca:	e8 93 7e 00 00       	call   80cd62 <sys_mbox_post>
  804ecf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804ed4:	c9                   	leave  
  804ed5:	c3                   	ret    

00804ed6 <tcpip_apimsg>:

#if LWIP_NETCONN
/**
 * Call the lower part of a netconn_* function
 * This function is then running in the thread context
 * of tcpip_thread and has exclusive access to lwIP core code.
 *
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  804ed6:	55                   	push   %ebp
  804ed7:	89 e5                	mov    %esp,%ebp
  804ed9:	53                   	push   %ebx
  804eda:	83 ec 24             	sub    $0x24,%esp
  804edd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
    msg.type = TCPIP_MSG_API;
    msg.msg.apimsg = apimsg;
    sys_mbox_post(mbox, &msg);
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
    return ERR_OK;
  }
  return ERR_VAL;
  804ee0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  804ee5:	83 3d a0 80 81 00 ff 	cmpl   $0xffffffff,0x8180a0
  804eec:	74 31                	je     804f1f <tcpip_apimsg+0x49>
  804eee:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  804ef5:	89 5d e0             	mov    %ebx,0xffffffe0(%ebp)
  804ef8:	83 ec 08             	sub    $0x8,%esp
  804efb:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  804efe:	50                   	push   %eax
  804eff:	ff 35 a0 80 81 00    	pushl  0x8180a0
  804f05:	e8 58 7e 00 00       	call   80cd62 <sys_mbox_post>
  804f0a:	83 c4 08             	add    $0x8,%esp
  804f0d:	6a 00                	push   $0x0
  804f0f:	8b 43 04             	mov    0x4(%ebx),%eax
  804f12:	ff 70 10             	pushl  0x10(%eax)
  804f15:	e8 c2 80 00 00       	call   80cfdc <sys_arch_sem_wait>
  804f1a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804f1f:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  804f22:	c9                   	leave  
  804f23:	c3                   	ret    

00804f24 <tcpip_init>:

#if LWIP_TCPIP_CORE_LOCKING
/**
 * Call the lower part of a netconn_* function
 * This function has exclusive access to lwIP core code by locking it
 * before the function is called.
 *
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK (only for compatibility fo tcpip_apimsg())
 */
err_t
tcpip_apimsg_lock(struct api_msg *apimsg)
{
  LOCK_TCPIP_CORE();
  apimsg->function(&(apimsg->msg));
  UNLOCK_TCPIP_CORE();
  return ERR_OK;

}
#endif /* LWIP_TCPIP_CORE_LOCKING */
#endif /* LWIP_NETCONN */

#if LWIP_NETIF_API
#if !LWIP_TCPIP_CORE_LOCKING
/**
 * Much like tcpip_apimsg, but calls the lower part of a netifapi_*
 * function.
 *
 * @param netifapimsg a struct containing the function to call and its parameters
 * @return error code given back by the function that was called
 */
err_t
tcpip_netifapi(struct netifapi_msg* netifapimsg)
{
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
    netifapimsg->msg.sem = sys_sem_new(0);
    if (netifapimsg->msg.sem == SYS_SEM_NULL) {
      netifapimsg->msg.err = ERR_MEM;
      return netifapimsg->msg.err;
    }
    
    msg.type = TCPIP_MSG_NETIFAPI;
    msg.msg.netifapimsg = netifapimsg;
    sys_mbox_post(mbox, &msg);
    sys_sem_wait(netifapimsg->msg.sem);
    sys_sem_free(netifapimsg->msg.sem);
    return netifapimsg->msg.err;
  }
  return ERR_VAL;
}
#else /* !LWIP_TCPIP_CORE_LOCKING */
/**
 * Call the lower part of a netifapi_* function
 * This function has exclusive access to lwIP core code by locking it
 * before the function is called.
 *
 * @param netifapimsg a struct containing the function to call and its parameters
 * @return ERR_OK (only for compatibility fo tcpip_netifapi())
 */
err_t
tcpip_netifapi_lock(struct netifapi_msg* netifapimsg)
{
  LOCK_TCPIP_CORE();  
  netifapimsg->function(&(netifapimsg->msg));
  UNLOCK_TCPIP_CORE();
  return netifapimsg->msg.err;
}
#endif /* !LWIP_TCPIP_CORE_LOCKING */
#endif /* LWIP_NETIF_API */

/**
 * Initialize this module:
 * - initialize all sub modules
 * - start the tcpip_thread
 *
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  804f24:	55                   	push   %ebp
  804f25:	89 e5                	mov    %esp,%ebp
  804f27:	83 ec 08             	sub    $0x8,%esp
  lwip_init();
  804f2a:	e8 9e 03 00 00       	call   8052cd <lwip_init>

  tcpip_init_done = initfunc;
  804f2f:	8b 45 08             	mov    0x8(%ebp),%eax
  804f32:	a3 0c 87 81 00       	mov    %eax,0x81870c
  tcpip_init_done_arg = arg;
  804f37:	8b 45 0c             	mov    0xc(%ebp),%eax
  804f3a:	a3 10 87 81 00       	mov    %eax,0x818710
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  804f3f:	83 ec 0c             	sub    $0xc,%esp
  804f42:	6a 00                	push   $0x0
  804f44:	e8 66 7c 00 00       	call   80cbaf <sys_mbox_new>
  804f49:	a3 a0 80 81 00       	mov    %eax,0x8180a0
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  804f4e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  804f55:	6a 00                	push   $0x0
  804f57:	6a 00                	push   $0x0
  804f59:	68 16 4c 80 00       	push   $0x804c16
  804f5e:	68 b4 24 81 00       	push   $0x8124b4
  804f63:	e8 fb 82 00 00       	call   80d263 <sys_thread_new>
}
  804f68:	c9                   	leave  
  804f69:	c3                   	ret    

00804f6a <pbuf_free_int>:

/**
 * Simple callback function used with tcpip_callback to free a pbuf
 * (pbuf_free has a wrong signature for tcpip_callback)
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  804f6a:	55                   	push   %ebp
  804f6b:	89 e5                	mov    %esp,%ebp
  804f6d:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  804f70:	ff 75 08             	pushl  0x8(%ebp)
  804f73:	e8 a1 29 00 00       	call   807919 <pbuf_free>
}
  804f78:	c9                   	leave  
  804f79:	c3                   	ret    

00804f7a <pbuf_free_callback>:

/**
 * A simple wrapper function that allows you to free a pbuf from interrupt context.
 *
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  804f7a:	55                   	push   %ebp
  804f7b:	89 e5                	mov    %esp,%ebp
  804f7d:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  804f80:	6a 00                	push   $0x0
  804f82:	ff 75 08             	pushl  0x8(%ebp)
  804f85:	68 6a 4f 80 00       	push   $0x804f6a
  804f8a:	e8 5c fe ff ff       	call   804deb <tcpip_callback_with_block>
  804f8f:	0f be c0             	movsbl %al,%eax
}
  804f92:	c9                   	leave  
  804f93:	c3                   	ret    

00804f94 <mem_free_callback>:

/**
 * A simple wrapper function that allows you to free heap memory from
 * interrupt context.
 *
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  804f94:	55                   	push   %ebp
  804f95:	89 e5                	mov    %esp,%ebp
  804f97:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  804f9a:	6a 00                	push   $0x0
  804f9c:	ff 75 08             	pushl  0x8(%ebp)
  804f9f:	68 cb 6c 80 00       	push   $0x806ccb
  804fa4:	e8 42 fe ff ff       	call   804deb <tcpip_callback_with_block>
  804fa9:	0f be c0             	movsbl %al,%eax
}
  804fac:	c9                   	leave  
  804fad:	c3                   	ret    
	...

00804fb0 <netbuf_new>:
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  804fb0:	55                   	push   %ebp
  804fb1:	89 e5                	mov    %esp,%ebp
  804fb3:	83 ec 14             	sub    $0x14,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  804fb6:	6a 06                	push   $0x6
  804fb8:	e8 da 21 00 00       	call   807197 <memp_malloc>
  if (buf != NULL) {
  804fbd:	83 c4 10             	add    $0x10,%esp
    buf->p = NULL;
    buf->ptr = NULL;
    buf->addr = NULL;
    return buf;
  } else {
    return NULL;
  804fc0:	ba 00 00 00 00       	mov    $0x0,%edx
  804fc5:	85 c0                	test   %eax,%eax
  804fc7:	74 16                	je     804fdf <netbuf_new+0x2f>
  804fc9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  804fcf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  804fd6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  804fdd:	89 c2                	mov    %eax,%edx
  }
}
  804fdf:	89 d0                	mov    %edx,%eax
  804fe1:	c9                   	leave  
  804fe2:	c3                   	ret    

00804fe3 <netbuf_delete>:

/**
 * Deallocate a netbuf allocated by netbuf_new().
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  804fe3:	55                   	push   %ebp
  804fe4:	89 e5                	mov    %esp,%ebp
  804fe6:	53                   	push   %ebx
  804fe7:	83 ec 04             	sub    $0x4,%esp
  804fea:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  804fed:	85 db                	test   %ebx,%ebx
  804fef:	74 2d                	je     80501e <netbuf_delete+0x3b>
    if (buf->p != NULL) {
  804ff1:	83 3b 00             	cmpl   $0x0,(%ebx)
  804ff4:	74 1a                	je     805010 <netbuf_delete+0x2d>
      pbuf_free(buf->p);
  804ff6:	83 ec 0c             	sub    $0xc,%esp
  804ff9:	ff 33                	pushl  (%ebx)
  804ffb:	e8 19 29 00 00       	call   807919 <pbuf_free>
      buf->p = buf->ptr = NULL;
  805000:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  805007:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80500d:	83 c4 10             	add    $0x10,%esp
    }
    memp_free(MEMP_NETBUF, buf);
  805010:	83 ec 08             	sub    $0x8,%esp
  805013:	53                   	push   %ebx
  805014:	6a 06                	push   $0x6
  805016:	e8 d6 21 00 00       	call   8071f1 <memp_free>
  80501b:	83 c4 10             	add    $0x10,%esp
  }
}
  80501e:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  805021:	c9                   	leave  
  805022:	c3                   	ret    

00805023 <netbuf_alloc>:

/**
 * Allocate memory for a packet buffer for a given netbuf.
 *
 * @param buf the netbuf for which to allocate a packet buffer
 * @param size the size of the packet buffer to allocate
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  805023:	55                   	push   %ebp
  805024:	89 e5                	mov    %esp,%ebp
  805026:	56                   	push   %esi
  805027:	53                   	push   %ebx
  805028:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80502b:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  80502e:	85 db                	test   %ebx,%ebx
  805030:	75 14                	jne    805046 <netbuf_alloc+0x23>
  805032:	83 ec 04             	sub    $0x4,%esp
  805035:	68 c1 24 81 00       	push   $0x8124c1
  80503a:	6a 63                	push   $0x63
  80503c:	68 db 24 81 00       	push   $0x8124db
  805041:	e8 86 ba ff ff       	call   800acc <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  805046:	83 3b 00             	cmpl   $0x0,(%ebx)
  805049:	74 0d                	je     805058 <netbuf_alloc+0x35>
    pbuf_free(buf->p);
  80504b:	83 ec 0c             	sub    $0xc,%esp
  80504e:	ff 33                	pushl  (%ebx)
  805050:	e8 c4 28 00 00       	call   807919 <pbuf_free>
  805055:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  805058:	83 ec 04             	sub    $0x4,%esp
  80505b:	6a 00                	push   $0x0
  80505d:	0f b7 c6             	movzwl %si,%eax
  805060:	50                   	push   %eax
  805061:	6a 00                	push   $0x0
  805063:	e8 20 24 00 00       	call   807488 <pbuf_alloc>
  805068:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  80506a:	83 c4 10             	add    $0x10,%esp
     return NULL;
  80506d:	b8 00 00 00 00       	mov    $0x0,%eax
  805072:	83 3b 00             	cmpl   $0x0,(%ebx)
  805075:	74 24                	je     80509b <netbuf_alloc+0x78>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  805077:	8b 03                	mov    (%ebx),%eax
  805079:	66 39 70 0a          	cmp    %si,0xa(%eax)
  80507d:	73 14                	jae    805093 <netbuf_alloc+0x70>
  80507f:	83 ec 04             	sub    $0x4,%esp
  805082:	68 a8 25 81 00       	push   $0x8125a8
  805087:	6a 6e                	push   $0x6e
  805089:	68 db 24 81 00       	push   $0x8124db
  80508e:	e8 39 ba ff ff       	call   800acc <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  805093:	8b 03                	mov    (%ebx),%eax
  805095:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  805098:	8b 40 04             	mov    0x4(%eax),%eax
}
  80509b:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80509e:	5b                   	pop    %ebx
  80509f:	5e                   	pop    %esi
  8050a0:	c9                   	leave  
  8050a1:	c3                   	ret    

008050a2 <netbuf_free>:

/**
 * Free the packet buffer included in a netbuf
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  8050a2:	55                   	push   %ebp
  8050a3:	89 e5                	mov    %esp,%ebp
  8050a5:	53                   	push   %ebx
  8050a6:	83 ec 04             	sub    $0x4,%esp
  8050a9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8050ac:	85 db                	test   %ebx,%ebx
  8050ae:	75 14                	jne    8050c4 <netbuf_free+0x22>
  8050b0:	83 ec 04             	sub    $0x4,%esp
  8050b3:	68 f1 24 81 00       	push   $0x8124f1
  8050b8:	6a 7b                	push   $0x7b
  8050ba:	68 db 24 81 00       	push   $0x8124db
  8050bf:	e8 08 ba ff ff       	call   800acc <_panic>
  if (buf->p != NULL) {
  8050c4:	83 3b 00             	cmpl   $0x0,(%ebx)
  8050c7:	74 0d                	je     8050d6 <netbuf_free+0x34>
    pbuf_free(buf->p);
  8050c9:	83 ec 0c             	sub    $0xc,%esp
  8050cc:	ff 33                	pushl  (%ebx)
  8050ce:	e8 46 28 00 00       	call   807919 <pbuf_free>
  8050d3:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = buf->ptr = NULL;
  8050d6:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8050dd:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  8050e3:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8050e6:	c9                   	leave  
  8050e7:	c3                   	ret    

008050e8 <netbuf_ref>:

/**
 * Let a netbuf reference existing (non-volatile) data.
 *
 * @param buf netbuf which should reference the data
 * @param dataptr pointer to the data to reference
 * @param size size of the data
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  8050e8:	55                   	push   %ebp
  8050e9:	89 e5                	mov    %esp,%ebp
  8050eb:	56                   	push   %esi
  8050ec:	53                   	push   %ebx
  8050ed:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8050f0:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8050f3:	85 db                	test   %ebx,%ebx
  8050f5:	75 17                	jne    80510e <netbuf_ref+0x26>
  8050f7:	83 ec 04             	sub    $0x4,%esp
  8050fa:	68 0a 25 81 00       	push   $0x81250a
  8050ff:	68 8e 00 00 00       	push   $0x8e
  805104:	68 db 24 81 00       	push   $0x8124db
  805109:	e8 be b9 ff ff       	call   800acc <_panic>
  if (buf->p != NULL) {
  80510e:	83 3b 00             	cmpl   $0x0,(%ebx)
  805111:	74 0d                	je     805120 <netbuf_ref+0x38>
    pbuf_free(buf->p);
  805113:	83 ec 0c             	sub    $0xc,%esp
  805116:	ff 33                	pushl  (%ebx)
  805118:	e8 fc 27 00 00       	call   807919 <pbuf_free>
  80511d:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  805120:	83 ec 04             	sub    $0x4,%esp
  805123:	6a 02                	push   $0x2
  805125:	6a 00                	push   $0x0
  805127:	6a 00                	push   $0x0
  805129:	e8 5a 23 00 00       	call   807488 <pbuf_alloc>
  80512e:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  805130:	83 c4 10             	add    $0x10,%esp
  805133:	85 c0                	test   %eax,%eax
  805135:	75 0e                	jne    805145 <netbuf_ref+0x5d>
    buf->ptr = NULL;
  805137:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  80513e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805143:	eb 1c                	jmp    805161 <netbuf_ref+0x79>
  }
  buf->p->payload = (void*)dataptr;
  805145:	8b 13                	mov    (%ebx),%edx
  805147:	8b 45 0c             	mov    0xc(%ebp),%eax
  80514a:	89 42 04             	mov    %eax,0x4(%edx)
  buf->p->len = buf->p->tot_len = size;
  80514d:	8b 03                	mov    (%ebx),%eax
  80514f:	66 89 70 08          	mov    %si,0x8(%eax)
  805153:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  805157:	8b 03                	mov    (%ebx),%eax
  805159:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  80515c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805161:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  805164:	5b                   	pop    %ebx
  805165:	5e                   	pop    %esi
  805166:	c9                   	leave  
  805167:	c3                   	ret    

00805168 <netbuf_chain>:

/**
 * Chain one netbuf to another (@see pbuf_chain)
 *
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  805168:	55                   	push   %ebp
  805169:	89 e5                	mov    %esp,%ebp
  80516b:	56                   	push   %esi
  80516c:	53                   	push   %ebx
  80516d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805170:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  805173:	85 db                	test   %ebx,%ebx
  805175:	75 17                	jne    80518e <netbuf_chain+0x26>
  805177:	83 ec 04             	sub    $0x4,%esp
  80517a:	68 22 25 81 00       	push   $0x812522
  80517f:	68 a6 00 00 00       	push   $0xa6
  805184:	68 db 24 81 00       	push   $0x8124db
  805189:	e8 3e b9 ff ff       	call   800acc <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  80518e:	85 f6                	test   %esi,%esi
  805190:	75 17                	jne    8051a9 <netbuf_chain+0x41>
  805192:	83 ec 04             	sub    $0x4,%esp
  805195:	68 3b 25 81 00       	push   $0x81253b
  80519a:	68 a7 00 00 00       	push   $0xa7
  80519f:	68 db 24 81 00       	push   $0x8124db
  8051a4:	e8 23 b9 ff ff       	call   800acc <_panic>
  pbuf_chain(head->p, tail->p);
  8051a9:	83 ec 08             	sub    $0x8,%esp
  8051ac:	ff 36                	pushl  (%esi)
  8051ae:	ff 33                	pushl  (%ebx)
  8051b0:	e8 ed 28 00 00       	call   807aa2 <pbuf_chain>
  head->ptr = head->p;
  8051b5:	8b 03                	mov    (%ebx),%eax
  8051b7:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  8051ba:	83 c4 08             	add    $0x8,%esp
  8051bd:	56                   	push   %esi
  8051be:	6a 06                	push   $0x6
  8051c0:	e8 2c 20 00 00       	call   8071f1 <memp_free>
}
  8051c5:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  8051c8:	5b                   	pop    %ebx
  8051c9:	5e                   	pop    %esi
  8051ca:	c9                   	leave  
  8051cb:	c3                   	ret    

008051cc <netbuf_data>:

/**
 * Get the data pointer and length of the data inside a netbuf.
 *
 * @param buf netbuf to get the data from
 * @param dataptr pointer to a void pointer where to store the data pointer
 * @param len pointer to an u16_t where the length of the data is stored
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  8051cc:	55                   	push   %ebp
  8051cd:	89 e5                	mov    %esp,%ebp
  8051cf:	53                   	push   %ebx
  8051d0:	83 ec 04             	sub    $0x4,%esp
  8051d3:	8b 55 08             	mov    0x8(%ebp),%edx
  8051d6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8051d9:	8b 5d 10             	mov    0x10(%ebp),%ebx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  8051dc:	85 d2                	test   %edx,%edx
  8051de:	75 17                	jne    8051f7 <netbuf_data+0x2b>
  8051e0:	83 ec 04             	sub    $0x4,%esp
  8051e3:	68 56 25 81 00       	push   $0x812556
  8051e8:	68 b9 00 00 00       	push   $0xb9
  8051ed:	68 db 24 81 00       	push   $0x8124db
  8051f2:	e8 d5 b8 ff ff       	call   800acc <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  8051f7:	85 c9                	test   %ecx,%ecx
  8051f9:	75 17                	jne    805212 <netbuf_data+0x46>
  8051fb:	83 ec 04             	sub    $0x4,%esp
  8051fe:	68 6f 25 81 00       	push   $0x81256f
  805203:	68 ba 00 00 00       	push   $0xba
  805208:	68 db 24 81 00       	push   $0x8124db
  80520d:	e8 ba b8 ff ff       	call   800acc <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  805212:	85 db                	test   %ebx,%ebx
  805214:	75 17                	jne    80522d <netbuf_data+0x61>
  805216:	83 ec 04             	sub    $0x4,%esp
  805219:	68 8c 25 81 00       	push   $0x81258c
  80521e:	68 bb 00 00 00       	push   $0xbb
  805223:	68 db 24 81 00       	push   $0x8124db
  805228:	e8 9f b8 ff ff       	call   800acc <_panic>

  if (buf->ptr == NULL) {
    return ERR_BUF;
  80522d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  805232:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
  805236:	74 17                	je     80524f <netbuf_data+0x83>
  }
  *dataptr = buf->ptr->payload;
  805238:	8b 42 04             	mov    0x4(%edx),%eax
  80523b:	8b 40 04             	mov    0x4(%eax),%eax
  80523e:	89 01                	mov    %eax,(%ecx)
  *len = buf->ptr->len;
  805240:	8b 42 04             	mov    0x4(%edx),%eax
  805243:	66 8b 40 0a          	mov    0xa(%eax),%ax
  805247:	66 89 03             	mov    %ax,(%ebx)
  return ERR_OK;
  80524a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80524f:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  805252:	c9                   	leave  
  805253:	c3                   	ret    

00805254 <netbuf_next>:

/**
 * Move the current data pointer of a packet buffer contained in a netbuf
 * to the next part.
 * The packet buffer itself is not modified.
 *
 * @param buf the netbuf to modify
 * @return -1 if there is no next part
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  805254:	55                   	push   %ebp
  805255:	89 e5                	mov    %esp,%ebp
  805257:	83 ec 08             	sub    $0x8,%esp
  80525a:	8b 55 08             	mov    0x8(%ebp),%edx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  80525d:	85 d2                	test   %edx,%edx
  80525f:	75 17                	jne    805278 <netbuf_next+0x24>
  805261:	83 ec 04             	sub    $0x4,%esp
  805264:	68 f1 24 81 00       	push   $0x8124f1
  805269:	68 d2 00 00 00       	push   $0xd2
  80526e:	68 db 24 81 00       	push   $0x8124db
  805273:	e8 54 b8 ff ff       	call   800acc <_panic>
  if (buf->ptr->next == NULL) {
  805278:	8b 42 04             	mov    0x4(%edx),%eax
    return -1;
  80527b:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  805280:	83 38 00             	cmpl   $0x0,(%eax)
  805283:	74 11                	je     805296 <netbuf_next+0x42>
  }
  buf->ptr = buf->ptr->next;
  805285:	8b 42 04             	mov    0x4(%edx),%eax
  805288:	8b 00                	mov    (%eax),%eax
  80528a:	89 42 04             	mov    %eax,0x4(%edx)
  if (buf->ptr->next == NULL) {
    return 1;
  80528d:	83 38 00             	cmpl   $0x0,(%eax)
  805290:	0f 94 c0             	sete   %al
  805293:	0f b6 c8             	movzbl %al,%ecx
  }
  return 0;
}
  805296:	89 c8                	mov    %ecx,%eax
  805298:	c9                   	leave  
  805299:	c3                   	ret    

0080529a <netbuf_first>:

/**
 * Move the current data pointer of a packet buffer contained in a netbuf
 * to the beginning of the packet.
 * The packet buffer itself is not modified.
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  80529a:	55                   	push   %ebp
  80529b:	89 e5                	mov    %esp,%ebp
  80529d:	83 ec 08             	sub    $0x8,%esp
  8052a0:	8b 55 08             	mov    0x8(%ebp),%edx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8052a3:	85 d2                	test   %edx,%edx
  8052a5:	75 17                	jne    8052be <netbuf_first+0x24>
  8052a7:	83 ec 04             	sub    $0x4,%esp
  8052aa:	68 f1 24 81 00       	push   $0x8124f1
  8052af:	68 e7 00 00 00       	push   $0xe7
  8052b4:	68 db 24 81 00       	push   $0x8124db
  8052b9:	e8 0e b8 ff ff       	call   800acc <_panic>
  buf->ptr = buf->p;
  8052be:	8b 02                	mov    (%edx),%eax
  8052c0:	89 42 04             	mov    %eax,0x4(%edx)
}
  8052c3:	c9                   	leave  
  8052c4:	c3                   	ret    
  8052c5:	00 00                	add    %al,(%eax)
	...

008052c8 <lwip_sanity_check>:

#ifdef LWIP_DEBUG
static void
lwip_sanity_check(void)
{
  8052c8:	55                   	push   %ebp
  8052c9:	89 e5                	mov    %esp,%ebp
  /* Warnings */
#if LWIP_NETCONN
  if (MEMP_NUM_NETCONN > (MEMP_NUM_TCP_PCB+MEMP_NUM_TCP_PCB_LISTEN+MEMP_NUM_UDP_PCB+MEMP_NUM_RAW_PCB))
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: MEMP_NUM_NETCONN should be less than the sum of MEMP_NUM_{TCP,RAW,UDP}_PCB+MEMP_NUM_TCP_PCB_LISTEN\n"));
#endif /* LWIP_NETCONN */
#if LWIP_TCP
  if (MEMP_NUM_TCP_SEG < TCP_SND_QUEUELEN)
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: MEMP_NUM_TCP_SEG should be at least as big as TCP_SND_QUEUELEN\n"));
  if (TCP_SND_QUEUELEN < (2 * (TCP_SND_BUF/TCP_MSS)))
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_SND_QUEUELEN must be at least as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work\n"));
  if (TCP_SNDLOWAT > TCP_SND_BUF)
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_SNDLOWAT must be less than or equal to TCP_SND_BUF.\n"));
  if (TCP_WND > (PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE))
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is larger than space provided by PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE\n"));
  if (TCP_WND < TCP_MSS)
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is smaller than MSS\n"));
#endif /* LWIP_TCP */
}
  8052cb:	c9                   	leave  
  8052cc:	c3                   	ret    

008052cd <lwip_init>:
#else  /* LWIP_DEBUG */
#define lwip_sanity_check()
#endif /* LWIP_DEBUG */

/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  8052cd:	55                   	push   %ebp
  8052ce:	89 e5                	mov    %esp,%ebp
  8052d0:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  8052d3:	e8 24 78 00 00       	call   80cafc <sys_init>
  mem_init();
  8052d8:	e8 8d 19 00 00       	call   806c6a <mem_init>
  memp_init();
  8052dd:	e8 42 1e 00 00       	call   807124 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  8052e2:	e8 41 df ff ff       	call   803228 <lwip_socket_init>
#endif /* LWIP_SOCKET */
  ip_init();
#if LWIP_ARP
  etharp_init();
#endif /* LWIP_ARP */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
#endif /* LWIP_TCP */
#if LWIP_AUTOIP
  autoip_init();
#endif /* LWIP_AUTOIP */
#if LWIP_IGMP
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  8052e7:	c9                   	leave  
  8052e8:	c3                   	ret    
  8052e9:	00 00                	add    %al,(%eax)
	...

008052ec <dhcp_handle_nak>:
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  8052ec:	55                   	push   %ebp
  8052ed:	89 e5                	mov    %esp,%ebp
  8052ef:	56                   	push   %esi
  8052f0:	53                   	push   %ebx
  8052f1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct dhcp *dhcp = netif->dhcp;
  8052f4:	8b 73 20             	mov    0x20(%ebx),%esi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  8052f7:	83 ec 0c             	sub    $0xc,%esp
  8052fa:	53                   	push   %ebx
  8052fb:	e8 64 21 00 00       	call   807464 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  805300:	83 c4 08             	add    $0x8,%esp
  805303:	68 b0 32 81 00       	push   $0x8132b0
  805308:	53                   	push   %ebx
  805309:	e8 69 20 00 00       	call   807377 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  80530e:	83 c4 08             	add    $0x8,%esp
  805311:	68 b0 32 81 00       	push   $0x8132b0
  805316:	53                   	push   %ebx
  805317:	e8 dc 20 00 00       	call   8073f8 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  80531c:	83 c4 08             	add    $0x8,%esp
  80531f:	68 b0 32 81 00       	push   $0x8132b0
  805324:	53                   	push   %ebx
  805325:	e8 e7 20 00 00       	call   807411 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  80532a:	83 c4 08             	add    $0x8,%esp
  80532d:	6a 0c                	push   $0xc
  80532f:	56                   	push   %esi
  805330:	e8 3a 0f 00 00       	call   80626f <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  805335:	89 1c 24             	mov    %ebx,(%esp)
  805338:	e8 ca 08 00 00       	call   805c07 <dhcp_discover>
}
  80533d:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  805340:	5b                   	pop    %ebx
  805341:	5e                   	pop    %esi
  805342:	c9                   	leave  
  805343:	c3                   	ret    

00805344 <dhcp_check>:

/**
 * Checks if the offered IP address is already in use.
 *
 * It does so by sending an ARP request for the offered address and
 * entering CHECKING state. If no ARP reply is received within a small
 * interval, the address is assumed to be free for use by us.
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  805344:	55                   	push   %ebp
  805345:	89 e5                	mov    %esp,%ebp
  805347:	53                   	push   %ebx
  805348:	83 ec 08             	sub    $0x8,%esp
  80534b:	8b 55 08             	mov    0x8(%ebp),%edx
  struct dhcp *dhcp = netif->dhcp;
  80534e:	8b 5a 20             	mov    0x20(%edx),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  805351:	6a 00                	push   $0x0
  805353:	8d 43 30             	lea    0x30(%ebx),%eax
  805356:	50                   	push   %eax
  805357:	52                   	push   %edx
  805358:	e8 38 73 00 00       	call   80c695 <etharp_query>
  if (result != ERR_OK) {
  80535d:	83 c4 08             	add    $0x8,%esp
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  805360:	fe 43 01             	incb   0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805363:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  805369:	6a 08                	push   $0x8
  80536b:	53                   	push   %ebx
  80536c:	e8 fe 0e 00 00       	call   80626f <dhcp_set_state>
}
  805371:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  805374:	c9                   	leave  
  805375:	c3                   	ret    

00805376 <dhcp_handle_offer>:

/**
 * Remember the configuration offered by a DHCP server.
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  805376:	55                   	push   %ebp
  805377:	89 e5                	mov    %esp,%ebp
  805379:	56                   	push   %esi
  80537a:	53                   	push   %ebx
  80537b:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  80537e:	8b 5e 20             	mov    0x20(%esi),%ebx
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  805381:	83 ec 08             	sub    $0x8,%esp
  805384:	6a 36                	push   $0x36
  805386:	53                   	push   %ebx
  805387:	e8 ac 16 00 00       	call   806a38 <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
  80538c:	83 c4 10             	add    $0x10,%esp
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  80538f:	85 c0                	test   %eax,%eax
  805391:	74 3a                	je     8053cd <dhcp_handle_offer+0x57>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  805393:	83 ec 0c             	sub    $0xc,%esp
  805396:	83 c0 02             	add    $0x2,%eax
  805399:	50                   	push   %eax
  80539a:	e8 a5 17 00 00       	call   806b44 <dhcp_get_option_long>
  80539f:	89 04 24             	mov    %eax,(%esp)
  8053a2:	e8 e3 52 00 00       	call   80a68a <htonl>
  8053a7:	89 43 2c             	mov    %eax,0x2c(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
  8053aa:	83 c4 10             	add    $0x10,%esp
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  8053ad:	b8 00 00 00 00       	mov    $0x0,%eax
  8053b2:	83 7b 10 f0          	cmpl   $0xfffffff0,0x10(%ebx)
  8053b6:	74 06                	je     8053be <dhcp_handle_offer+0x48>
  8053b8:	8b 43 10             	mov    0x10(%ebx),%eax
  8053bb:	8b 40 10             	mov    0x10(%eax),%eax
  8053be:	89 43 30             	mov    %eax,0x30(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  8053c1:	83 ec 0c             	sub    $0xc,%esp
  8053c4:	56                   	push   %esi
  8053c5:	e8 0a 00 00 00       	call   8053d4 <dhcp_select>
  8053ca:	83 c4 10             	add    $0x10,%esp
  }
}
  8053cd:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  8053d0:	5b                   	pop    %ebx
  8053d1:	5e                   	pop    %esi
  8053d2:	c9                   	leave  
  8053d3:	c3                   	ret    

008053d4 <dhcp_select>:

/**
 * Select a DHCP server offer out of all offers.
 *
 * Simply select the first offer received.
 *
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  8053d4:	55                   	push   %ebp
  8053d5:	89 e5                	mov    %esp,%ebp
  8053d7:	57                   	push   %edi
  8053d8:	56                   	push   %esi
  8053d9:	53                   	push   %ebx
  8053da:	83 ec 18             	sub    $0x18,%esp
  8053dd:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  8053e0:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
#if LWIP_NETIF_HOSTNAME
  const char *p;
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8053e3:	56                   	push   %esi
  8053e4:	e8 fc 12 00 00       	call   8066e5 <dhcp_create_request>
  8053e9:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  8053eb:	83 c4 10             	add    $0x10,%esp
  8053ee:	84 c0                	test   %al,%al
  8053f0:	0f 85 0d 01 00 00    	jne    805503 <dhcp_select+0x12f>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8053f6:	83 ec 04             	sub    $0x4,%esp
  8053f9:	6a 01                	push   $0x1
  8053fb:	6a 35                	push   $0x35
  8053fd:	53                   	push   %ebx
  8053fe:	e8 81 0e 00 00       	call   806284 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  805403:	83 c4 08             	add    $0x8,%esp
  805406:	6a 03                	push   $0x3
  805408:	53                   	push   %ebx
  805409:	e8 e3 0e 00 00       	call   8062f1 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80540e:	83 c4 0c             	add    $0xc,%esp
  805411:	6a 02                	push   $0x2
  805413:	6a 39                	push   $0x39
  805415:	53                   	push   %ebx
  805416:	e8 69 0e 00 00       	call   806284 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80541b:	83 c4 08             	add    $0x8,%esp
  80541e:	68 40 02 00 00       	push   $0x240
  805423:	53                   	push   %ebx
  805424:	e8 0a 0f 00 00       	call   806333 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  805429:	83 c4 0c             	add    $0xc,%esp
  80542c:	6a 04                	push   $0x4
  80542e:	6a 32                	push   $0x32
  805430:	53                   	push   %ebx
  805431:	e8 4e 0e 00 00       	call   806284 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  805436:	83 c4 04             	add    $0x4,%esp
  805439:	ff 73 30             	pushl  0x30(%ebx)
  80543c:	e8 75 52 00 00       	call   80a6b6 <ntohl>
  805441:	83 c4 08             	add    $0x8,%esp
  805444:	50                   	push   %eax
  805445:	53                   	push   %ebx
  805446:	e8 53 0f 00 00       	call   80639e <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  80544b:	83 c4 0c             	add    $0xc,%esp
  80544e:	6a 04                	push   $0x4
  805450:	6a 36                	push   $0x36
  805452:	53                   	push   %ebx
  805453:	e8 2c 0e 00 00       	call   806284 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  805458:	83 c4 04             	add    $0x4,%esp
  80545b:	ff 73 2c             	pushl  0x2c(%ebx)
  80545e:	e8 53 52 00 00       	call   80a6b6 <ntohl>
  805463:	83 c4 08             	add    $0x8,%esp
  805466:	50                   	push   %eax
  805467:	53                   	push   %ebx
  805468:	e8 31 0f 00 00       	call   80639e <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80546d:	83 c4 0c             	add    $0xc,%esp
  805470:	6a 04                	push   $0x4
  805472:	6a 37                	push   $0x37
  805474:	53                   	push   %ebx
  805475:	e8 0a 0e 00 00       	call   806284 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80547a:	83 c4 08             	add    $0x8,%esp
  80547d:	6a 01                	push   $0x1
  80547f:	53                   	push   %ebx
  805480:	e8 6c 0e 00 00       	call   8062f1 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  805485:	83 c4 08             	add    $0x8,%esp
  805488:	6a 03                	push   $0x3
  80548a:	53                   	push   %ebx
  80548b:	e8 61 0e 00 00       	call   8062f1 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  805490:	83 c4 08             	add    $0x8,%esp
  805493:	6a 1c                	push   $0x1c
  805495:	53                   	push   %ebx
  805496:	e8 56 0e 00 00       	call   8062f1 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80549b:	83 c4 08             	add    $0x8,%esp
  80549e:	6a 06                	push   $0x6
  8054a0:	53                   	push   %ebx
  8054a1:	e8 4b 0e 00 00       	call   8062f1 <dhcp_option_byte>

#if LWIP_NETIF_HOSTNAME
    p = (const char*)netif->hostname;
    if (p!=NULL) {
      dhcp_option(dhcp, DHCP_OPTION_HOSTNAME, strlen(p));
      while (*p) {
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  8054a6:	89 1c 24             	mov    %ebx,(%esp)
  8054a9:	e8 cb 14 00 00       	call   806979 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8054ae:	83 c4 08             	add    $0x8,%esp
  8054b1:	66 8b 43 24          	mov    0x24(%ebx),%ax
  8054b5:	05 f0 00 00 00       	add    $0xf0,%eax
  8054ba:	0f b7 c0             	movzwl %ax,%eax
  8054bd:	50                   	push   %eax
  8054be:	ff 73 1c             	pushl  0x1c(%ebx)
  8054c1:	e8 5c 22 00 00       	call   807722 <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8054c6:	89 34 24             	mov    %esi,(%esp)
  8054c9:	6a 43                	push   $0x43
  8054cb:	68 b4 32 81 00       	push   $0x8132b4
  8054d0:	ff 73 1c             	pushl  0x1c(%ebx)
  8054d3:	ff 73 08             	pushl  0x8(%ebx)
  8054d6:	e8 28 65 00 00       	call   80ba03 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8054db:	83 c4 1c             	add    $0x1c,%esp
  8054de:	6a 43                	push   $0x43
  8054e0:	68 b0 32 81 00       	push   $0x8132b0
  8054e5:	ff 73 08             	pushl  0x8(%ebx)
  8054e8:	e8 51 67 00 00       	call   80bc3e <udp_connect>
    dhcp_delete_request(netif);
  8054ed:	89 34 24             	mov    %esi,(%esp)
  8054f0:	e8 e0 13 00 00       	call   8068d5 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  8054f5:	83 c4 08             	add    $0x8,%esp
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  8054f8:	6a 01                	push   $0x1
  8054fa:	53                   	push   %ebx
  8054fb:	e8 6f 0d 00 00       	call   80626f <dhcp_set_state>
  805500:	83 c4 10             	add    $0x10,%esp
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  805503:	fe 43 01             	incb   0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  805506:	b8 a0 0f 00 00       	mov    $0xfa0,%eax
  80550b:	80 7b 01 03          	cmpb   $0x3,0x1(%ebx)
  80550f:	77 10                	ja     805521 <dhcp_select+0x14d>
  805511:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  805515:	8d 04 80             	lea    (%eax,%eax,4),%eax
  805518:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80551b:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80551e:	c1 e0 03             	shl    $0x3,%eax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805521:	0f b7 c0             	movzwl %ax,%eax
  805524:	05 f3 01 00 00       	add    $0x1f3,%eax
  805529:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80552e:	f7 ea                	imul   %edx
  805530:	89 d0                	mov    %edx,%eax
  805532:	c1 f8 05             	sar    $0x5,%eax
  805535:	66 89 43 26          	mov    %ax,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  805539:	89 fa                	mov    %edi,%edx
  80553b:	0f be c2             	movsbl %dl,%eax
}
  80553e:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  805541:	5b                   	pop    %ebx
  805542:	5e                   	pop    %esi
  805543:	5f                   	pop    %edi
  805544:	c9                   	leave  
  805545:	c3                   	ret    

00805546 <dhcp_coarse_tmr>:

/**
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  805546:	55                   	push   %ebp
  805547:	89 e5                	mov    %esp,%ebp
  805549:	53                   	push   %ebx
  80554a:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  80554d:	8b 1d 60 e6 b3 00    	mov    0xb3e660,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  805553:	85 db                	test   %ebx,%ebx
  805555:	74 42                	je     805599 <dhcp_coarse_tmr+0x53>
  805557:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  80555b:	74 36                	je     805593 <dhcp_coarse_tmr+0x4d>
  80555d:	8b 43 20             	mov    0x20(%ebx),%eax
  805560:	66 ff 48 2a          	decw   0x2a(%eax)
  805564:	66 83 78 2a 00       	cmpw   $0x0,0x2a(%eax)
  805569:	75 0e                	jne    805579 <dhcp_coarse_tmr+0x33>
  80556b:	83 ec 0c             	sub    $0xc,%esp
  80556e:	53                   	push   %ebx
  80556f:	e8 64 01 00 00       	call   8056d8 <dhcp_t2_timeout>
  805574:	83 c4 10             	add    $0x10,%esp
  805577:	eb 1a                	jmp    805593 <dhcp_coarse_tmr+0x4d>
  805579:	8b 43 20             	mov    0x20(%ebx),%eax
  80557c:	66 ff 48 28          	decw   0x28(%eax)
  805580:	66 83 78 28 00       	cmpw   $0x0,0x28(%eax)
  805585:	75 0c                	jne    805593 <dhcp_coarse_tmr+0x4d>
  805587:	83 ec 0c             	sub    $0xc,%esp
  80558a:	53                   	push   %ebx
  80558b:	e8 1f 01 00 00       	call   8056af <dhcp_t1_timeout>
  805590:	83 c4 10             	add    $0x10,%esp
  805593:	8b 1b                	mov    (%ebx),%ebx
  805595:	85 db                	test   %ebx,%ebx
  805597:	75 be                	jne    805557 <dhcp_coarse_tmr+0x11>
  }
}
  805599:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80559c:	c9                   	leave  
  80559d:	c3                   	ret    

0080559e <dhcp_fine_tmr>:

/**
 * DHCP transaction timeout handling
 *
 * A DHCP server is expected to respond within a short period of time.
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  80559e:	55                   	push   %ebp
  80559f:	89 e5                	mov    %esp,%ebp
  8055a1:	53                   	push   %ebx
  8055a2:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  8055a5:	8b 1d 60 e6 b3 00    	mov    0xb3e660,%ebx
  /* loop through netif's */
  while (netif != NULL) {
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
        netif->dhcp->request_timeout--;
      }
      else if (netif->dhcp->request_timeout == 1) {
        netif->dhcp->request_timeout--;
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  8055ab:	85 db                	test   %ebx,%ebx
  8055ad:	74 38                	je     8055e7 <dhcp_fine_tmr+0x49>
  8055af:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  8055b3:	74 2c                	je     8055e1 <dhcp_fine_tmr+0x43>
  8055b5:	8b 43 20             	mov    0x20(%ebx),%eax
  8055b8:	66 83 78 26 01       	cmpw   $0x1,0x26(%eax)
  8055bd:	76 06                	jbe    8055c5 <dhcp_fine_tmr+0x27>
  8055bf:	66 ff 48 26          	decw   0x26(%eax)
  8055c3:	eb 1c                	jmp    8055e1 <dhcp_fine_tmr+0x43>
  8055c5:	8b 43 20             	mov    0x20(%ebx),%eax
  8055c8:	66 83 78 26 01       	cmpw   $0x1,0x26(%eax)
  8055cd:	75 12                	jne    8055e1 <dhcp_fine_tmr+0x43>
  8055cf:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
  8055d5:	83 ec 0c             	sub    $0xc,%esp
  8055d8:	53                   	push   %ebx
  8055d9:	e8 0e 00 00 00       	call   8055ec <dhcp_timeout>
  8055de:	83 c4 10             	add    $0x10,%esp
  8055e1:	8b 1b                	mov    (%ebx),%ebx
  8055e3:	85 db                	test   %ebx,%ebx
  8055e5:	75 c8                	jne    8055af <dhcp_fine_tmr+0x11>
  }
}
  8055e7:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8055ea:	c9                   	leave  
  8055eb:	c3                   	ret    

008055ec <dhcp_timeout>:

/**
 * A DHCP negotiation transaction, or ARP request, has timed out.
 *
 * The timer that was started with the DHCP or ARP request has
 * timed out, indicating no response was received in time.
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  8055ec:	55                   	push   %ebp
  8055ed:	89 e5                	mov    %esp,%ebp
  8055ef:	53                   	push   %ebx
  8055f0:	83 ec 04             	sub    $0x4,%esp
  8055f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct dhcp *dhcp = netif->dhcp;
  8055f6:	8b 43 20             	mov    0x20(%ebx),%eax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  8055f9:	80 38 0c             	cmpb   $0xc,(%eax)
  8055fc:	74 05                	je     805603 <dhcp_timeout+0x17>
  8055fe:	80 38 06             	cmpb   $0x6,(%eax)
  805601:	75 11                	jne    805614 <dhcp_timeout+0x28>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  805603:	83 ec 0c             	sub    $0xc,%esp
  805606:	53                   	push   %ebx
  805607:	e8 fb 05 00 00       	call   805c07 <dhcp_discover>
  80560c:	83 c4 10             	add    $0x10,%esp
  80560f:	e9 96 00 00 00       	jmp    8056aa <dhcp_timeout+0xbe>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  805614:	80 38 01             	cmpb   $0x1,(%eax)
  805617:	75 2a                	jne    805643 <dhcp_timeout+0x57>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  805619:	80 78 01 05          	cmpb   $0x5,0x1(%eax)
  80561d:	77 0e                	ja     80562d <dhcp_timeout+0x41>
      dhcp_select(netif);
  80561f:	83 ec 0c             	sub    $0xc,%esp
  805622:	53                   	push   %ebx
  805623:	e8 ac fd ff ff       	call   8053d4 <dhcp_select>
  805628:	83 c4 10             	add    $0x10,%esp
  80562b:	eb 7d                	jmp    8056aa <dhcp_timeout+0xbe>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  80562d:	83 ec 0c             	sub    $0xc,%esp
  805630:	53                   	push   %ebx
  805631:	e8 70 0a 00 00       	call   8060a6 <dhcp_release>
      dhcp_discover(netif);
  805636:	89 1c 24             	mov    %ebx,(%esp)
  805639:	e8 c9 05 00 00       	call   805c07 <dhcp_discover>
  80563e:	83 c4 10             	add    $0x10,%esp
  805641:	eb 67                	jmp    8056aa <dhcp_timeout+0xbe>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  805643:	80 38 08             	cmpb   $0x8,(%eax)
  805646:	75 22                	jne    80566a <dhcp_timeout+0x7e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  805648:	80 78 01 01          	cmpb   $0x1,0x1(%eax)
  80564c:	77 0e                	ja     80565c <dhcp_timeout+0x70>
      dhcp_check(netif);
  80564e:	83 ec 0c             	sub    $0xc,%esp
  805651:	53                   	push   %ebx
  805652:	e8 ed fc ff ff       	call   805344 <dhcp_check>
  805657:	83 c4 10             	add    $0x10,%esp
  80565a:	eb 4e                	jmp    8056aa <dhcp_timeout+0xbe>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  80565c:	83 ec 0c             	sub    $0xc,%esp
  80565f:	53                   	push   %ebx
  805660:	e8 dd 06 00 00       	call   805d42 <dhcp_bind>
  805665:	83 c4 10             	add    $0x10,%esp
  805668:	eb 40                	jmp    8056aa <dhcp_timeout+0xbe>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  80566a:	80 38 05             	cmpb   $0x5,(%eax)
  80566d:	75 0e                	jne    80567d <dhcp_timeout+0x91>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  80566f:	83 ec 0c             	sub    $0xc,%esp
  805672:	53                   	push   %ebx
  805673:	e8 49 08 00 00       	call   805ec1 <dhcp_renew>
  805678:	83 c4 10             	add    $0x10,%esp
  80567b:	eb 2d                	jmp    8056aa <dhcp_timeout+0xbe>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  80567d:	80 38 04             	cmpb   $0x4,(%eax)
  805680:	75 28                	jne    8056aa <dhcp_timeout+0xbe>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  805682:	80 78 01 08          	cmpb   $0x8,0x1(%eax)
  805686:	77 0e                	ja     805696 <dhcp_timeout+0xaa>
      dhcp_rebind(netif);
  805688:	83 ec 0c             	sub    $0xc,%esp
  80568b:	53                   	push   %ebx
  80568c:	e8 20 09 00 00       	call   805fb1 <dhcp_rebind>
  805691:	83 c4 10             	add    $0x10,%esp
  805694:	eb 14                	jmp    8056aa <dhcp_timeout+0xbe>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  805696:	83 ec 0c             	sub    $0xc,%esp
  805699:	53                   	push   %ebx
  80569a:	e8 07 0a 00 00       	call   8060a6 <dhcp_release>
      dhcp_discover(netif);
  80569f:	89 1c 24             	mov    %ebx,(%esp)
  8056a2:	e8 60 05 00 00       	call   805c07 <dhcp_discover>
  8056a7:	83 c4 10             	add    $0x10,%esp
    }
  }
}
  8056aa:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8056ad:	c9                   	leave  
  8056ae:	c3                   	ret    

008056af <dhcp_t1_timeout>:

/**
 * The renewal period has timed out.
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
  8056af:	55                   	push   %ebp
  8056b0:	89 e5                	mov    %esp,%ebp
  8056b2:	83 ec 08             	sub    $0x8,%esp
  8056b5:	8b 55 08             	mov    0x8(%ebp),%edx
  struct dhcp *dhcp = netif->dhcp;
  8056b8:	8b 42 20             	mov    0x20(%edx),%eax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  8056bb:	80 38 01             	cmpb   $0x1,(%eax)
  8056be:	74 0a                	je     8056ca <dhcp_t1_timeout+0x1b>
  8056c0:	80 38 0a             	cmpb   $0xa,(%eax)
  8056c3:	74 05                	je     8056ca <dhcp_t1_timeout+0x1b>
  8056c5:	80 38 05             	cmpb   $0x5,(%eax)
  8056c8:	75 0c                	jne    8056d6 <dhcp_t1_timeout+0x27>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  8056ca:	83 ec 0c             	sub    $0xc,%esp
  8056cd:	52                   	push   %edx
  8056ce:	e8 ee 07 00 00       	call   805ec1 <dhcp_renew>
  8056d3:	83 c4 10             	add    $0x10,%esp
  }
}
  8056d6:	c9                   	leave  
  8056d7:	c3                   	ret    

008056d8 <dhcp_t2_timeout>:

/**
 * The rebind period has timed out.
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
  8056d8:	55                   	push   %ebp
  8056d9:	89 e5                	mov    %esp,%ebp
  8056db:	83 ec 08             	sub    $0x8,%esp
  8056de:	8b 55 08             	mov    0x8(%ebp),%edx
  struct dhcp *dhcp = netif->dhcp;
  8056e1:	8b 42 20             	mov    0x20(%edx),%eax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  8056e4:	80 38 01             	cmpb   $0x1,(%eax)
  8056e7:	74 0a                	je     8056f3 <dhcp_t2_timeout+0x1b>
  8056e9:	80 38 0a             	cmpb   $0xa,(%eax)
  8056ec:	74 05                	je     8056f3 <dhcp_t2_timeout+0x1b>
  8056ee:	80 38 05             	cmpb   $0x5,(%eax)
  8056f1:	75 0c                	jne    8056ff <dhcp_t2_timeout+0x27>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  8056f3:	83 ec 0c             	sub    $0xc,%esp
  8056f6:	52                   	push   %edx
  8056f7:	e8 b5 08 00 00       	call   805fb1 <dhcp_rebind>
  8056fc:	83 c4 10             	add    $0x10,%esp
  }
}
  8056ff:	c9                   	leave  
  805700:	c3                   	ret    

00805701 <dhcp_handle_ack>:

/**
 * Handle a DHCP ACK packet
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  805701:	55                   	push   %ebp
  805702:	89 e5                	mov    %esp,%ebp
  805704:	57                   	push   %edi
  805705:	56                   	push   %esi
  805706:	53                   	push   %ebx
  805707:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp = netif->dhcp;
  80570a:	8b 45 08             	mov    0x8(%ebp),%eax
  80570d:	8b 78 20             	mov    0x20(%eax),%edi
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  805710:	c7 47 34 00 00 00 00 	movl   $0x0,0x34(%edi)
  dhcp->offered_gw_addr.addr = 0;
  805717:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  dhcp->offered_bc_addr.addr = 0;
  80571e:	c7 47 3c 00 00 00 00 	movl   $0x0,0x3c(%edi)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  805725:	6a 33                	push   $0x33
  805727:	57                   	push   %edi
  805728:	e8 0b 13 00 00       	call   806a38 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80572d:	83 c4 10             	add    $0x10,%esp
  805730:	85 c0                	test   %eax,%eax
  805732:	74 12                	je     805746 <dhcp_handle_ack+0x45>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  805734:	83 ec 0c             	sub    $0xc,%esp
  805737:	8d 40 02             	lea    0x2(%eax),%eax
  80573a:	50                   	push   %eax
  80573b:	e8 04 14 00 00       	call   806b44 <dhcp_get_option_long>
  805740:	89 47 4c             	mov    %eax,0x4c(%edi)
  805743:	83 c4 10             	add    $0x10,%esp
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  805746:	83 ec 08             	sub    $0x8,%esp
  805749:	6a 3a                	push   $0x3a
  80574b:	57                   	push   %edi
  80574c:	e8 e7 12 00 00       	call   806a38 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  805751:	83 c4 10             	add    $0x10,%esp
  805754:	85 c0                	test   %eax,%eax
  805756:	74 14                	je     80576c <dhcp_handle_ack+0x6b>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  805758:	83 ec 0c             	sub    $0xc,%esp
  80575b:	8d 40 02             	lea    0x2(%eax),%eax
  80575e:	50                   	push   %eax
  80575f:	e8 e0 13 00 00       	call   806b44 <dhcp_get_option_long>
  805764:	89 47 50             	mov    %eax,0x50(%edi)
  805767:	83 c4 10             	add    $0x10,%esp
  80576a:	eb 08                	jmp    805774 <dhcp_handle_ack+0x73>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  80576c:	8b 47 4c             	mov    0x4c(%edi),%eax
  80576f:	d1 e8                	shr    %eax
  805771:	89 47 50             	mov    %eax,0x50(%edi)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  805774:	83 ec 08             	sub    $0x8,%esp
  805777:	6a 3b                	push   $0x3b
  805779:	57                   	push   %edi
  80577a:	e8 b9 12 00 00       	call   806a38 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80577f:	83 c4 10             	add    $0x10,%esp
  805782:	85 c0                	test   %eax,%eax
  805784:	74 14                	je     80579a <dhcp_handle_ack+0x99>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  805786:	83 ec 0c             	sub    $0xc,%esp
  805789:	8d 40 02             	lea    0x2(%eax),%eax
  80578c:	50                   	push   %eax
  80578d:	e8 b2 13 00 00       	call   806b44 <dhcp_get_option_long>
  805792:	89 47 54             	mov    %eax,0x54(%edi)
  805795:	83 c4 10             	add    $0x10,%esp
  805798:	eb 06                	jmp    8057a0 <dhcp_handle_ack+0x9f>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  80579a:	8b 47 4c             	mov    0x4c(%edi),%eax
  80579d:	89 47 54             	mov    %eax,0x54(%edi)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8057a0:	b8 00 00 00 00       	mov    $0x0,%eax
  8057a5:	83 7f 10 f0          	cmpl   $0xfffffff0,0x10(%edi)
  8057a9:	74 06                	je     8057b1 <dhcp_handle_ack+0xb0>
  8057ab:	8b 47 10             	mov    0x10(%edi),%eax
  8057ae:	8b 40 10             	mov    0x10(%eax),%eax
  8057b1:	89 47 30             	mov    %eax,0x30(%edi)

/**
 * Patch #1308
 * TODO: we must check if the file field is not overloaded by DHCP options!
 */
#if 0
  /* boot server address */
  ip_addr_set(&dhcp->offered_si_addr, &dhcp->msg_in->siaddr);
  /* boot file name */
  if (dhcp->msg_in->file[0]) {
    dhcp->boot_file_name = mem_malloc(strlen(dhcp->msg_in->file) + 1);
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8057b4:	83 ec 08             	sub    $0x8,%esp
  8057b7:	6a 01                	push   $0x1
  8057b9:	57                   	push   %edi
  8057ba:	e8 79 12 00 00       	call   806a38 <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  8057bf:	83 c4 10             	add    $0x10,%esp
  8057c2:	85 c0                	test   %eax,%eax
  8057c4:	74 1a                	je     8057e0 <dhcp_handle_ack+0xdf>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8057c6:	83 ec 0c             	sub    $0xc,%esp
  8057c9:	8d 40 02             	lea    0x2(%eax),%eax
  8057cc:	50                   	push   %eax
  8057cd:	e8 72 13 00 00       	call   806b44 <dhcp_get_option_long>
  8057d2:	89 04 24             	mov    %eax,(%esp)
  8057d5:	e8 b0 4e 00 00       	call   80a68a <htonl>
  8057da:	89 47 34             	mov    %eax,0x34(%edi)
  8057dd:	83 c4 10             	add    $0x10,%esp
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  8057e0:	83 ec 08             	sub    $0x8,%esp
  8057e3:	6a 03                	push   $0x3
  8057e5:	57                   	push   %edi
  8057e6:	e8 4d 12 00 00       	call   806a38 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8057eb:	83 c4 10             	add    $0x10,%esp
  8057ee:	85 c0                	test   %eax,%eax
  8057f0:	74 1a                	je     80580c <dhcp_handle_ack+0x10b>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8057f2:	83 ec 0c             	sub    $0xc,%esp
  8057f5:	8d 40 02             	lea    0x2(%eax),%eax
  8057f8:	50                   	push   %eax
  8057f9:	e8 46 13 00 00       	call   806b44 <dhcp_get_option_long>
  8057fe:	89 04 24             	mov    %eax,(%esp)
  805801:	e8 84 4e 00 00       	call   80a68a <htonl>
  805806:	89 47 38             	mov    %eax,0x38(%edi)
  805809:	83 c4 10             	add    $0x10,%esp
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  80580c:	83 ec 08             	sub    $0x8,%esp
  80580f:	6a 1c                	push   $0x1c
  805811:	57                   	push   %edi
  805812:	e8 21 12 00 00       	call   806a38 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  805817:	83 c4 10             	add    $0x10,%esp
  80581a:	85 c0                	test   %eax,%eax
  80581c:	74 1a                	je     805838 <dhcp_handle_ack+0x137>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80581e:	83 ec 0c             	sub    $0xc,%esp
  805821:	8d 40 02             	lea    0x2(%eax),%eax
  805824:	50                   	push   %eax
  805825:	e8 1a 13 00 00       	call   806b44 <dhcp_get_option_long>
  80582a:	89 04 24             	mov    %eax,(%esp)
  80582d:	e8 58 4e 00 00       	call   80a68a <htonl>
  805832:	89 47 3c             	mov    %eax,0x3c(%edi)
  805835:	83 c4 10             	add    $0x10,%esp
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  805838:	83 ec 08             	sub    $0x8,%esp
  80583b:	6a 06                	push   $0x6
  80583d:	57                   	push   %edi
  80583e:	e8 f5 11 00 00       	call   806a38 <dhcp_get_option_ptr>
  805843:	89 c6                	mov    %eax,%esi
  if (option_ptr != NULL) {
  805845:	83 c4 10             	add    $0x10,%esp
  805848:	85 c0                	test   %eax,%eax
  80584a:	74 5a                	je     8058a6 <dhcp_handle_ack+0x1a5>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  80584c:	83 ec 0c             	sub    $0xc,%esp
  80584f:	8d 40 01             	lea    0x1(%eax),%eax
  805852:	50                   	push   %eax
  805853:	e8 e1 12 00 00       	call   806b39 <dhcp_get_option_byte>
  805858:	c0 e8 02             	shr    $0x2,%al
  80585b:	0f b6 c0             	movzbl %al,%eax
  80585e:	89 47 40             	mov    %eax,0x40(%edi)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
  805861:	83 c4 10             	add    $0x10,%esp
  805864:	83 f8 02             	cmp    $0x2,%eax
  805867:	76 07                	jbe    805870 <dhcp_handle_ack+0x16f>
      dhcp->dns_count = DHCP_MAX_DNS;
  805869:	c7 47 40 02 00 00 00 	movl   $0x2,0x40(%edi)
    for (n = 0; n < dhcp->dns_count; n++) {
  805870:	c6 45 f3 00          	movb   $0x0,0xfffffff3(%ebp)
  805874:	83 7f 40 00          	cmpl   $0x0,0x40(%edi)
  805878:	74 2c                	je     8058a6 <dhcp_handle_ack+0x1a5>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  80587a:	0f b6 5d f3          	movzbl 0xfffffff3(%ebp),%ebx
  80587e:	83 ec 0c             	sub    $0xc,%esp
  805881:	8d 44 9e 02          	lea    0x2(%esi,%ebx,4),%eax
  805885:	50                   	push   %eax
  805886:	e8 b9 12 00 00       	call   806b44 <dhcp_get_option_long>
  80588b:	89 04 24             	mov    %eax,(%esp)
  80588e:	e8 f7 4d 00 00       	call   80a68a <htonl>
  805893:	89 44 9f 44          	mov    %eax,0x44(%edi,%ebx,4)
  805897:	83 c4 10             	add    $0x10,%esp
  80589a:	fe 45 f3             	incb   0xfffffff3(%ebp)
  80589d:	0f b6 45 f3          	movzbl 0xfffffff3(%ebp),%eax
  8058a1:	3b 47 40             	cmp    0x40(%edi),%eax
  8058a4:	72 d4                	jb     80587a <dhcp_handle_ack+0x179>
#if LWIP_DNS
      dns_setserver( n, (struct ip_addr *)(&(dhcp->offered_dns_addr[n].addr)));
#endif /* LWIP_DNS */
    }
#if LWIP_DNS
    dns_setserver( n, (struct ip_addr *)(&ip_addr_any));
#endif /* LWIP_DNS */
  }
}
  8058a6:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8058a9:	5b                   	pop    %ebx
  8058aa:	5e                   	pop    %esi
  8058ab:	5f                   	pop    %edi
  8058ac:	c9                   	leave  
  8058ad:	c3                   	ret    

008058ae <dhcp_start>:

/**
 * Start DHCP negotiation for a network interface.
 *
 * If no DHCP client instance was attached to this interface,
 * a new client is created first. If a DHCP client instance
 * was already present, it restarts negotiation.
 *
 * @param netif The lwIP network interface
 * @return lwIP error code
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  8058ae:	55                   	push   %ebp
  8058af:	89 e5                	mov    %esp,%ebp
  8058b1:	56                   	push   %esi
  8058b2:	53                   	push   %ebx
  8058b3:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  8058b6:	85 f6                	test   %esi,%esi
  8058b8:	75 17                	jne    8058d1 <dhcp_start+0x23>
  8058ba:	83 ec 04             	sub    $0x4,%esp
  8058bd:	68 ec 25 81 00       	push   $0x8125ec
  8058c2:	68 38 02 00 00       	push   $0x238
  8058c7:	68 cc 25 81 00       	push   $0x8125cc
  8058cc:	e8 fb b1 ff ff       	call   800acc <_panic>
  dhcp = netif->dhcp;
  8058d1:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  8058d4:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  8058d8:	85 db                	test   %ebx,%ebx
  8058da:	75 1f                	jne    8058fb <dhcp_start+0x4d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  8058dc:	83 ec 0c             	sub    $0xc,%esp
  8058df:	6a 58                	push   $0x58
  8058e1:	e8 2b 16 00 00       	call   806f11 <mem_malloc>
  8058e6:	89 c3                	mov    %eax,%ebx
    if (dhcp == NULL) {
  8058e8:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  8058eb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8058f0:	85 db                	test   %ebx,%ebx
  8058f2:	0f 84 91 00 00 00    	je     805989 <dhcp_start+0xdb>
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  8058f8:	89 5e 20             	mov    %ebx,0x20(%esi)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
  /* already has DHCP client attached */
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  8058fb:	83 ec 04             	sub    $0x4,%esp
  8058fe:	6a 58                	push   $0x58
  805900:	6a 00                	push   $0x0
  805902:	53                   	push   %ebx
  805903:	e8 e1 b9 ff ff       	call   8012e9 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  805908:	e8 29 64 00 00       	call   80bd36 <udp_new>
  80590d:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  805910:	83 c4 10             	add    $0x10,%esp
  805913:	85 c0                	test   %eax,%eax
  805915:	75 17                	jne    80592e <dhcp_start+0x80>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  805917:	83 ec 0c             	sub    $0xc,%esp
  80591a:	53                   	push   %ebx
  80591b:	e8 ab 13 00 00       	call   806ccb <mem_free>
    netif->dhcp = dhcp = NULL;
  805920:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
    return ERR_MEM;
  805927:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80592c:	eb 5b                	jmp    805989 <dhcp_start+0xdb>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80592e:	83 ec 04             	sub    $0x4,%esp
  805931:	6a 44                	push   $0x44
  805933:	68 b0 32 81 00       	push   $0x8132b0
  805938:	ff 73 08             	pushl  0x8(%ebx)
  80593b:	e8 46 62 00 00       	call   80bb86 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  805940:	83 c4 0c             	add    $0xc,%esp
  805943:	6a 43                	push   $0x43
  805945:	68 b0 32 81 00       	push   $0x8132b0
  80594a:	ff 73 08             	pushl  0x8(%ebx)
  80594d:	e8 ec 62 00 00       	call   80bc3e <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  805952:	83 c4 0c             	add    $0xc,%esp
  805955:	56                   	push   %esi
  805956:	68 b2 65 80 00       	push   $0x8065b2
  80595b:	ff 73 08             	pushl  0x8(%ebx)
  80595e:	e8 75 63 00 00       	call   80bcd8 <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  805963:	89 34 24             	mov    %esi,(%esp)
  805966:	e8 9c 02 00 00       	call   805c07 <dhcp_discover>
  if (result != ERR_OK) {
  80596b:	83 c4 10             	add    $0x10,%esp
  80596e:	84 c0                	test   %al,%al
  805970:	74 10                	je     805982 <dhcp_start+0xd4>
    /* free resources allocated above */
    dhcp_stop(netif);
  805972:	83 ec 0c             	sub    $0xc,%esp
  805975:	56                   	push   %esi
  805976:	e8 6e 08 00 00       	call   8061e9 <dhcp_stop>
    return ERR_MEM;
  80597b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805980:	eb 07                	jmp    805989 <dhcp_start+0xdb>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  805982:	80 4e 2e 08          	orb    $0x8,0x2e(%esi)
  return result;
  805986:	0f be c0             	movsbl %al,%eax
}
  805989:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80598c:	5b                   	pop    %ebx
  80598d:	5e                   	pop    %esi
  80598e:	c9                   	leave  
  80598f:	c3                   	ret    

00805990 <dhcp_inform>:

/**
 * Inform a DHCP server of our manual configuration.
 *
 * This informs DHCP servers of our fixed IP address configuration
 * by sending an INFORM message. It does not involve DHCP address
 * configuration, it is just here to be nice to the network.
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  805990:	55                   	push   %ebp
  805991:	89 e5                	mov    %esp,%ebp
  805993:	57                   	push   %edi
  805994:	56                   	push   %esi
  805995:	53                   	push   %ebx
  805996:	83 ec 18             	sub    $0x18,%esp
  805999:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  80599c:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  80599f:	6a 58                	push   $0x58
  8059a1:	e8 6b 15 00 00       	call   806f11 <mem_malloc>
  8059a6:	89 c3                	mov    %eax,%ebx
  if (dhcp == NULL) {
  8059a8:	83 c4 10             	add    $0x10,%esp
  8059ab:	85 c0                	test   %eax,%eax
  8059ad:	0f 84 18 01 00 00    	je     805acb <dhcp_inform+0x13b>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  8059b3:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  8059b6:	83 ec 04             	sub    $0x4,%esp
  8059b9:	6a 58                	push   $0x58
  8059bb:	6a 00                	push   $0x0
  8059bd:	50                   	push   %eax
  8059be:	e8 26 b9 ff ff       	call   8012e9 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  8059c3:	83 c4 10             	add    $0x10,%esp
  dhcp->pcb = udp_new();
  8059c6:	e8 6b 63 00 00       	call   80bd36 <udp_new>
  8059cb:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  8059ce:	85 c0                	test   %eax,%eax
  8059d0:	75 0e                	jne    8059e0 <dhcp_inform+0x50>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  8059d2:	83 ec 0c             	sub    $0xc,%esp
  8059d5:	53                   	push   %ebx
  8059d6:	e8 f0 12 00 00       	call   806ccb <mem_free>
    return;
  8059db:	e9 eb 00 00 00       	jmp    805acb <dhcp_inform+0x13b>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8059e0:	83 ec 0c             	sub    $0xc,%esp
  8059e3:	56                   	push   %esi
  8059e4:	e8 fc 0c 00 00       	call   8066e5 <dhcp_create_request>
  if (result == ERR_OK) {
  8059e9:	83 c4 10             	add    $0x10,%esp
  8059ec:	84 c0                	test   %al,%al
  8059ee:	0f 85 a9 00 00 00    	jne    805a9d <dhcp_inform+0x10d>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8059f4:	83 ec 04             	sub    $0x4,%esp
  8059f7:	6a 01                	push   $0x1
  8059f9:	6a 35                	push   $0x35
  8059fb:	53                   	push   %ebx
  8059fc:	e8 83 08 00 00       	call   806284 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  805a01:	83 c4 08             	add    $0x8,%esp
  805a04:	6a 08                	push   $0x8
  805a06:	53                   	push   %ebx
  805a07:	e8 e5 08 00 00       	call   8062f1 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  805a0c:	83 c4 0c             	add    $0xc,%esp
  805a0f:	6a 02                	push   $0x2
  805a11:	6a 39                	push   $0x39
  805a13:	53                   	push   %ebx
  805a14:	e8 6b 08 00 00       	call   806284 <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  805a19:	83 c4 08             	add    $0x8,%esp
  805a1c:	68 40 02 00 00       	push   $0x240
  805a21:	53                   	push   %ebx
  805a22:	e8 0c 09 00 00       	call   806333 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  805a27:	89 1c 24             	mov    %ebx,(%esp)
  805a2a:	e8 4a 0f 00 00       	call   806979 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805a2f:	83 c4 08             	add    $0x8,%esp
  805a32:	66 8b 43 24          	mov    0x24(%ebx),%ax
  805a36:	05 f0 00 00 00       	add    $0xf0,%eax
  805a3b:	0f b7 c0             	movzwl %ax,%eax
  805a3e:	50                   	push   %eax
  805a3f:	ff 73 1c             	pushl  0x1c(%ebx)
  805a42:	e8 db 1c 00 00       	call   807722 <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  805a47:	83 c4 0c             	add    $0xc,%esp
  805a4a:	6a 44                	push   $0x44
  805a4c:	68 b0 32 81 00       	push   $0x8132b0
  805a51:	ff 73 08             	pushl  0x8(%ebx)
  805a54:	e8 2d 61 00 00       	call   80bb86 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  805a59:	83 c4 0c             	add    $0xc,%esp
  805a5c:	6a 43                	push   $0x43
  805a5e:	68 b4 32 81 00       	push   $0x8132b4
  805a63:	ff 73 08             	pushl  0x8(%ebx)
  805a66:	e8 d3 61 00 00       	call   80bc3e <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  805a6b:	89 34 24             	mov    %esi,(%esp)
  805a6e:	6a 43                	push   $0x43
  805a70:	68 b4 32 81 00       	push   $0x8132b4
  805a75:	ff 73 1c             	pushl  0x1c(%ebx)
  805a78:	ff 73 08             	pushl  0x8(%ebx)
  805a7b:	e8 83 5f 00 00       	call   80ba03 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  805a80:	83 c4 1c             	add    $0x1c,%esp
  805a83:	6a 43                	push   $0x43
  805a85:	68 b0 32 81 00       	push   $0x8132b0
  805a8a:	ff 73 08             	pushl  0x8(%ebx)
  805a8d:	e8 ac 61 00 00       	call   80bc3e <udp_connect>
    dhcp_delete_request(netif);
  805a92:	89 34 24             	mov    %esi,(%esp)
  805a95:	e8 3b 0e 00 00       	call   8068d5 <dhcp_delete_request>
  805a9a:	83 c4 10             	add    $0x10,%esp
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
  805a9d:	85 db                	test   %ebx,%ebx
  805a9f:	74 2a                	je     805acb <dhcp_inform+0x13b>
    if (dhcp->pcb != NULL) {
  805aa1:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  805aa5:	74 0e                	je     805ab5 <dhcp_inform+0x125>
      udp_remove(dhcp->pcb);
  805aa7:	83 ec 0c             	sub    $0xc,%esp
  805aaa:	ff 73 08             	pushl  0x8(%ebx)
  805aad:	e8 3a 62 00 00       	call   80bcec <udp_remove>
  805ab2:	83 c4 10             	add    $0x10,%esp
    }
    dhcp->pcb = NULL;
  805ab5:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  805abc:	83 ec 0c             	sub    $0xc,%esp
  805abf:	53                   	push   %ebx
  805ac0:	e8 06 12 00 00       	call   806ccb <mem_free>
    netif->dhcp = old_dhcp;
  805ac5:	89 7e 20             	mov    %edi,0x20(%esi)
  805ac8:	83 c4 10             	add    $0x10,%esp
  }
}
  805acb:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  805ace:	5b                   	pop    %ebx
  805acf:	5e                   	pop    %esi
  805ad0:	5f                   	pop    %edi
  805ad1:	c9                   	leave  
  805ad2:	c3                   	ret    

00805ad3 <dhcp_arp_reply>:

#if DHCP_DOES_ARP_CHECK
/**
 * Match an ARP reply with the offered IP address.
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  805ad3:	55                   	push   %ebp
  805ad4:	89 e5                	mov    %esp,%ebp
  805ad6:	83 ec 08             	sub    $0x8,%esp
  805ad9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  805adc:	85 c9                	test   %ecx,%ecx
  805ade:	75 17                	jne    805af7 <dhcp_arp_reply+0x24>
  805ae0:	83 ec 04             	sub    $0x4,%esp
  805ae3:	68 ec 25 81 00       	push   $0x8125ec
  805ae8:	68 b5 02 00 00       	push   $0x2b5
  805aed:	68 cc 25 81 00       	push   $0x8125cc
  805af2:	e8 d5 af ff ff       	call   800acc <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  805af7:	83 79 20 00          	cmpl   $0x0,0x20(%ecx)
  805afb:	74 1e                	je     805b1b <dhcp_arp_reply+0x48>
  805afd:	8b 41 20             	mov    0x20(%ecx),%eax
  805b00:	80 38 08             	cmpb   $0x8,(%eax)
  805b03:	75 16                	jne    805b1b <dhcp_arp_reply+0x48>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  805b05:	8b 55 0c             	mov    0xc(%ebp),%edx
  805b08:	8b 12                	mov    (%edx),%edx
  805b0a:	3b 50 30             	cmp    0x30(%eax),%edx
  805b0d:	75 0c                	jne    805b1b <dhcp_arp_reply+0x48>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
  805b0f:	83 ec 0c             	sub    $0xc,%esp
  805b12:	51                   	push   %ecx
  805b13:	e8 05 00 00 00       	call   805b1d <dhcp_decline>
  805b18:	83 c4 10             	add    $0x10,%esp
    }
  }
}
  805b1b:	c9                   	leave  
  805b1c:	c3                   	ret    

00805b1d <dhcp_decline>:

/**
 * Decline an offered lease.
 *
 * Tell the DHCP server we do not accept the offered address.
 * One reason to decline the lease is when we find out the address
 * is already in use by another host (through ARP).
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
  805b1d:	55                   	push   %ebp
  805b1e:	89 e5                	mov    %esp,%ebp
  805b20:	57                   	push   %edi
  805b21:	56                   	push   %esi
  805b22:	53                   	push   %ebx
  805b23:	83 ec 14             	sub    $0x14,%esp
  805b26:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  805b29:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  805b2c:	6a 0c                	push   $0xc
  805b2e:	53                   	push   %ebx
  805b2f:	e8 3b 07 00 00       	call   80626f <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805b34:	89 34 24             	mov    %esi,(%esp)
  805b37:	e8 a9 0b 00 00       	call   8066e5 <dhcp_create_request>
  805b3c:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  805b3e:	83 c4 10             	add    $0x10,%esp
  805b41:	84 c0                	test   %al,%al
  805b43:	0f 85 a8 00 00 00    	jne    805bf1 <dhcp_decline+0xd4>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805b49:	83 ec 04             	sub    $0x4,%esp
  805b4c:	6a 01                	push   $0x1
  805b4e:	6a 35                	push   $0x35
  805b50:	53                   	push   %ebx
  805b51:	e8 2e 07 00 00       	call   806284 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  805b56:	83 c4 08             	add    $0x8,%esp
  805b59:	6a 04                	push   $0x4
  805b5b:	53                   	push   %ebx
  805b5c:	e8 90 07 00 00       	call   8062f1 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  805b61:	83 c4 0c             	add    $0xc,%esp
  805b64:	6a 02                	push   $0x2
  805b66:	6a 39                	push   $0x39
  805b68:	53                   	push   %ebx
  805b69:	e8 16 07 00 00       	call   806284 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  805b6e:	83 c4 08             	add    $0x8,%esp
  805b71:	68 40 02 00 00       	push   $0x240
  805b76:	53                   	push   %ebx
  805b77:	e8 b7 07 00 00       	call   806333 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  805b7c:	83 c4 0c             	add    $0xc,%esp
  805b7f:	6a 04                	push   $0x4
  805b81:	6a 32                	push   $0x32
  805b83:	53                   	push   %ebx
  805b84:	e8 fb 06 00 00       	call   806284 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  805b89:	83 c4 04             	add    $0x4,%esp
  805b8c:	ff 73 30             	pushl  0x30(%ebx)
  805b8f:	e8 22 4b 00 00       	call   80a6b6 <ntohl>
  805b94:	83 c4 08             	add    $0x8,%esp
  805b97:	50                   	push   %eax
  805b98:	53                   	push   %ebx
  805b99:	e8 00 08 00 00       	call   80639e <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  805b9e:	89 1c 24             	mov    %ebx,(%esp)
  805ba1:	e8 d3 0d 00 00       	call   806979 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805ba6:	83 c4 08             	add    $0x8,%esp
  805ba9:	66 8b 43 24          	mov    0x24(%ebx),%ax
  805bad:	05 f0 00 00 00       	add    $0xf0,%eax
  805bb2:	0f b7 c0             	movzwl %ax,%eax
  805bb5:	50                   	push   %eax
  805bb6:	ff 73 1c             	pushl  0x1c(%ebx)
  805bb9:	e8 64 1b 00 00       	call   807722 <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  805bbe:	83 c4 0c             	add    $0xc,%esp
  805bc1:	6a 43                	push   $0x43
  805bc3:	68 b0 32 81 00       	push   $0x8132b0
  805bc8:	ff 73 08             	pushl  0x8(%ebx)
  805bcb:	e8 6e 60 00 00       	call   80bc3e <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  805bd0:	89 34 24             	mov    %esi,(%esp)
  805bd3:	6a 43                	push   $0x43
  805bd5:	68 b4 32 81 00       	push   $0x8132b4
  805bda:	ff 73 1c             	pushl  0x1c(%ebx)
  805bdd:	ff 73 08             	pushl  0x8(%ebx)
  805be0:	e8 1e 5e 00 00       	call   80ba03 <udp_sendto_if>
    dhcp_delete_request(netif);
  805be5:	83 c4 14             	add    $0x14,%esp
  805be8:	56                   	push   %esi
  805be9:	e8 e7 0c 00 00       	call   8068d5 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  805bee:	83 c4 10             	add    $0x10,%esp
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  805bf1:	fe 43 01             	incb   0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805bf4:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  805bfa:	89 fa                	mov    %edi,%edx
  805bfc:	0f be c2             	movsbl %dl,%eax
}
  805bff:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  805c02:	5b                   	pop    %ebx
  805c03:	5e                   	pop    %esi
  805c04:	5f                   	pop    %edi
  805c05:	c9                   	leave  
  805c06:	c3                   	ret    

00805c07 <dhcp_discover>:
#endif


/**
 * Start the DHCP process, discover a DHCP server.
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  805c07:	55                   	push   %ebp
  805c08:	89 e5                	mov    %esp,%ebp
  805c0a:	57                   	push   %edi
  805c0b:	56                   	push   %esi
  805c0c:	53                   	push   %ebx
  805c0d:	83 ec 18             	sub    $0x18,%esp
  805c10:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  805c13:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  805c16:	a1 b0 32 81 00       	mov    0x8132b0,%eax
  805c1b:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805c1e:	56                   	push   %esi
  805c1f:	e8 c1 0a 00 00       	call   8066e5 <dhcp_create_request>
  805c24:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  805c26:	83 c4 10             	add    $0x10,%esp
  805c29:	84 c0                	test   %al,%al
  805c2b:	0f 85 ca 00 00 00    	jne    805cfb <dhcp_discover+0xf4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805c31:	83 ec 04             	sub    $0x4,%esp
  805c34:	6a 01                	push   $0x1
  805c36:	6a 35                	push   $0x35
  805c38:	53                   	push   %ebx
  805c39:	e8 46 06 00 00       	call   806284 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  805c3e:	83 c4 08             	add    $0x8,%esp
  805c41:	6a 01                	push   $0x1
  805c43:	53                   	push   %ebx
  805c44:	e8 a8 06 00 00       	call   8062f1 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  805c49:	83 c4 0c             	add    $0xc,%esp
  805c4c:	6a 02                	push   $0x2
  805c4e:	6a 39                	push   $0x39
  805c50:	53                   	push   %ebx
  805c51:	e8 2e 06 00 00       	call   806284 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  805c56:	83 c4 08             	add    $0x8,%esp
  805c59:	68 40 02 00 00       	push   $0x240
  805c5e:	53                   	push   %ebx
  805c5f:	e8 cf 06 00 00       	call   806333 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  805c64:	83 c4 0c             	add    $0xc,%esp
  805c67:	6a 04                	push   $0x4
  805c69:	6a 37                	push   $0x37
  805c6b:	53                   	push   %ebx
  805c6c:	e8 13 06 00 00       	call   806284 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  805c71:	83 c4 08             	add    $0x8,%esp
  805c74:	6a 01                	push   $0x1
  805c76:	53                   	push   %ebx
  805c77:	e8 75 06 00 00       	call   8062f1 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  805c7c:	83 c4 08             	add    $0x8,%esp
  805c7f:	6a 03                	push   $0x3
  805c81:	53                   	push   %ebx
  805c82:	e8 6a 06 00 00       	call   8062f1 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  805c87:	83 c4 08             	add    $0x8,%esp
  805c8a:	6a 1c                	push   $0x1c
  805c8c:	53                   	push   %ebx
  805c8d:	e8 5f 06 00 00       	call   8062f1 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  805c92:	83 c4 08             	add    $0x8,%esp
  805c95:	6a 06                	push   $0x6
  805c97:	53                   	push   %ebx
  805c98:	e8 54 06 00 00       	call   8062f1 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  805c9d:	89 1c 24             	mov    %ebx,(%esp)
  805ca0:	e8 d4 0c 00 00       	call   806979 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
  805ca5:	83 c4 08             	add    $0x8,%esp
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805ca8:	66 8b 43 24          	mov    0x24(%ebx),%ax
  805cac:	05 f0 00 00 00       	add    $0xf0,%eax
  805cb1:	0f b7 c0             	movzwl %ax,%eax
  805cb4:	50                   	push   %eax
  805cb5:	ff 73 1c             	pushl  0x1c(%ebx)
  805cb8:	e8 65 1a 00 00       	call   807722 <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  805cbd:	83 c4 0c             	add    $0xc,%esp
  805cc0:	6a 43                	push   $0x43
  805cc2:	68 b0 32 81 00       	push   $0x8132b0
  805cc7:	ff 73 08             	pushl  0x8(%ebx)
  805cca:	e8 6f 5f 00 00       	call   80bc3e <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  805ccf:	89 34 24             	mov    %esi,(%esp)
  805cd2:	6a 43                	push   $0x43
  805cd4:	68 b4 32 81 00       	push   $0x8132b4
  805cd9:	ff 73 1c             	pushl  0x1c(%ebx)
  805cdc:	ff 73 08             	pushl  0x8(%ebx)
  805cdf:	e8 1f 5d 00 00       	call   80ba03 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
  805ce4:	83 c4 14             	add    $0x14,%esp
    dhcp_delete_request(netif);
  805ce7:	56                   	push   %esi
  805ce8:	e8 e8 0b 00 00       	call   8068d5 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  805ced:	83 c4 08             	add    $0x8,%esp
    dhcp_set_state(dhcp, DHCP_SELECTING);
  805cf0:	6a 06                	push   $0x6
  805cf2:	53                   	push   %ebx
  805cf3:	e8 77 05 00 00       	call   80626f <dhcp_set_state>
  805cf8:	83 c4 10             	add    $0x10,%esp
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  805cfb:	fe 43 01             	incb   0x1(%ebx)
#if LWIP_DHCP_AUTOIP_COOP
  /* that means we waited 57 seconds */
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  805cfe:	b8 10 27 00 00       	mov    $0x2710,%eax
  805d03:	80 7b 01 03          	cmpb   $0x3,0x1(%ebx)
  805d07:	77 14                	ja     805d1d <dhcp_discover+0x116>
  805d09:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  805d0d:	8d 04 80             	lea    (%eax,%eax,4),%eax
  805d10:	8d 04 80             	lea    (%eax,%eax,4),%eax
  805d13:	8d 04 80             	lea    (%eax,%eax,4),%eax
  805d16:	8d 04 c5 e8 03 00 00 	lea    0x3e8(,%eax,8),%eax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805d1d:	0f b7 c0             	movzwl %ax,%eax
  805d20:	05 f3 01 00 00       	add    $0x1f3,%eax
  805d25:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  805d2a:	f7 ea                	imul   %edx
  805d2c:	89 d0                	mov    %edx,%eax
  805d2e:	c1 f8 05             	sar    $0x5,%eax
  805d31:	66 89 43 26          	mov    %ax,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  805d35:	89 fa                	mov    %edi,%edx
  805d37:	0f be c2             	movsbl %dl,%eax
}
  805d3a:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  805d3d:	5b                   	pop    %ebx
  805d3e:	5e                   	pop    %esi
  805d3f:	5f                   	pop    %edi
  805d40:	c9                   	leave  
  805d41:	c3                   	ret    

00805d42 <dhcp_bind>:


/**
 * Bind the interface to the offered IP address.
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  805d42:	55                   	push   %ebp
  805d43:	89 e5                	mov    %esp,%ebp
  805d45:	56                   	push   %esi
  805d46:	53                   	push   %ebx
  805d47:	83 ec 10             	sub    $0x10,%esp
  805d4a:	8b 75 08             	mov    0x8(%ebp),%esi
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  805d4d:	85 f6                	test   %esi,%esi
  805d4f:	75 17                	jne    805d68 <dhcp_bind+0x26>
  805d51:	83 ec 04             	sub    $0x4,%esp
  805d54:	68 e1 25 81 00       	push   $0x8125e1
  805d59:	68 3d 03 00 00       	push   $0x33d
  805d5e:	68 cc 25 81 00       	push   $0x8125cc
  805d63:	e8 64 ad ff ff       	call   800acc <_panic>
  dhcp = netif->dhcp;
  805d68:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  805d6b:	85 db                	test   %ebx,%ebx
  805d6d:	75 17                	jne    805d86 <dhcp_bind+0x44>
  805d6f:	83 ec 04             	sub    $0x4,%esp
  805d72:	68 fa 25 81 00       	push   $0x8125fa
  805d77:	68 3f 03 00 00       	push   $0x33f
  805d7c:	68 cc 25 81 00       	push   $0x8125cc
  805d81:	e8 46 ad ff ff       	call   800acc <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  805d86:	83 7b 50 ff          	cmpl   $0xffffffff,0x50(%ebx)
  805d8a:	74 2c                	je     805db8 <dhcp_bind+0x76>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  805d8c:	8b 53 50             	mov    0x50(%ebx),%edx
  805d8f:	83 c2 1e             	add    $0x1e,%edx
  805d92:	b8 89 88 88 88       	mov    $0x88888889,%eax
  805d97:	f7 e2                	mul    %edx
  805d99:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
  805d9c:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  805da2:	76 05                	jbe    805da9 <dhcp_bind+0x67>
      timeout = 0xffff;
  805da4:	ba ff ff 00 00       	mov    $0xffff,%edx
    }
    dhcp->t1_timeout = (u16_t)timeout;
  805da9:	66 89 53 28          	mov    %dx,0x28(%ebx)
    if (dhcp->t1_timeout == 0) {
  805dad:	66 85 d2             	test   %dx,%dx
  805db0:	75 06                	jne    805db8 <dhcp_bind+0x76>
      dhcp->t1_timeout = 1;
  805db2:	66 c7 43 28 01 00    	movw   $0x1,0x28(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  805db8:	83 7b 54 ff          	cmpl   $0xffffffff,0x54(%ebx)
  805dbc:	74 2c                	je     805dea <dhcp_bind+0xa8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  805dbe:	8b 53 54             	mov    0x54(%ebx),%edx
  805dc1:	83 c2 1e             	add    $0x1e,%edx
  805dc4:	b8 89 88 88 88       	mov    $0x88888889,%eax
  805dc9:	f7 e2                	mul    %edx
  805dcb:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
  805dce:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  805dd4:	76 05                	jbe    805ddb <dhcp_bind+0x99>
      timeout = 0xffff;
  805dd6:	ba ff ff 00 00       	mov    $0xffff,%edx
    }
    dhcp->t2_timeout = (u16_t)timeout;
  805ddb:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
    if (dhcp->t2_timeout == 0) {
  805ddf:	66 85 d2             	test   %dx,%dx
  805de2:	75 06                	jne    805dea <dhcp_bind+0xa8>
      dhcp->t2_timeout = 1;
  805de4:	66 c7 43 2a 01 00    	movw   $0x1,0x2a(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  805dea:	b8 00 00 00 00       	mov    $0x0,%eax
  805def:	83 fb cc             	cmp    $0xffffffcc,%ebx
  805df2:	74 03                	je     805df7 <dhcp_bind+0xb5>
  805df4:	8b 43 34             	mov    0x34(%ebx),%eax
  805df7:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  805dfa:	85 c0                	test   %eax,%eax
  805dfc:	75 55                	jne    805e53 <dhcp_bind+0x111>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  805dfe:	83 ec 0c             	sub    $0xc,%esp
  805e01:	6a 00                	push   $0x0
  805e03:	e8 ae 48 00 00       	call   80a6b6 <ntohl>
  805e08:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  805e0b:	83 c4 10             	add    $0x10,%esp
  805e0e:	84 c0                	test   %al,%al
  805e10:	78 15                	js     805e27 <dhcp_bind+0xe5>
      sn_mask.addr = htonl(0xff000000);
  805e12:	83 ec 0c             	sub    $0xc,%esp
  805e15:	68 00 00 00 ff       	push   $0xff000000
  805e1a:	e8 6b 48 00 00       	call   80a68a <htonl>
  805e1f:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  805e22:	83 c4 10             	add    $0x10,%esp
  805e25:	eb 2c                	jmp    805e53 <dhcp_bind+0x111>
    } else if (first_octet >= 192) {
  805e27:	3c bf                	cmp    $0xbf,%al
  805e29:	76 15                	jbe    805e40 <dhcp_bind+0xfe>
      sn_mask.addr = htonl(0xffffff00);
  805e2b:	83 ec 0c             	sub    $0xc,%esp
  805e2e:	68 00 ff ff ff       	push   $0xffffff00
  805e33:	e8 52 48 00 00       	call   80a68a <htonl>
  805e38:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  805e3b:	83 c4 10             	add    $0x10,%esp
  805e3e:	eb 13                	jmp    805e53 <dhcp_bind+0x111>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  805e40:	83 ec 0c             	sub    $0xc,%esp
  805e43:	68 00 00 ff ff       	push   $0xffff0000
  805e48:	e8 3d 48 00 00       	call   80a68a <htonl>
  805e4d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  805e50:	83 c4 10             	add    $0x10,%esp
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  805e53:	b8 00 00 00 00       	mov    $0x0,%eax
  805e58:	83 fb c8             	cmp    $0xffffffc8,%ebx
  805e5b:	74 03                	je     805e60 <dhcp_bind+0x11e>
  805e5d:	8b 43 38             	mov    0x38(%ebx),%eax
  805e60:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  805e63:	85 c0                	test   %eax,%eax
  805e65:	75 19                	jne    805e80 <dhcp_bind+0x13e>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  805e67:	8b 43 30             	mov    0x30(%ebx),%eax
  805e6a:	23 45 f4             	and    0xfffffff4(%ebp),%eax
  805e6d:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  805e70:	83 ec 0c             	sub    $0xc,%esp
  805e73:	6a 01                	push   $0x1
  805e75:	e8 10 48 00 00       	call   80a68a <htonl>
  805e7a:	09 45 f0             	or     %eax,0xfffffff0(%ebp)
  805e7d:	83 c4 10             	add    $0x10,%esp
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  805e80:	83 ec 08             	sub    $0x8,%esp
  805e83:	8d 43 30             	lea    0x30(%ebx),%eax
  805e86:	50                   	push   %eax
  805e87:	56                   	push   %esi
  805e88:	e8 ea 14 00 00       	call   807377 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  805e8d:	83 c4 08             	add    $0x8,%esp
  netif_set_netmask(netif, &sn_mask);
  805e90:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  805e93:	50                   	push   %eax
  805e94:	56                   	push   %esi
  805e95:	e8 77 15 00 00       	call   807411 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  805e9a:	83 c4 08             	add    $0x8,%esp
  netif_set_gw(netif, &gw_addr);
  805e9d:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  805ea0:	50                   	push   %eax
  805ea1:	56                   	push   %esi
  805ea2:	e8 51 15 00 00       	call   8073f8 <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  805ea7:	89 34 24             	mov    %esi,(%esp)
  805eaa:	e8 88 15 00 00       	call   807437 <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  805eaf:	83 c4 08             	add    $0x8,%esp
  805eb2:	6a 0a                	push   $0xa
  805eb4:	53                   	push   %ebx
  805eb5:	e8 b5 03 00 00       	call   80626f <dhcp_set_state>
}
  805eba:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  805ebd:	5b                   	pop    %ebx
  805ebe:	5e                   	pop    %esi
  805ebf:	c9                   	leave  
  805ec0:	c3                   	ret    

00805ec1 <dhcp_renew>:

/**
 * Renew an existing DHCP lease at the involved DHCP server.
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  805ec1:	55                   	push   %ebp
  805ec2:	89 e5                	mov    %esp,%ebp
  805ec4:	57                   	push   %edi
  805ec5:	56                   	push   %esi
  805ec6:	53                   	push   %ebx
  805ec7:	83 ec 14             	sub    $0x14,%esp
  805eca:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  805ecd:	8b 77 20             	mov    0x20(%edi),%esi
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  805ed0:	6a 05                	push   $0x5
  805ed2:	56                   	push   %esi
  805ed3:	e8 97 03 00 00       	call   80626f <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805ed8:	89 3c 24             	mov    %edi,(%esp)
  805edb:	e8 05 08 00 00       	call   8066e5 <dhcp_create_request>
  805ee0:	88 45 f3             	mov    %al,0xfffffff3(%ebp)
  if (result == ERR_OK) {
  805ee3:	83 c4 10             	add    $0x10,%esp
  805ee6:	84 c0                	test   %al,%al
  805ee8:	0f 85 81 00 00 00    	jne    805f6f <dhcp_renew+0xae>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805eee:	83 ec 04             	sub    $0x4,%esp
  805ef1:	6a 01                	push   $0x1
  805ef3:	6a 35                	push   $0x35
  805ef5:	56                   	push   %esi
  805ef6:	e8 89 03 00 00       	call   806284 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  805efb:	83 c4 08             	add    $0x8,%esp
  805efe:	6a 03                	push   $0x3
  805f00:	56                   	push   %esi
  805f01:	e8 eb 03 00 00       	call   8062f1 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  805f06:	83 c4 0c             	add    $0xc,%esp
  805f09:	6a 02                	push   $0x2
  805f0b:	6a 39                	push   $0x39
  805f0d:	56                   	push   %esi
  805f0e:	e8 71 03 00 00       	call   806284 <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  805f13:	83 c4 08             	add    $0x8,%esp
  805f16:	68 40 02 00 00       	push   $0x240
  805f1b:	56                   	push   %esi
  805f1c:	e8 12 04 00 00       	call   806333 <dhcp_option_short>

#if 0
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
#endif

#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  805f21:	89 34 24             	mov    %esi,(%esp)
  805f24:	e8 50 0a 00 00       	call   806979 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805f29:	83 c4 08             	add    $0x8,%esp
  805f2c:	66 8b 46 24          	mov    0x24(%esi),%ax
  805f30:	05 f0 00 00 00       	add    $0xf0,%eax
  805f35:	0f b7 c0             	movzwl %ax,%eax
  805f38:	50                   	push   %eax
  805f39:	ff 76 1c             	pushl  0x1c(%esi)
  805f3c:	e8 e1 17 00 00       	call   807722 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  805f41:	83 c4 0c             	add    $0xc,%esp
  805f44:	6a 43                	push   $0x43
  805f46:	8d 5e 2c             	lea    0x2c(%esi),%ebx
  805f49:	53                   	push   %ebx
  805f4a:	ff 76 08             	pushl  0x8(%esi)
  805f4d:	e8 ec 5c 00 00       	call   80bc3e <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  805f52:	89 3c 24             	mov    %edi,(%esp)
  805f55:	6a 43                	push   $0x43
  805f57:	53                   	push   %ebx
  805f58:	ff 76 1c             	pushl  0x1c(%esi)
  805f5b:	ff 76 08             	pushl  0x8(%esi)
  805f5e:	e8 a0 5a 00 00       	call   80ba03 <udp_sendto_if>
    dhcp_delete_request(netif);
  805f63:	83 c4 14             	add    $0x14,%esp
  805f66:	57                   	push   %edi
  805f67:	e8 69 09 00 00       	call   8068d5 <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  805f6c:	83 c4 10             	add    $0x10,%esp
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  805f6f:	fe 46 01             	incb   0x1(%esi)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  805f72:	b8 20 4e 00 00       	mov    $0x4e20,%eax
  805f77:	80 7e 01 09          	cmpb   $0x9,0x1(%esi)
  805f7b:	77 10                	ja     805f8d <dhcp_renew+0xcc>
  805f7d:	0f b6 46 01          	movzbl 0x1(%esi),%eax
  805f81:	8d 04 80             	lea    (%eax,%eax,4),%eax
  805f84:	8d 04 80             	lea    (%eax,%eax,4),%eax
  805f87:	8d 04 80             	lea    (%eax,%eax,4),%eax
  805f8a:	c1 e0 04             	shl    $0x4,%eax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805f8d:	0f b7 c0             	movzwl %ax,%eax
  805f90:	05 f3 01 00 00       	add    $0x1f3,%eax
  805f95:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  805f9a:	f7 ea                	imul   %edx
  805f9c:	89 d0                	mov    %edx,%eax
  805f9e:	c1 f8 05             	sar    $0x5,%eax
  805fa1:	66 89 46 26          	mov    %ax,0x26(%esi)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  805fa5:	0f be 45 f3          	movsbl 0xfffffff3(%ebp),%eax
}
  805fa9:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  805fac:	5b                   	pop    %ebx
  805fad:	5e                   	pop    %esi
  805fae:	5f                   	pop    %edi
  805faf:	c9                   	leave  
  805fb0:	c3                   	ret    

00805fb1 <dhcp_rebind>:

/**
 * Rebind with a DHCP server for an existing DHCP lease.
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  805fb1:	55                   	push   %ebp
  805fb2:	89 e5                	mov    %esp,%ebp
  805fb4:	57                   	push   %edi
  805fb5:	56                   	push   %esi
  805fb6:	53                   	push   %ebx
  805fb7:	83 ec 14             	sub    $0x14,%esp
  805fba:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  805fbd:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  805fc0:	6a 04                	push   $0x4
  805fc2:	53                   	push   %ebx
  805fc3:	e8 a7 02 00 00       	call   80626f <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805fc8:	89 34 24             	mov    %esi,(%esp)
  805fcb:	e8 15 07 00 00       	call   8066e5 <dhcp_create_request>
  805fd0:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  805fd2:	83 c4 10             	add    $0x10,%esp
  805fd5:	84 c0                	test   %al,%al
  805fd7:	0f 85 86 00 00 00    	jne    806063 <dhcp_rebind+0xb2>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805fdd:	83 ec 04             	sub    $0x4,%esp
  805fe0:	6a 01                	push   $0x1
  805fe2:	6a 35                	push   $0x35
  805fe4:	53                   	push   %ebx
  805fe5:	e8 9a 02 00 00       	call   806284 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  805fea:	83 c4 08             	add    $0x8,%esp
  805fed:	6a 03                	push   $0x3
  805fef:	53                   	push   %ebx
  805ff0:	e8 fc 02 00 00       	call   8062f1 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  805ff5:	83 c4 0c             	add    $0xc,%esp
  805ff8:	6a 02                	push   $0x2
  805ffa:	6a 39                	push   $0x39
  805ffc:	53                   	push   %ebx
  805ffd:	e8 82 02 00 00       	call   806284 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  806002:	83 c4 08             	add    $0x8,%esp
  806005:	68 40 02 00 00       	push   $0x240
  80600a:	53                   	push   %ebx
  80600b:	e8 23 03 00 00       	call   806333 <dhcp_option_short>

#if 0
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  806010:	89 1c 24             	mov    %ebx,(%esp)
  806013:	e8 61 09 00 00       	call   806979 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  806018:	83 c4 08             	add    $0x8,%esp
  80601b:	66 8b 43 24          	mov    0x24(%ebx),%ax
  80601f:	05 f0 00 00 00       	add    $0xf0,%eax
  806024:	0f b7 c0             	movzwl %ax,%eax
  806027:	50                   	push   %eax
  806028:	ff 73 1c             	pushl  0x1c(%ebx)
  80602b:	e8 f2 16 00 00       	call   807722 <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  806030:	83 c4 0c             	add    $0xc,%esp
  806033:	6a 43                	push   $0x43
  806035:	68 b0 32 81 00       	push   $0x8132b0
  80603a:	ff 73 08             	pushl  0x8(%ebx)
  80603d:	e8 fc 5b 00 00       	call   80bc3e <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  806042:	89 34 24             	mov    %esi,(%esp)
  806045:	6a 43                	push   $0x43
  806047:	68 b4 32 81 00       	push   $0x8132b4
  80604c:	ff 73 1c             	pushl  0x1c(%ebx)
  80604f:	ff 73 08             	pushl  0x8(%ebx)
  806052:	e8 ac 59 00 00       	call   80ba03 <udp_sendto_if>
    dhcp_delete_request(netif);
  806057:	83 c4 14             	add    $0x14,%esp
  80605a:	56                   	push   %esi
  80605b:	e8 75 08 00 00       	call   8068d5 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  806060:	83 c4 10             	add    $0x10,%esp
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  806063:	fe 43 01             	incb   0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  806066:	b8 10 27 00 00       	mov    $0x2710,%eax
  80606b:	80 7b 01 09          	cmpb   $0x9,0x1(%ebx)
  80606f:	77 10                	ja     806081 <dhcp_rebind+0xd0>
  806071:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  806075:	8d 04 80             	lea    (%eax,%eax,4),%eax
  806078:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80607b:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80607e:	c1 e0 03             	shl    $0x3,%eax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  806081:	0f b7 c0             	movzwl %ax,%eax
  806084:	05 f3 01 00 00       	add    $0x1f3,%eax
  806089:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80608e:	f7 ea                	imul   %edx
  806090:	89 d0                	mov    %edx,%eax
  806092:	c1 f8 05             	sar    $0x5,%eax
  806095:	66 89 43 26          	mov    %ax,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  806099:	89 fa                	mov    %edi,%edx
  80609b:	0f be c2             	movsbl %dl,%eax
}
  80609e:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8060a1:	5b                   	pop    %ebx
  8060a2:	5e                   	pop    %esi
  8060a3:	5f                   	pop    %edi
  8060a4:	c9                   	leave  
  8060a5:	c3                   	ret    

008060a6 <dhcp_release>:

/**
 * Release a DHCP lease.
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  8060a6:	55                   	push   %ebp
  8060a7:	89 e5                	mov    %esp,%ebp
  8060a9:	57                   	push   %edi
  8060aa:	56                   	push   %esi
  8060ab:	53                   	push   %ebx
  8060ac:	83 ec 14             	sub    $0x14,%esp
  8060af:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  8060b2:	8b 77 20             	mov    0x20(%edi),%esi
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  8060b5:	6a 0d                	push   $0xd
  8060b7:	56                   	push   %esi
  8060b8:	e8 b2 01 00 00       	call   80626f <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  8060bd:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  8060c4:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  8060cb:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  8060d2:	c7 46 3c 00 00 00 00 	movl   $0x0,0x3c(%esi)
  8060d9:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  8060e0:	c7 46 54 00 00 00 00 	movl   $0x0,0x54(%esi)
  8060e7:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
  8060ee:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
  dhcp->dns_count = 0;
  8060f5:	c7 46 40 00 00 00 00 	movl   $0x0,0x40(%esi)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8060fc:	89 3c 24             	mov    %edi,(%esp)
  8060ff:	e8 e1 05 00 00       	call   8066e5 <dhcp_create_request>
  806104:	88 45 f3             	mov    %al,0xfffffff3(%ebp)
  if (result == ERR_OK) {
  806107:	83 c4 10             	add    $0x10,%esp
  80610a:	84 c0                	test   %al,%al
  80610c:	75 66                	jne    806174 <dhcp_release+0xce>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80610e:	83 ec 04             	sub    $0x4,%esp
  806111:	6a 01                	push   $0x1
  806113:	6a 35                	push   $0x35
  806115:	56                   	push   %esi
  806116:	e8 69 01 00 00       	call   806284 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  80611b:	83 c4 08             	add    $0x8,%esp
  80611e:	6a 07                	push   $0x7
  806120:	56                   	push   %esi
  806121:	e8 cb 01 00 00       	call   8062f1 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  806126:	89 34 24             	mov    %esi,(%esp)
  806129:	e8 4b 08 00 00       	call   806979 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80612e:	83 c4 08             	add    $0x8,%esp
  806131:	66 8b 46 24          	mov    0x24(%esi),%ax
  806135:	05 f0 00 00 00       	add    $0xf0,%eax
  80613a:	0f b7 c0             	movzwl %ax,%eax
  80613d:	50                   	push   %eax
  80613e:	ff 76 1c             	pushl  0x1c(%esi)
  806141:	e8 dc 15 00 00       	call   807722 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  806146:	83 c4 0c             	add    $0xc,%esp
  806149:	6a 43                	push   $0x43
  80614b:	8d 5e 2c             	lea    0x2c(%esi),%ebx
  80614e:	53                   	push   %ebx
  80614f:	ff 76 08             	pushl  0x8(%esi)
  806152:	e8 e7 5a 00 00       	call   80bc3e <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  806157:	89 3c 24             	mov    %edi,(%esp)
  80615a:	6a 43                	push   $0x43
  80615c:	53                   	push   %ebx
  80615d:	ff 76 1c             	pushl  0x1c(%esi)
  806160:	ff 76 08             	pushl  0x8(%esi)
  806163:	e8 9b 58 00 00       	call   80ba03 <udp_sendto_if>
    dhcp_delete_request(netif);
  806168:	83 c4 14             	add    $0x14,%esp
  80616b:	57                   	push   %edi
  80616c:	e8 64 07 00 00       	call   8068d5 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  806171:	83 c4 10             	add    $0x10,%esp
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  806174:	fe 46 01             	incb   0x1(%esi)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  806177:	b8 10 27 00 00       	mov    $0x2710,%eax
  80617c:	80 7e 01 09          	cmpb   $0x9,0x1(%esi)
  806180:	77 10                	ja     806192 <dhcp_release+0xec>
  806182:	0f b6 46 01          	movzbl 0x1(%esi),%eax
  806186:	8d 04 80             	lea    (%eax,%eax,4),%eax
  806189:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80618c:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80618f:	c1 e0 03             	shl    $0x3,%eax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  806192:	0f b7 c0             	movzwl %ax,%eax
  806195:	05 f3 01 00 00       	add    $0x1f3,%eax
  80619a:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80619f:	f7 ea                	imul   %edx
  8061a1:	89 d0                	mov    %edx,%eax
  8061a3:	c1 f8 05             	sar    $0x5,%eax
  8061a6:	66 89 46 26          	mov    %ax,0x26(%esi)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  8061aa:	83 ec 0c             	sub    $0xc,%esp
  8061ad:	57                   	push   %edi
  8061ae:	e8 b1 12 00 00       	call   807464 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  8061b3:	83 c4 08             	add    $0x8,%esp
  8061b6:	68 b0 32 81 00       	push   $0x8132b0
  8061bb:	57                   	push   %edi
  8061bc:	e8 b6 11 00 00       	call   807377 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  8061c1:	83 c4 08             	add    $0x8,%esp
  8061c4:	68 b0 32 81 00       	push   $0x8132b0
  8061c9:	57                   	push   %edi
  8061ca:	e8 29 12 00 00       	call   8073f8 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  8061cf:	83 c4 08             	add    $0x8,%esp
  8061d2:	68 b0 32 81 00       	push   $0x8132b0
  8061d7:	57                   	push   %edi
  8061d8:	e8 34 12 00 00       	call   807411 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
  8061dd:	0f be 45 f3          	movsbl 0xfffffff3(%ebp),%eax
}
  8061e1:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8061e4:	5b                   	pop    %ebx
  8061e5:	5e                   	pop    %esi
  8061e6:	5f                   	pop    %edi
  8061e7:	c9                   	leave  
  8061e8:	c3                   	ret    

008061e9 <dhcp_stop>:

/**
 * Remove the DHCP client from the interface.
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  8061e9:	55                   	push   %ebp
  8061ea:	89 e5                	mov    %esp,%ebp
  8061ec:	56                   	push   %esi
  8061ed:	53                   	push   %ebx
  8061ee:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  8061f1:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  8061f4:	85 f6                	test   %esi,%esi
  8061f6:	75 17                	jne    80620f <dhcp_stop+0x26>
  8061f8:	83 ec 04             	sub    $0x4,%esp
  8061fb:	68 12 26 81 00       	push   $0x812612
  806200:	68 2c 04 00 00       	push   $0x42c
  806205:	68 cc 25 81 00       	push   $0x8125cc
  80620a:	e8 bd a8 ff ff       	call   800acc <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  80620f:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  806213:	85 db                	test   %ebx,%ebx
  806215:	74 51                	je     806268 <dhcp_stop+0x7f>
    if (dhcp->pcb != NULL) {
  806217:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80621b:	74 15                	je     806232 <dhcp_stop+0x49>
      udp_remove(dhcp->pcb);
  80621d:	83 ec 0c             	sub    $0xc,%esp
  806220:	ff 73 08             	pushl  0x8(%ebx)
  806223:	e8 c4 5a 00 00       	call   80bcec <udp_remove>
      dhcp->pcb = NULL;
  806228:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  80622f:	83 c4 10             	add    $0x10,%esp
    }
    if (dhcp->p != NULL) {
  806232:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  806236:	74 15                	je     80624d <dhcp_stop+0x64>
      pbuf_free(dhcp->p);
  806238:	83 ec 0c             	sub    $0xc,%esp
  80623b:	ff 73 0c             	pushl  0xc(%ebx)
  80623e:	e8 d6 16 00 00       	call   807919 <pbuf_free>
      dhcp->p = NULL;
  806243:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  80624a:	83 c4 10             	add    $0x10,%esp
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  80624d:	83 ec 0c             	sub    $0xc,%esp
  806250:	53                   	push   %ebx
  806251:	e8 11 03 00 00       	call   806567 <dhcp_free_reply>
    mem_free((void *)dhcp);
  806256:	89 1c 24             	mov    %ebx,(%esp)
  806259:	e8 6d 0a 00 00       	call   806ccb <mem_free>
    netif->dhcp = NULL;
  80625e:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  806265:	83 c4 10             	add    $0x10,%esp
  }
}
  806268:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80626b:	5b                   	pop    %ebx
  80626c:	5e                   	pop    %esi
  80626d:	c9                   	leave  
  80626e:	c3                   	ret    

0080626f <dhcp_set_state>:

/*
 * Set the DHCP state of a DHCP client.
 *
 * If the state changed, reset the number of tries.
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  80626f:	55                   	push   %ebp
  806270:	89 e5                	mov    %esp,%ebp
  806272:	8b 55 08             	mov    0x8(%ebp),%edx
  806275:	8b 45 0c             	mov    0xc(%ebp),%eax
  if (new_state != dhcp->state) {
  806278:	38 02                	cmp    %al,(%edx)
  80627a:	74 06                	je     806282 <dhcp_set_state+0x13>
    dhcp->state = new_state;
  80627c:	88 02                	mov    %al,(%edx)
    dhcp->tries = 0;
  80627e:	c6 42 01 00          	movb   $0x0,0x1(%edx)
  }
}
  806282:	c9                   	leave  
  806283:	c3                   	ret    

00806284 <dhcp_option>:

/*
 * Concatenate an option type and length field to the outgoing
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  806284:	55                   	push   %ebp
  806285:	89 e5                	mov    %esp,%ebp
  806287:	56                   	push   %esi
  806288:	53                   	push   %ebx
  806289:	83 ec 10             	sub    $0x10,%esp
  80628c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80628f:	8a 45 0c             	mov    0xc(%ebp),%al
  806292:	88 45 f7             	mov    %al,0xfffffff7(%ebp)
  806295:	8a 5d 10             	mov    0x10(%ebp),%bl
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  806298:	0f b7 41 24          	movzwl 0x24(%ecx),%eax
  80629c:	0f b6 d3             	movzbl %bl,%edx
  80629f:	8d 44 10 02          	lea    0x2(%eax,%edx,1),%eax
  8062a3:	83 f8 44             	cmp    $0x44,%eax
  8062a6:	76 17                	jbe    8062bf <dhcp_option+0x3b>
  8062a8:	83 ec 04             	sub    $0x4,%esp
  8062ab:	68 58 26 81 00       	push   $0x812658
  8062b0:	68 5a 04 00 00       	push   $0x45a
  8062b5:	68 cc 25 81 00       	push   $0x8125cc
  8062ba:	e8 0d a8 ff ff       	call   800acc <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  8062bf:	8b 51 20             	mov    0x20(%ecx),%edx
  8062c2:	0f b7 71 24          	movzwl 0x24(%ecx),%esi
  8062c6:	8a 45 f7             	mov    0xfffffff7(%ebp),%al
  8062c9:	88 84 16 f0 00 00 00 	mov    %al,0xf0(%esi,%edx,1)
  8062d0:	66 8b 41 24          	mov    0x24(%ecx),%ax
  8062d4:	40                   	inc    %eax
  8062d5:	66 89 41 24          	mov    %ax,0x24(%ecx)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  8062d9:	8b 51 20             	mov    0x20(%ecx),%edx
  8062dc:	0f b7 c0             	movzwl %ax,%eax
  8062df:	88 9c 10 f0 00 00 00 	mov    %bl,0xf0(%eax,%edx,1)
  8062e6:	66 ff 41 24          	incw   0x24(%ecx)
}
  8062ea:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  8062ed:	5b                   	pop    %ebx
  8062ee:	5e                   	pop    %esi
  8062ef:	c9                   	leave  
  8062f0:	c3                   	ret    

008062f1 <dhcp_option_byte>:
/*
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  8062f1:	55                   	push   %ebp
  8062f2:	89 e5                	mov    %esp,%ebp
  8062f4:	53                   	push   %ebx
  8062f5:	83 ec 04             	sub    $0x4,%esp
  8062f8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8062fb:	8a 5d 0c             	mov    0xc(%ebp),%bl
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8062fe:	66 83 79 24 43       	cmpw   $0x43,0x24(%ecx)
  806303:	76 17                	jbe    80631c <dhcp_option_byte+0x2b>
  806305:	83 ec 04             	sub    $0x4,%esp
  806308:	68 a0 26 81 00       	push   $0x8126a0
  80630d:	68 65 04 00 00       	push   $0x465
  806312:	68 cc 25 81 00       	push   $0x8125cc
  806317:	e8 b0 a7 ff ff       	call   800acc <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80631c:	8b 51 20             	mov    0x20(%ecx),%edx
  80631f:	0f b7 41 24          	movzwl 0x24(%ecx),%eax
  806323:	88 9c 10 f0 00 00 00 	mov    %bl,0xf0(%eax,%edx,1)
  80632a:	66 ff 41 24          	incw   0x24(%ecx)
}
  80632e:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  806331:	c9                   	leave  
  806332:	c3                   	ret    

00806333 <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  806333:	55                   	push   %ebp
  806334:	89 e5                	mov    %esp,%ebp
  806336:	57                   	push   %edi
  806337:	56                   	push   %esi
  806338:	53                   	push   %ebx
  806339:	83 ec 0c             	sub    $0xc,%esp
  80633c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80633f:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  806342:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  806346:	83 c0 02             	add    $0x2,%eax
  806349:	83 f8 44             	cmp    $0x44,%eax
  80634c:	76 17                	jbe    806365 <dhcp_option_short+0x32>
  80634e:	83 ec 04             	sub    $0x4,%esp
  806351:	68 dc 26 81 00       	push   $0x8126dc
  806356:	68 6c 04 00 00       	push   $0x46c
  80635b:	68 cc 25 81 00       	push   $0x8125cc
  806360:	e8 67 a7 ff ff       	call   800acc <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  806365:	8b 4b 20             	mov    0x20(%ebx),%ecx
  806368:	0f b7 53 24          	movzwl 0x24(%ebx),%edx
  80636c:	89 f0                	mov    %esi,%eax
  80636e:	0f b6 fc             	movzbl %ah,%edi
  806371:	89 f8                	mov    %edi,%eax
  806373:	88 84 0a f0 00 00 00 	mov    %al,0xf0(%edx,%ecx,1)
  80637a:	66 8b 43 24          	mov    0x24(%ebx),%ax
  80637e:	40                   	inc    %eax
  80637f:	66 89 43 24          	mov    %ax,0x24(%ebx)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  806383:	8b 53 20             	mov    0x20(%ebx),%edx
  806386:	0f b7 c0             	movzwl %ax,%eax
  806389:	89 f1                	mov    %esi,%ecx
  80638b:	88 8c 10 f0 00 00 00 	mov    %cl,0xf0(%eax,%edx,1)
  806392:	66 ff 43 24          	incw   0x24(%ebx)
}
  806396:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  806399:	5b                   	pop    %ebx
  80639a:	5e                   	pop    %esi
  80639b:	5f                   	pop    %edi
  80639c:	c9                   	leave  
  80639d:	c3                   	ret    

0080639e <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  80639e:	55                   	push   %ebp
  80639f:	89 e5                	mov    %esp,%ebp
  8063a1:	56                   	push   %esi
  8063a2:	53                   	push   %ebx
  8063a3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  8063a6:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8063aa:	83 c0 04             	add    $0x4,%eax
  8063ad:	83 f8 44             	cmp    $0x44,%eax
  8063b0:	76 17                	jbe    8063c9 <dhcp_option_long+0x2b>
  8063b2:	83 ec 04             	sub    $0x4,%esp
  8063b5:	68 20 27 81 00       	push   $0x812720
  8063ba:	68 74 04 00 00       	push   $0x474
  8063bf:	68 cc 25 81 00       	push   $0x8125cc
  8063c4:	e8 03 a7 ff ff       	call   800acc <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  8063c9:	8b 4b 20             	mov    0x20(%ebx),%ecx
  8063cc:	0f b7 53 24          	movzwl 0x24(%ebx),%edx
  8063d0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8063d3:	c1 e8 18             	shr    $0x18,%eax
  8063d6:	88 84 0a f0 00 00 00 	mov    %al,0xf0(%edx,%ecx,1)
  8063dd:	66 8b 43 24          	mov    0x24(%ebx),%ax
  8063e1:	40                   	inc    %eax
  8063e2:	66 89 43 24          	mov    %ax,0x24(%ebx)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  8063e6:	8b 4b 20             	mov    0x20(%ebx),%ecx
  8063e9:	0f b7 c0             	movzwl %ax,%eax
  8063ec:	8b 55 0c             	mov    0xc(%ebp),%edx
  8063ef:	c1 ea 10             	shr    $0x10,%edx
  8063f2:	88 94 08 f0 00 00 00 	mov    %dl,0xf0(%eax,%ecx,1)
  8063f9:	66 8b 43 24          	mov    0x24(%ebx),%ax
  8063fd:	40                   	inc    %eax
  8063fe:	66 89 43 24          	mov    %ax,0x24(%ebx)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  806402:	8b 4b 20             	mov    0x20(%ebx),%ecx
  806405:	0f b7 f0             	movzwl %ax,%esi
  806408:	8b 45 0c             	mov    0xc(%ebp),%eax
  80640b:	0f b6 d4             	movzbl %ah,%edx
  80640e:	88 94 0e f0 00 00 00 	mov    %dl,0xf0(%esi,%ecx,1)
  806415:	66 8b 43 24          	mov    0x24(%ebx),%ax
  806419:	40                   	inc    %eax
  80641a:	66 89 43 24          	mov    %ax,0x24(%ebx)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  80641e:	8b 53 20             	mov    0x20(%ebx),%edx
  806421:	0f b7 c0             	movzwl %ax,%eax
  806424:	8a 4d 0c             	mov    0xc(%ebp),%cl
  806427:	88 8c 10 f0 00 00 00 	mov    %cl,0xf0(%eax,%edx,1)
  80642e:	66 ff 43 24          	incw   0x24(%ebx)
}
  806432:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  806435:	5b                   	pop    %ebx
  806436:	5e                   	pop    %esi
  806437:	c9                   	leave  
  806438:	c3                   	ret    

00806439 <dhcp_unfold_reply>:

/**
 * Extract the DHCP message and the DHCP options.
 *
 * Extract the DHCP message and the DHCP options, each into a contiguous
 * piece of memory. As a DHCP message is variable sized by its options,
 * and also allows overriding some fields for options, the easy approach
 * is to first unfold the options into a conitguous piece of memory, and
 * use that further on.
 *
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  806439:	55                   	push   %ebp
  80643a:	89 e5                	mov    %esp,%ebp
  80643c:	53                   	push   %ebx
  80643d:	83 ec 04             	sub    $0x4,%esp
  806440:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  806443:	85 db                	test   %ebx,%ebx
  806445:	75 17                	jne    80645e <dhcp_unfold_reply+0x25>
  806447:	83 ec 04             	sub    $0x4,%esp
  80644a:	68 05 26 81 00       	push   $0x812605
  80644f:	68 89 04 00 00       	push   $0x489
  806454:	68 cc 25 81 00       	push   $0x8125cc
  806459:	e8 6e a6 ff ff       	call   800acc <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80645e:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  806462:	75 17                	jne    80647b <dhcp_unfold_reply+0x42>
  806464:	83 ec 04             	sub    $0x4,%esp
  806467:	68 2b 26 81 00       	push   $0x81262b
  80646c:	68 8a 04 00 00       	push   $0x48a
  806471:	68 cc 25 81 00       	push   $0x8125cc
  806476:	e8 51 a6 ff ff       	call   800acc <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  80647b:	83 ec 0c             	sub    $0xc,%esp
  80647e:	53                   	push   %ebx
  80647f:	e8 e3 00 00 00       	call   806567 <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  806484:	8b 43 0c             	mov    0xc(%ebx),%eax
  806487:	83 c4 10             	add    $0x10,%esp
  80648a:	66 81 78 08 f0 00    	cmpw   $0xf0,0x8(%eax)
  806490:	76 2e                	jbe    8064c0 <dhcp_unfold_reply+0x87>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806492:	66 8b 40 08          	mov    0x8(%eax),%ax
  806496:	2d f0 00 00 00       	sub    $0xf0,%eax
  80649b:	66 89 43 18          	mov    %ax,0x18(%ebx)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  80649f:	83 ec 0c             	sub    $0xc,%esp
  8064a2:	0f b7 c0             	movzwl %ax,%eax
  8064a5:	50                   	push   %eax
  8064a6:	e8 66 0a 00 00       	call   806f11 <mem_malloc>
  8064ab:	89 43 14             	mov    %eax,0x14(%ebx)
    if (dhcp->options_in == NULL) {
  8064ae:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
  8064b1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8064b6:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
  8064ba:	0f 84 a2 00 00 00    	je     806562 <dhcp_unfold_reply+0x129>
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8064c0:	83 ec 0c             	sub    $0xc,%esp
  8064c3:	68 f0 00 00 00       	push   $0xf0
  8064c8:	e8 44 0a 00 00       	call   806f11 <mem_malloc>
  8064cd:	89 43 10             	mov    %eax,0x10(%ebx)
  if (dhcp->msg_in == NULL) {
  8064d0:	83 c4 10             	add    $0x10,%esp
  8064d3:	85 c0                	test   %eax,%eax
  8064d5:	75 19                	jne    8064f0 <dhcp_unfold_reply+0xb7>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  8064d7:	83 ec 0c             	sub    $0xc,%esp
  8064da:	ff 73 14             	pushl  0x14(%ebx)
  8064dd:	e8 e9 07 00 00       	call   806ccb <mem_free>
    dhcp->options_in = NULL;
  8064e2:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    return ERR_MEM;
  8064e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8064ee:	eb 72                	jmp    806562 <dhcp_unfold_reply+0x129>
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  8064f0:	6a 00                	push   $0x0
  8064f2:	68 f0 00 00 00       	push   $0xf0
  8064f7:	ff 73 10             	pushl  0x10(%ebx)
  8064fa:	ff 73 0c             	pushl  0xc(%ebx)
  8064fd:	e8 d5 17 00 00       	call   807cd7 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806502:	83 c4 10             	add    $0x10,%esp
  806505:	66 3d f0 00          	cmp    $0xf0,%ax
  806509:	74 17                	je     806522 <dhcp_unfold_reply+0xe9>
  80650b:	83 ec 04             	sub    $0x4,%esp
  80650e:	68 60 27 81 00       	push   $0x812760
  806513:	68 a0 04 00 00       	push   $0x4a0
  806518:	68 cc 25 81 00       	push   $0x8125cc
  80651d:	e8 aa a5 ff ff       	call   800acc <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  806522:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
  806526:	74 35                	je     80655d <dhcp_unfold_reply+0x124>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806528:	68 f0 00 00 00       	push   $0xf0
  80652d:	0f b7 43 18          	movzwl 0x18(%ebx),%eax
  806531:	50                   	push   %eax
  806532:	ff 73 14             	pushl  0x14(%ebx)
  806535:	ff 73 0c             	pushl  0xc(%ebx)
  806538:	e8 9a 17 00 00       	call   807cd7 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  80653d:	83 c4 10             	add    $0x10,%esp
  806540:	66 39 43 18          	cmp    %ax,0x18(%ebx)
  806544:	74 17                	je     80655d <dhcp_unfold_reply+0x124>
  806546:	83 ec 04             	sub    $0x4,%esp
  806549:	68 3b 26 81 00       	push   $0x81263b
  80654e:	68 a7 04 00 00       	push   $0x4a7
  806553:	68 cc 25 81 00       	push   $0x8125cc
  806558:	e8 6f a5 ff ff       	call   800acc <_panic>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes to dhcp->options_in[]\n",
      dhcp->options_in_len));
  }
  LWIP_UNUSED_ARG(ret);
  return ERR_OK;
  80655d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  806562:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  806565:	c9                   	leave  
  806566:	c3                   	ret    

00806567 <dhcp_free_reply>:

/**
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  806567:	55                   	push   %ebp
  806568:	89 e5                	mov    %esp,%ebp
  80656a:	53                   	push   %ebx
  80656b:	83 ec 04             	sub    $0x4,%esp
  80656e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (dhcp->msg_in != NULL) {
  806571:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  806575:	74 15                	je     80658c <dhcp_free_reply+0x25>
    mem_free((void *)dhcp->msg_in);
  806577:	83 ec 0c             	sub    $0xc,%esp
  80657a:	ff 73 10             	pushl  0x10(%ebx)
  80657d:	e8 49 07 00 00       	call   806ccb <mem_free>
    dhcp->msg_in = NULL;
  806582:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  806589:	83 c4 10             	add    $0x10,%esp
  }
  if (dhcp->options_in) {
  80658c:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
  806590:	74 1b                	je     8065ad <dhcp_free_reply+0x46>
    mem_free((void *)dhcp->options_in);
  806592:	83 ec 0c             	sub    $0xc,%esp
  806595:	ff 73 14             	pushl  0x14(%ebx)
  806598:	e8 2e 07 00 00       	call   806ccb <mem_free>
    dhcp->options_in = NULL;
  80659d:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  8065a4:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  8065aa:	83 c4 10             	add    $0x10,%esp
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  8065ad:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8065b0:	c9                   	leave  
  8065b1:	c3                   	ret    

008065b2 <dhcp_recv>:


/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  8065b2:	55                   	push   %ebp
  8065b3:	89 e5                	mov    %esp,%ebp
  8065b5:	57                   	push   %edi
  8065b6:	56                   	push   %esi
  8065b7:	53                   	push   %ebx
  8065b8:	83 ec 0c             	sub    $0xc,%esp
  struct netif *netif = (struct netif *)arg;
  8065bb:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  8065be:	8b 7e 20             	mov    0x20(%esi),%edi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  8065c1:	8b 45 10             	mov    0x10(%ebp),%eax
  8065c4:	8b 58 04             	mov    0x4(%eax),%ebx
  u8_t *options_ptr;
  u8_t msg_type;
  u8_t i;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_recv(pbuf = %p) from DHCP server %"U16_F".%"U16_F".%"U16_F".%"U16_F" port %"U16_F"\n", (void*)p,
    (u16_t)(ntohl(addr->addr) >> 24 & 0xff), (u16_t)(ntohl(addr->addr) >> 16 & 0xff),
    (u16_t)(ntohl(addr->addr) >>  8 & 0xff), (u16_t)(ntohl(addr->addr) & 0xff), port));
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->len = %"U16_F"\n", p->len));
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  8065c7:	89 47 0c             	mov    %eax,0xc(%edi)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  8065ca:	80 3b 02             	cmpb   $0x2,(%ebx)
  8065cd:	0f 85 f8 00 00 00    	jne    8066cb <dhcp_recv+0x119>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8065d3:	b1 00                	mov    $0x0,%cl
  8065d5:	80 7e 24 00          	cmpb   $0x0,0x24(%esi)
  8065d9:	76 17                	jbe    8065f2 <dhcp_recv+0x40>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  8065db:	0f b6 d1             	movzbl %cl,%edx
  8065de:	8a 44 32 25          	mov    0x25(%edx,%esi,1),%al
  8065e2:	3a 44 1a 1c          	cmp    0x1c(%edx,%ebx,1),%al
  8065e6:	0f 85 df 00 00 00    	jne    8066cb <dhcp_recv+0x119>
  8065ec:	41                   	inc    %ecx
  8065ed:	38 4e 24             	cmp    %cl,0x24(%esi)
  8065f0:	77 e9                	ja     8065db <dhcp_recv+0x29>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  8065f2:	83 ec 0c             	sub    $0xc,%esp
  8065f5:	ff 73 04             	pushl  0x4(%ebx)
  8065f8:	e8 b9 40 00 00       	call   80a6b6 <ntohl>
  8065fd:	83 c4 10             	add    $0x10,%esp
  806600:	3b 47 04             	cmp    0x4(%edi),%eax
  806603:	0f 85 c2 00 00 00    	jne    8066cb <dhcp_recv+0x119>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp) != ERR_OK) {
  806609:	83 ec 0c             	sub    $0xc,%esp
  80660c:	57                   	push   %edi
  80660d:	e8 27 fe ff ff       	call   806439 <dhcp_unfold_reply>
  806612:	83 c4 10             	add    $0x10,%esp
  806615:	84 c0                	test   %al,%al
  806617:	0f 85 ae 00 00 00    	jne    8066cb <dhcp_recv+0x119>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  80661d:	83 ec 08             	sub    $0x8,%esp
  806620:	6a 35                	push   $0x35
  806622:	57                   	push   %edi
  806623:	e8 10 04 00 00       	call   806a38 <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  806628:	83 c4 10             	add    $0x10,%esp
  80662b:	85 c0                	test   %eax,%eax
  80662d:	0f 84 98 00 00 00    	je     8066cb <dhcp_recv+0x119>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  806633:	83 ec 0c             	sub    $0xc,%esp
  806636:	83 c0 02             	add    $0x2,%eax
  806639:	50                   	push   %eax
  80663a:	e8 fa 04 00 00       	call   806b39 <dhcp_get_option_byte>
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  80663f:	83 c4 10             	add    $0x10,%esp
  806642:	3c 05                	cmp    $0x5,%al
  806644:	75 3e                	jne    806684 <dhcp_recv+0xd2>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  806646:	80 3f 01             	cmpb   $0x1,(%edi)
  806649:	75 1c                	jne    806667 <dhcp_recv+0xb5>
      dhcp_handle_ack(netif);
  80664b:	83 ec 0c             	sub    $0xc,%esp
  80664e:	56                   	push   %esi
  80664f:	e8 ad f0 ff ff       	call   805701 <dhcp_handle_ack>
      dhcp->request_timeout = 0;
  806654:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  80665a:	89 34 24             	mov    %esi,(%esp)
  80665d:	e8 e2 ec ff ff       	call   805344 <dhcp_check>
  806662:	83 c4 10             	add    $0x10,%esp
  806665:	eb 64                	jmp    8066cb <dhcp_recv+0x119>
#else
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  806667:	8a 07                	mov    (%edi),%al
  806669:	83 e8 03             	sub    $0x3,%eax
  80666c:	3c 02                	cmp    $0x2,%al
  80666e:	77 5b                	ja     8066cb <dhcp_recv+0x119>
      dhcp->request_timeout = 0;
  806670:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_bind(netif);
  806676:	83 ec 0c             	sub    $0xc,%esp
  806679:	56                   	push   %esi
  80667a:	e8 c3 f6 ff ff       	call   805d42 <dhcp_bind>
  80667f:	83 c4 10             	add    $0x10,%esp
  806682:	eb 47                	jmp    8066cb <dhcp_recv+0x119>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  806684:	3c 06                	cmp    $0x6,%al
  806686:	75 28                	jne    8066b0 <dhcp_recv+0xfe>
  806688:	80 3f 03             	cmpb   $0x3,(%edi)
  80668b:	74 0f                	je     80669c <dhcp_recv+0xea>
  80668d:	80 3f 01             	cmpb   $0x1,(%edi)
  806690:	74 0a                	je     80669c <dhcp_recv+0xea>
  806692:	80 3f 04             	cmpb   $0x4,(%edi)
  806695:	74 05                	je     80669c <dhcp_recv+0xea>
  806697:	80 3f 05             	cmpb   $0x5,(%edi)
  80669a:	75 14                	jne    8066b0 <dhcp_recv+0xfe>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  80669c:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
    dhcp_handle_nak(netif);
  8066a2:	83 ec 0c             	sub    $0xc,%esp
  8066a5:	56                   	push   %esi
  8066a6:	e8 41 ec ff ff       	call   8052ec <dhcp_handle_nak>
  8066ab:	83 c4 10             	add    $0x10,%esp
  8066ae:	eb 1b                	jmp    8066cb <dhcp_recv+0x119>
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  8066b0:	3c 02                	cmp    $0x2,%al
  8066b2:	75 17                	jne    8066cb <dhcp_recv+0x119>
  8066b4:	80 3f 06             	cmpb   $0x6,(%edi)
  8066b7:	75 12                	jne    8066cb <dhcp_recv+0x119>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  8066b9:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
    /* remember offered lease */
    dhcp_handle_offer(netif);
  8066bf:	83 ec 0c             	sub    $0xc,%esp
  8066c2:	56                   	push   %esi
  8066c3:	e8 ae ec ff ff       	call   805376 <dhcp_handle_offer>
  8066c8:	83 c4 10             	add    $0x10,%esp
  }
free_pbuf_and_return:
  pbuf_free(p);
  8066cb:	83 ec 0c             	sub    $0xc,%esp
  8066ce:	ff 75 10             	pushl  0x10(%ebp)
  8066d1:	e8 43 12 00 00       	call   807919 <pbuf_free>
  dhcp->p = NULL;
  8066d6:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
}
  8066dd:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8066e0:	5b                   	pop    %ebx
  8066e1:	5e                   	pop    %esi
  8066e2:	5f                   	pop    %edi
  8066e3:	c9                   	leave  
  8066e4:	c3                   	ret    

008066e5 <dhcp_create_request>:

/**
 * Create a DHCP request, fill in common headers
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  8066e5:	55                   	push   %ebp
  8066e6:	89 e5                	mov    %esp,%ebp
  8066e8:	57                   	push   %edi
  8066e9:	56                   	push   %esi
  8066ea:	53                   	push   %ebx
  8066eb:	83 ec 0c             	sub    $0xc,%esp
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  8066ee:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  8066f2:	75 17                	jne    80670b <dhcp_create_request+0x26>
  8066f4:	83 ec 04             	sub    $0x4,%esp
  8066f7:	68 94 27 81 00       	push   $0x812794
  8066fc:	68 2d 05 00 00       	push   $0x52d
  806701:	68 cc 25 81 00       	push   $0x8125cc
  806706:	e8 c1 a3 ff ff       	call   800acc <_panic>
  dhcp = netif->dhcp;
  80670b:	8b 45 08             	mov    0x8(%ebp),%eax
  80670e:	8b 70 20             	mov    0x20(%eax),%esi
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  806711:	85 f6                	test   %esi,%esi
  806713:	75 17                	jne    80672c <dhcp_create_request+0x47>
  806715:	83 ec 04             	sub    $0x4,%esp
  806718:	68 b8 27 81 00       	push   $0x8127b8
  80671d:	68 2f 05 00 00       	push   $0x52f
  806722:	68 cc 25 81 00       	push   $0x8125cc
  806727:	e8 a0 a3 ff ff       	call   800acc <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  80672c:	83 7e 1c 00          	cmpl   $0x0,0x1c(%esi)
  806730:	74 17                	je     806749 <dhcp_create_request+0x64>
  806732:	83 ec 04             	sub    $0x4,%esp
  806735:	68 dc 27 81 00       	push   $0x8127dc
  80673a:	68 30 05 00 00       	push   $0x530
  80673f:	68 cc 25 81 00       	push   $0x8125cc
  806744:	e8 83 a3 ff ff       	call   800acc <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  806749:	83 7e 20 00          	cmpl   $0x0,0x20(%esi)
  80674d:	74 17                	je     806766 <dhcp_create_request+0x81>
  80674f:	83 ec 04             	sub    $0x4,%esp
  806752:	68 08 28 81 00       	push   $0x812808
  806757:	68 31 05 00 00       	push   $0x531
  80675c:	68 cc 25 81 00       	push   $0x8125cc
  806761:	e8 66 a3 ff ff       	call   800acc <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  806766:	83 ec 04             	sub    $0x4,%esp
  806769:	6a 00                	push   $0x0
  80676b:	68 34 01 00 00       	push   $0x134
  806770:	6a 00                	push   $0x0
  806772:	e8 11 0d 00 00       	call   807488 <pbuf_alloc>
  806777:	89 46 1c             	mov    %eax,0x1c(%esi)
  if (dhcp->p_out == NULL) {
  80677a:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  80677d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806782:	83 7e 1c 00          	cmpl   $0x0,0x1c(%esi)
  806786:	0f 84 41 01 00 00    	je     8068cd <dhcp_create_request+0x1e8>
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  80678c:	8b 46 1c             	mov    0x1c(%esi),%eax
  80678f:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  806795:	77 17                	ja     8067ae <dhcp_create_request+0xc9>
  806797:	83 ec 04             	sub    $0x4,%esp
  80679a:	68 34 28 81 00       	push   $0x812834
  80679f:	68 38 05 00 00       	push   $0x538
  8067a4:	68 cc 25 81 00       	push   $0x8125cc
  8067a9:	e8 1e a3 ff ff       	call   800acc <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  8067ae:	8b 15 a4 80 81 00    	mov    0x8180a4,%edx
  8067b4:	8d 42 01             	lea    0x1(%edx),%eax
  8067b7:	a3 a4 80 81 00       	mov    %eax,0x8180a4
  8067bc:	89 56 04             	mov    %edx,0x4(%esi)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  8067bf:	8b 46 1c             	mov    0x1c(%esi),%eax
  8067c2:	8b 40 04             	mov    0x4(%eax),%eax
  8067c5:	89 46 20             	mov    %eax,0x20(%esi)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  8067c8:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  8067cb:	8b 46 20             	mov    0x20(%esi),%eax
  8067ce:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  8067d2:	8b 46 20             	mov    0x20(%esi),%eax
  8067d5:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  8067d9:	8b 46 20             	mov    0x20(%esi),%eax
  8067dc:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  8067e0:	8b 5e 20             	mov    0x20(%esi),%ebx
  8067e3:	83 ec 0c             	sub    $0xc,%esp
  8067e6:	ff 76 04             	pushl  0x4(%esi)
  8067e9:	e8 9c 3e 00 00       	call   80a68a <htonl>
  8067ee:	89 43 04             	mov    %eax,0x4(%ebx)
  dhcp->msg_out->secs = 0;
  8067f1:	8b 46 20             	mov    0x20(%esi),%eax
  8067f4:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  8067fa:	8b 46 20             	mov    0x20(%esi),%eax
  8067fd:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  806803:	8b 56 20             	mov    0x20(%esi),%edx
  806806:	8b 4d 08             	mov    0x8(%ebp),%ecx
  806809:	8b 41 04             	mov    0x4(%ecx),%eax
  80680c:	89 42 0c             	mov    %eax,0xc(%edx)
  dhcp->msg_out->yiaddr.addr = 0;
  80680f:	8b 46 20             	mov    0x20(%esi),%eax
  806812:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  806819:	8b 46 20             	mov    0x20(%esi),%eax
  80681c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  806823:	8b 46 20             	mov    0x20(%esi),%eax
  806826:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80682d:	b9 00 00 00 00       	mov    $0x0,%ecx
  806832:	83 c4 10             	add    $0x10,%esp
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  806835:	8b 5e 20             	mov    0x20(%esi),%ebx
  806838:	0f b7 d1             	movzwl %cx,%edx
  80683b:	8b 7d 08             	mov    0x8(%ebp),%edi
  80683e:	66 0f b6 47 24       	movzbw 0x24(%edi),%ax
  806843:	bf 00 00 00 00       	mov    $0x0,%edi
  806848:	66 39 c8             	cmp    %cx,%ax
  80684b:	76 08                	jbe    806855 <dhcp_create_request+0x170>
  80684d:	8b 45 08             	mov    0x8(%ebp),%eax
  806850:	0f b6 7c 02 25       	movzbl 0x25(%edx,%eax,1),%edi
  806855:	89 f8                	mov    %edi,%eax
  806857:	88 44 1a 1c          	mov    %al,0x1c(%edx,%ebx,1)
  80685b:	41                   	inc    %ecx
  80685c:	66 83 f9 0f          	cmp    $0xf,%cx
  806860:	76 d3                	jbe    806835 <dhcp_create_request+0x150>
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  806862:	b9 00 00 00 00       	mov    $0x0,%ecx
    dhcp->msg_out->sname[i] = 0;
  806867:	8b 56 20             	mov    0x20(%esi),%edx
  80686a:	0f b7 c1             	movzwl %cx,%eax
  80686d:	c6 44 10 2c 00       	movb   $0x0,0x2c(%eax,%edx,1)
  806872:	41                   	inc    %ecx
  806873:	66 83 f9 3f          	cmp    $0x3f,%cx
  806877:	76 ee                	jbe    806867 <dhcp_create_request+0x182>
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  806879:	b9 00 00 00 00       	mov    $0x0,%ecx
    dhcp->msg_out->file[i] = 0;
  80687e:	8b 56 20             	mov    0x20(%esi),%edx
  806881:	0f b7 c1             	movzwl %cx,%eax
  806884:	c6 44 10 6c 00       	movb   $0x0,0x6c(%eax,%edx,1)
  806889:	41                   	inc    %ecx
  80688a:	66 83 f9 7f          	cmp    $0x7f,%cx
  80688e:	76 ee                	jbe    80687e <dhcp_create_request+0x199>
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  806890:	8b 5e 20             	mov    0x20(%esi),%ebx
  806893:	83 ec 0c             	sub    $0xc,%esp
  806896:	68 63 53 82 63       	push   $0x63825363
  80689b:	e8 ea 3d 00 00       	call   80a68a <htonl>
  8068a0:	89 83 ec 00 00 00    	mov    %eax,0xec(%ebx)
  dhcp->options_out_len = 0;
  8068a6:	66 c7 46 24 00 00    	movw   $0x0,0x24(%esi)
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  8068ac:	b9 00 00 00 00       	mov    $0x0,%ecx
  8068b1:	83 c4 10             	add    $0x10,%esp
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  8068b4:	8b 56 20             	mov    0x20(%esi),%edx
  8068b7:	0f b7 c1             	movzwl %cx,%eax
  8068ba:	88 8c 10 f0 00 00 00 	mov    %cl,0xf0(%eax,%edx,1)
  8068c1:	41                   	inc    %ecx
  8068c2:	66 83 f9 43          	cmp    $0x43,%cx
  8068c6:	76 ec                	jbe    8068b4 <dhcp_create_request+0x1cf>
  }
  return ERR_OK;
  8068c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8068cd:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8068d0:	5b                   	pop    %ebx
  8068d1:	5e                   	pop    %esi
  8068d2:	5f                   	pop    %edi
  8068d3:	c9                   	leave  
  8068d4:	c3                   	ret    

008068d5 <dhcp_delete_request>:

/**
 * Free previously allocated memory used to send a DHCP request.
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  8068d5:	55                   	push   %ebp
  8068d6:	89 e5                	mov    %esp,%ebp
  8068d8:	53                   	push   %ebx
  8068d9:	83 ec 04             	sub    $0x4,%esp
  8068dc:	8b 45 08             	mov    0x8(%ebp),%eax
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  8068df:	85 c0                	test   %eax,%eax
  8068e1:	75 17                	jne    8068fa <dhcp_delete_request+0x25>
  8068e3:	83 ec 04             	sub    $0x4,%esp
  8068e6:	68 78 28 81 00       	push   $0x812878
  8068eb:	68 69 05 00 00       	push   $0x569
  8068f0:	68 cc 25 81 00       	push   $0x8125cc
  8068f5:	e8 d2 a1 ff ff       	call   800acc <_panic>
  dhcp = netif->dhcp;
  8068fa:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  8068fd:	85 db                	test   %ebx,%ebx
  8068ff:	75 17                	jne    806918 <dhcp_delete_request+0x43>
  806901:	83 ec 04             	sub    $0x4,%esp
  806904:	68 9c 28 81 00       	push   $0x81289c
  806909:	68 6b 05 00 00       	push   $0x56b
  80690e:	68 cc 25 81 00       	push   $0x8125cc
  806913:	e8 b4 a1 ff ff       	call   800acc <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  806918:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  80691c:	75 17                	jne    806935 <dhcp_delete_request+0x60>
  80691e:	83 ec 04             	sub    $0x4,%esp
  806921:	68 c0 28 81 00       	push   $0x8128c0
  806926:	68 6c 05 00 00       	push   $0x56c
  80692b:	68 cc 25 81 00       	push   $0x8125cc
  806930:	e8 97 a1 ff ff       	call   800acc <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  806935:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  806939:	75 17                	jne    806952 <dhcp_delete_request+0x7d>
  80693b:	83 ec 04             	sub    $0x4,%esp
  80693e:	68 ec 28 81 00       	push   $0x8128ec
  806943:	68 6d 05 00 00       	push   $0x56d
  806948:	68 cc 25 81 00       	push   $0x8125cc
  80694d:	e8 7a a1 ff ff       	call   800acc <_panic>
  if (dhcp->p_out != NULL) {
  806952:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  806956:	74 0e                	je     806966 <dhcp_delete_request+0x91>
    pbuf_free(dhcp->p_out);
  806958:	83 ec 0c             	sub    $0xc,%esp
  80695b:	ff 73 1c             	pushl  0x1c(%ebx)
  80695e:	e8 b6 0f 00 00       	call   807919 <pbuf_free>
  806963:	83 c4 10             	add    $0x10,%esp
  }
  dhcp->p_out = NULL;
  806966:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  80696d:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  806974:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  806977:	c9                   	leave  
  806978:	c3                   	ret    

00806979 <dhcp_option_trailer>:

/**
 * Add a DHCP message trailer
 *
 * Adds the END option to the DHCP message, and if
 * necessary, up to three padding bytes.
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  806979:	55                   	push   %ebp
  80697a:	89 e5                	mov    %esp,%ebp
  80697c:	83 ec 08             	sub    $0x8,%esp
  80697f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  806982:	85 c9                	test   %ecx,%ecx
  806984:	75 17                	jne    80699d <dhcp_option_trailer+0x24>
  806986:	83 ec 04             	sub    $0x4,%esp
  806989:	68 18 29 81 00       	push   $0x812918
  80698e:	68 80 05 00 00       	push   $0x580
  806993:	68 cc 25 81 00       	push   $0x8125cc
  806998:	e8 2f a1 ff ff       	call   800acc <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  80699d:	83 79 20 00          	cmpl   $0x0,0x20(%ecx)
  8069a1:	75 17                	jne    8069ba <dhcp_option_trailer+0x41>
  8069a3:	83 ec 04             	sub    $0x4,%esp
  8069a6:	68 3c 29 81 00       	push   $0x81293c
  8069ab:	68 81 05 00 00       	push   $0x581
  8069b0:	68 cc 25 81 00       	push   $0x8125cc
  8069b5:	e8 12 a1 ff ff       	call   800acc <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8069ba:	66 83 79 24 43       	cmpw   $0x43,0x24(%ecx)
  8069bf:	76 17                	jbe    8069d8 <dhcp_option_trailer+0x5f>
  8069c1:	83 ec 04             	sub    $0x4,%esp
  8069c4:	68 68 29 81 00       	push   $0x812968
  8069c9:	68 82 05 00 00       	push   $0x582
  8069ce:	68 cc 25 81 00       	push   $0x8125cc
  8069d3:	e8 f4 a0 ff ff       	call   800acc <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  8069d8:	8b 51 20             	mov    0x20(%ecx),%edx
  8069db:	0f b7 41 24          	movzwl 0x24(%ecx),%eax
  8069df:	c6 84 10 f0 00 00 00 	movb   $0xff,0xf0(%eax,%edx,1)
  8069e6:	ff 
  8069e7:	66 ff 41 24          	incw   0x24(%ecx)
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  8069eb:	66 83 79 24 43       	cmpw   $0x43,0x24(%ecx)
  8069f0:	76 24                	jbe    806a16 <dhcp_option_trailer+0x9d>
  8069f2:	f6 41 24 03          	testb  $0x3,0x24(%ecx)
  8069f6:	74 3e                	je     806a36 <dhcp_option_trailer+0xbd>
  8069f8:	66 83 79 24 43       	cmpw   $0x43,0x24(%ecx)
  8069fd:	76 17                	jbe    806a16 <dhcp_option_trailer+0x9d>
  8069ff:	83 ec 04             	sub    $0x4,%esp
  806a02:	68 68 29 81 00       	push   $0x812968
  806a07:	68 87 05 00 00       	push   $0x587
  806a0c:	68 cc 25 81 00       	push   $0x8125cc
  806a11:	e8 b6 a0 ff ff       	call   800acc <_panic>
  806a16:	8b 51 20             	mov    0x20(%ecx),%edx
  806a19:	0f b7 41 24          	movzwl 0x24(%ecx),%eax
  806a1d:	c6 84 10 f0 00 00 00 	movb   $0x0,0xf0(%eax,%edx,1)
  806a24:	00 
  806a25:	66 ff 41 24          	incw   0x24(%ecx)
  806a29:	66 83 79 24 43       	cmpw   $0x43,0x24(%ecx)
  806a2e:	76 e6                	jbe    806a16 <dhcp_option_trailer+0x9d>
  806a30:	f6 41 24 03          	testb  $0x3,0x24(%ecx)
  806a34:	75 c2                	jne    8069f8 <dhcp_option_trailer+0x7f>
  }
}
  806a36:	c9                   	leave  
  806a37:	c3                   	ret    

00806a38 <dhcp_get_option_ptr>:

/**
 * Find the offset of a DHCP option inside the DHCP message.
 *
 * @param dhcp DHCP client
 * @param option_type
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  806a38:	55                   	push   %ebp
  806a39:	89 e5                	mov    %esp,%ebp
  806a3b:	57                   	push   %edi
  806a3c:	56                   	push   %esi
  806a3d:	53                   	push   %ebx
  806a3e:	83 ec 04             	sub    $0x4,%esp
  806a41:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806a44:	8a 45 0c             	mov    0xc(%ebp),%al
  806a47:	88 45 f3             	mov    %al,0xfffffff3(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;
  806a4a:	be 00 00 00 00       	mov    $0x0,%esi

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  806a4f:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
  806a53:	0f 84 d3 00 00 00    	je     806b2c <dhcp_get_option_ptr+0xf4>
  806a59:	66 83 7b 18 00       	cmpw   $0x0,0x18(%ebx)
  806a5e:	0f 84 c8 00 00 00    	je     806b2c <dhcp_get_option_ptr+0xf4>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
  806a64:	8b 4b 14             	mov    0x14(%ebx),%ecx
    u16_t offset = 0;
  806a67:	ba 00 00 00 00       	mov    $0x0,%edx
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
        overload = options[offset++];
      }
      /* requested option found */
      else if (options[offset] == option_type) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset %"U16_F" in options\n", offset));
        return &options[offset];
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  806a6c:	66 83 7b 18 00       	cmpw   $0x0,0x18(%ebx)
  806a71:	76 4b                	jbe    806abe <dhcp_get_option_ptr+0x86>
  806a73:	80 39 ff             	cmpb   $0xff,(%ecx)
  806a76:	74 46                	je     806abe <dhcp_get_option_ptr+0x86>
  806a78:	0f b7 c2             	movzwl %dx,%eax
  806a7b:	80 3c 08 34          	cmpb   $0x34,(%eax,%ecx,1)
  806a7f:	75 0d                	jne    806a8e <dhcp_get_option_ptr+0x56>
  806a81:	83 c2 02             	add    $0x2,%edx
  806a84:	0f b7 c2             	movzwl %dx,%eax
  806a87:	42                   	inc    %edx
  806a88:	0f b6 34 08          	movzbl (%eax,%ecx,1),%esi
  806a8c:	eb 21                	jmp    806aaf <dhcp_get_option_ptr+0x77>
  806a8e:	0f b7 fa             	movzwl %dx,%edi
  806a91:	8a 45 f3             	mov    0xfffffff3(%ebp),%al
  806a94:	38 04 0f             	cmp    %al,(%edi,%ecx,1)
  806a97:	75 09                	jne    806aa2 <dhcp_get_option_ptr+0x6a>
  806a99:	89 f8                	mov    %edi,%eax
  806a9b:	01 c8                	add    %ecx,%eax
  806a9d:	e9 8f 00 00 00       	jmp    806b31 <dhcp_get_option_ptr+0xf9>
  806aa2:	42                   	inc    %edx
  806aa3:	0f b7 c2             	movzwl %dx,%eax
  806aa6:	66 0f b6 04 08       	movzbw (%eax,%ecx,1),%ax
  806aab:	8d 54 02 01          	lea    0x1(%edx,%eax,1),%edx
  806aaf:	66 39 53 18          	cmp    %dx,0x18(%ebx)
  806ab3:	76 09                	jbe    806abe <dhcp_get_option_ptr+0x86>
  806ab5:	0f b7 c2             	movzwl %dx,%eax
  806ab8:	80 3c 08 ff          	cmpb   $0xff,(%eax,%ecx,1)
  806abc:	75 ba                	jne    806a78 <dhcp_get_option_ptr+0x40>
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  806abe:	89 f0                	mov    %esi,%eax
  806ac0:	84 c0                	test   %al,%al
  806ac2:	74 68                	je     806b2c <dhcp_get_option_ptr+0xf4>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  806ac4:	3c 01                	cmp    $0x1,%al
  806ac6:	75 0d                	jne    806ad5 <dhcp_get_option_ptr+0x9d>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  806ac8:	8b 4b 10             	mov    0x10(%ebx),%ecx
  806acb:	83 c1 6c             	add    $0x6c,%ecx
        field_len = DHCP_FILE_LEN;
  806ace:	be 80 00 00 00       	mov    $0x80,%esi
  806ad3:	eb 1e                	jmp    806af3 <dhcp_get_option_ptr+0xbb>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  806ad5:	89 f0                	mov    %esi,%eax
  806ad7:	3c 02                	cmp    $0x2,%al
  806ad9:	75 0d                	jne    806ae8 <dhcp_get_option_ptr+0xb0>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  806adb:	8b 4b 10             	mov    0x10(%ebx),%ecx
  806ade:	83 c1 2c             	add    $0x2c,%ecx
        field_len = DHCP_SNAME_LEN;
  806ae1:	be 40 00 00 00       	mov    $0x40,%esi
  806ae6:	eb 0b                	jmp    806af3 <dhcp_get_option_ptr+0xbb>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  806ae8:	8b 4b 10             	mov    0x10(%ebx),%ecx
  806aeb:	83 c1 2c             	add    $0x2c,%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  806aee:	be c0 00 00 00       	mov    $0xc0,%esi
      }
      offset = 0;
  806af3:	ba 00 00 00 00       	mov    $0x0,%edx

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
        if (options[offset] == option_type) {
           LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset=%"U16_F"\n", offset));
          return &options[offset];
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
          offset += 1 + options[offset];
  806af8:	66 39 f2             	cmp    %si,%dx
  806afb:	73 2f                	jae    806b2c <dhcp_get_option_ptr+0xf4>
  806afd:	80 39 ff             	cmpb   $0xff,(%ecx)
  806b00:	74 2a                	je     806b2c <dhcp_get_option_ptr+0xf4>
  806b02:	0f b7 c2             	movzwl %dx,%eax
  806b05:	8a 5d f3             	mov    0xfffffff3(%ebp),%bl
  806b08:	38 1c 08             	cmp    %bl,(%eax,%ecx,1)
  806b0b:	75 04                	jne    806b11 <dhcp_get_option_ptr+0xd9>
  806b0d:	01 c8                	add    %ecx,%eax
  806b0f:	eb 20                	jmp    806b31 <dhcp_get_option_ptr+0xf9>
  806b11:	42                   	inc    %edx
  806b12:	0f b7 c2             	movzwl %dx,%eax
  806b15:	66 0f b6 04 08       	movzbw (%eax,%ecx,1),%ax
  806b1a:	8d 54 02 01          	lea    0x1(%edx,%eax,1),%edx
  806b1e:	66 39 f2             	cmp    %si,%dx
  806b21:	73 09                	jae    806b2c <dhcp_get_option_ptr+0xf4>
  806b23:	0f b7 c2             	movzwl %dx,%eax
  806b26:	80 3c 08 ff          	cmpb   $0xff,(%eax,%ecx,1)
  806b2a:	75 d6                	jne    806b02 <dhcp_get_option_ptr+0xca>
        }
      }
    }
  }
  return NULL;
  806b2c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  806b31:	83 c4 04             	add    $0x4,%esp
  806b34:	5b                   	pop    %ebx
  806b35:	5e                   	pop    %esi
  806b36:	5f                   	pop    %edi
  806b37:	c9                   	leave  
  806b38:	c3                   	ret    

00806b39 <dhcp_get_option_byte>:

/**
 * Return the byte of DHCP option data.
 *
 * @param client DHCP client.
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  806b39:	55                   	push   %ebp
  806b3a:	89 e5                	mov    %esp,%ebp
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  806b3c:	8b 45 08             	mov    0x8(%ebp),%eax
  806b3f:	0f b6 00             	movzbl (%eax),%eax
}
  806b42:	c9                   	leave  
  806b43:	c3                   	ret    

00806b44 <dhcp_get_option_long>:

#if 0 /* currently unused */
/**
 * Return the 16-bit value of DHCP option data.
 *
 * @param client DHCP client.
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u16_t
dhcp_get_option_short(u8_t *ptr)
{
  u16_t value;
  value = *ptr++ << 8;
  value |= *ptr;
  LWIP_DEBUGF(DHCP_DEBUG, ("option short value=%"U16_F"\n", value));
  return value;
}
#endif

/**
 * Return the 32-bit value of DHCP option data.
 *
 * @param client DHCP client.
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  806b44:	55                   	push   %ebp
  806b45:	89 e5                	mov    %esp,%ebp
  806b47:	8b 4d 08             	mov    0x8(%ebp),%ecx
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  806b4a:	0f b6 01             	movzbl (%ecx),%eax
  806b4d:	c1 e0 18             	shl    $0x18,%eax
  806b50:	41                   	inc    %ecx
  value |= (u32_t)(*ptr++) << 16;
  806b51:	0f b6 11             	movzbl (%ecx),%edx
  806b54:	c1 e2 10             	shl    $0x10,%edx
  806b57:	09 d0                	or     %edx,%eax
  806b59:	41                   	inc    %ecx
  value |= (u32_t)(*ptr++) << 8;
  806b5a:	0f b6 11             	movzbl (%ecx),%edx
  806b5d:	c1 e2 08             	shl    $0x8,%edx
  806b60:	09 d0                	or     %edx,%eax
  value |= (u32_t)(*ptr++);
  806b62:	0f b6 51 01          	movzbl 0x1(%ecx),%edx
  806b66:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  806b68:	c9                   	leave  
  806b69:	c3                   	ret    
	...

00806b6c <plug_holes>:
 * already.
 */
static void
plug_holes(struct mem *mem)
{
  806b6c:	55                   	push   %ebp
  806b6d:	89 e5                	mov    %esp,%ebp
  806b6f:	56                   	push   %esi
  806b70:	53                   	push   %ebx
  806b71:	8b 75 08             	mov    0x8(%ebp),%esi
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  806b74:	3b 35 3c 87 a3 00    	cmp    0xa3873c,%esi
  806b7a:	73 17                	jae    806b93 <plug_holes+0x27>
  806b7c:	83 ec 04             	sub    $0x4,%esp
  806b7f:	68 a7 29 81 00       	push   $0x8129a7
  806b84:	68 e3 00 00 00       	push   $0xe3
  806b89:	68 be 29 81 00       	push   $0x8129be
  806b8e:	e8 39 9f ff ff       	call   800acc <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  806b93:	3b 35 40 87 a3 00    	cmp    0xa38740,%esi
  806b99:	72 17                	jb     806bb2 <plug_holes+0x46>
  806b9b:	83 ec 04             	sub    $0x4,%esp
  806b9e:	68 d2 29 81 00       	push   $0x8129d2
  806ba3:	68 e4 00 00 00       	push   $0xe4
  806ba8:	68 be 29 81 00       	push   $0x8129be
  806bad:	e8 1a 9f ff ff       	call   800acc <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
  806bb2:	80 7e 08 00          	cmpb   $0x0,0x8(%esi)
  806bb6:	74 17                	je     806bcf <plug_holes+0x63>
  806bb8:	83 ec 04             	sub    $0x4,%esp
  806bbb:	68 ec 29 81 00       	push   $0x8129ec
  806bc0:	68 e5 00 00 00       	push   $0xe5
  806bc5:	68 be 29 81 00       	push   $0x8129be
  806bca:	e8 fd 9e ff ff       	call   800acc <_panic>

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  806bcf:	81 3e 00 00 22 00    	cmpl   $0x220000,(%esi)
  806bd5:	76 17                	jbe    806bee <plug_holes+0x82>
  806bd7:	83 ec 04             	sub    $0x4,%esp
  806bda:	68 68 2a 81 00       	push   $0x812a68
  806bdf:	68 e8 00 00 00       	push   $0xe8
  806be4:	68 be 29 81 00       	push   $0x8129be
  806be9:	e8 de 9e ff ff       	call   800acc <_panic>

  nmem = (struct mem *)&ram[mem->next];
  806bee:	8b 06                	mov    (%esi),%eax
  806bf0:	89 c2                	mov    %eax,%edx
  806bf2:	03 15 3c 87 a3 00    	add    0xa3873c,%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  806bf8:	39 d6                	cmp    %edx,%esi
  806bfa:	74 30                	je     806c2c <plug_holes+0xc0>
  806bfc:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  806c00:	75 2a                	jne    806c2c <plug_holes+0xc0>
  806c02:	3b 15 40 87 a3 00    	cmp    0xa38740,%edx
  806c08:	74 22                	je     806c2c <plug_holes+0xc0>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  806c0a:	39 15 44 87 a3 00    	cmp    %edx,0xa38744
  806c10:	75 06                	jne    806c18 <plug_holes+0xac>
      lfree = mem;
  806c12:	89 35 44 87 a3 00    	mov    %esi,0xa38744
    }
    mem->next = nmem->next;
  806c18:	8b 02                	mov    (%edx),%eax
  806c1a:	89 06                	mov    %eax,(%esi)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  806c1c:	8b 0a                	mov    (%edx),%ecx
  806c1e:	8b 15 3c 87 a3 00    	mov    0xa3873c,%edx
  806c24:	89 f0                	mov    %esi,%eax
  806c26:	29 d0                	sub    %edx,%eax
  806c28:	89 44 11 04          	mov    %eax,0x4(%ecx,%edx,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  806c2c:	8b 46 04             	mov    0x4(%esi),%eax
  806c2f:	89 c3                	mov    %eax,%ebx
  806c31:	03 1d 3c 87 a3 00    	add    0xa3873c,%ebx
  if (pmem != mem && pmem->used == 0) {
  806c37:	39 f3                	cmp    %esi,%ebx
  806c39:	74 28                	je     806c63 <plug_holes+0xf7>
  806c3b:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  806c3f:	75 22                	jne    806c63 <plug_holes+0xf7>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  806c41:	39 35 44 87 a3 00    	cmp    %esi,0xa38744
  806c47:	75 06                	jne    806c4f <plug_holes+0xe3>
      lfree = pmem;
  806c49:	89 1d 44 87 a3 00    	mov    %ebx,0xa38744
    }
    pmem->next = mem->next;
  806c4f:	8b 06                	mov    (%esi),%eax
  806c51:	89 03                	mov    %eax,(%ebx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  806c53:	8b 0e                	mov    (%esi),%ecx
  806c55:	8b 15 3c 87 a3 00    	mov    0xa3873c,%edx
  806c5b:	89 d8                	mov    %ebx,%eax
  806c5d:	29 d0                	sub    %edx,%eax
  806c5f:	89 44 11 04          	mov    %eax,0x4(%ecx,%edx,1)
  }
}
  806c63:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  806c66:	5b                   	pop    %ebx
  806c67:	5e                   	pop    %esi
  806c68:	c9                   	leave  
  806c69:	c3                   	ret    

00806c6a <mem_init>:

/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  806c6a:	55                   	push   %ebp
  806c6b:	89 e5                	mov    %esp,%ebp
  806c6d:	83 ec 14             	sub    $0x14,%esp
  struct mem *mem;

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  806c70:	b8 23 87 81 00       	mov    $0x818723,%eax
  806c75:	83 e0 fc             	and    $0xfffffffc,%eax
  806c78:	a3 3c 87 a3 00       	mov    %eax,0xa3873c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  806c7d:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  806c83:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  806c8a:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  806c8e:	05 00 00 22 00       	add    $0x220000,%eax
  806c93:	a3 40 87 a3 00       	mov    %eax,0xa38740
  ram_end->used = 1;
  806c98:	c6 40 08 01          	movb   $0x1,0x8(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  806c9c:	a1 40 87 a3 00       	mov    0xa38740,%eax
  806ca1:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  ram_end->prev = MEM_SIZE_ALIGNED;
  806ca7:	a1 40 87 a3 00       	mov    0xa38740,%eax
  806cac:	c7 40 04 00 00 22 00 	movl   $0x220000,0x4(%eax)

  mem_sem = sys_sem_new(1);
  806cb3:	6a 01                	push   $0x1
  806cb5:	e8 af 61 00 00       	call   80ce69 <sys_sem_new>
  806cba:	a3 48 87 a3 00       	mov    %eax,0xa38748

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  806cbf:	a1 3c 87 a3 00       	mov    0xa3873c,%eax
  806cc4:	a3 44 87 a3 00       	mov    %eax,0xa38744

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  806cc9:	c9                   	leave  
  806cca:	c3                   	ret    

00806ccb <mem_free>:

/**
 * Put a struct mem back on the heap
 *
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  806ccb:	55                   	push   %ebp
  806ccc:	89 e5                	mov    %esp,%ebp
  806cce:	53                   	push   %ebx
  806ccf:	83 ec 04             	sub    $0x4,%esp
  806cd2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  806cd5:	85 db                	test   %ebx,%ebx
  806cd7:	0f 84 ae 00 00 00    	je     806d8b <mem_free+0xc0>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  806cdd:	f6 c3 03             	test   $0x3,%bl
  806ce0:	74 17                	je     806cf9 <mem_free+0x2e>
  806ce2:	83 ec 04             	sub    $0x4,%esp
  806ce5:	68 94 2a 81 00       	push   $0x812a94
  806cea:	68 30 01 00 00       	push   $0x130
  806cef:	68 be 29 81 00       	push   $0x8129be
  806cf4:	e8 d3 9d ff ff       	call   800acc <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  806cf9:	3b 1d 3c 87 a3 00    	cmp    0xa3873c,%ebx
  806cff:	72 08                	jb     806d09 <mem_free+0x3e>
  806d01:	3b 1d 40 87 a3 00    	cmp    0xa38740,%ebx
  806d07:	72 17                	jb     806d20 <mem_free+0x55>
  806d09:	83 ec 04             	sub    $0x4,%esp
  806d0c:	68 07 2a 81 00       	push   $0x812a07
  806d11:	68 33 01 00 00       	push   $0x133
  806d16:	68 be 29 81 00       	push   $0x8129be
  806d1b:	e8 ac 9d ff ff       	call   800acc <_panic>
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  806d20:	3b 1d 3c 87 a3 00    	cmp    0xa3873c,%ebx
  806d26:	72 63                	jb     806d8b <mem_free+0xc0>
  806d28:	3b 1d 40 87 a3 00    	cmp    0xa38740,%ebx
  806d2e:	73 5b                	jae    806d8b <mem_free+0xc0>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  806d30:	83 ec 08             	sub    $0x8,%esp
  806d33:	6a 00                	push   $0x0
  806d35:	ff 35 48 87 a3 00    	pushl  0xa38748
  806d3b:	e8 9c 62 00 00       	call   80cfdc <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  806d40:	8d 43 f4             	lea    0xfffffff4(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  806d43:	83 c4 10             	add    $0x10,%esp
  806d46:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  806d4a:	75 17                	jne    806d63 <mem_free+0x98>
  806d4c:	83 ec 04             	sub    $0x4,%esp
  806d4f:	68 1e 2a 81 00       	push   $0x812a1e
  806d54:	68 43 01 00 00       	push   $0x143
  806d59:	68 be 29 81 00       	push   $0x8129be
  806d5e:	e8 69 9d ff ff       	call   800acc <_panic>
  /* ... and is now unused. */
  mem->used = 0;
  806d63:	c6 40 08 00          	movb   $0x0,0x8(%eax)

  if (mem < lfree) {
  806d67:	3b 05 44 87 a3 00    	cmp    0xa38744,%eax
  806d6d:	73 05                	jae    806d74 <mem_free+0xa9>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  806d6f:	a3 44 87 a3 00       	mov    %eax,0xa38744
  }

  MEM_STATS_DEC_USED(used, mem->next - ((u8_t *)mem - ram));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
  806d74:	83 ec 0c             	sub    $0xc,%esp
  806d77:	50                   	push   %eax
  806d78:	e8 ef fd ff ff       	call   806b6c <plug_holes>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  806d7d:	83 c4 04             	add    $0x4,%esp
  806d80:	ff 35 48 87 a3 00    	pushl  0xa38748
  806d86:	e8 ef 61 00 00       	call   80cf7a <sys_sem_signal>
}
  806d8b:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  806d8e:	c9                   	leave  
  806d8f:	c3                   	ret    

00806d90 <mem_realloc>:

/**
 * In contrast to its name, mem_realloc can only shrink memory, not expand it.
 * Since the only use (for now) is in pbuf_realloc (which also can only shrink),
 * this shouldn't be a problem!
 *
 * @param rmem pointer to memory allocated by mem_malloc the is to be shrinked
 * @param newsize required size after shrinking (needs to be smaller than or
 *                equal to the previous size)
 * @return for compatibility reasons: is always == rmem, at the moment
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  806d90:	55                   	push   %ebp
  806d91:	89 e5                	mov    %esp,%ebp
  806d93:	57                   	push   %edi
  806d94:	56                   	push   %esi
  806d95:	53                   	push   %ebx
  806d96:	83 ec 0c             	sub    $0xc,%esp
  806d99:	8b 75 08             	mov    0x8(%ebp),%esi
  mem_size_t size;
  mem_size_t ptr, ptr2;
  struct mem *mem, *mem2;
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  806d9c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  806d9f:	83 c3 03             	add    $0x3,%ebx
  806da2:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  806da5:	83 fb 0b             	cmp    $0xb,%ebx
  806da8:	77 05                	ja     806daf <mem_realloc+0x1f>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  806daa:	bb 0c 00 00 00       	mov    $0xc,%ebx
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  806daf:	b8 00 00 00 00       	mov    $0x0,%eax
  806db4:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  806dba:	0f 87 49 01 00 00    	ja     806f09 <mem_realloc+0x179>
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  806dc0:	3b 35 3c 87 a3 00    	cmp    0xa3873c,%esi
  806dc6:	72 08                	jb     806dd0 <mem_realloc+0x40>
  806dc8:	3b 35 40 87 a3 00    	cmp    0xa38740,%esi
  806dce:	72 17                	jb     806de7 <mem_realloc+0x57>
  806dd0:	83 ec 04             	sub    $0x4,%esp
  806dd3:	68 32 2a 81 00       	push   $0x812a32
  806dd8:	68 79 01 00 00       	push   $0x179
  806ddd:	68 be 29 81 00       	push   $0x8129be
  806de2:	e8 e5 9c ff ff       	call   800acc <_panic>
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  806de7:	3b 35 3c 87 a3 00    	cmp    0xa3873c,%esi
  806ded:	72 08                	jb     806df7 <mem_realloc+0x67>
  806def:	3b 35 40 87 a3 00    	cmp    0xa38740,%esi
  806df5:	72 07                	jb     806dfe <mem_realloc+0x6e>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_realloc: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  806df7:	89 f0                	mov    %esi,%eax
  806df9:	e9 0b 01 00 00       	jmp    806f09 <mem_realloc+0x179>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  806dfe:	8d 46 f4             	lea    0xfffffff4(%esi),%eax
  806e01:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  806e04:	2b 05 3c 87 a3 00    	sub    0xa3873c,%eax
  806e0a:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  806e0d:	8b 46 f4             	mov    0xfffffff4(%esi),%eax
  806e10:	89 c7                	mov    %eax,%edi
  806e12:	2b 7d f0             	sub    0xfffffff0(%ebp),%edi
  806e15:	83 ef 0c             	sub    $0xc,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  806e18:	39 fb                	cmp    %edi,%ebx
  806e1a:	76 17                	jbe    806e33 <mem_realloc+0xa3>
  806e1c:	83 ec 04             	sub    $0x4,%esp
  806e1f:	68 b8 2a 81 00       	push   $0x812ab8
  806e24:	68 8a 01 00 00       	push   $0x18a
  806e29:	68 be 29 81 00       	push   $0x8129be
  806e2e:	e8 99 9c ff ff       	call   800acc <_panic>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
    /* No change in size, simply return */
    return rmem;
  806e33:	89 f0                	mov    %esi,%eax
  806e35:	39 fb                	cmp    %edi,%ebx
  806e37:	0f 84 cc 00 00 00    	je     806f09 <mem_realloc+0x179>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  806e3d:	83 ec 08             	sub    $0x8,%esp
  806e40:	6a 00                	push   $0x0
  806e42:	ff 35 48 87 a3 00    	pushl  0xa38748
  806e48:	e8 8f 61 00 00       	call   80cfdc <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  806e4d:	a1 3c 87 a3 00       	mov    0xa3873c,%eax
  806e52:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  806e55:	8b 11                	mov    (%ecx),%edx
  806e57:	01 c2                	add    %eax,%edx
  if(mem2->used == 0) {
  806e59:	83 c4 10             	add    $0x10,%esp
  806e5c:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  806e60:	75 4d                	jne    806eaf <mem_realloc+0x11f>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  806e62:	8b 3a                	mov    (%edx),%edi
  806e64:	89 7d e8             	mov    %edi,0xffffffe8(%ebp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  806e67:	8b 7d f0             	mov    0xfffffff0(%ebp),%edi
  806e6a:	8d 4c 1f 0c          	lea    0xc(%edi,%ebx,1),%ecx
    if (lfree == mem2) {
  806e6e:	39 15 44 87 a3 00    	cmp    %edx,0xa38744
  806e74:	75 08                	jne    806e7e <mem_realloc+0xee>
      lfree = (struct mem *)&ram[ptr2];
  806e76:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  806e79:	a3 44 87 a3 00       	mov    %eax,0xa38744
    }
    mem2 = (struct mem *)&ram[ptr2];
  806e7e:	89 ca                	mov    %ecx,%edx
  806e80:	03 15 3c 87 a3 00    	add    0xa3873c,%edx
    mem2->used = 0;
  806e86:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  806e8a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  806e8d:	89 02                	mov    %eax,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  806e8f:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
  806e92:	89 5a 04             	mov    %ebx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  806e95:	8b 7d ec             	mov    0xffffffec(%ebp),%edi
  806e98:	89 0f                	mov    %ecx,(%edi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  806e9a:	81 3a 00 00 22 00    	cmpl   $0x220000,(%edx)
  806ea0:	74 57                	je     806ef9 <mem_realloc+0x169>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  806ea2:	8b 12                	mov    (%edx),%edx
  806ea4:	a1 3c 87 a3 00       	mov    0xa3873c,%eax
  806ea9:	89 4c 02 04          	mov    %ecx,0x4(%edx,%eax,1)
  806ead:	eb 4a                	jmp    806ef9 <mem_realloc+0x169>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  806eaf:	8d 43 18             	lea    0x18(%ebx),%eax
  806eb2:	39 f8                	cmp    %edi,%eax
  806eb4:	77 43                	ja     806ef9 <mem_realloc+0x169>
    /* Next struct is used but there's room for another struct mem with
     * at least MIN_SIZE_ALIGNED of data.
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  806eb6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  806eb9:	8d 4c 18 0c          	lea    0xc(%eax,%ebx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  806ebd:	89 ca                	mov    %ecx,%edx
  806ebf:	03 15 3c 87 a3 00    	add    0xa3873c,%edx
    if (mem2 < lfree) {
  806ec5:	3b 15 44 87 a3 00    	cmp    0xa38744,%edx
  806ecb:	73 06                	jae    806ed3 <mem_realloc+0x143>
      lfree = mem2;
  806ecd:	89 15 44 87 a3 00    	mov    %edx,0xa38744
    }
    mem2->used = 0;
  806ed3:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  806ed7:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
  806eda:	8b 03                	mov    (%ebx),%eax
  806edc:	89 02                	mov    %eax,(%edx)
    mem2->prev = ptr;
  806ede:	8b 7d f0             	mov    0xfffffff0(%ebp),%edi
  806ee1:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  806ee4:	89 0b                	mov    %ecx,(%ebx)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  806ee6:	81 3a 00 00 22 00    	cmpl   $0x220000,(%edx)
  806eec:	74 0b                	je     806ef9 <mem_realloc+0x169>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  806eee:	8b 12                	mov    (%edx),%edx
  806ef0:	a1 3c 87 a3 00       	mov    0xa3873c,%eax
  806ef5:	89 4c 02 04          	mov    %ecx,0x4(%edx,%eax,1)
    }
    /* the original mem->next is used, so no need to plug holes! */
  }
  /* else {
    next struct mem is used but size between mem and mem2 is not big enough
    to create another struct mem
    -> don't do anyhting. 
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  806ef9:	83 ec 0c             	sub    $0xc,%esp
  806efc:	ff 35 48 87 a3 00    	pushl  0xa38748
  806f02:	e8 73 60 00 00       	call   80cf7a <sys_sem_signal>
  return rmem;
  806f07:	89 f0                	mov    %esi,%eax
}
  806f09:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  806f0c:	5b                   	pop    %ebx
  806f0d:	5e                   	pop    %esi
  806f0e:	5f                   	pop    %edi
  806f0f:	c9                   	leave  
  806f10:	c3                   	ret    

00806f11 <mem_malloc>:

/**
 * Adam's mem_malloc() plus solution for bug #17922
 * Allocate a block of memory with a minimum of 'size' bytes.
 *
 * @param size is the minimum size of the requested block in bytes.
 * @return pointer to allocated memory or NULL if no free memory was found.
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  806f11:	55                   	push   %ebp
  806f12:	89 e5                	mov    %esp,%ebp
  806f14:	57                   	push   %edi
  806f15:	56                   	push   %esi
  806f16:	53                   	push   %ebx
  806f17:	83 ec 0c             	sub    $0xc,%esp
  806f1a:	8b 7d 08             	mov    0x8(%ebp),%edi
  mem_size_t ptr, ptr2;
  struct mem *mem, *mem2;
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    return NULL;
  806f1d:	b8 00 00 00 00       	mov    $0x0,%eax
  806f22:	85 ff                	test   %edi,%edi
  806f24:	0f 84 ba 01 00 00    	je     8070e4 <mem_malloc+0x1d3>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  806f2a:	83 c7 03             	add    $0x3,%edi
  806f2d:	83 e7 fc             	and    $0xfffffffc,%edi

  if(size < MIN_SIZE_ALIGNED) {
  806f30:	83 ff 0b             	cmp    $0xb,%edi
  806f33:	77 05                	ja     806f3a <mem_malloc+0x29>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  806f35:	bf 0c 00 00 00       	mov    $0xc,%edi
  }

  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  806f3a:	b8 00 00 00 00       	mov    $0x0,%eax
  806f3f:	81 ff 00 00 22 00    	cmp    $0x220000,%edi
  806f45:	0f 87 99 01 00 00    	ja     8070e4 <mem_malloc+0x1d3>
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  806f4b:	83 ec 08             	sub    $0x8,%esp
  806f4e:	6a 00                	push   $0x0
  806f50:	ff 35 48 87 a3 00    	pushl  0xa38748
  806f56:	e8 81 60 00 00       	call   80cfdc <sys_arch_sem_wait>
  LWIP_MEM_ALLOC_PROTECT();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  /* run as long as a mem_free disturbed mem_malloc */
  do {
    local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  806f5b:	a1 44 87 a3 00       	mov    0xa38744,%eax
  806f60:	89 c1                	mov    %eax,%ecx
  806f62:	2b 0d 3c 87 a3 00    	sub    0xa3873c,%ecx
  806f68:	83 c4 10             	add    $0x10,%esp
  806f6b:	b8 00 00 22 00       	mov    $0x220000,%eax
  806f70:	29 f8                	sub    %edi,%eax
  806f72:	39 c8                	cmp    %ecx,%eax
  806f74:	0f 86 57 01 00 00    	jbe    8070d1 <mem_malloc+0x1c0>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  806f7a:	8b 1d 3c 87 a3 00    	mov    0xa3873c,%ebx
  806f80:	8d 34 19             	lea    (%ecx,%ebx,1),%esi
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
      mem_free_count = 0;
      LWIP_MEM_ALLOC_UNPROTECT();
      /* allow mem_free to run */
      LWIP_MEM_ALLOC_PROTECT();
      if (mem_free_count != 0) {
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  806f83:	80 7e 08 00          	cmpb   $0x0,0x8(%esi)
  806f87:	0f 85 2d 01 00 00    	jne    8070ba <mem_malloc+0x1a9>
  806f8d:	8b 06                	mov    (%esi),%eax
  806f8f:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  806f92:	29 c8                	sub    %ecx,%eax
  806f94:	8d 50 f4             	lea    0xfffffff4(%eax),%edx
  806f97:	39 fa                	cmp    %edi,%edx
  806f99:	0f 82 1b 01 00 00    	jb     8070ba <mem_malloc+0x1a9>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  806f9f:	8d 47 18             	lea    0x18(%edi),%eax
  806fa2:	39 c2                	cmp    %eax,%edx
  806fa4:	72 35                	jb     806fdb <mem_malloc+0xca>
          /* (in addition to the above, we test if another struct mem (SIZEOF_STRUCT_MEM) containing
           * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
           * -> split large block, create empty remainder,
           * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
           * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  806fa6:	8d 54 39 0c          	lea    0xc(%ecx,%edi,1),%edx
  806faa:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  806fad:	89 d0                	mov    %edx,%eax
  806faf:	01 d8                	add    %ebx,%eax
          mem2->used = 0;
  806fb1:	c6 40 08 00          	movb   $0x0,0x8(%eax)
          mem2->next = mem->next;
  806fb5:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  806fb8:	89 10                	mov    %edx,(%eax)
          mem2->prev = ptr;
  806fba:	89 48 04             	mov    %ecx,0x4(%eax)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  806fbd:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  806fc0:	89 0e                	mov    %ecx,(%esi)
          mem->used = 1;
  806fc2:	c6 46 08 01          	movb   $0x1,0x8(%esi)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  806fc6:	81 38 00 00 22 00    	cmpl   $0x220000,(%eax)
  806fcc:	74 11                	je     806fdf <mem_malloc+0xce>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  806fce:	8b 10                	mov    (%eax),%edx
  806fd0:	a1 3c 87 a3 00       	mov    0xa3873c,%eax
  806fd5:	89 4c 02 04          	mov    %ecx,0x4(%edx,%eax,1)
  806fd9:	eb 04                	jmp    806fdf <mem_malloc+0xce>
          }
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
        } else {
          /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
           * be used at this point: if not we have 2 unused structs in a row, plug_holes should have
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  806fdb:	c6 46 08 01          	movb   $0x1,0x8(%esi)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  806fdf:	3b 35 44 87 a3 00    	cmp    0xa38744,%esi
  806fe5:	75 5c                	jne    807043 <mem_malloc+0x132>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  806fe7:	80 7e 08 00          	cmpb   $0x0,0x8(%esi)
  806feb:	74 2c                	je     807019 <mem_malloc+0x108>
  806fed:	3b 35 40 87 a3 00    	cmp    0xa38740,%esi
  806ff3:	74 24                	je     807019 <mem_malloc+0x108>
  806ff5:	8b 0d 3c 87 a3 00    	mov    0xa3873c,%ecx
  806ffb:	8b 15 40 87 a3 00    	mov    0xa38740,%edx
  807001:	a1 44 87 a3 00       	mov    0xa38744,%eax
  807006:	8b 00                	mov    (%eax),%eax
  807008:	01 c8                	add    %ecx,%eax
  80700a:	a3 44 87 a3 00       	mov    %eax,0xa38744
  80700f:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  807013:	74 04                	je     807019 <mem_malloc+0x108>
  807015:	39 d0                	cmp    %edx,%eax
  807017:	75 e8                	jne    807001 <mem_malloc+0xf0>
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  807019:	a1 44 87 a3 00       	mov    0xa38744,%eax
  80701e:	3b 05 40 87 a3 00    	cmp    0xa38740,%eax
  807024:	74 1d                	je     807043 <mem_malloc+0x132>
  807026:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  80702a:	74 17                	je     807043 <mem_malloc+0x132>
  80702c:	83 ec 04             	sub    $0x4,%esp
  80702f:	68 4c 2a 81 00       	push   $0x812a4c
  807034:	68 46 02 00 00       	push   $0x246
  807039:	68 be 29 81 00       	push   $0x8129be
  80703e:	e8 89 9a ff ff       	call   800acc <_panic>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  807043:	83 ec 0c             	sub    $0xc,%esp
  807046:	ff 35 48 87 a3 00    	pushl  0xa38748
  80704c:	e8 29 5f 00 00       	call   80cf7a <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  807051:	8d 44 3e 0c          	lea    0xc(%esi,%edi,1),%eax
  807055:	83 c4 10             	add    $0x10,%esp
  807058:	3b 05 40 87 a3 00    	cmp    0xa38740,%eax
  80705e:	76 17                	jbe    807077 <mem_malloc+0x166>
  807060:	83 ec 04             	sub    $0x4,%esp
  807063:	68 dc 2a 81 00       	push   $0x812adc
  807068:	68 4b 02 00 00       	push   $0x24b
  80706d:	68 be 29 81 00       	push   $0x8129be
  807072:	e8 55 9a ff ff       	call   800acc <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  807077:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80707d:	74 17                	je     807096 <mem_malloc+0x185>
  80707f:	83 ec 04             	sub    $0x4,%esp
  807082:	68 0c 2b 81 00       	push   $0x812b0c
  807087:	68 4d 02 00 00       	push   $0x24d
  80708c:	68 be 29 81 00       	push   $0x8129be
  807091:	e8 36 9a ff ff       	call   800acc <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  807096:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80709c:	74 17                	je     8070b5 <mem_malloc+0x1a4>
  80709e:	83 ec 04             	sub    $0x4,%esp
  8070a1:	68 3c 2b 81 00       	push   $0x812b3c
  8070a6:	68 4f 02 00 00       	push   $0x24f
  8070ab:	68 be 29 81 00       	push   $0x8129be
  8070b0:	e8 17 9a ff ff       	call   800acc <_panic>
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  8070b5:	8d 46 0c             	lea    0xc(%esi),%eax
  8070b8:	eb 2a                	jmp    8070e4 <mem_malloc+0x1d3>
  8070ba:	a1 3c 87 a3 00       	mov    0xa3873c,%eax
  8070bf:	8b 0c 08             	mov    (%eax,%ecx,1),%ecx
  8070c2:	b8 00 00 22 00       	mov    $0x220000,%eax
  8070c7:	29 f8                	sub    %edi,%eax
  8070c9:	39 c8                	cmp    %ecx,%eax
  8070cb:	0f 87 a9 fe ff ff    	ja     806f7a <mem_malloc+0x69>
      }
    }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  8070d1:	83 ec 0c             	sub    $0xc,%esp
  8070d4:	ff 35 48 87 a3 00    	pushl  0xa38748
  8070da:	e8 9b 5e 00 00       	call   80cf7a <sys_sem_signal>
  return NULL;
  8070df:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8070e4:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8070e7:	5b                   	pop    %ebx
  8070e8:	5e                   	pop    %esi
  8070e9:	5f                   	pop    %edi
  8070ea:	c9                   	leave  
  8070eb:	c3                   	ret    

008070ec <mem_calloc>:

#endif /* MEM_USE_POOLS */
/**
 * Contiguously allocates enough space for count objects that are size bytes
 * of memory each and returns a pointer to the allocated memory.
 *
 * The allocated memory is filled with bytes of value zero.
 *
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8070ec:	55                   	push   %ebp
  8070ed:	89 e5                	mov    %esp,%ebp
  8070ef:	56                   	push   %esi
  8070f0:	53                   	push   %ebx
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8070f1:	83 ec 0c             	sub    $0xc,%esp
  8070f4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8070f7:	8b 75 08             	mov    0x8(%ebp),%esi
  8070fa:	0f af f0             	imul   %eax,%esi
  8070fd:	56                   	push   %esi
  8070fe:	e8 0e fe ff ff       	call   806f11 <mem_malloc>
  807103:	89 c3                	mov    %eax,%ebx
  if (p) {
  807105:	83 c4 10             	add    $0x10,%esp
  807108:	85 c0                	test   %eax,%eax
  80710a:	74 0f                	je     80711b <mem_calloc+0x2f>
    /* zero the memory */
    memset(p, 0, count * size);
  80710c:	83 ec 04             	sub    $0x4,%esp
  80710f:	56                   	push   %esi
  807110:	6a 00                	push   $0x0
  807112:	50                   	push   %eax
  807113:	e8 d1 a1 ff ff       	call   8012e9 <memset>
  807118:	83 c4 10             	add    $0x10,%esp
  }
  return p;
}
  80711b:	89 d8                	mov    %ebx,%eax
  80711d:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  807120:	5b                   	pop    %ebx
  807121:	5e                   	pop    %esi
  807122:	c9                   	leave  
  807123:	c3                   	ret    

00807124 <memp_init>:
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  807124:	55                   	push   %ebp
  807125:	89 e5                	mov    %esp,%ebp
  807127:	57                   	push   %edi
  807128:	56                   	push   %esi
  807129:	53                   	push   %ebx
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
  80712a:	bf 00 00 00 00       	mov    $0x0,%edi
  80712f:	47                   	inc    %edi
  807130:	66 83 ff 0d          	cmp    $0xd,%di
  807134:	76 f9                	jbe    80712f <memp_init+0xb>
    MEMP_STATS_AVAIL(used, i, 0);
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  807136:	b8 a3 87 a3 00       	mov    $0xa387a3,%eax
  80713b:	89 c1                	mov    %eax,%ecx
  80713d:	83 e1 fc             	and    $0xfffffffc,%ecx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  807140:	bf 00 00 00 00       	mov    $0x0,%edi
    memp_tab[i] = NULL;
  807145:	0f b7 c7             	movzwl %di,%eax
  807148:	89 c2                	mov    %eax,%edx
  80714a:	c7 04 85 60 87 a3 00 	movl   $0x0,0xa38760(,%eax,4)
  807151:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  807155:	bb 00 00 00 00       	mov    $0x0,%ebx
  80715a:	66 83 bc 00 7c 2b 81 	cmpw   $0x0,0x812b7c(%eax,%eax,1)
  807161:	00 00 
  807163:	76 26                	jbe    80718b <memp_init+0x67>
  807165:	be 60 87 a3 00       	mov    $0xa38760,%esi
      memp->next = memp_tab[i];
  80716a:	89 d0                	mov    %edx,%eax
  80716c:	8b 14 96             	mov    (%esi,%edx,4),%edx
  80716f:	89 11                	mov    %edx,(%ecx)
      memp_tab[i] = memp;
  807171:	89 0c 86             	mov    %ecx,(%esi,%eax,4)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  807174:	0f b7 94 00 60 2b 81 	movzwl 0x812b60(%eax,%eax,1),%edx
  80717b:	00 
  80717c:	01 d1                	add    %edx,%ecx
  80717e:	43                   	inc    %ebx
  80717f:	89 c2                	mov    %eax,%edx
  807181:	66 39 9c 00 7c 2b 81 	cmp    %bx,0x812b7c(%eax,%eax,1)
  807188:	00 
  807189:	77 df                	ja     80716a <memp_init+0x46>
  80718b:	47                   	inc    %edi
  80718c:	66 83 ff 0d          	cmp    $0xd,%di
  807190:	76 b3                	jbe    807145 <memp_init+0x21>
    }
  }
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  807192:	5b                   	pop    %ebx
  807193:	5e                   	pop    %esi
  807194:	5f                   	pop    %edi
  807195:	c9                   	leave  
  807196:	c3                   	ret    

00807197 <memp_malloc>:

/**
 * Get an element from a specific pool.
 *
 * @param type the pool to get an element from
 *
 * the debug version has two more parameters:
 * @param file file name calling this function
 * @param line number of line where this function is called
 *
 * @return a pointer to the allocated memory or a NULL pointer on error
 */
void *
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  807197:	55                   	push   %ebp
  807198:	89 e5                	mov    %esp,%ebp
  80719a:	53                   	push   %ebx
  80719b:	83 ec 04             	sub    $0x4,%esp
  80719e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  8071a1:	83 f9 0d             	cmp    $0xd,%ecx
  8071a4:	76 17                	jbe    8071bd <memp_malloc+0x26>
  8071a6:	83 ec 04             	sub    $0x4,%esp
  8071a9:	68 2b 2c 81 00       	push   $0x812c2b
  8071ae:	68 2d 01 00 00       	push   $0x12d
  8071b3:	68 48 2c 81 00       	push   $0x812c48
  8071b8:	e8 0f 99 ff ff       	call   800acc <_panic>

  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  8071bd:	bb 60 87 a3 00       	mov    $0xa38760,%ebx
  8071c2:	8b 14 8b             	mov    (%ebx,%ecx,4),%edx
  
  if (memp != NULL) {    
  8071c5:	85 d2                	test   %edx,%edx
  8071c7:	74 21                	je     8071ea <memp_malloc+0x53>
    memp_tab[type] = memp->next;    
  8071c9:	8b 02                	mov    (%edx),%eax
  8071cb:	89 04 8b             	mov    %eax,(%ebx,%ecx,4)
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  8071ce:	f6 c2 03             	test   $0x3,%dl
  8071d1:	74 17                	je     8071ea <memp_malloc+0x53>
  8071d3:	83 ec 04             	sub    $0x4,%esp
  8071d6:	68 60 2c 81 00       	push   $0x812c60
  8071db:	68 3f 01 00 00       	push   $0x13f
  8071e0:	68 48 2c 81 00       	push   $0x812c48
  8071e5:	e8 e2 98 ff ff       	call   800acc <_panic>
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
    memp = (struct memp*)((u8_t*)memp + MEMP_SIZE);
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | 2, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  8071ea:	89 d0                	mov    %edx,%eax
  8071ec:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8071ef:	c9                   	leave  
  8071f0:	c3                   	ret    

008071f1 <memp_free>:

/**
 * Put an element back into its pool.
 *
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  8071f1:	55                   	push   %ebp
  8071f2:	89 e5                	mov    %esp,%ebp
  8071f4:	53                   	push   %ebx
  8071f5:	83 ec 04             	sub    $0x4,%esp
  8071f8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8071fb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  8071fe:	85 c9                	test   %ecx,%ecx
  807200:	74 29                	je     80722b <memp_free+0x3a>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  807202:	f6 c1 03             	test   $0x3,%cl
  807205:	74 17                	je     80721e <memp_free+0x2d>
  807207:	83 ec 04             	sub    $0x4,%esp
  80720a:	68 84 2c 81 00       	push   $0x812c84
  80720f:	68 5b 01 00 00       	push   $0x15b
  807214:	68 48 2c 81 00       	push   $0x812c48
  807219:	e8 ae 98 ff ff       	call   800acc <_panic>
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)((u8_t*)mem - MEMP_SIZE);

  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#else
  memp_overflow_check_element(memp, memp_sizes[type]);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  80721e:	ba 60 87 a3 00       	mov    $0xa38760,%edx
  807223:	8b 04 9a             	mov    (%edx,%ebx,4),%eax
  807226:	89 01                	mov    %eax,(%ecx)
  memp_tab[type] = memp;
  807228:	89 0c 9a             	mov    %ecx,(%edx,%ebx,4)

#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  80722b:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80722e:	c9                   	leave  
  80722f:	c3                   	ret    

00807230 <netif_add>:
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  807230:	55                   	push   %ebp
  807231:	89 e5                	mov    %esp,%ebp
  807233:	53                   	push   %ebx
  807234:	83 ec 04             	sub    $0x4,%esp
  807237:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  80723a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  807241:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  807248:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  80724f:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  807253:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
#endif /* LWIP_DHCP */
#if LWIP_AUTOIP
  /* netif not under AutoIP control by default */
  netif->autoip = NULL;
#endif /* LWIP_AUTOIP */
#if LWIP_NETIF_STATUS_CALLBACK
  netif->status_callback = NULL;
#endif /* LWIP_NETIF_STATUS_CALLBACK */
#if LWIP_NETIF_LINK_CALLBACK
  netif->link_callback = NULL;
#endif /* LWIP_NETIF_LINK_CALLBACK */
#if LWIP_IGMP
  netif->igmp_mac_filter = NULL;
#endif /* LWIP_IGMP */
#if ENABLE_LOOPBACK
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  80725a:	8b 45 18             	mov    0x18(%ebp),%eax
  80725d:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  807260:	8a 15 04 78 b3 00    	mov    0xb37804,%dl
  807266:	8d 42 01             	lea    0x1(%edx),%eax
  807269:	a2 04 78 b3 00       	mov    %al,0xb37804
  80726e:	88 53 31             	mov    %dl,0x31(%ebx)
  netif->input = input;
  807271:	8b 45 20             	mov    0x20(%ebp),%eax
  807274:	89 43 10             	mov    %eax,0x10(%ebx)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  807277:	ff 75 14             	pushl  0x14(%ebp)
  80727a:	ff 75 10             	pushl  0x10(%ebp)
  80727d:	ff 75 0c             	pushl  0xc(%ebp)
  807280:	53                   	push   %ebx
  807281:	e8 28 00 00 00       	call   8072ae <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  807286:	89 1c 24             	mov    %ebx,(%esp)
  807289:	ff 55 1c             	call   *0x1c(%ebp)
  80728c:	83 c4 10             	add    $0x10,%esp
    return NULL;
  80728f:	ba 00 00 00 00       	mov    $0x0,%edx
  807294:	84 c0                	test   %al,%al
  807296:	75 0f                	jne    8072a7 <netif_add+0x77>
  }

  /* add this netif to the list */
  netif->next = netif_list;
  807298:	a1 60 e6 b3 00       	mov    0xb3e660,%eax
  80729d:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  80729f:	89 1d 60 e6 b3 00    	mov    %ebx,0xb3e660
  snmp_inc_iflist();

#if LWIP_IGMP
  /* start IGMP processing */
  if (netif->flags & NETIF_FLAG_IGMP) {
    igmp_start( netif);
  }
#endif /* LWIP_IGMP */

  LWIP_DEBUGF(NETIF_DEBUG, ("netif: added interface %c%c IP addr ",
    netif->name[0], netif->name[1]));
  ip_addr_debug_print(NETIF_DEBUG, ipaddr);
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  8072a5:	89 da                	mov    %ebx,%edx
}
  8072a7:	89 d0                	mov    %edx,%eax
  8072a9:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8072ac:	c9                   	leave  
  8072ad:	c3                   	ret    

008072ae <netif_set_addr>:

/**
 * Change IP address configuration for a network interface (including netmask
 * and default gateway).
 *
 * @param netif the network interface to change
 * @param ipaddr the new IP address
 * @param netmask the new netmask
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  8072ae:	55                   	push   %ebp
  8072af:	89 e5                	mov    %esp,%ebp
  8072b1:	53                   	push   %ebx
  8072b2:	83 ec 0c             	sub    $0xc,%esp
  8072b5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif_set_ipaddr(netif, ipaddr);
  8072b8:	ff 75 0c             	pushl  0xc(%ebp)
  8072bb:	53                   	push   %ebx
  8072bc:	e8 b6 00 00 00       	call   807377 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
  8072c1:	83 c4 08             	add    $0x8,%esp
  8072c4:	ff 75 10             	pushl  0x10(%ebp)
  8072c7:	53                   	push   %ebx
  8072c8:	e8 44 01 00 00       	call   807411 <netif_set_netmask>
  netif_set_gw(netif, gw);
  8072cd:	83 c4 08             	add    $0x8,%esp
  8072d0:	ff 75 14             	pushl  0x14(%ebp)
  8072d3:	53                   	push   %ebx
  8072d4:	e8 1f 01 00 00       	call   8073f8 <netif_set_gw>
}
  8072d9:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8072dc:	c9                   	leave  
  8072dd:	c3                   	ret    

008072de <netif_remove>:

/**
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  8072de:	55                   	push   %ebp
  8072df:	89 e5                	mov    %esp,%ebp
  8072e1:	83 ec 08             	sub    $0x8,%esp
  8072e4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  8072e7:	85 c9                	test   %ecx,%ecx
  8072e9:	74 44                	je     80732f <netif_remove+0x51>

#if LWIP_IGMP
  /* stop IGMP processing */
  if (netif->flags & NETIF_FLAG_IGMP) {
    igmp_stop( netif);
  }
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  8072eb:	39 0d 60 e6 b3 00    	cmp    %ecx,0xb3e660
  8072f1:	75 09                	jne    8072fc <netif_remove+0x1e>
    netif_list = netif->next;
  8072f3:	8b 01                	mov    (%ecx),%eax
  8072f5:	a3 60 e6 b3 00       	mov    %eax,0xb3e660
  8072fa:	eb 1e                	jmp    80731a <netif_remove+0x3c>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  8072fc:	8b 15 60 e6 b3 00    	mov    0xb3e660,%edx
  807302:	85 d2                	test   %edx,%edx
  807304:	74 29                	je     80732f <netif_remove+0x51>
      if (tmpNetif->next == netif) {
  807306:	39 0a                	cmp    %ecx,(%edx)
  807308:	74 08                	je     807312 <netif_remove+0x34>
  80730a:	8b 12                	mov    (%edx),%edx
  80730c:	85 d2                	test   %edx,%edx
  80730e:	75 f6                	jne    807306 <netif_remove+0x28>
  807310:	eb 1d                	jmp    80732f <netif_remove+0x51>
        tmpNetif->next = netif->next;
  807312:	8b 01                	mov    (%ecx),%eax
  807314:	89 02                	mov    %eax,(%edx)
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
  807316:	85 d2                	test   %edx,%edx
  807318:	74 15                	je     80732f <netif_remove+0x51>
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  80731a:	39 0d 64 e6 b3 00    	cmp    %ecx,0xb3e664
  807320:	75 0d                	jne    80732f <netif_remove+0x51>
    /* reset default netif */
    netif_set_default(NULL);
  807322:	83 ec 0c             	sub    $0xc,%esp
  807325:	6a 00                	push   $0x0
  807327:	e8 fe 00 00 00       	call   80742a <netif_set_default>
  80732c:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  80732f:	c9                   	leave  
  807330:	c3                   	ret    

00807331 <netif_find>:

/**
 * Find a network interface by searching for its name
 *
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  807331:	55                   	push   %ebp
  807332:	89 e5                	mov    %esp,%ebp
  807334:	53                   	push   %ebx
  807335:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    return NULL;
  807338:	b8 00 00 00 00       	mov    $0x0,%eax
  80733d:	85 db                	test   %ebx,%ebx
  80733f:	74 33                	je     807374 <netif_find+0x43>
  }

  num = name[2] - '0';
  807341:	8a 4b 02             	mov    0x2(%ebx),%cl
  807344:	83 e9 30             	sub    $0x30,%ecx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  807347:	8b 15 60 e6 b3 00    	mov    0xb3e660,%edx
  80734d:	85 d2                	test   %edx,%edx
  80734f:	74 1e                	je     80736f <netif_find+0x3e>
    if (num == netif->num &&
  807351:	38 4a 31             	cmp    %cl,0x31(%edx)
  807354:	75 13                	jne    807369 <netif_find+0x38>
  807356:	8a 03                	mov    (%ebx),%al
  807358:	3a 42 2f             	cmp    0x2f(%edx),%al
  80735b:	75 0c                	jne    807369 <netif_find+0x38>
  80735d:	8a 43 01             	mov    0x1(%ebx),%al
  807360:	3a 42 30             	cmp    0x30(%edx),%al
  807363:	75 04                	jne    807369 <netif_find+0x38>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
  807365:	89 d0                	mov    %edx,%eax
  807367:	eb 0b                	jmp    807374 <netif_find+0x43>
  807369:	8b 12                	mov    (%edx),%edx
  80736b:	85 d2                	test   %edx,%edx
  80736d:	75 e2                	jne    807351 <netif_find+0x20>
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
  80736f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807374:	5b                   	pop    %ebx
  807375:	c9                   	leave  
  807376:	c3                   	ret    

00807377 <netif_set_ipaddr>:

/**
 * Change the IP address of a network interface
 *
 * @param netif the network interface to change
 * @param ipaddr the new IP address
 *
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  807377:	55                   	push   %ebp
  807378:	89 e5                	mov    %esp,%ebp
  80737a:	57                   	push   %edi
  80737b:	56                   	push   %esi
  80737c:	53                   	push   %ebx
  80737d:	83 ec 0c             	sub    $0xc,%esp
  807380:	8b 75 08             	mov    0x8(%ebp),%esi
  807383:	8b 7d 0c             	mov    0xc(%ebp),%edi
  /* TODO: Handling of obsolete pcbs */
  /* See:  http://mail.gnu.org/archive/html/lwip-users/2003-03/msg00118.html */
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  807386:	8b 07                	mov    (%edi),%eax
  807388:	3b 46 04             	cmp    0x4(%esi),%eax
  80738b:	74 55                	je     8073e2 <netif_set_ipaddr+0x6b>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  80738d:	8b 15 68 e6 b3 00    	mov    0xb3e668,%edx
    while (pcb != NULL) {
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
        pcb = next;
      } else {
        pcb = pcb->next;
  807393:	85 d2                	test   %edx,%edx
  807395:	74 21                	je     8073b8 <netif_set_ipaddr+0x41>
  807397:	8b 02                	mov    (%edx),%eax
  807399:	3b 46 04             	cmp    0x4(%esi),%eax
  80739c:	75 13                	jne    8073b1 <netif_set_ipaddr+0x3a>
  80739e:	8b 5a 0c             	mov    0xc(%edx),%ebx
  8073a1:	83 ec 0c             	sub    $0xc,%esp
  8073a4:	52                   	push   %edx
  8073a5:	e8 9f 0e 00 00       	call   808249 <tcp_abort>
  8073aa:	89 da                	mov    %ebx,%edx
  8073ac:	83 c4 10             	add    $0x10,%esp
  8073af:	eb 03                	jmp    8073b4 <netif_set_ipaddr+0x3d>
  8073b1:	8b 52 0c             	mov    0xc(%edx),%edx
  8073b4:	85 d2                	test   %edx,%edx
  8073b6:	75 df                	jne    807397 <netif_set_ipaddr+0x20>
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8073b8:	8b 15 70 e6 b3 00    	mov    0xb3e670,%edx
  8073be:	85 d2                	test   %edx,%edx
  8073c0:	74 20                	je     8073e2 <netif_set_ipaddr+0x6b>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  8073c2:	83 3a 00             	cmpl   $0x0,(%edx)
  8073c5:	74 14                	je     8073db <netif_set_ipaddr+0x64>
  8073c7:	8b 02                	mov    (%edx),%eax
  8073c9:	3b 46 04             	cmp    0x4(%esi),%eax
  8073cc:	75 0d                	jne    8073db <netif_set_ipaddr+0x64>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  8073ce:	b8 00 00 00 00       	mov    $0x0,%eax
  8073d3:	85 ff                	test   %edi,%edi
  8073d5:	74 02                	je     8073d9 <netif_set_ipaddr+0x62>
  8073d7:	8b 07                	mov    (%edi),%eax
  8073d9:	89 02                	mov    %eax,(%edx)
  8073db:	8b 52 0c             	mov    0xc(%edx),%edx
  8073de:	85 d2                	test   %edx,%edx
  8073e0:	75 e0                	jne    8073c2 <netif_set_ipaddr+0x4b>
      }
    }
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  8073e2:	b8 00 00 00 00       	mov    $0x0,%eax
  8073e7:	85 ff                	test   %edi,%edi
  8073e9:	74 02                	je     8073ed <netif_set_ipaddr+0x76>
  8073eb:	8b 07                	mov    (%edi),%eax
  8073ed:	89 46 04             	mov    %eax,0x4(%esi)
  snmp_insert_ipaddridx_tree(netif);
  snmp_insert_iprteidx_tree(0,netif);

  LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("netif: IP address of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  8073f0:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8073f3:	5b                   	pop    %ebx
  8073f4:	5e                   	pop    %esi
  8073f5:	5f                   	pop    %edi
  8073f6:	c9                   	leave  
  8073f7:	c3                   	ret    

008073f8 <netif_set_gw>:

/**
 * Change the default gateway for a network interface
 *
 * @param netif the network interface to change
 * @param gw the new default gateway
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  8073f8:	55                   	push   %ebp
  8073f9:	89 e5                	mov    %esp,%ebp
  8073fb:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&(netif->gw), gw);
  8073fe:	ba 00 00 00 00       	mov    $0x0,%edx
  807403:	85 c0                	test   %eax,%eax
  807405:	74 02                	je     807409 <netif_set_gw+0x11>
  807407:	8b 10                	mov    (%eax),%edx
  807409:	8b 45 08             	mov    0x8(%ebp),%eax
  80740c:	89 50 0c             	mov    %edx,0xc(%eax)
  LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("netif: GW address of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  80740f:	c9                   	leave  
  807410:	c3                   	ret    

00807411 <netif_set_netmask>:

/**
 * Change the netmask of a network interface
 *
 * @param netif the network interface to change
 * @param netmask the new netmask
 *
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  807411:	55                   	push   %ebp
  807412:	89 e5                	mov    %esp,%ebp
  807414:	8b 45 0c             	mov    0xc(%ebp),%eax
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  807417:	ba 00 00 00 00       	mov    $0x0,%edx
  80741c:	85 c0                	test   %eax,%eax
  80741e:	74 02                	je     807422 <netif_set_netmask+0x11>
  807420:	8b 10                	mov    (%eax),%edx
  807422:	8b 45 08             	mov    0x8(%ebp),%eax
  807425:	89 50 08             	mov    %edx,0x8(%eax)
  snmp_insert_iprteidx_tree(0, netif);
  LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("netif: netmask of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  807428:	c9                   	leave  
  807429:	c3                   	ret    

0080742a <netif_set_default>:

/**
 * Set a network interface as the default network interface
 * (used to output all packets for which no specific route is found)
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  80742a:	55                   	push   %ebp
  80742b:	89 e5                	mov    %esp,%ebp
  if (netif == NULL)
  {
    /* remove default route */
    snmp_delete_iprteidx_tree(1, netif);
  }
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  80742d:	8b 45 08             	mov    0x8(%ebp),%eax
  807430:	a3 64 e6 b3 00       	mov    %eax,0xb3e664
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  807435:	c9                   	leave  
  807436:	c3                   	ret    

00807437 <netif_set_up>:

/**
 * Bring an interface up, available for processing
 * traffic.
 * 
 * @note: Enabling DHCP on a down interface will make it come
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  807437:	55                   	push   %ebp
  807438:	89 e5                	mov    %esp,%ebp
  80743a:	83 ec 08             	sub    $0x8,%esp
  80743d:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  807440:	f6 42 2e 01          	testb  $0x1,0x2e(%edx)
  807444:	75 1c                	jne    807462 <netif_set_up+0x2b>
    netif->flags |= NETIF_FLAG_UP;
  807446:	80 4a 2e 01          	orb    $0x1,0x2e(%edx)
    
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif /* LWIP_SNMP */

    NETIF_LINK_CALLBACK(netif);
    NETIF_STATUS_CALLBACK(netif);

#if LWIP_ARP
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  80744a:	f6 42 2e 20          	testb  $0x20,0x2e(%edx)
  80744e:	74 12                	je     807462 <netif_set_up+0x2b>
      etharp_query(netif, &(netif->ip_addr), NULL);
  807450:	83 ec 04             	sub    $0x4,%esp
  807453:	6a 00                	push   $0x0
  807455:	8d 42 04             	lea    0x4(%edx),%eax
  807458:	50                   	push   %eax
  807459:	52                   	push   %edx
  80745a:	e8 36 52 00 00       	call   80c695 <etharp_query>
  80745f:	83 c4 10             	add    $0x10,%esp
    }
#endif /* LWIP_ARP */
    
  }
}
  807462:	c9                   	leave  
  807463:	c3                   	ret    

00807464 <netif_set_down>:

/**
 * Bring an interface down, disabling any traffic processing.
 *
 * @note: Enabling DHCP on a down interface will make it come
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  807464:	55                   	push   %ebp
  807465:	89 e5                	mov    %esp,%ebp
  807467:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( netif->flags & NETIF_FLAG_UP )
  80746a:	f6 40 2e 01          	testb  $0x1,0x2e(%eax)
  80746e:	74 04                	je     807474 <netif_set_down+0x10>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  807470:	80 60 2e fe          	andb   $0xfe,0x2e(%eax)
#if LWIP_SNMP
      snmp_get_sysuptime(&netif->ts);
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  807474:	c9                   	leave  
  807475:	c3                   	ret    

00807476 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  807476:	55                   	push   %ebp
  807477:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  807479:	8b 45 08             	mov    0x8(%ebp),%eax
  80747c:	f6 40 2e 01          	testb  $0x1,0x2e(%eax)
  807480:	0f 95 c0             	setne  %al
  807483:	0f b6 c0             	movzbl %al,%eax
}
  807486:	c9                   	leave  
  807487:	c3                   	ret    

00807488 <pbuf_alloc>:
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  807488:	55                   	push   %ebp
  807489:	89 e5                	mov    %esp,%ebp
  80748b:	57                   	push   %edi
  80748c:	56                   	push   %esi
  80748d:	53                   	push   %ebx
  80748e:	83 ec 0c             	sub    $0xc,%esp
  807491:	8b 45 08             	mov    0x8(%ebp),%eax
  807494:	8b 55 0c             	mov    0xc(%ebp),%edx
  807497:	66 89 55 f2          	mov    %dx,0xfffffff2(%ebp)
  struct pbuf *p, *q, *r;
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  80749b:	bb 00 00 00 00       	mov    $0x0,%ebx
  switch (layer) {
  8074a0:	83 f8 01             	cmp    $0x1,%eax
  8074a3:	74 14                	je     8074b9 <pbuf_alloc+0x31>
  8074a5:	83 f8 01             	cmp    $0x1,%eax
  8074a8:	72 0c                	jb     8074b6 <pbuf_alloc+0x2e>
  8074aa:	83 f8 02             	cmp    $0x2,%eax
  8074ad:	74 0d                	je     8074bc <pbuf_alloc+0x34>
  8074af:	83 f8 03             	cmp    $0x3,%eax
  8074b2:	74 24                	je     8074d8 <pbuf_alloc+0x50>
  8074b4:	eb 0b                	jmp    8074c1 <pbuf_alloc+0x39>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  8074b6:	83 c3 14             	add    $0x14,%ebx
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  8074b9:	83 c3 14             	add    $0x14,%ebx
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  8074bc:	83 c3 0e             	add    $0xe,%ebx
    break;
  8074bf:	eb 17                	jmp    8074d8 <pbuf_alloc+0x50>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  8074c1:	83 ec 04             	sub    $0x4,%esp
  8074c4:	68 a4 2c 81 00       	push   $0x812ca4
  8074c9:	68 8a 00 00 00       	push   $0x8a
  8074ce:	68 bf 2c 81 00       	push   $0x812cbf
  8074d3:	e8 f4 95 ff ff       	call   800acc <_panic>
    return NULL;
  }

  switch (type) {
  8074d8:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  8074dc:	77 0f                	ja     8074ed <pbuf_alloc+0x65>
  8074de:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  8074e2:	0f 83 c6 01 00 00    	jae    8076ae <pbuf_alloc+0x226>
  8074e8:	e9 6a 01 00 00       	jmp    807657 <pbuf_alloc+0x1cf>
  8074ed:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
  8074f1:	0f 85 f0 01 00 00    	jne    8076e7 <pbuf_alloc+0x25f>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  8074f7:	83 ec 0c             	sub    $0xc,%esp
  8074fa:	6a 0d                	push   $0xd
  8074fc:	e8 96 fc ff ff       	call   807197 <memp_malloc>
  807501:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
  807503:	83 c4 10             	add    $0x10,%esp
    if (p == NULL) {
      return NULL;
  807506:	b8 00 00 00 00       	mov    $0x0,%eax
  80750b:	85 f6                	test   %esi,%esi
  80750d:	0f 84 07 02 00 00    	je     80771a <pbuf_alloc+0x292>
    }
    p->type = type;
  807513:	8a 45 10             	mov    0x10(%ebp),%al
  807516:	88 46 0c             	mov    %al,0xc(%esi)
    p->next = NULL;
  807519:	c7 06 00 00 00 00    	movl   $0x0,(%esi)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  80751f:	0f b7 c3             	movzwl %bx,%eax
  807522:	8d 44 30 13          	lea    0x13(%eax,%esi,1),%eax
  807526:	83 e0 fc             	and    $0xfffffffc,%eax
  807529:	89 46 04             	mov    %eax,0x4(%esi)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  80752c:	66 8b 55 f2          	mov    0xfffffff2(%ebp),%dx
  807530:	66 89 56 08          	mov    %dx,0x8(%esi)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  807534:	0f b7 c3             	movzwl %bx,%eax
  807537:	83 c0 03             	add    $0x3,%eax
  80753a:	83 e0 fc             	and    $0xfffffffc,%eax
  80753d:	ba d0 07 00 00       	mov    $0x7d0,%edx
  807542:	29 c2                	sub    %eax,%edx
  807544:	89 d0                	mov    %edx,%eax
  807546:	0f b7 55 f2          	movzwl 0xfffffff2(%ebp),%edx
  80754a:	39 d0                	cmp    %edx,%eax
  80754c:	7e 02                	jle    807550 <pbuf_alloc+0xc8>
  80754e:	89 d0                	mov    %edx,%eax
  807550:	66 89 46 0a          	mov    %ax,0xa(%esi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  807554:	0f b7 c0             	movzwl %ax,%eax
  807557:	03 46 04             	add    0x4(%esi),%eax
  80755a:	8d 96 e0 07 00 00    	lea    0x7e0(%esi),%edx
  807560:	39 d0                	cmp    %edx,%eax
  807562:	76 17                	jbe    80757b <pbuf_alloc+0xf3>
  807564:	83 ec 04             	sub    $0x4,%esp
  807567:	68 38 2e 81 00       	push   $0x812e38
  80756c:	68 a3 00 00 00       	push   $0xa3
  807571:	68 bf 2c 81 00       	push   $0x812cbf
  807576:	e8 51 95 ff ff       	call   800acc <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  80757b:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  807581:	89 f7                	mov    %esi,%edi
    /* remaining length to be allocated */
    rem_len = length - p->len;
  807583:	0f b7 5d f2          	movzwl 0xfffffff2(%ebp),%ebx
  807587:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  80758b:	29 c3                	sub    %eax,%ebx
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
      q = memp_malloc(MEMP_PBUF_POOL);
      if (q == NULL) {
        /* free chain so far allocated */
        pbuf_free(p);
        /* bail out unsuccesfully */
        return NULL;
      }
      q->type = type;
      q->flags = 0;
      q->next = NULL;
      /* make previous pbuf point to this pbuf */
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
      /* remember this pbuf for linkage in next iteration */
      r = q;
  80758d:	85 db                	test   %ebx,%ebx
  80758f:	0f 8e 79 01 00 00    	jle    80770e <pbuf_alloc+0x286>
  807595:	83 ec 0c             	sub    $0xc,%esp
  807598:	6a 0d                	push   $0xd
  80759a:	e8 f8 fb ff ff       	call   807197 <memp_malloc>
  80759f:	89 c1                	mov    %eax,%ecx
  8075a1:	83 c4 10             	add    $0x10,%esp
  8075a4:	85 c0                	test   %eax,%eax
  8075a6:	0f 84 52 01 00 00    	je     8076fe <pbuf_alloc+0x276>
  8075ac:	8a 45 10             	mov    0x10(%ebp),%al
  8075af:	88 41 0c             	mov    %al,0xc(%ecx)
  8075b2:	c6 41 0d 00          	movb   $0x0,0xd(%ecx)
  8075b6:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
  8075bc:	89 0f                	mov    %ecx,(%edi)
  8075be:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  8075c4:	7e 17                	jle    8075dd <pbuf_alloc+0x155>
  8075c6:	83 ec 04             	sub    $0x4,%esp
  8075c9:	68 d4 2c 81 00       	push   $0x812cd4
  8075ce:	68 bc 00 00 00       	push   $0xbc
  8075d3:	68 bf 2c 81 00       	push   $0x812cbf
  8075d8:	e8 ef 94 ff ff       	call   800acc <_panic>
  8075dd:	66 89 59 08          	mov    %bx,0x8(%ecx)
  8075e1:	89 d8                	mov    %ebx,%eax
  8075e3:	66 81 fb d0 07       	cmp    $0x7d0,%bx
  8075e8:	76 05                	jbe    8075ef <pbuf_alloc+0x167>
  8075ea:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  8075ef:	66 89 41 0a          	mov    %ax,0xa(%ecx)
  8075f3:	8d 41 10             	lea    0x10(%ecx),%eax
  8075f6:	89 41 04             	mov    %eax,0x4(%ecx)
  8075f9:	a8 03                	test   $0x3,%al
  8075fb:	74 17                	je     807614 <pbuf_alloc+0x18c>
  8075fd:	83 ec 04             	sub    $0x4,%esp
  807600:	68 6c 2e 81 00       	push   $0x812e6c
  807605:	68 c2 00 00 00       	push   $0xc2
  80760a:	68 bf 2c 81 00       	push   $0x812cbf
  80760f:	e8 b8 94 ff ff       	call   800acc <_panic>
  807614:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807618:	03 46 04             	add    0x4(%esi),%eax
  80761b:	8d 96 e0 07 00 00    	lea    0x7e0(%esi),%edx
  807621:	39 d0                	cmp    %edx,%eax
  807623:	76 17                	jbe    80763c <pbuf_alloc+0x1b4>
  807625:	83 ec 04             	sub    $0x4,%esp
  807628:	68 38 2e 81 00       	push   $0x812e38
  80762d:	68 c5 00 00 00       	push   $0xc5
  807632:	68 bf 2c 81 00       	push   $0x812cbf
  807637:	e8 90 94 ff ff       	call   800acc <_panic>
  80763c:	66 c7 41 0e 01 00    	movw   $0x1,0xe(%ecx)
  807642:	0f b7 41 0a          	movzwl 0xa(%ecx),%eax
  807646:	29 c3                	sub    %eax,%ebx
  807648:	89 cf                	mov    %ecx,%edi
  80764a:	85 db                	test   %ebx,%ebx
  80764c:	0f 8f 43 ff ff ff    	jg     807595 <pbuf_alloc+0x10d>
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
  807652:	e9 b7 00 00 00       	jmp    80770e <pbuf_alloc+0x286>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  807657:	83 ec 0c             	sub    $0xc,%esp
  80765a:	0f b7 d3             	movzwl %bx,%edx
  80765d:	83 c2 13             	add    $0x13,%edx
  807660:	83 e2 fc             	and    $0xfffffffc,%edx
  807663:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  807667:	83 c0 03             	add    $0x3,%eax
  80766a:	83 e0 fc             	and    $0xfffffffc,%eax
  80766d:	01 c2                	add    %eax,%edx
  80766f:	52                   	push   %edx
  807670:	e8 9c f8 ff ff       	call   806f11 <mem_malloc>
  807675:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  807677:	83 c4 10             	add    $0x10,%esp
      return NULL;
  80767a:	b8 00 00 00 00       	mov    $0x0,%eax
  80767f:	85 f6                	test   %esi,%esi
  807681:	0f 84 93 00 00 00    	je     80771a <pbuf_alloc+0x292>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  807687:	0f b7 c3             	movzwl %bx,%eax
  80768a:	8d 44 30 13          	lea    0x13(%eax,%esi,1),%eax
  80768e:	83 e0 fc             	and    $0xfffffffc,%eax
  807691:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  807694:	66 8b 55 f2          	mov    0xfffffff2(%ebp),%dx
  807698:	66 89 56 08          	mov    %dx,0x8(%esi)
  80769c:	66 89 56 0a          	mov    %dx,0xa(%esi)
    p->next = NULL;
  8076a0:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  8076a6:	8a 45 10             	mov    0x10(%ebp),%al
  8076a9:	88 46 0c             	mov    %al,0xc(%esi)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
  8076ac:	eb 60                	jmp    80770e <pbuf_alloc+0x286>
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  8076ae:	83 ec 0c             	sub    $0xc,%esp
  8076b1:	6a 0c                	push   $0xc
  8076b3:	e8 df fa ff ff       	call   807197 <memp_malloc>
  8076b8:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8076ba:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  8076bd:	b8 00 00 00 00       	mov    $0x0,%eax
  8076c2:	85 f6                	test   %esi,%esi
  8076c4:	74 54                	je     80771a <pbuf_alloc+0x292>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  8076c6:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    p->len = p->tot_len = length;
  8076cd:	66 8b 55 f2          	mov    0xfffffff2(%ebp),%dx
  8076d1:	66 89 56 08          	mov    %dx,0x8(%esi)
  8076d5:	66 89 56 0a          	mov    %dx,0xa(%esi)
    p->next = NULL;
  8076d9:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  8076df:	8a 45 10             	mov    0x10(%ebp),%al
  8076e2:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  8076e5:	eb 27                	jmp    80770e <pbuf_alloc+0x286>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  8076e7:	83 ec 04             	sub    $0x4,%esp
  8076ea:	68 e8 2c 81 00       	push   $0x812ce8
  8076ef:	68 f1 00 00 00       	push   $0xf1
  8076f4:	68 bf 2c 81 00       	push   $0x812cbf
  8076f9:	e8 ce 93 ff ff       	call   800acc <_panic>
  8076fe:	83 ec 0c             	sub    $0xc,%esp
  807701:	56                   	push   %esi
  807702:	e8 12 02 00 00       	call   807919 <pbuf_free>
  807707:	b8 00 00 00 00       	mov    $0x0,%eax
  80770c:	eb 0c                	jmp    80771a <pbuf_alloc+0x292>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  80770e:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  807714:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  807718:	89 f0                	mov    %esi,%eax
}
  80771a:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80771d:	5b                   	pop    %ebx
  80771e:	5e                   	pop    %esi
  80771f:	5f                   	pop    %edi
  807720:	c9                   	leave  
  807721:	c3                   	ret    

00807722 <pbuf_realloc>:


/**
 * Shrink a pbuf chain to a desired length.
 *
 * @param p pbuf to shrink.
 * @param new_len desired new length of pbuf chain
 *
 * Depending on the desired length, the first few pbufs in a chain might
 * be skipped and left unchanged. The new last pbuf in the chain will be
 * resized, and any remaining pbufs will be freed.
 *
 * @note If the pbuf is ROM/REF, only the ->tot_len and ->len fields are adjusted.
 * @note May not be called on a packet queue.
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  807722:	55                   	push   %ebp
  807723:	89 e5                	mov    %esp,%ebp
  807725:	56                   	push   %esi
  807726:	53                   	push   %ebx
  807727:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80772a:	8b 55 0c             	mov    0xc(%ebp),%edx
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  80772d:	85 db                	test   %ebx,%ebx
  80772f:	75 17                	jne    807748 <pbuf_realloc+0x26>
  807731:	83 ec 04             	sub    $0x4,%esp
  807734:	68 03 2d 81 00       	push   $0x812d03
  807739:	68 13 01 00 00       	push   $0x113
  80773e:	68 bf 2c 81 00       	push   $0x812cbf
  807743:	e8 84 93 ff ff       	call   800acc <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  807748:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  80774c:	74 29                	je     807777 <pbuf_realloc+0x55>
  80774e:	80 7b 0c 01          	cmpb   $0x1,0xc(%ebx)
  807752:	74 23                	je     807777 <pbuf_realloc+0x55>
  807754:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  807758:	74 1d                	je     807777 <pbuf_realloc+0x55>
  80775a:	80 7b 0c 02          	cmpb   $0x2,0xc(%ebx)
  80775e:	74 17                	je     807777 <pbuf_realloc+0x55>
  807760:	83 ec 04             	sub    $0x4,%esp
  807763:	68 1b 2d 81 00       	push   $0x812d1b
  807768:	68 17 01 00 00       	push   $0x117
  80776d:	68 bf 2c 81 00       	push   $0x812cbf
  807772:	e8 55 93 ff ff       	call   800acc <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  807777:	66 39 53 08          	cmp    %dx,0x8(%ebx)
  80777b:	0f 86 bb 00 00 00    	jbe    80783c <pbuf_realloc+0x11a>
    /* enlarging not yet supported */
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  807781:	0f b7 ca             	movzwl %dx,%ecx
  807784:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  807788:	29 c1                	sub    %eax,%ecx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  80778a:	89 d6                	mov    %edx,%esi
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    q->tot_len += (u16_t)grow;
    /* proceed to next pbuf in chain */
    q = q->next;
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  80778c:	66 39 53 0a          	cmp    %dx,0xa(%ebx)
  807790:	73 4a                	jae    8077dc <pbuf_realloc+0xba>
  807792:	66 2b 73 0a          	sub    0xa(%ebx),%si
  807796:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
  80779c:	7e 17                	jle    8077b5 <pbuf_realloc+0x93>
  80779e:	83 ec 04             	sub    $0x4,%esp
  8077a1:	68 36 2d 81 00       	push   $0x812d36
  8077a6:	68 2b 01 00 00       	push   $0x12b
  8077ab:	68 bf 2c 81 00       	push   $0x812cbf
  8077b0:	e8 17 93 ff ff       	call   800acc <_panic>
  8077b5:	66 01 4b 08          	add    %cx,0x8(%ebx)
  8077b9:	8b 1b                	mov    (%ebx),%ebx
  8077bb:	85 db                	test   %ebx,%ebx
  8077bd:	75 17                	jne    8077d6 <pbuf_realloc+0xb4>
  8077bf:	83 ec 04             	sub    $0x4,%esp
  8077c2:	68 47 2d 81 00       	push   $0x812d47
  8077c7:	68 2f 01 00 00       	push   $0x12f
  8077cc:	68 bf 2c 81 00       	push   $0x812cbf
  8077d1:	e8 f6 92 ff ff       	call   800acc <_panic>
  8077d6:	66 39 73 0a          	cmp    %si,0xa(%ebx)
  8077da:	72 b6                	jb     807792 <pbuf_realloc+0x70>
  }
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  8077dc:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  8077e0:	75 3a                	jne    80781c <pbuf_realloc+0xfa>
  8077e2:	66 39 73 0a          	cmp    %si,0xa(%ebx)
  8077e6:	74 34                	je     80781c <pbuf_realloc+0xfa>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  8077e8:	83 ec 08             	sub    $0x8,%esp
  8077eb:	8b 43 04             	mov    0x4(%ebx),%eax
  8077ee:	29 d8                	sub    %ebx,%eax
  8077f0:	0f b7 d6             	movzwl %si,%edx
  8077f3:	01 d0                	add    %edx,%eax
  8077f5:	50                   	push   %eax
  8077f6:	53                   	push   %ebx
  8077f7:	e8 94 f5 ff ff       	call   806d90 <mem_realloc>
  8077fc:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  8077fe:	83 c4 10             	add    $0x10,%esp
  807801:	85 c0                	test   %eax,%eax
  807803:	75 17                	jne    80781c <pbuf_realloc+0xfa>
  807805:	83 ec 04             	sub    $0x4,%esp
  807808:	68 5f 2d 81 00       	push   $0x812d5f
  80780d:	68 39 01 00 00       	push   $0x139
  807812:	68 bf 2c 81 00       	push   $0x812cbf
  807817:	e8 b0 92 ff ff       	call   800acc <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  80781c:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  807820:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  807824:	83 3b 00             	cmpl   $0x0,(%ebx)
  807827:	74 0d                	je     807836 <pbuf_realloc+0x114>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  807829:	83 ec 0c             	sub    $0xc,%esp
  80782c:	ff 33                	pushl  (%ebx)
  80782e:	e8 e6 00 00 00       	call   807919 <pbuf_free>
  807833:	83 c4 10             	add    $0x10,%esp
  }
  /* q is last packet in chain */
  q->next = NULL;
  807836:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  80783c:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80783f:	5b                   	pop    %ebx
  807840:	5e                   	pop    %esi
  807841:	c9                   	leave  
  807842:	c3                   	ret    

00807843 <pbuf_header>:

/**
 * Adjusts the payload pointer to hide or reveal headers in the payload.
 *
 * Adjusts the ->payload pointer so that space for a header
 * (dis)appears in the pbuf payload.
 *
 * The ->payload, ->tot_len and ->len fields are adjusted.
 *
 * @param p pbuf to change the header size.
 * @param header_size_increment Number of bytes to increment header size which
 * increases the size of the pbuf. New space is on the front.
 * (Using a negative value decreases the header size.)
 * If hdr_size_inc is 0, this function does nothing and returns succesful.
 *
 * PBUF_ROM and PBUF_REF type buffers cannot have their sizes increased, so
 * the call will fail. A check is made that the increase in header size does
 * not move the payload pointer in front of the start of the buffer.
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  807843:	55                   	push   %ebp
  807844:	89 e5                	mov    %esp,%ebp
  807846:	56                   	push   %esi
  807847:	53                   	push   %ebx
  807848:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80784b:	8b 55 0c             	mov    0xc(%ebp),%edx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  80784e:	85 c9                	test   %ecx,%ecx
  807850:	75 17                	jne    807869 <pbuf_header+0x26>
  807852:	83 ec 04             	sub    $0x4,%esp
  807855:	68 11 2d 81 00       	push   $0x812d11
  80785a:	68 64 01 00 00       	push   $0x164
  80785f:	68 bf 2c 81 00       	push   $0x812cbf
  807864:	e8 63 92 ff ff       	call   800acc <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  807869:	66 85 d2             	test   %dx,%dx
  80786c:	74 04                	je     807872 <pbuf_header+0x2f>
  80786e:	85 c9                	test   %ecx,%ecx
  807870:	75 0a                	jne    80787c <pbuf_header+0x39>
    return 0;
  807872:	b8 00 00 00 00       	mov    $0x0,%eax
  807877:	e9 96 00 00 00       	jmp    807912 <pbuf_header+0xcf>
 
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  80787c:	89 d3                	mov    %edx,%ebx
  80787e:	66 85 d2             	test   %dx,%dx
  807881:	79 1f                	jns    8078a2 <pbuf_header+0x5f>
  807883:	f7 db                	neg    %ebx
  807885:	66 39 59 0a          	cmp    %bx,0xa(%ecx)
  807889:	73 17                	jae    8078a2 <pbuf_header+0x5f>
  80788b:	83 ec 04             	sub    $0x4,%esp
  80788e:	68 7a 2d 81 00       	push   $0x812d7a
  807893:	68 6b 01 00 00       	push   $0x16b
  807898:	68 bf 2c 81 00       	push   $0x812cbf
  80789d:	e8 2a 92 ff ff       	call   800acc <_panic>
#if 0
    /* Can't assert these as some callers speculatively call
         pbuf_header() to see if it's OK.  Will return 1 below instead. */
    /* Check that we've got the correct type of pbuf to work with */
    LWIP_ASSERT("p->type == PBUF_RAM || p->type == PBUF_POOL", 
                p->type == PBUF_RAM || p->type == PBUF_POOL);
    /* Check that we aren't going to move off the beginning of the pbuf */
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  8078a2:	66 0f b6 41 0c       	movzbw 0xc(%ecx),%ax
  /* remember current payload pointer */
  payload = p->payload;
  8078a7:	8b 71 04             	mov    0x4(%ecx),%esi

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  8078aa:	66 85 c0             	test   %ax,%ax
  8078ad:	74 06                	je     8078b5 <pbuf_header+0x72>
  8078af:	66 83 f8 03          	cmp    $0x3,%ax
  8078b3:	75 18                	jne    8078cd <pbuf_header+0x8a>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  8078b5:	0f bf c2             	movswl %dx,%eax
  8078b8:	29 41 04             	sub    %eax,0x4(%ecx)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8078bb:	8d 41 10             	lea    0x10(%ecx),%eax
  8078be:	39 41 04             	cmp    %eax,0x4(%ecx)
  8078c1:	73 42                	jae    807905 <pbuf_header+0xc2>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  8078c3:	89 71 04             	mov    %esi,0x4(%ecx)
      /* bail out unsuccesfully */
      return 1;
  8078c6:	b8 01 00 00 00       	mov    $0x1,%eax
  8078cb:	eb 45                	jmp    807912 <pbuf_header+0xcf>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  8078cd:	48                   	dec    %eax
  8078ce:	66 83 f8 01          	cmp    $0x1,%ax
  8078d2:	77 1a                	ja     8078ee <pbuf_header+0xab>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  8078d4:	66 85 d2             	test   %dx,%dx
  8078d7:	79 0e                	jns    8078e7 <pbuf_header+0xa4>
  8078d9:	66 39 59 0a          	cmp    %bx,0xa(%ecx)
  8078dd:	72 08                	jb     8078e7 <pbuf_header+0xa4>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  8078df:	0f bf c2             	movswl %dx,%eax
  8078e2:	29 41 04             	sub    %eax,0x4(%ecx)
  8078e5:	eb 1e                	jmp    807905 <pbuf_header+0xc2>
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  8078e7:	b8 01 00 00 00       	mov    $0x1,%eax
  8078ec:	eb 24                	jmp    807912 <pbuf_header+0xcf>
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  8078ee:	83 ec 04             	sub    $0x4,%esp
  8078f1:	68 98 2d 81 00       	push   $0x812d98
  8078f6:	68 9a 01 00 00       	push   $0x19a
  8078fb:	68 bf 2c 81 00       	push   $0x812cbf
  807900:	e8 c7 91 ff ff       	call   800acc <_panic>
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  807905:	66 01 51 0a          	add    %dx,0xa(%ecx)
  p->tot_len += header_size_increment;
  807909:	66 01 51 08          	add    %dx,0x8(%ecx)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  80790d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807912:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  807915:	5b                   	pop    %ebx
  807916:	5e                   	pop    %esi
  807917:	c9                   	leave  
  807918:	c3                   	ret    

00807919 <pbuf_free>:

/**
 * Dereference a pbuf chain or queue and deallocate any no-longer-used
 * pbufs at the head of this chain or queue.
 *
 * Decrements the pbuf reference count. If it reaches zero, the pbuf is
 * deallocated.
 *
 * For a pbuf chain, this is repeated for each pbuf in the chain,
 * up to the first pbuf which has a non-zero reference count after
 * decrementing. So, when all reference counts are one, the whole
 * chain is free'd.
 *
 * @param p The pbuf (chain) to be dereferenced.
 *
 * @return the number of pbufs that were de-allocated
 * from the head of the chain.
 *
 * @note MUST NOT be called on a packet queue (Not verified to work yet).
 * @note the reference counter of a pbuf equals the number of pointers
 * that refer to the pbuf (or into the pbuf).
 *
 * @internal examples:
 *
 * Assuming existing chains a->b->c with the following reference
 * counts, calling pbuf_free(a) results in:
 * 
 * 1->2->3 becomes ...1->3
 * 3->3->3 becomes 2->3->3
 * 1->1->2 becomes ......1
 * 2->1->1 becomes 1->1->1
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  807919:	55                   	push   %ebp
  80791a:	89 e5                	mov    %esp,%ebp
  80791c:	56                   	push   %esi
  80791d:	53                   	push   %ebx
  80791e:	8b 55 08             	mov    0x8(%ebp),%edx
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  807921:	85 d2                	test   %edx,%edx
  807923:	75 17                	jne    80793c <pbuf_free+0x23>
    LWIP_ASSERT("p != NULL", p != NULL);
  807925:	83 ec 04             	sub    $0x4,%esp
  807928:	68 11 2d 81 00       	push   $0x812d11
  80792d:	68 d0 01 00 00       	push   $0x1d0
  807932:	68 bf 2c 81 00       	push   $0x812cbf
  807937:	e8 90 91 ff ff       	call   800acc <_panic>
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_free(p == NULL) was called.\n"));
    return 0;
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  80793c:	80 7a 0c 03          	cmpb   $0x3,0xc(%edx)
  807940:	76 17                	jbe    807959 <pbuf_free+0x40>
  807942:	83 ec 04             	sub    $0x4,%esp
  807945:	68 a6 2d 81 00       	push   $0x812da6
  80794a:	68 db 01 00 00       	push   $0x1db
  80794f:	68 bf 2c 81 00       	push   $0x812cbf
  807954:	e8 73 91 ff ff       	call   800acc <_panic>
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  807959:	be 00 00 00 00       	mov    $0x0,%esi
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
    u16_t ref;
    SYS_ARCH_DECL_PROTECT(old_level);
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
        memp_free(MEMP_PBUF_POOL, p);
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
        memp_free(MEMP_PBUF, p);
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
      }
      count++;
      /* proceed to next pbuf */
      p = q;
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
  80795e:	85 d2                	test   %edx,%edx
  807960:	74 7a                	je     8079dc <pbuf_free+0xc3>
  807962:	66 83 7a 0e 00       	cmpw   $0x0,0xe(%edx)
  807967:	75 17                	jne    807980 <pbuf_free+0x67>
  807969:	83 ec 04             	sub    $0x4,%esp
  80796c:	68 bb 2d 81 00       	push   $0x812dbb
  807971:	68 e8 01 00 00       	push   $0x1e8
  807976:	68 bf 2c 81 00       	push   $0x812cbf
  80797b:	e8 4c 91 ff ff       	call   800acc <_panic>
  807980:	66 8b 42 0e          	mov    0xe(%edx),%ax
  807984:	48                   	dec    %eax
  807985:	66 89 42 0e          	mov    %ax,0xe(%edx)
  807989:	66 85 c0             	test   %ax,%ax
  80798c:	75 45                	jne    8079d3 <pbuf_free+0xba>
  80798e:	8b 1a                	mov    (%edx),%ebx
  807990:	66 0f b6 42 0c       	movzbw 0xc(%edx),%ax
  807995:	66 83 f8 03          	cmp    $0x3,%ax
  807999:	75 10                	jne    8079ab <pbuf_free+0x92>
  80799b:	83 ec 08             	sub    $0x8,%esp
  80799e:	52                   	push   %edx
  80799f:	6a 0d                	push   $0xd
  8079a1:	e8 4b f8 ff ff       	call   8071f1 <memp_free>
  8079a6:	83 c4 10             	add    $0x10,%esp
  8079a9:	eb 23                	jmp    8079ce <pbuf_free+0xb5>
  8079ab:	48                   	dec    %eax
  8079ac:	66 83 f8 01          	cmp    $0x1,%ax
  8079b0:	77 10                	ja     8079c2 <pbuf_free+0xa9>
  8079b2:	83 ec 08             	sub    $0x8,%esp
  8079b5:	52                   	push   %edx
  8079b6:	6a 0c                	push   $0xc
  8079b8:	e8 34 f8 ff ff       	call   8071f1 <memp_free>
  8079bd:	83 c4 10             	add    $0x10,%esp
  8079c0:	eb 0c                	jmp    8079ce <pbuf_free+0xb5>
  8079c2:	83 ec 0c             	sub    $0xc,%esp
  8079c5:	52                   	push   %edx
  8079c6:	e8 00 f3 ff ff       	call   806ccb <mem_free>
  8079cb:	83 c4 10             	add    $0x10,%esp
  8079ce:	46                   	inc    %esi
  8079cf:	89 da                	mov    %ebx,%edx
  8079d1:	eb 05                	jmp    8079d8 <pbuf_free+0xbf>
  8079d3:	ba 00 00 00 00       	mov    $0x0,%edx
  8079d8:	85 d2                	test   %edx,%edx
  8079da:	75 86                	jne    807962 <pbuf_free+0x49>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
  8079dc:	89 f2                	mov    %esi,%edx
  8079de:	0f b6 c2             	movzbl %dl,%eax
}
  8079e1:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  8079e4:	5b                   	pop    %ebx
  8079e5:	5e                   	pop    %esi
  8079e6:	c9                   	leave  
  8079e7:	c3                   	ret    

008079e8 <pbuf_clen>:

/**
 * Count number of pbufs in a chain
 *
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  8079e8:	55                   	push   %ebp
  8079e9:	89 e5                	mov    %esp,%ebp
  8079eb:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  8079ee:	b0 00                	mov    $0x0,%al
  while (p != NULL) {
    ++len;
    p = p->next;
  8079f0:	85 d2                	test   %edx,%edx
  8079f2:	74 07                	je     8079fb <pbuf_clen+0x13>
  8079f4:	40                   	inc    %eax
  8079f5:	8b 12                	mov    (%edx),%edx
  8079f7:	85 d2                	test   %edx,%edx
  8079f9:	75 f9                	jne    8079f4 <pbuf_clen+0xc>
  }
  return len;
  8079fb:	0f b6 c0             	movzbl %al,%eax
}
  8079fe:	c9                   	leave  
  8079ff:	c3                   	ret    

00807a00 <pbuf_ref>:

/**
 * Increment the reference count of the pbuf.
 *
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  807a00:	55                   	push   %ebp
  807a01:	89 e5                	mov    %esp,%ebp
  807a03:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  807a06:	85 c0                	test   %eax,%eax
  807a08:	74 04                	je     807a0e <pbuf_ref+0xe>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  807a0a:	66 ff 40 0e          	incw   0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  807a0e:	c9                   	leave  
  807a0f:	c3                   	ret    

00807a10 <pbuf_cat>:

/**
 * Concatenate two pbufs (each may be a pbuf chain) and take over
 * the caller's reference of the tail pbuf.
 * 
 * @note The caller MAY NOT reference the tail pbuf afterwards.
 * Use pbuf_chain() for that purpose.
 * 
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  807a10:	55                   	push   %ebp
  807a11:	89 e5                	mov    %esp,%ebp
  807a13:	83 ec 08             	sub    $0x8,%esp
  807a16:	8b 45 08             	mov    0x8(%ebp),%eax
  807a19:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  807a1c:	85 c0                	test   %eax,%eax
  807a1e:	74 04                	je     807a24 <pbuf_cat+0x14>
  807a20:	85 c9                	test   %ecx,%ecx
  807a22:	75 17                	jne    807a3b <pbuf_cat+0x2b>
  807a24:	83 ec 04             	sub    $0x4,%esp
  807a27:	68 9c 2e 81 00       	push   $0x812e9c
  807a2c:	68 42 02 00 00       	push   $0x242
  807a31:	68 bf 2c 81 00       	push   $0x812cbf
  807a36:	e8 91 90 ff ff       	call   800acc <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  807a3b:	89 c2                	mov    %eax,%edx
  807a3d:	83 38 00             	cmpl   $0x0,(%eax)
  807a40:	74 13                	je     807a55 <pbuf_cat+0x45>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  807a42:	66 8b 42 08          	mov    0x8(%edx),%ax
  807a46:	66 03 41 08          	add    0x8(%ecx),%ax
  807a4a:	66 89 42 08          	mov    %ax,0x8(%edx)
  807a4e:	8b 12                	mov    (%edx),%edx
  807a50:	83 3a 00             	cmpl   $0x0,(%edx)
  807a53:	75 ed                	jne    807a42 <pbuf_cat+0x32>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  807a55:	66 8b 42 08          	mov    0x8(%edx),%ax
  807a59:	66 3b 42 0a          	cmp    0xa(%edx),%ax
  807a5d:	74 17                	je     807a76 <pbuf_cat+0x66>
  807a5f:	83 ec 04             	sub    $0x4,%esp
  807a62:	68 d4 2e 81 00       	push   $0x812ed4
  807a67:	68 4a 02 00 00       	push   $0x24a
  807a6c:	68 bf 2c 81 00       	push   $0x812cbf
  807a71:	e8 56 90 ff ff       	call   800acc <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  807a76:	83 3a 00             	cmpl   $0x0,(%edx)
  807a79:	74 17                	je     807a92 <pbuf_cat+0x82>
  807a7b:	83 ec 04             	sub    $0x4,%esp
  807a7e:	68 d1 2d 81 00       	push   $0x812dd1
  807a83:	68 4b 02 00 00       	push   $0x24b
  807a88:	68 bf 2c 81 00       	push   $0x812cbf
  807a8d:	e8 3a 90 ff ff       	call   800acc <_panic>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  807a92:	66 8b 42 08          	mov    0x8(%edx),%ax
  807a96:	66 03 41 08          	add    0x8(%ecx),%ax
  807a9a:	66 89 42 08          	mov    %ax,0x8(%edx)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  807a9e:	89 0a                	mov    %ecx,(%edx)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  807aa0:	c9                   	leave  
  807aa1:	c3                   	ret    

00807aa2 <pbuf_chain>:

/**
 * Chain two pbufs (or pbuf chains) together.
 * 
 * The caller MUST call pbuf_free(t) once it has stopped
 * using it. Use pbuf_cat() instead if you no longer use t.
 * 
 * @param h head pbuf (chain)
 * @param t tail pbuf (chain)
 * @note The pbufs MUST belong to the same packet.
 * @note MAY NOT be called on a packet queue.
 *
 * The ->tot_len fields of all pbufs of the head chain are adjusted.
 * The ->next field of the last pbuf of the head chain is adjusted.
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  807aa2:	55                   	push   %ebp
  807aa3:	89 e5                	mov    %esp,%ebp
  807aa5:	53                   	push   %ebx
  807aa6:	83 ec 0c             	sub    $0xc,%esp
  807aa9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  807aac:	53                   	push   %ebx
  807aad:	ff 75 08             	pushl  0x8(%ebp)
  807ab0:	e8 5b ff ff ff       	call   807a10 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  807ab5:	53                   	push   %ebx
  807ab6:	e8 45 ff ff ff       	call   807a00 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
  807abb:	83 c4 14             	add    $0x14,%esp
}
  807abe:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  807ac1:	c9                   	leave  
  807ac2:	c3                   	ret    

00807ac3 <pbuf_dechain>:

/**
 * Dechains the first pbuf from its succeeding pbufs in the chain.
 *
 * Makes p->tot_len field equal to p->len.
 * @param p pbuf to dechain
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  807ac3:	55                   	push   %ebp
  807ac4:	89 e5                	mov    %esp,%ebp
  807ac6:	56                   	push   %esi
  807ac7:	53                   	push   %ebx
  807ac8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  807acb:	b2 01                	mov    $0x1,%dl
  /* tail */
  q = p->next;
  807acd:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  807acf:	85 f6                	test   %esi,%esi
  807ad1:	74 50                	je     807b23 <pbuf_dechain+0x60>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  807ad3:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  807ad7:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  807adb:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  807adf:	29 ca                	sub    %ecx,%edx
  807ae1:	39 d0                	cmp    %edx,%eax
  807ae3:	74 17                	je     807afc <pbuf_dechain+0x39>
  807ae5:	83 ec 04             	sub    $0x4,%esp
  807ae8:	68 04 2f 81 00       	push   $0x812f04
  807aed:	68 80 02 00 00       	push   $0x280
  807af2:	68 bf 2c 81 00       	push   $0x812cbf
  807af7:	e8 d0 8f ff ff       	call   800acc <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  807afc:	66 8b 53 0a          	mov    0xa(%ebx),%dx
  807b00:	66 8b 43 08          	mov    0x8(%ebx),%ax
  807b04:	66 29 d0             	sub    %dx,%ax
  807b07:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  807b0b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  807b11:	66 89 53 08          	mov    %dx,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  807b15:	83 ec 0c             	sub    $0xc,%esp
  807b18:	56                   	push   %esi
  807b19:	e8 fb fd ff ff       	call   807919 <pbuf_free>
  807b1e:	88 c2                	mov    %al,%dl
    if (tail_gone > 0) {
  807b20:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE,
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  807b23:	66 8b 43 08          	mov    0x8(%ebx),%ax
  807b27:	66 3b 43 0a          	cmp    0xa(%ebx),%ax
  807b2b:	74 17                	je     807b44 <pbuf_dechain+0x81>
  807b2d:	83 ec 04             	sub    $0x4,%esp
  807b30:	68 e1 2d 81 00       	push   $0x812de1
  807b35:	68 91 02 00 00       	push   $0x291
  807b3a:	68 bf 2c 81 00       	push   $0x812cbf
  807b3f:	e8 88 8f ff ff       	call   800acc <_panic>
  return ((tail_gone > 0) ? NULL : q);
  807b44:	89 f0                	mov    %esi,%eax
  807b46:	84 d2                	test   %dl,%dl
  807b48:	74 05                	je     807b4f <pbuf_dechain+0x8c>
  807b4a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807b4f:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  807b52:	5b                   	pop    %ebx
  807b53:	5e                   	pop    %esi
  807b54:	c9                   	leave  
  807b55:	c3                   	ret    

00807b56 <pbuf_copy>:

/**
 *
 * Create PBUF_RAM copies of pbufs.
 *
 * Used to queue packets on behalf of the lwIP stack, such as
 * ARP based queueing.
 *
 * @note You MUST explicitly use p = pbuf_take(p);
 *
 * @note Only one packet is copied, no packet queue!
 *
 * @param p_to pbuf destination of the copy
 * @param p_from pbuf source of the copy
 *
 * @return ERR_OK if pbuf was copied
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  807b56:	55                   	push   %ebp
  807b57:	89 e5                	mov    %esp,%ebp
  807b59:	57                   	push   %edi
  807b5a:	56                   	push   %esi
  807b5b:	53                   	push   %ebx
  807b5c:	83 ec 0c             	sub    $0xc,%esp
  807b5f:	8b 7d 08             	mov    0x8(%ebp),%edi
  807b62:	8b 75 0c             	mov    0xc(%ebp),%esi
  u16_t offset_to=0, offset_from=0, len;
  807b65:	66 c7 45 f2 00 00    	movw   $0x0,0xfffffff2(%ebp)
  807b6b:	66 c7 45 f0 00 00    	movw   $0x0,0xfffffff0(%ebp)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  807b71:	85 ff                	test   %edi,%edi
  807b73:	74 0e                	je     807b83 <pbuf_copy+0x2d>
  807b75:	85 f6                	test   %esi,%esi
  807b77:	74 0a                	je     807b83 <pbuf_copy+0x2d>
  807b79:	66 8b 47 08          	mov    0x8(%edi),%ax
  807b7d:	66 3b 46 08          	cmp    0x8(%esi),%ax
  807b81:	73 17                	jae    807b9a <pbuf_copy+0x44>
  807b83:	83 ec 04             	sub    $0x4,%esp
  807b86:	68 28 2f 81 00       	push   $0x812f28
  807b8b:	68 b1 02 00 00       	push   $0x2b1
  807b90:	68 bf 2c 81 00       	push   $0x812cbf
  807b95:	e8 32 8f ff ff       	call   800acc <_panic>
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  807b9a:	85 ff                	test   %edi,%edi
  807b9c:	75 17                	jne    807bb5 <pbuf_copy+0x5f>
  807b9e:	83 ec 04             	sub    $0x4,%esp
  807ba1:	68 f6 2d 81 00       	push   $0x812df6
  807ba6:	68 b6 02 00 00       	push   $0x2b6
  807bab:	68 bf 2c 81 00       	push   $0x812cbf
  807bb0:	e8 17 8f ff ff       	call   800acc <_panic>
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  807bb5:	0f b7 4f 0a          	movzwl 0xa(%edi),%ecx
  807bb9:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  807bbd:	29 c1                	sub    %eax,%ecx
  807bbf:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807bc3:	0f b7 55 f0          	movzwl 0xfffffff0(%ebp),%edx
  807bc7:	29 d0                	sub    %edx,%eax
  807bc9:	39 c1                	cmp    %eax,%ecx
  807bcb:	7c 0c                	jl     807bd9 <pbuf_copy+0x83>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  807bcd:	66 8b 46 0a          	mov    0xa(%esi),%ax
  807bd1:	89 c3                	mov    %eax,%ebx
  807bd3:	66 2b 5d f0          	sub    0xfffffff0(%ebp),%bx
  807bd7:	eb 0a                	jmp    807be3 <pbuf_copy+0x8d>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  807bd9:	66 8b 47 0a          	mov    0xa(%edi),%ax
  807bdd:	89 c3                	mov    %eax,%ebx
  807bdf:	66 2b 5d f2          	sub    0xfffffff2(%ebp),%bx
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  807be3:	83 ec 04             	sub    $0x4,%esp
  807be6:	0f b7 c3             	movzwl %bx,%eax
  807be9:	50                   	push   %eax
  807bea:	0f b7 45 f0          	movzwl 0xfffffff0(%ebp),%eax
  807bee:	03 46 04             	add    0x4(%esi),%eax
  807bf1:	50                   	push   %eax
  807bf2:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  807bf6:	03 47 04             	add    0x4(%edi),%eax
  807bf9:	50                   	push   %eax
  807bfa:	e8 a8 97 ff ff       	call   8013a7 <memcpy>
    offset_to += len;
  807bff:	66 01 5d f2          	add    %bx,0xfffffff2(%ebp)
    offset_from += len;
  807c03:	66 01 5d f0          	add    %bx,0xfffffff0(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  807c07:	83 c4 10             	add    $0x10,%esp
  807c0a:	66 8b 45 f2          	mov    0xfffffff2(%ebp),%ax
  807c0e:	66 39 47 0a          	cmp    %ax,0xa(%edi)
  807c12:	73 17                	jae    807c2b <pbuf_copy+0xd5>
  807c14:	83 ec 04             	sub    $0x4,%esp
  807c17:	68 03 2e 81 00       	push   $0x812e03
  807c1c:	68 c2 02 00 00       	push   $0x2c2
  807c21:	68 bf 2c 81 00       	push   $0x812cbf
  807c26:	e8 a1 8e ff ff       	call   800acc <_panic>
    if (offset_to == p_to->len) {
  807c2b:	66 8b 45 f2          	mov    0xfffffff2(%ebp),%ax
  807c2f:	66 39 47 0a          	cmp    %ax,0xa(%edi)
  807c33:	75 08                	jne    807c3d <pbuf_copy+0xe7>
      /* on to next p_to (if any) */
      offset_to = 0;
  807c35:	66 c7 45 f2 00 00    	movw   $0x0,0xfffffff2(%ebp)
      p_to = p_to->next;
  807c3b:	8b 3f                	mov    (%edi),%edi
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  807c3d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  807c40:	66 39 46 0a          	cmp    %ax,0xa(%esi)
  807c44:	73 17                	jae    807c5d <pbuf_copy+0x107>
  807c46:	83 ec 04             	sub    $0x4,%esp
  807c49:	68 1a 2e 81 00       	push   $0x812e1a
  807c4e:	68 c8 02 00 00       	push   $0x2c8
  807c53:	68 bf 2c 81 00       	push   $0x812cbf
  807c58:	e8 6f 8e ff ff       	call   800acc <_panic>
    if (offset_from >= p_from->len) {
  807c5d:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  807c60:	66 39 46 0a          	cmp    %ax,0xa(%esi)
  807c64:	77 08                	ja     807c6e <pbuf_copy+0x118>
      /* on to next p_from (if any) */
      offset_from = 0;
  807c66:	66 c7 45 f0 00 00    	movw   $0x0,0xfffffff0(%ebp)
      p_from = p_from->next;
  807c6c:	8b 36                	mov    (%esi),%esi
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  807c6e:	85 f6                	test   %esi,%esi
  807c70:	74 26                	je     807c98 <pbuf_copy+0x142>
  807c72:	66 8b 46 0a          	mov    0xa(%esi),%ax
  807c76:	66 3b 46 08          	cmp    0x8(%esi),%ax
  807c7a:	75 1c                	jne    807c98 <pbuf_copy+0x142>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  807c7c:	83 3e 00             	cmpl   $0x0,(%esi)
  807c7f:	74 17                	je     807c98 <pbuf_copy+0x142>
  807c81:	83 ec 04             	sub    $0x4,%esp
  807c84:	68 58 2f 81 00       	push   $0x812f58
  807c89:	68 d2 02 00 00       	push   $0x2d2
  807c8e:	68 bf 2c 81 00       	push   $0x812cbf
  807c93:	e8 34 8e ff ff       	call   800acc <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  807c98:	85 ff                	test   %edi,%edi
  807c9a:	74 26                	je     807cc2 <pbuf_copy+0x16c>
  807c9c:	66 8b 47 0a          	mov    0xa(%edi),%ax
  807ca0:	66 3b 47 08          	cmp    0x8(%edi),%ax
  807ca4:	75 1c                	jne    807cc2 <pbuf_copy+0x16c>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  807ca6:	83 3f 00             	cmpl   $0x0,(%edi)
  807ca9:	74 17                	je     807cc2 <pbuf_copy+0x16c>
  807cab:	83 ec 04             	sub    $0x4,%esp
  807cae:	68 58 2f 81 00       	push   $0x812f58
  807cb3:	68 d7 02 00 00       	push   $0x2d7
  807cb8:	68 bf 2c 81 00       	push   $0x812cbf
  807cbd:	e8 0a 8e ff ff       	call   800acc <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  807cc2:	85 f6                	test   %esi,%esi
  807cc4:	0f 85 d0 fe ff ff    	jne    807b9a <pbuf_copy+0x44>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  807cca:	b8 00 00 00 00       	mov    $0x0,%eax
  807ccf:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  807cd2:	5b                   	pop    %ebx
  807cd3:	5e                   	pop    %esi
  807cd4:	5f                   	pop    %edi
  807cd5:	c9                   	leave  
  807cd6:	c3                   	ret    

00807cd7 <pbuf_copy_partial>:

/**
 * Copy (part of) the contents of a packet buffer
 * to an application supplied buffer.
 *
 * @param buf the pbuf from which to copy data
 * @param dataptr the application supplied buffer
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  807cd7:	55                   	push   %ebp
  807cd8:	89 e5                	mov    %esp,%ebp
  807cda:	57                   	push   %edi
  807cdb:	56                   	push   %esi
  807cdc:	53                   	push   %ebx
  807cdd:	83 ec 0c             	sub    $0xc,%esp
  807ce0:	8b 45 08             	mov    0x8(%ebp),%eax
  807ce3:	8b 7d 10             	mov    0x10(%ebp),%edi
  807ce6:	8b 55 14             	mov    0x14(%ebp),%edx
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
  807ce9:	66 c7 45 f0 00 00    	movw   $0x0,0xfffffff0(%ebp)

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  807cef:	85 c0                	test   %eax,%eax
  807cf1:	75 17                	jne    807d0a <pbuf_copy_partial+0x33>
  807cf3:	83 ec 04             	sub    $0x4,%esp
  807cf6:	68 84 2f 81 00       	push   $0x812f84
  807cfb:	68 ef 02 00 00       	push   $0x2ef
  807d00:	68 bf 2c 81 00       	push   $0x812cbf
  807d05:	e8 c2 8d ff ff       	call   800acc <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  807d0a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807d0e:	75 17                	jne    807d27 <pbuf_copy_partial+0x50>
  807d10:	83 ec 04             	sub    $0x4,%esp
  807d13:	68 a8 2f 81 00       	push   $0x812fa8
  807d18:	68 f0 02 00 00       	push   $0x2f0
  807d1d:	68 bf 2c 81 00       	push   $0x812cbf
  807d22:	e8 a5 8d ff ff       	call   800acc <_panic>

  left = 0;
  807d27:	66 c7 45 f2 00 00    	movw   $0x0,0xfffffff2(%ebp)

  if((buf == NULL) || (dataptr == NULL)) {
  807d2d:	85 c0                	test   %eax,%eax
  807d2f:	74 06                	je     807d37 <pbuf_copy_partial+0x60>
  807d31:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807d35:	75 07                	jne    807d3e <pbuf_copy_partial+0x67>
    return 0;
  807d37:	b8 00 00 00 00       	mov    $0x0,%eax
  807d3c:	eb 69                	jmp    807da7 <pbuf_copy_partial+0xd0>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  807d3e:	89 c6                	mov    %eax,%esi
  807d40:	66 85 ff             	test   %di,%di
  807d43:	74 5e                	je     807da3 <pbuf_copy_partial+0xcc>
  807d45:	85 c0                	test   %eax,%eax
  807d47:	74 5a                	je     807da3 <pbuf_copy_partial+0xcc>
    if ((offset != 0) && (offset >= p->len)) {
  807d49:	66 85 d2             	test   %dx,%dx
  807d4c:	74 0c                	je     807d5a <pbuf_copy_partial+0x83>
  807d4e:	66 39 56 0a          	cmp    %dx,0xa(%esi)
  807d52:	77 06                	ja     807d5a <pbuf_copy_partial+0x83>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  807d54:	66 2b 56 0a          	sub    0xa(%esi),%dx
  807d58:	eb 3e                	jmp    807d98 <pbuf_copy_partial+0xc1>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  807d5a:	66 8b 46 0a          	mov    0xa(%esi),%ax
  807d5e:	89 c3                	mov    %eax,%ebx
  807d60:	66 29 d3             	sub    %dx,%bx
      if (buf_copy_len > len)
  807d63:	66 39 fb             	cmp    %di,%bx
  807d66:	76 02                	jbe    807d6a <pbuf_copy_partial+0x93>
          buf_copy_len = len;
  807d68:	89 fb                	mov    %edi,%ebx
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  807d6a:	83 ec 04             	sub    $0x4,%esp
  807d6d:	0f b7 c3             	movzwl %bx,%eax
  807d70:	50                   	push   %eax
  807d71:	0f b7 c2             	movzwl %dx,%eax
  807d74:	03 46 04             	add    0x4(%esi),%eax
  807d77:	50                   	push   %eax
  807d78:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  807d7c:	03 45 0c             	add    0xc(%ebp),%eax
  807d7f:	50                   	push   %eax
  807d80:	e8 22 96 ff ff       	call   8013a7 <memcpy>
      copied_total += buf_copy_len;
  807d85:	66 01 5d f0          	add    %bx,0xfffffff0(%ebp)
      left += buf_copy_len;
  807d89:	66 01 5d f2          	add    %bx,0xfffffff2(%ebp)
      len -= buf_copy_len;
  807d8d:	66 29 df             	sub    %bx,%di
      offset = 0;
  807d90:	ba 00 00 00 00       	mov    $0x0,%edx
  807d95:	83 c4 10             	add    $0x10,%esp
  807d98:	8b 36                	mov    (%esi),%esi
  807d9a:	66 85 ff             	test   %di,%di
  807d9d:	74 04                	je     807da3 <pbuf_copy_partial+0xcc>
  807d9f:	85 f6                	test   %esi,%esi
  807da1:	75 a6                	jne    807d49 <pbuf_copy_partial+0x72>
    }
  }
  return copied_total;
  807da3:	0f b7 45 f0          	movzwl 0xfffffff0(%ebp),%eax
}
  807da7:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  807daa:	5b                   	pop    %ebx
  807dab:	5e                   	pop    %esi
  807dac:	5f                   	pop    %edi
  807dad:	c9                   	leave  
  807dae:	c3                   	ret    
	...

00807db0 <sys_mbox_fetch>:
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  807db0:	55                   	push   %ebp
  807db1:	89 e5                	mov    %esp,%ebp
  807db3:	57                   	push   %edi
  807db4:	56                   	push   %esi
  807db5:	53                   	push   %ebx
  807db6:	83 ec 0c             	sub    $0xc,%esp
  807db9:	8b 7d 0c             	mov    0xc(%ebp),%edi
  u32_t time_needed;
  struct sys_timeouts *timeouts;
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  807dbc:	e8 a1 55 00 00       	call   80d362 <sys_arch_timeouts>
  807dc1:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  807dc3:	85 c0                	test   %eax,%eax
  807dc5:	74 05                	je     807dcc <sys_mbox_fetch+0x1c>
  807dc7:	83 38 00             	cmpl   $0x0,(%eax)
  807dca:	75 13                	jne    807ddf <sys_mbox_fetch+0x2f>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  807dcc:	83 ec 04             	sub    $0x4,%esp
  807dcf:	6a 00                	push   $0x0
  807dd1:	57                   	push   %edi
  807dd2:	ff 75 08             	pushl  0x8(%ebp)
  807dd5:	e8 34 53 00 00       	call   80d10e <sys_arch_mbox_fetch>
  807dda:	83 c4 10             	add    $0x10,%esp
  807ddd:	eb 62                	jmp    807e41 <sys_mbox_fetch+0x91>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  807ddf:	8b 10                	mov    (%eax),%edx
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  807de1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807de6:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
  807dea:	74 12                	je     807dfe <sys_mbox_fetch+0x4e>
  807dec:	83 ec 04             	sub    $0x4,%esp
  807def:	ff 72 04             	pushl  0x4(%edx)
  807df2:	57                   	push   %edi
  807df3:	ff 75 08             	pushl  0x8(%ebp)
  807df6:	e8 13 53 00 00       	call   80d10e <sys_arch_mbox_fetch>
  807dfb:	83 c4 10             	add    $0x10,%esp
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  807dfe:	83 f8 ff             	cmp    $0xffffffff,%eax
  807e01:	75 29                	jne    807e2c <sys_mbox_fetch+0x7c>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  807e03:	8b 13                	mov    (%ebx),%edx
      timeouts->next = tmptimeout->next;
  807e05:	8b 02                	mov    (%edx),%eax
  807e07:	89 03                	mov    %eax,(%ebx)
      h   = tmptimeout->h;
  807e09:	8b 5a 08             	mov    0x8(%edx),%ebx
      arg = tmptimeout->arg;
  807e0c:	8b 72 0c             	mov    0xc(%edx),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  807e0f:	83 ec 08             	sub    $0x8,%esp
  807e12:	52                   	push   %edx
  807e13:	6a 0b                	push   $0xb
  807e15:	e8 d7 f3 ff ff       	call   8071f1 <memp_free>
      if (h != NULL) {
  807e1a:	83 c4 10             	add    $0x10,%esp
  807e1d:	85 db                	test   %ebx,%ebx
  807e1f:	74 9b                	je     807dbc <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  807e21:	83 ec 0c             	sub    $0xc,%esp
  807e24:	56                   	push   %esi
  807e25:	ff d3                	call   *%ebx
  807e27:	83 c4 10             	add    $0x10,%esp
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  807e2a:	eb 90                	jmp    807dbc <sys_mbox_fetch+0xc>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  807e2c:	8b 13                	mov    (%ebx),%edx
  807e2e:	39 42 04             	cmp    %eax,0x4(%edx)
  807e31:	76 05                	jbe    807e38 <sys_mbox_fetch+0x88>
        timeouts->next->time -= time_needed;
  807e33:	29 42 04             	sub    %eax,0x4(%edx)
  807e36:	eb 09                	jmp    807e41 <sys_mbox_fetch+0x91>
      } else {
        timeouts->next->time = 0;
  807e38:	8b 03                	mov    (%ebx),%eax
  807e3a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      }
    }
  }
}
  807e41:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  807e44:	5b                   	pop    %ebx
  807e45:	5e                   	pop    %esi
  807e46:	5f                   	pop    %edi
  807e47:	c9                   	leave  
  807e48:	c3                   	ret    

00807e49 <sys_sem_wait>:

/**
 * Wait (forever) for a semaphore to become available.
 * While waiting, timeouts (for this thread) are processed.
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  807e49:	55                   	push   %ebp
  807e4a:	89 e5                	mov    %esp,%ebp
  807e4c:	57                   	push   %edi
  807e4d:	56                   	push   %esi
  807e4e:	53                   	push   %ebx
  807e4f:	83 ec 0c             	sub    $0xc,%esp
  807e52:	8b 7d 08             	mov    0x8(%ebp),%edi
  u32_t time_needed;
  struct sys_timeouts *timeouts;
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  807e55:	e8 08 55 00 00       	call   80d362 <sys_arch_timeouts>
  807e5a:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  807e5c:	85 c0                	test   %eax,%eax
  807e5e:	74 05                	je     807e65 <sys_sem_wait+0x1c>
  807e60:	83 38 00             	cmpl   $0x0,(%eax)
  807e63:	75 10                	jne    807e75 <sys_sem_wait+0x2c>
    sys_arch_sem_wait(sem, 0);
  807e65:	83 ec 08             	sub    $0x8,%esp
  807e68:	6a 00                	push   $0x0
  807e6a:	57                   	push   %edi
  807e6b:	e8 6c 51 00 00       	call   80cfdc <sys_arch_sem_wait>
  807e70:	83 c4 10             	add    $0x10,%esp
  807e73:	eb 5f                	jmp    807ed4 <sys_sem_wait+0x8b>
  } else {
    if (timeouts->next->time > 0) {
  807e75:	8b 10                	mov    (%eax),%edx
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  807e77:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807e7c:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
  807e80:	74 0f                	je     807e91 <sys_sem_wait+0x48>
  807e82:	83 ec 08             	sub    $0x8,%esp
  807e85:	ff 72 04             	pushl  0x4(%edx)
  807e88:	57                   	push   %edi
  807e89:	e8 4e 51 00 00       	call   80cfdc <sys_arch_sem_wait>
  807e8e:	83 c4 10             	add    $0x10,%esp
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  807e91:	83 f8 ff             	cmp    $0xffffffff,%eax
  807e94:	75 29                	jne    807ebf <sys_sem_wait+0x76>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  807e96:	8b 13                	mov    (%ebx),%edx
      timeouts->next = tmptimeout->next;
  807e98:	8b 02                	mov    (%edx),%eax
  807e9a:	89 03                	mov    %eax,(%ebx)
      h = tmptimeout->h;
  807e9c:	8b 5a 08             	mov    0x8(%edx),%ebx
      arg = tmptimeout->arg;
  807e9f:	8b 72 0c             	mov    0xc(%edx),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  807ea2:	83 ec 08             	sub    $0x8,%esp
  807ea5:	52                   	push   %edx
  807ea6:	6a 0b                	push   $0xb
  807ea8:	e8 44 f3 ff ff       	call   8071f1 <memp_free>
      if (h != NULL) {
  807ead:	83 c4 10             	add    $0x10,%esp
  807eb0:	85 db                	test   %ebx,%ebx
  807eb2:	74 a1                	je     807e55 <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  807eb4:	83 ec 0c             	sub    $0xc,%esp
  807eb7:	56                   	push   %esi
  807eb8:	ff d3                	call   *%ebx
  807eba:	83 c4 10             	add    $0x10,%esp
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  807ebd:	eb 96                	jmp    807e55 <sys_sem_wait+0xc>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  807ebf:	8b 13                	mov    (%ebx),%edx
  807ec1:	39 42 04             	cmp    %eax,0x4(%edx)
  807ec4:	76 05                	jbe    807ecb <sys_sem_wait+0x82>
        timeouts->next->time -= time_needed;
  807ec6:	29 42 04             	sub    %eax,0x4(%edx)
  807ec9:	eb 09                	jmp    807ed4 <sys_sem_wait+0x8b>
      } else {
        timeouts->next->time = 0;
  807ecb:	8b 03                	mov    (%ebx),%eax
  807ecd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      }
    }
  }
}
  807ed4:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  807ed7:	5b                   	pop    %ebx
  807ed8:	5e                   	pop    %esi
  807ed9:	5f                   	pop    %edi
  807eda:	c9                   	leave  
  807edb:	c3                   	ret    

00807edc <sys_timeout>:

/**
 * Create a one-shot timer (aka timeout). Timeouts are processed in the
 * following cases:
 * - while waiting for a message using sys_mbox_fetch()
 * - while waiting for a semaphore using sys_sem_wait() or sys_sem_wait_timeout()
 * - while sleeping using the inbuilt sys_msleep()
 *
 * @param msecs time in milliseconds after that the timer should expire
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  807edc:	55                   	push   %ebp
  807edd:	89 e5                	mov    %esp,%ebp
  807edf:	57                   	push   %edi
  807ee0:	56                   	push   %esi
  807ee1:	53                   	push   %ebx
  807ee2:	83 ec 18             	sub    $0x18,%esp
  807ee5:	8b 7d 08             	mov    0x8(%ebp),%edi
  807ee8:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  807eeb:	6a 0b                	push   $0xb
  807eed:	e8 a5 f2 ff ff       	call   807197 <memp_malloc>
  807ef2:	89 c3                	mov    %eax,%ebx
  if (timeout == NULL) {
  807ef4:	83 c4 10             	add    $0x10,%esp
  807ef7:	85 c0                	test   %eax,%eax
  807ef9:	75 17                	jne    807f12 <sys_timeout+0x36>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  807efb:	83 ec 04             	sub    $0x4,%esp
  807efe:	68 cd 2f 81 00       	push   $0x812fcd
  807f03:	68 c3 00 00 00       	push   $0xc3
  807f08:	68 ea 2f 81 00       	push   $0x812fea
  807f0d:	e8 ba 8b ff ff       	call   800acc <_panic>
    return;
  }
  timeout->next = NULL;
  807f12:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  807f18:	89 70 08             	mov    %esi,0x8(%eax)
  timeout->arg = arg;
  807f1b:	8b 45 10             	mov    0x10(%ebp),%eax
  807f1e:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  807f21:	89 7b 04             	mov    %edi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  807f24:	e8 39 54 00 00       	call   80d362 <sys_arch_timeouts>
  807f29:	89 c2                	mov    %eax,%edx

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  807f2b:	85 c0                	test   %eax,%eax
  807f2d:	75 17                	jne    807f46 <sys_timeout+0x6a>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  807f2f:	83 ec 04             	sub    $0x4,%esp
  807f32:	68 fe 2f 81 00       	push   $0x812ffe
  807f37:	68 d1 00 00 00       	push   $0xd1
  807f3c:	68 ea 2f 81 00       	push   $0x812fea
  807f41:	e8 86 8b ff ff       	call   800acc <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  807f46:	83 38 00             	cmpl   $0x0,(%eax)
  807f49:	75 04                	jne    807f4f <sys_timeout+0x73>
    timeouts->next = timeout;
  807f4b:	89 18                	mov    %ebx,(%eax)
    return;
  807f4d:	eb 48                	jmp    807f97 <sys_timeout+0xbb>
  }

  if (timeouts->next->time > msecs) {
  807f4f:	8b 00                	mov    (%eax),%eax
  807f51:	39 78 04             	cmp    %edi,0x4(%eax)
  807f54:	76 0b                	jbe    807f61 <sys_timeout+0x85>
    timeouts->next->time -= msecs;
  807f56:	29 78 04             	sub    %edi,0x4(%eax)
    timeout->next = timeouts->next;
  807f59:	8b 02                	mov    (%edx),%eax
  807f5b:	89 03                	mov    %eax,(%ebx)
    timeouts->next = timeout;
  807f5d:	89 1a                	mov    %ebx,(%edx)
  807f5f:	eb 36                	jmp    807f97 <sys_timeout+0xbb>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  807f61:	8b 12                	mov    (%edx),%edx
  807f63:	85 d2                	test   %edx,%edx
  807f65:	74 30                	je     807f97 <sys_timeout+0xbb>
      timeout->time -= t->time;
  807f67:	8b 43 04             	mov    0x4(%ebx),%eax
  807f6a:	89 c6                	mov    %eax,%esi
  807f6c:	2b 72 04             	sub    0x4(%edx),%esi
  807f6f:	89 73 04             	mov    %esi,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  807f72:	83 3a 00             	cmpl   $0x0,(%edx)
  807f75:	74 12                	je     807f89 <sys_timeout+0xad>
  807f77:	8b 0a                	mov    (%edx),%ecx
  807f79:	8b 41 04             	mov    0x4(%ecx),%eax
  807f7c:	39 f0                	cmp    %esi,%eax
  807f7e:	76 11                	jbe    807f91 <sys_timeout+0xb5>
        if (t->next != NULL) {
  807f80:	85 c9                	test   %ecx,%ecx
  807f82:	74 05                	je     807f89 <sys_timeout+0xad>
          t->next->time -= timeout->time;
  807f84:	29 f0                	sub    %esi,%eax
  807f86:	89 41 04             	mov    %eax,0x4(%ecx)
        }
        timeout->next = t->next;
  807f89:	8b 02                	mov    (%edx),%eax
  807f8b:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  807f8d:	89 1a                	mov    %ebx,(%edx)
        break;
  807f8f:	eb 06                	jmp    807f97 <sys_timeout+0xbb>
  807f91:	8b 12                	mov    (%edx),%edx
  807f93:	85 d2                	test   %edx,%edx
  807f95:	75 d0                	jne    807f67 <sys_timeout+0x8b>
      }
    }
  }
}
  807f97:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  807f9a:	5b                   	pop    %ebx
  807f9b:	5e                   	pop    %esi
  807f9c:	5f                   	pop    %edi
  807f9d:	c9                   	leave  
  807f9e:	c3                   	ret    

00807f9f <sys_untimeout>:

/**
 * Go through timeout list (for this task only) and remove the first matching
 * entry, even though the timeout has not triggered yet.
 *
 * @note This function only works as expected if there is only one timeout
 * calling 'h' in the list of timeouts.
 *
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  807f9f:	55                   	push   %ebp
  807fa0:	89 e5                	mov    %esp,%ebp
  807fa2:	57                   	push   %edi
  807fa3:	56                   	push   %esi
  807fa4:	53                   	push   %ebx
  807fa5:	83 ec 0c             	sub    $0xc,%esp
  807fa8:	8b 75 08             	mov    0x8(%ebp),%esi
  807fab:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  807fae:	e8 af 53 00 00       	call   80d362 <sys_arch_timeouts>
  807fb3:	89 c2                	mov    %eax,%edx

  if (timeouts == NULL) {
  807fb5:	85 c0                	test   %eax,%eax
  807fb7:	75 17                	jne    807fd0 <sys_untimeout+0x31>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  807fb9:	83 ec 04             	sub    $0x4,%esp
  807fbc:	68 1c 30 81 00       	push   $0x81301c
  807fc1:	68 00 01 00 00       	push   $0x100
  807fc6:	68 ea 2f 81 00       	push   $0x812fea
  807fcb:	e8 fc 8a ff ff       	call   800acc <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  807fd0:	83 38 00             	cmpl   $0x0,(%eax)
  807fd3:	74 46                	je     80801b <sys_untimeout+0x7c>
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  807fd5:	8b 08                	mov    (%eax),%ecx
  807fd7:	bb 00 00 00 00       	mov    $0x0,%ebx
  807fdc:	74 3d                	je     80801b <sys_untimeout+0x7c>
    if ((t->h == h) && (t->arg == arg)) {
  807fde:	39 71 08             	cmp    %esi,0x8(%ecx)
  807fe1:	75 30                	jne    808013 <sys_untimeout+0x74>
  807fe3:	39 79 0c             	cmp    %edi,0xc(%ecx)
  807fe6:	75 2b                	jne    808013 <sys_untimeout+0x74>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  807fe8:	85 db                	test   %ebx,%ebx
  807fea:	75 06                	jne    807ff2 <sys_untimeout+0x53>
        timeouts->next = t->next;
  807fec:	8b 01                	mov    (%ecx),%eax
  807fee:	89 02                	mov    %eax,(%edx)
  807ff0:	eb 04                	jmp    807ff6 <sys_untimeout+0x57>
      else
        prev_t->next = t->next;
  807ff2:	8b 01                	mov    (%ecx),%eax
  807ff4:	89 03                	mov    %eax,(%ebx)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  807ff6:	83 39 00             	cmpl   $0x0,(%ecx)
  807ff9:	74 0b                	je     808006 <sys_untimeout+0x67>
        t->next->time += t->time;
  807ffb:	8b 11                	mov    (%ecx),%edx
  807ffd:	8b 42 04             	mov    0x4(%edx),%eax
  808000:	03 41 04             	add    0x4(%ecx),%eax
  808003:	89 42 04             	mov    %eax,0x4(%edx)
      memp_free(MEMP_SYS_TIMEOUT, t);
  808006:	83 ec 08             	sub    $0x8,%esp
  808009:	51                   	push   %ecx
  80800a:	6a 0b                	push   $0xb
  80800c:	e8 e0 f1 ff ff       	call   8071f1 <memp_free>
      return;
  808011:	eb 08                	jmp    80801b <sys_untimeout+0x7c>
  808013:	89 cb                	mov    %ecx,%ebx
  808015:	8b 09                	mov    (%ecx),%ecx
  808017:	85 c9                	test   %ecx,%ecx
  808019:	75 c3                	jne    807fde <sys_untimeout+0x3f>
    }
  }
  return;
}
  80801b:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80801e:	5b                   	pop    %ebx
  80801f:	5e                   	pop    %esi
  808020:	5f                   	pop    %edi
  808021:	c9                   	leave  
  808022:	c3                   	ret    

00808023 <sswt_handler>:

/**
 * Timeout handler function for sys_sem_wait_timeout()
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  808023:	55                   	push   %ebp
  808024:	89 e5                	mov    %esp,%ebp
  808026:	83 ec 14             	sub    $0x14,%esp
  808029:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80802c:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  808031:	8b 40 04             	mov    0x4(%eax),%eax
  808034:	ff 30                	pushl  (%eax)
  808036:	e8 3f 4f 00 00       	call   80cf7a <sys_sem_signal>
}
  80803b:	c9                   	leave  
  80803c:	c3                   	ret    

0080803d <sys_sem_wait_timeout>:

/**
 * Wait for a semaphore with timeout (specified in ms)
 *
 * @param sem semaphore to wait
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  80803d:	55                   	push   %ebp
  80803e:	89 e5                	mov    %esp,%ebp
  808040:	83 ec 08             	sub    $0x8,%esp
  808043:	8b 55 0c             	mov    0xc(%ebp),%edx
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  808046:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  808049:	8d 4d 08             	lea    0x8(%ebp),%ecx
  80804c:	89 48 04             	mov    %ecx,0x4(%eax)
  sswt_cb.timeflag = 0;
  80804f:	66 c7 45 f8 00 00    	movw   $0x0,0xfffffff8(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  808055:	85 d2                	test   %edx,%edx
  808057:	74 12                	je     80806b <sys_sem_wait_timeout+0x2e>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  808059:	83 ec 04             	sub    $0x4,%esp
  80805c:	50                   	push   %eax
  80805d:	68 23 80 80 00       	push   $0x808023
  808062:	52                   	push   %edx
  808063:	e8 74 fe ff ff       	call   807edc <sys_timeout>
  808068:	83 c4 10             	add    $0x10,%esp
  }
  sys_sem_wait(sem);
  80806b:	83 ec 0c             	sub    $0xc,%esp
  80806e:	ff 75 08             	pushl  0x8(%ebp)
  808071:	e8 d3 fd ff ff       	call   807e49 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  808076:	83 c4 10             	add    $0x10,%esp
    /* timeout */
    return 0;
  808079:	b8 00 00 00 00       	mov    $0x0,%eax
  80807e:	66 83 7d f8 00       	cmpw   $0x0,0xfffffff8(%ebp)
  808083:	75 16                	jne    80809b <sys_sem_wait_timeout+0x5e>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  808085:	83 ec 08             	sub    $0x8,%esp
  808088:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  80808b:	50                   	push   %eax
  80808c:	68 23 80 80 00       	push   $0x808023
  808091:	e8 09 ff ff ff       	call   807f9f <sys_untimeout>
    return 1;
  808096:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  80809b:	c9                   	leave  
  80809c:	c3                   	ret    

0080809d <sys_msleep>:

/**
 * Sleep for some ms. Timeouts are processed while sleeping.
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80809d:	55                   	push   %ebp
  80809e:	89 e5                	mov    %esp,%ebp
  8080a0:	53                   	push   %ebx
  8080a1:	83 ec 10             	sub    $0x10,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  8080a4:	6a 00                	push   $0x0
  8080a6:	e8 be 4d 00 00       	call   80ce69 <sys_sem_new>
  8080ab:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  8080ad:	83 c4 08             	add    $0x8,%esp
  8080b0:	ff 75 08             	pushl  0x8(%ebp)
  8080b3:	50                   	push   %eax
  8080b4:	e8 84 ff ff ff       	call   80803d <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  8080b9:	89 1c 24             	mov    %ebx,(%esp)
  8080bc:	e8 3e 4e 00 00       	call   80ceff <sys_sem_free>
}
  8080c1:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  8080c4:	c9                   	leave  
  8080c5:	c3                   	ret    
	...

008080c8 <tcp_tmr>:
 *
 */
void
tcp_tmr(void)
{
  8080c8:	55                   	push   %ebp
  8080c9:	89 e5                	mov    %esp,%ebp
  8080cb:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  8080ce:	e8 60 0b 00 00       	call   808c33 <tcp_fasttmr>

  if (++tcp_timer & 1) {
  8080d3:	fe 05 08 78 b3 00    	incb   0xb37808
  8080d9:	f6 05 08 78 b3 00 01 	testb  $0x1,0xb37808
  8080e0:	74 05                	je     8080e7 <tcp_tmr+0x1f>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  8080e2:	e8 12 07 00 00       	call   8087f9 <tcp_slowtmr>
  }
}
  8080e7:	c9                   	leave  
  8080e8:	c3                   	ret    

008080e9 <tcp_close>:

/**
 * Closes the connection held by the PCB.
 *
 * Listening pcbs are freed and may not be referenced any more.
 * Connection pcbs are freed if not yet connected and may not be referenced
 * any more. If a connection is established (at least SYN received or in
 * a closing state), the connection is closed, and put in a closing state.
 * The pcb is then automatically freed in tcp_slowtmr(). It is therefore
 * unsafe to reference it.
 *
 * @param pcb the tcp_pcb to close
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  8080e9:	55                   	push   %ebp
  8080ea:	89 e5                	mov    %esp,%ebp
  8080ec:	56                   	push   %esi
  8080ed:	53                   	push   %ebx
  8080ee:	8b 5d 08             	mov    0x8(%ebp),%ebx
  err_t err;

#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  8080f1:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  8080f5:	0f 87 22 01 00 00    	ja     80821d <tcp_close+0x134>
  8080fb:	8b 43 10             	mov    0x10(%ebx),%eax
  8080fe:	ff 24 85 50 30 81 00 	jmp    *0x813050(,%eax,4)
  case CLOSED:
    /* Closing a pcb in the CLOSED state might seem erroneous,
     * however, it is in this state once allocated and as yet unused
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  808105:	be 00 00 00 00       	mov    $0x0,%esi
    TCP_RMV(&tcp_bound_pcbs, pcb);
  80810a:	39 1d 78 e6 b3 00    	cmp    %ebx,0xb3e678
  808110:	75 12                	jne    808124 <tcp_close+0x3b>
  808112:	8b 43 0c             	mov    0xc(%ebx),%eax
  808115:	a3 78 e6 b3 00       	mov    %eax,0xb3e678
  80811a:	eb 38                	jmp    808154 <tcp_close+0x6b>
  80811c:	8b 43 0c             	mov    0xc(%ebx),%eax
  80811f:	89 42 0c             	mov    %eax,0xc(%edx)
  808122:	eb 30                	jmp    808154 <tcp_close+0x6b>
  808124:	a1 78 e6 b3 00       	mov    0xb3e678,%eax
  808129:	a3 74 e6 b3 00       	mov    %eax,0xb3e674
  80812e:	85 c0                	test   %eax,%eax
  808130:	74 22                	je     808154 <tcp_close+0x6b>
  808132:	8b 15 74 e6 b3 00    	mov    0xb3e674,%edx
  808138:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  80813c:	74 05                	je     808143 <tcp_close+0x5a>
  80813e:	39 5a 0c             	cmp    %ebx,0xc(%edx)
  808141:	74 d9                	je     80811c <tcp_close+0x33>
  808143:	a1 74 e6 b3 00       	mov    0xb3e674,%eax
  808148:	8b 40 0c             	mov    0xc(%eax),%eax
  80814b:	a3 74 e6 b3 00       	mov    %eax,0xb3e674
  808150:	85 c0                	test   %eax,%eax
  808152:	75 de                	jne    808132 <tcp_close+0x49>
  808154:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  80815b:	83 ec 08             	sub    $0x8,%esp
  80815e:	53                   	push   %ebx
  80815f:	6a 02                	push   $0x2
  808161:	e8 8b f0 ff ff       	call   8071f1 <memp_free>
    pcb = NULL;
  808166:	bb 00 00 00 00       	mov    $0x0,%ebx
    break;
  80816b:	83 c4 10             	add    $0x10,%esp
  80816e:	e9 b4 00 00 00       	jmp    808227 <tcp_close+0x13e>
  case LISTEN:
    err = ERR_OK;
  808173:	be 00 00 00 00       	mov    $0x0,%esi
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  808178:	83 ec 08             	sub    $0x8,%esp
  80817b:	53                   	push   %ebx
  80817c:	68 70 e6 b3 00       	push   $0xb3e670
  808181:	e8 db 0e 00 00       	call   809061 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  808186:	83 c4 08             	add    $0x8,%esp
  808189:	53                   	push   %ebx
  80818a:	6a 03                	push   $0x3
  80818c:	e8 60 f0 ff ff       	call   8071f1 <memp_free>
    pcb = NULL;
  808191:	bb 00 00 00 00       	mov    $0x0,%ebx
    break;
  808196:	83 c4 10             	add    $0x10,%esp
  808199:	e9 89 00 00 00       	jmp    808227 <tcp_close+0x13e>
  case SYN_SENT:
    err = ERR_OK;
  80819e:	be 00 00 00 00       	mov    $0x0,%esi
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  8081a3:	83 ec 08             	sub    $0x8,%esp
  8081a6:	53                   	push   %ebx
  8081a7:	68 68 e6 b3 00       	push   $0xb3e668
  8081ac:	e8 b0 0e 00 00       	call   809061 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  8081b1:	83 c4 08             	add    $0x8,%esp
  8081b4:	53                   	push   %ebx
  8081b5:	6a 02                	push   $0x2
  8081b7:	e8 35 f0 ff ff       	call   8071f1 <memp_free>
    pcb = NULL;
  8081bc:	bb 00 00 00 00       	mov    $0x0,%ebx
    snmp_inc_tcpattemptfails();
    break;
  8081c1:	83 c4 10             	add    $0x10,%esp
  8081c4:	eb 61                	jmp    808227 <tcp_close+0x13e>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8081c6:	83 ec 08             	sub    $0x8,%esp
  8081c9:	6a 01                	push   $0x1
  8081cb:	53                   	push   %ebx
  8081cc:	e8 f7 24 00 00       	call   80a6c8 <tcp_send_ctrl>
  8081d1:	89 c6                	mov    %eax,%esi
    if (err == ERR_OK) {
  8081d3:	83 c4 10             	add    $0x10,%esp
  8081d6:	84 c0                	test   %al,%al
  8081d8:	75 4d                	jne    808227 <tcp_close+0x13e>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  8081da:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
    }
    break;
  8081e1:	eb 44                	jmp    808227 <tcp_close+0x13e>
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8081e3:	83 ec 08             	sub    $0x8,%esp
  8081e6:	6a 01                	push   $0x1
  8081e8:	53                   	push   %ebx
  8081e9:	e8 da 24 00 00       	call   80a6c8 <tcp_send_ctrl>
  8081ee:	89 c6                	mov    %eax,%esi
    if (err == ERR_OK) {
  8081f0:	83 c4 10             	add    $0x10,%esp
  8081f3:	84 c0                	test   %al,%al
  8081f5:	75 30                	jne    808227 <tcp_close+0x13e>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  8081f7:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
    }
    break;
  8081fe:	eb 27                	jmp    808227 <tcp_close+0x13e>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  808200:	83 ec 08             	sub    $0x8,%esp
  808203:	6a 01                	push   $0x1
  808205:	53                   	push   %ebx
  808206:	e8 bd 24 00 00       	call   80a6c8 <tcp_send_ctrl>
  80820b:	89 c6                	mov    %eax,%esi
    if (err == ERR_OK) {
  80820d:	83 c4 10             	add    $0x10,%esp
  808210:	84 c0                	test   %al,%al
  808212:	75 13                	jne    808227 <tcp_close+0x13e>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  808214:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
    }
    break;
  80821b:	eb 0a                	jmp    808227 <tcp_close+0x13e>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
  80821d:	be 00 00 00 00       	mov    $0x0,%esi
    pcb = NULL;
  808222:	bb 00 00 00 00       	mov    $0x0,%ebx
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  808227:	85 db                	test   %ebx,%ebx
  808229:	74 12                	je     80823d <tcp_close+0x154>
  80822b:	89 f0                	mov    %esi,%eax
  80822d:	84 c0                	test   %al,%al
  80822f:	75 0c                	jne    80823d <tcp_close+0x154>
    /* To ensure all data has been sent when tcp_close returns, we have
       to make sure tcp_output doesn't fail.
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  808231:	83 ec 0c             	sub    $0xc,%esp
  808234:	53                   	push   %ebx
  808235:	e8 78 2b 00 00       	call   80adb2 <tcp_output>
  80823a:	83 c4 10             	add    $0x10,%esp
  }
  return err;
  80823d:	89 f2                	mov    %esi,%edx
  80823f:	0f be c2             	movsbl %dl,%eax
}
  808242:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  808245:	5b                   	pop    %ebx
  808246:	5e                   	pop    %esi
  808247:	c9                   	leave  
  808248:	c3                   	ret    

00808249 <tcp_abort>:

/**
 * Aborts a connection by sending a RST to the remote host and deletes
 * the local protocol control block. This is done when a connection is
 * killed because of shortage of memory.
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  808249:	55                   	push   %ebp
  80824a:	89 e5                	mov    %esp,%ebp
  80824c:	57                   	push   %edi
  80824d:	56                   	push   %esi
  80824e:	53                   	push   %ebx
  80824f:	83 ec 1c             	sub    $0x1c,%esp
  808252:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u32_t seqno, ackno;
  u16_t remote_port, local_port;
  struct ip_addr remote_ip, local_ip;
#if LWIP_CALLBACK_API  
  void (* errf)(void *arg, err_t err);
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  808255:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  808259:	75 21                	jne    80827c <tcp_abort+0x33>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  80825b:	83 ec 08             	sub    $0x8,%esp
  80825e:	53                   	push   %ebx
  80825f:	68 7c e6 b3 00       	push   $0xb3e67c
  808264:	e8 f8 0d 00 00       	call   809061 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  808269:	83 c4 08             	add    $0x8,%esp
  80826c:	53                   	push   %ebx
  80826d:	6a 02                	push   $0x2
  80826f:	e8 7d ef ff ff       	call   8071f1 <memp_free>
  808274:	83 c4 10             	add    $0x10,%esp
  808277:	e9 d0 00 00 00       	jmp    80834c <tcp_abort+0x103>
  } else {
    seqno = pcb->snd_nxt;
  80827c:	8b 43 54             	mov    0x54(%ebx),%eax
  80827f:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
    ackno = pcb->rcv_nxt;
  808282:	8b 43 24             	mov    0x24(%ebx),%eax
  808285:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
    ip_addr_set(&local_ip, &(pcb->local_ip));
  808288:	b8 00 00 00 00       	mov    $0x0,%eax
  80828d:	85 db                	test   %ebx,%ebx
  80828f:	74 02                	je     808293 <tcp_abort+0x4a>
  808291:	8b 03                	mov    (%ebx),%eax
  808293:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  808296:	b8 00 00 00 00       	mov    $0x0,%eax
  80829b:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80829e:	74 03                	je     8082a3 <tcp_abort+0x5a>
  8082a0:	8b 43 04             	mov    0x4(%ebx),%eax
  8082a3:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    local_port = pcb->local_port;
  8082a6:	66 8b 43 1c          	mov    0x1c(%ebx),%ax
  8082aa:	66 89 45 e2          	mov    %ax,0xffffffe2(%ebp)
    remote_port = pcb->remote_port;
  8082ae:	66 8b 7b 1e          	mov    0x1e(%ebx),%di
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  8082b2:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  8082b8:	8b 43 18             	mov    0x18(%ebx),%eax
  8082bb:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  8082be:	83 ec 08             	sub    $0x8,%esp
  8082c1:	53                   	push   %ebx
  8082c2:	68 68 e6 b3 00       	push   $0xb3e668
  8082c7:	e8 95 0d 00 00       	call   809061 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  8082cc:	83 c4 10             	add    $0x10,%esp
  8082cf:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  8082d3:	74 0e                	je     8082e3 <tcp_abort+0x9a>
      tcp_segs_free(pcb->unacked);
  8082d5:	83 ec 0c             	sub    $0xc,%esp
  8082d8:	ff 73 78             	pushl  0x78(%ebx)
  8082db:	e8 e4 09 00 00       	call   808cc4 <tcp_segs_free>
  8082e0:	83 c4 10             	add    $0x10,%esp
    }
    if (pcb->unsent != NULL) {
  8082e3:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  8082e7:	74 0e                	je     8082f7 <tcp_abort+0xae>
      tcp_segs_free(pcb->unsent);
  8082e9:	83 ec 0c             	sub    $0xc,%esp
  8082ec:	ff 73 74             	pushl  0x74(%ebx)
  8082ef:	e8 d0 09 00 00       	call   808cc4 <tcp_segs_free>
  8082f4:	83 c4 10             	add    $0x10,%esp
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  8082f7:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  8082fb:	74 0e                	je     80830b <tcp_abort+0xc2>
      tcp_segs_free(pcb->ooseq);
  8082fd:	83 ec 0c             	sub    $0xc,%esp
  808300:	ff 73 7c             	pushl  0x7c(%ebx)
  808303:	e8 bc 09 00 00       	call   808cc4 <tcp_segs_free>
  808308:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  80830b:	83 ec 08             	sub    $0x8,%esp
  80830e:	53                   	push   %ebx
  80830f:	6a 02                	push   $0x2
  808311:	e8 db ee ff ff       	call   8071f1 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  808316:	83 c4 10             	add    $0x10,%esp
  808319:	85 f6                	test   %esi,%esi
  80831b:	74 0d                	je     80832a <tcp_abort+0xe1>
  80831d:	83 ec 08             	sub    $0x8,%esp
  808320:	6a fb                	push   $0xfffffffb
  808322:	ff 75 dc             	pushl  0xffffffdc(%ebp)
  808325:	ff d6                	call   *%esi
  808327:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  80832a:	83 ec 08             	sub    $0x8,%esp
  80832d:	0f b7 c7             	movzwl %di,%eax
  808330:	50                   	push   %eax
  808331:	0f b7 45 e2          	movzwl 0xffffffe2(%ebp),%eax
  808335:	50                   	push   %eax
  808336:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  808339:	50                   	push   %eax
  80833a:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  80833d:	50                   	push   %eax
  80833e:	ff 75 e4             	pushl  0xffffffe4(%ebp)
  808341:	ff 75 e8             	pushl  0xffffffe8(%ebp)
  808344:	e8 19 2f 00 00       	call   80b262 <tcp_rst>
  808349:	83 c4 20             	add    $0x20,%esp
  }
}
  80834c:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80834f:	5b                   	pop    %ebx
  808350:	5e                   	pop    %esi
  808351:	5f                   	pop    %edi
  808352:	c9                   	leave  
  808353:	c3                   	ret    

00808354 <tcp_bind>:

/**
 * Binds the connection to a local portnumber and IP address. If the
 * IP address is not given (i.e., ipaddr == NULL), the IP address of
 * the outgoing network interface is used instead.
 *
 * @param pcb the tcp_pcb to bind (no check is done whether this pcb is
 *        already bound!)
 * @param ipaddr the local ip address to bind to (use IP_ADDR_ANY to bind
 *        to any local address
 * @param port the local port to bind to
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808354:	55                   	push   %ebp
  808355:	89 e5                	mov    %esp,%ebp
  808357:	56                   	push   %esi
  808358:	53                   	push   %ebx
  808359:	8b 75 08             	mov    0x8(%ebp),%esi
  80835c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80835f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  808362:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  808366:	74 21                	je     808389 <tcp_bind+0x35>
  808368:	83 ec 04             	sub    $0x4,%esp
  80836b:	68 70 30 81 00       	push   $0x813070
  808370:	68 05 01 00 00       	push   $0x105
  808375:	68 52 32 81 00       	push   $0x813252
  80837a:	e8 4d 87 ff ff       	call   800acc <_panic>

  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80837f:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  808384:	e9 fe 00 00 00       	jmp    808487 <tcp_bind+0x133>
  808389:	66 85 c9             	test   %cx,%cx
  80838c:	75 07                	jne    808395 <tcp_bind+0x41>
  80838e:	e8 81 02 00 00       	call   808614 <tcp_new_port>
  808393:	89 c1                	mov    %eax,%ecx
  808395:	8b 15 70 e6 b3 00    	mov    0xb3e670,%edx
  80839b:	85 d2                	test   %edx,%edx
  80839d:	74 2f                	je     8083ce <tcp_bind+0x7a>
  80839f:	66 39 4a 1c          	cmp    %cx,0x1c(%edx)
  8083a3:	75 22                	jne    8083c7 <tcp_bind+0x73>
  8083a5:	85 d2                	test   %edx,%edx
  8083a7:	74 14                	je     8083bd <tcp_bind+0x69>
  8083a9:	83 3a 00             	cmpl   $0x0,(%edx)
  8083ac:	74 0f                	je     8083bd <tcp_bind+0x69>
  8083ae:	85 db                	test   %ebx,%ebx
  8083b0:	74 0b                	je     8083bd <tcp_bind+0x69>
  8083b2:	83 3b 00             	cmpl   $0x0,(%ebx)
  8083b5:	74 06                	je     8083bd <tcp_bind+0x69>
  8083b7:	8b 02                	mov    (%edx),%eax
  8083b9:	3b 03                	cmp    (%ebx),%eax
  8083bb:	75 0a                	jne    8083c7 <tcp_bind+0x73>
  8083bd:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8083c2:	e9 c0 00 00 00       	jmp    808487 <tcp_bind+0x133>
  8083c7:	8b 52 0c             	mov    0xc(%edx),%edx
  8083ca:	85 d2                	test   %edx,%edx
  8083cc:	75 d1                	jne    80839f <tcp_bind+0x4b>
  8083ce:	8b 15 68 e6 b3 00    	mov    0xb3e668,%edx
  8083d4:	85 d2                	test   %edx,%edx
  8083d6:	74 2f                	je     808407 <tcp_bind+0xb3>
  8083d8:	66 39 4a 1c          	cmp    %cx,0x1c(%edx)
  8083dc:	75 22                	jne    808400 <tcp_bind+0xac>
  8083de:	85 d2                	test   %edx,%edx
  8083e0:	74 14                	je     8083f6 <tcp_bind+0xa2>
  8083e2:	83 3a 00             	cmpl   $0x0,(%edx)
  8083e5:	74 0f                	je     8083f6 <tcp_bind+0xa2>
  8083e7:	85 db                	test   %ebx,%ebx
  8083e9:	74 0b                	je     8083f6 <tcp_bind+0xa2>
  8083eb:	83 3b 00             	cmpl   $0x0,(%ebx)
  8083ee:	74 06                	je     8083f6 <tcp_bind+0xa2>
  8083f0:	8b 02                	mov    (%edx),%eax
  8083f2:	3b 03                	cmp    (%ebx),%eax
  8083f4:	75 0a                	jne    808400 <tcp_bind+0xac>
  8083f6:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8083fb:	e9 87 00 00 00       	jmp    808487 <tcp_bind+0x133>
  808400:	8b 52 0c             	mov    0xc(%edx),%edx
  808403:	85 d2                	test   %edx,%edx
  808405:	75 d1                	jne    8083d8 <tcp_bind+0x84>
  808407:	8b 15 78 e6 b3 00    	mov    0xb3e678,%edx
  80840d:	85 d2                	test   %edx,%edx
  80840f:	74 2c                	je     80843d <tcp_bind+0xe9>
  808411:	66 39 4a 1c          	cmp    %cx,0x1c(%edx)
  808415:	75 1f                	jne    808436 <tcp_bind+0xe2>
  808417:	85 d2                	test   %edx,%edx
  808419:	74 14                	je     80842f <tcp_bind+0xdb>
  80841b:	83 3a 00             	cmpl   $0x0,(%edx)
  80841e:	74 0f                	je     80842f <tcp_bind+0xdb>
  808420:	85 db                	test   %ebx,%ebx
  808422:	74 0b                	je     80842f <tcp_bind+0xdb>
  808424:	83 3b 00             	cmpl   $0x0,(%ebx)
  808427:	74 06                	je     80842f <tcp_bind+0xdb>
  808429:	8b 02                	mov    (%edx),%eax
  80842b:	3b 03                	cmp    (%ebx),%eax
  80842d:	75 07                	jne    808436 <tcp_bind+0xe2>
  80842f:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  808434:	eb 51                	jmp    808487 <tcp_bind+0x133>
  808436:	8b 52 0c             	mov    0xc(%edx),%edx
  808439:	85 d2                	test   %edx,%edx
  80843b:	75 d4                	jne    808411 <tcp_bind+0xbd>
  80843d:	8b 15 7c e6 b3 00    	mov    0xb3e67c,%edx
  808443:	85 d2                	test   %edx,%edx
  808445:	74 17                	je     80845e <tcp_bind+0x10a>
  808447:	66 39 4a 1c          	cmp    %cx,0x1c(%edx)
  80844b:	75 0a                	jne    808457 <tcp_bind+0x103>
  80844d:	8b 02                	mov    (%edx),%eax
  80844f:	3b 03                	cmp    (%ebx),%eax
  808451:	0f 84 28 ff ff ff    	je     80837f <tcp_bind+0x2b>
  808457:	8b 52 0c             	mov    0xc(%edx),%edx
  80845a:	85 d2                	test   %edx,%edx
  80845c:	75 e9                	jne    808447 <tcp_bind+0xf3>
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  80845e:	85 db                	test   %ebx,%ebx
  808460:	74 09                	je     80846b <tcp_bind+0x117>
  808462:	83 3b 00             	cmpl   $0x0,(%ebx)
  808465:	74 04                	je     80846b <tcp_bind+0x117>
    pcb->local_ip = *ipaddr;
  808467:	8b 03                	mov    (%ebx),%eax
  808469:	89 06                	mov    %eax,(%esi)
  }
  pcb->local_port = port;
  80846b:	66 89 4e 1c          	mov    %cx,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  80846f:	a1 78 e6 b3 00       	mov    0xb3e678,%eax
  808474:	89 46 0c             	mov    %eax,0xc(%esi)
  808477:	89 35 78 e6 b3 00    	mov    %esi,0xb3e678
  80847d:	e8 cc c6 ff ff       	call   804b4e <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  808482:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808487:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80848a:	5b                   	pop    %ebx
  80848b:	5e                   	pop    %esi
  80848c:	c9                   	leave  
  80848d:	c3                   	ret    

0080848e <tcp_accept_null>:
#if LWIP_CALLBACK_API
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80848e:	55                   	push   %ebp
  80848f:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  808491:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  808496:	c9                   	leave  
  808497:	c3                   	ret    

00808498 <tcp_listen_with_backlog>:
#endif /* LWIP_CALLBACK_API */

/**
 * Set the state of the connection to be LISTEN, which means that it
 * is able to accept incoming connections. The protocol control block
 * is reallocated in order to consume less memory. Setting the
 * connection to LISTEN is an irreversible process.
 *
 * @param pcb the original tcp_pcb
 * @param backlog the incoming connections queue limit
 * @return tcp_pcb used for listening, consumes less memory.
 *
 * @note The original tcp_pcb is freed. This function therefore has to be
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  808498:	55                   	push   %ebp
  808499:	89 e5                	mov    %esp,%ebp
  80849b:	56                   	push   %esi
  80849c:	53                   	push   %ebx
  80849d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  8084a0:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8084a4:	74 17                	je     8084bd <tcp_listen_with_backlog+0x25>
  8084a6:	83 ec 04             	sub    $0x4,%esp
  8084a9:	68 9c 30 81 00       	push   $0x81309c
  8084ae:	68 60 01 00 00       	push   $0x160
  8084b3:	68 52 32 81 00       	push   $0x813252
  8084b8:	e8 0f 86 ff ff       	call   800acc <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  8084bd:	89 d8                	mov    %ebx,%eax
  8084bf:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  8084c3:	0f 84 d0 00 00 00    	je     808599 <tcp_listen_with_backlog+0x101>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  8084c9:	83 ec 0c             	sub    $0xc,%esp
  8084cc:	6a 03                	push   $0x3
  8084ce:	e8 c4 ec ff ff       	call   807197 <memp_malloc>
  8084d3:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  8084d5:	83 c4 10             	add    $0x10,%esp
    return NULL;
  8084d8:	b8 00 00 00 00       	mov    $0x0,%eax
  8084dd:	85 f6                	test   %esi,%esi
  8084df:	0f 84 b4 00 00 00    	je     808599 <tcp_listen_with_backlog+0x101>
  }
  lpcb->callback_arg = pcb->callback_arg;
  8084e5:	8b 43 18             	mov    0x18(%ebx),%eax
  8084e8:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  8084eb:	66 8b 43 1c          	mov    0x1c(%ebx),%ax
  8084ef:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  8084f3:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  8084fa:	66 8b 43 08          	mov    0x8(%ebx),%ax
  8084fe:	83 c8 02             	or     $0x2,%eax
  808501:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  808505:	8a 43 0b             	mov    0xb(%ebx),%al
  808508:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  80850b:	8a 43 0a             	mov    0xa(%ebx),%al
  80850e:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  808511:	b8 00 00 00 00       	mov    $0x0,%eax
  808516:	85 db                	test   %ebx,%ebx
  808518:	74 02                	je     80851c <tcp_listen_with_backlog+0x84>
  80851a:	8b 03                	mov    (%ebx),%eax
  80851c:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80851e:	39 1d 78 e6 b3 00    	cmp    %ebx,0xb3e678
  808524:	75 12                	jne    808538 <tcp_listen_with_backlog+0xa0>
  808526:	8b 43 0c             	mov    0xc(%ebx),%eax
  808529:	a3 78 e6 b3 00       	mov    %eax,0xb3e678
  80852e:	eb 38                	jmp    808568 <tcp_listen_with_backlog+0xd0>
  808530:	8b 43 0c             	mov    0xc(%ebx),%eax
  808533:	89 42 0c             	mov    %eax,0xc(%edx)
  808536:	eb 30                	jmp    808568 <tcp_listen_with_backlog+0xd0>
  808538:	a1 78 e6 b3 00       	mov    0xb3e678,%eax
  80853d:	a3 74 e6 b3 00       	mov    %eax,0xb3e674
  808542:	85 c0                	test   %eax,%eax
  808544:	74 22                	je     808568 <tcp_listen_with_backlog+0xd0>
  808546:	8b 15 74 e6 b3 00    	mov    0xb3e674,%edx
  80854c:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  808550:	74 05                	je     808557 <tcp_listen_with_backlog+0xbf>
  808552:	39 5a 0c             	cmp    %ebx,0xc(%edx)
  808555:	74 d9                	je     808530 <tcp_listen_with_backlog+0x98>
  808557:	a1 74 e6 b3 00       	mov    0xb3e674,%eax
  80855c:	8b 40 0c             	mov    0xc(%eax),%eax
  80855f:	a3 74 e6 b3 00       	mov    %eax,0xb3e674
  808564:	85 c0                	test   %eax,%eax
  808566:	75 de                	jne    808546 <tcp_listen_with_backlog+0xae>
  808568:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  80856f:	83 ec 08             	sub    $0x8,%esp
  808572:	53                   	push   %ebx
  808573:	6a 02                	push   $0x2
  808575:	e8 77 ec ff ff       	call   8071f1 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  80857a:	c7 46 20 8e 84 80 00 	movl   $0x80848e,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  808581:	a1 70 e6 b3 00       	mov    0xb3e670,%eax
  808586:	89 46 0c             	mov    %eax,0xc(%esi)
  808589:	89 35 70 e6 b3 00    	mov    %esi,0xb3e670
  80858f:	e8 ba c5 ff ff       	call   804b4e <tcp_timer_needed>
  808594:	83 c4 10             	add    $0x10,%esp
  return (struct tcp_pcb *)lpcb;
  808597:	89 f0                	mov    %esi,%eax
}
  808599:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80859c:	5b                   	pop    %ebx
  80859d:	5e                   	pop    %esi
  80859e:	c9                   	leave  
  80859f:	c3                   	ret    

008085a0 <tcp_recved>:

/**
 * This function should be called by the application when it has
 * processed the data. The purpose is to advertise a larger window
 * when the data has been processed.
 *
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  8085a0:	55                   	push   %ebp
  8085a1:	89 e5                	mov    %esp,%ebp
  8085a3:	53                   	push   %ebx
  8085a4:	83 ec 04             	sub    $0x4,%esp
  8085a7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8085aa:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  8085ad:	0f b7 41 28          	movzwl 0x28(%ecx),%eax
  8085b1:	0f b7 d3             	movzwl %bx,%edx
  8085b4:	01 d0                	add    %edx,%eax
  8085b6:	3d c0 5d 00 00       	cmp    $0x5dc0,%eax
  8085bb:	76 0e                	jbe    8085cb <tcp_recved+0x2b>
    pcb->rcv_wnd = TCP_WND;
  8085bd:	66 c7 41 28 c0 5d    	movw   $0x5dc0,0x28(%ecx)
    pcb->rcv_ann_wnd = TCP_WND;
  8085c3:	66 c7 41 2a c0 5d    	movw   $0x5dc0,0x2a(%ecx)
  8085c9:	eb 14                	jmp    8085df <tcp_recved+0x3f>
  } else {
    pcb->rcv_wnd += len;
  8085cb:	89 d8                	mov    %ebx,%eax
  8085cd:	66 03 41 28          	add    0x28(%ecx),%ax
  8085d1:	66 89 41 28          	mov    %ax,0x28(%ecx)
    if (pcb->rcv_wnd >= pcb->mss) {
  8085d5:	66 3b 41 34          	cmp    0x34(%ecx),%ax
  8085d9:	72 04                	jb     8085df <tcp_recved+0x3f>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  8085db:	66 89 41 2a          	mov    %ax,0x2a(%ecx)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  8085df:	0f b6 41 20          	movzbl 0x20(%ecx),%eax
  8085e3:	a8 01                	test   $0x1,%al
  8085e5:	75 0a                	jne    8085f1 <tcp_recved+0x51>
  8085e7:	a8 02                	test   $0x2,%al
  8085e9:	75 06                	jne    8085f1 <tcp_recved+0x51>
     !(pcb->flags & TF_ACK_NOW)) {
    /*
     * We send an ACK here (if one is not already pending, hence
     * the above tests) as tcp_recved() implies that the application
     * has processed some data, and so we can open the receiver's
     * window to allow more to be transmitted.  This could result in
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  8085eb:	80 49 20 01          	orb    $0x1,0x20(%ecx)
  8085ef:	eb 1e                	jmp    80860f <tcp_recved+0x6f>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  8085f1:	f6 41 20 01          	testb  $0x1,0x20(%ecx)
  8085f5:	74 18                	je     80860f <tcp_recved+0x6f>
  8085f7:	66 81 79 28 df 2e    	cmpw   $0x2edf,0x28(%ecx)
  8085fd:	76 10                	jbe    80860f <tcp_recved+0x6f>
    /* If we can send a window update such that there is a full
     * segment available in the window, do so now.  This is sort of
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  8085ff:	80 49 20 02          	orb    $0x2,0x20(%ecx)
  808603:	83 ec 0c             	sub    $0xc,%esp
  808606:	51                   	push   %ecx
  808607:	e8 a6 27 00 00       	call   80adb2 <tcp_output>
  80860c:	83 c4 10             	add    $0x10,%esp
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  80860f:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  808612:	c9                   	leave  
  808613:	c3                   	ret    

00808614 <tcp_new_port>:

/**
 * A nastly hack featuring 'goto' statements that allocates a
 * new TCP local port.
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  808614:	55                   	push   %ebp
  808615:	89 e5                	mov    %esp,%ebp
  struct tcp_pcb *pcb;
#ifndef TCP_LOCAL_PORT_RANGE_START
#define TCP_LOCAL_PORT_RANGE_START 4096
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  808617:	66 ff 05 f8 80 81 00 	incw   0x8180f8
  80861e:	66 83 3d f8 80 81 00 	cmpw   $0x0,0x8180f8
  808625:	00 
  808626:	79 09                	jns    808631 <tcp_new_port+0x1d>
    port = TCP_LOCAL_PORT_RANGE_START;
  808628:	66 c7 05 f8 80 81 00 	movw   $0x1000,0x8180f8
  80862f:	00 10 
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808631:	8b 15 68 e6 b3 00    	mov    0xb3e668,%edx
  808637:	85 d2                	test   %edx,%edx
  808639:	74 14                	je     80864f <tcp_new_port+0x3b>
    if (pcb->local_port == port) {
  80863b:	66 8b 42 1c          	mov    0x1c(%edx),%ax
  80863f:	66 3b 05 f8 80 81 00 	cmp    0x8180f8,%ax
  808646:	74 cf                	je     808617 <tcp_new_port+0x3>
  808648:	8b 52 0c             	mov    0xc(%edx),%edx
  80864b:	85 d2                	test   %edx,%edx
  80864d:	75 ec                	jne    80863b <tcp_new_port+0x27>
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80864f:	8b 15 7c e6 b3 00    	mov    0xb3e67c,%edx
  808655:	85 d2                	test   %edx,%edx
  808657:	74 14                	je     80866d <tcp_new_port+0x59>
    if (pcb->local_port == port) {
  808659:	66 8b 42 1c          	mov    0x1c(%edx),%ax
  80865d:	66 3b 05 f8 80 81 00 	cmp    0x8180f8,%ax
  808664:	74 b1                	je     808617 <tcp_new_port+0x3>
  808666:	8b 52 0c             	mov    0xc(%edx),%edx
  808669:	85 d2                	test   %edx,%edx
  80866b:	75 ec                	jne    808659 <tcp_new_port+0x45>
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80866d:	8b 15 70 e6 b3 00    	mov    0xb3e670,%edx
  808673:	85 d2                	test   %edx,%edx
  808675:	74 14                	je     80868b <tcp_new_port+0x77>
    if (pcb->local_port == port) {
  808677:	66 8b 42 1c          	mov    0x1c(%edx),%ax
  80867b:	66 3b 05 f8 80 81 00 	cmp    0x8180f8,%ax
  808682:	74 93                	je     808617 <tcp_new_port+0x3>
  808684:	8b 52 0c             	mov    0xc(%edx),%edx
  808687:	85 d2                	test   %edx,%edx
  808689:	75 ec                	jne    808677 <tcp_new_port+0x63>
      goto again;
    }
  }
  return port;
  80868b:	0f b7 05 f8 80 81 00 	movzwl 0x8180f8,%eax
}
  808692:	c9                   	leave  
  808693:	c3                   	ret    

00808694 <tcp_connect>:

/**
 * Connects to another host. The function given as the "connected"
 * argument will be called when the connection has been established.
 *
 * @param pcb the tcp_pcb used to establish the connection
 * @param ipaddr the remote ip address to connect to
 * @param port the remote tcp port to connect to
 * @param connected callback function to call when connected (or on error)
 * @return ERR_VAL if invalid arguments are given
 *         ERR_OK if connect request has been sent
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  808694:	55                   	push   %ebp
  808695:	89 e5                	mov    %esp,%ebp
  808697:	56                   	push   %esi
  808698:	53                   	push   %ebx
  808699:	83 ec 10             	sub    $0x10,%esp
  80869c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80869f:	8b 75 0c             	mov    0xc(%ebp),%esi
  8086a2:	8b 55 10             	mov    0x10(%ebp),%edx
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8086a5:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8086a9:	74 17                	je     8086c2 <tcp_connect+0x2e>
  8086ab:	83 ec 04             	sub    $0x4,%esp
  8086ae:	68 c0 30 81 00       	push   $0x8130c0
  8086b3:	68 ec 01 00 00       	push   $0x1ec
  8086b8:	68 52 32 81 00       	push   $0x813252
  8086bd:	e8 0a 84 ff ff       	call   800acc <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  8086c2:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8086c7:	85 f6                	test   %esi,%esi
  8086c9:	0f 84 23 01 00 00    	je     8087f2 <tcp_connect+0x15e>
  8086cf:	8b 06                	mov    (%esi),%eax
  8086d1:	89 43 04             	mov    %eax,0x4(%ebx)
  }
  pcb->remote_port = port;
  8086d4:	66 89 53 1e          	mov    %dx,0x1e(%ebx)
  if (pcb->local_port == 0) {
  8086d8:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  8086dd:	75 09                	jne    8086e8 <tcp_connect+0x54>
    pcb->local_port = tcp_new_port();
  8086df:	e8 30 ff ff ff       	call   808614 <tcp_new_port>
  8086e4:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  8086e8:	e8 5f 0a 00 00       	call   80914c <tcp_next_iss>
  pcb->rcv_nxt = 0;
  8086ed:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  8086f4:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  8086f7:	48                   	dec    %eax
  8086f8:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  8086fb:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  8086fe:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  808704:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  80870a:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  808710:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  808716:	83 ec 08             	sub    $0x8,%esp
  808719:	56                   	push   %esi
  80871a:	68 18 02 00 00       	push   $0x218
  80871f:	e8 3d 0a 00 00       	call   809161 <tcp_eff_send_mss>
  808724:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  808728:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  80872e:	0f b7 c0             	movzwl %ax,%eax
  808731:	8d 04 80             	lea    (%eax,%eax,4),%eax
  808734:	d1 e0                	shl    %eax
  808736:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  80873a:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  808741:	8b 45 14             	mov    0x14(%ebp),%eax
  808744:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80874a:	83 c4 10             	add    $0x10,%esp
  80874d:	39 1d 78 e6 b3 00    	cmp    %ebx,0xb3e678
  808753:	75 12                	jne    808767 <tcp_connect+0xd3>
  808755:	8b 43 0c             	mov    0xc(%ebx),%eax
  808758:	a3 78 e6 b3 00       	mov    %eax,0xb3e678
  80875d:	eb 38                	jmp    808797 <tcp_connect+0x103>
  80875f:	8b 43 0c             	mov    0xc(%ebx),%eax
  808762:	89 42 0c             	mov    %eax,0xc(%edx)
  808765:	eb 30                	jmp    808797 <tcp_connect+0x103>
  808767:	a1 78 e6 b3 00       	mov    0xb3e678,%eax
  80876c:	a3 74 e6 b3 00       	mov    %eax,0xb3e674
  808771:	85 c0                	test   %eax,%eax
  808773:	74 22                	je     808797 <tcp_connect+0x103>
  808775:	8b 15 74 e6 b3 00    	mov    0xb3e674,%edx
  80877b:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  80877f:	74 05                	je     808786 <tcp_connect+0xf2>
  808781:	39 5a 0c             	cmp    %ebx,0xc(%edx)
  808784:	74 d9                	je     80875f <tcp_connect+0xcb>
  808786:	a1 74 e6 b3 00       	mov    0xb3e674,%eax
  80878b:	8b 40 0c             	mov    0xc(%eax),%eax
  80878e:	a3 74 e6 b3 00       	mov    %eax,0xb3e674
  808793:	85 c0                	test   %eax,%eax
  808795:	75 de                	jne    808775 <tcp_connect+0xe1>
  808797:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  TCP_REG(&tcp_active_pcbs, pcb);
  80879e:	a1 68 e6 b3 00       	mov    0xb3e668,%eax
  8087a3:	89 43 0c             	mov    %eax,0xc(%ebx)
  8087a6:	89 1d 68 e6 b3 00    	mov    %ebx,0xb3e668
  8087ac:	e8 9d c3 ff ff       	call   804b4e <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  8087b1:	83 ec 0c             	sub    $0xc,%esp
  8087b4:	68 b4 05 04 02       	push   $0x20405b4
  8087b9:	e8 cc 1e 00 00       	call   80a68a <htonl>
  8087be:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  8087c1:	83 c4 0c             	add    $0xc,%esp
  8087c4:	6a 04                	push   $0x4
  8087c6:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  8087c9:	50                   	push   %eax
  8087ca:	6a 00                	push   $0x0
  8087cc:	6a 02                	push   $0x2
  8087ce:	6a 00                	push   $0x0
  8087d0:	6a 00                	push   $0x0
  8087d2:	53                   	push   %ebx
  8087d3:	e8 6b 1f 00 00       	call   80a743 <tcp_enqueue>
  8087d8:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  8087da:	83 c4 20             	add    $0x20,%esp
  8087dd:	84 c0                	test   %al,%al
  8087df:	75 0c                	jne    8087ed <tcp_connect+0x159>
    tcp_output(pcb);
  8087e1:	83 ec 0c             	sub    $0xc,%esp
  8087e4:	53                   	push   %ebx
  8087e5:	e8 c8 25 00 00       	call   80adb2 <tcp_output>
  8087ea:	83 c4 10             	add    $0x10,%esp
  }
  return ret;
  8087ed:	89 f2                	mov    %esi,%edx
  8087ef:	0f be c2             	movsbl %dl,%eax
} 
  8087f2:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  8087f5:	5b                   	pop    %ebx
  8087f6:	5e                   	pop    %esi
  8087f7:	c9                   	leave  
  8087f8:	c3                   	ret    

008087f9 <tcp_slowtmr>:

/**
 * Called every 500 ms and implements the retransmission timer and the timer that
 * removes PCBs that have been in TIME-WAIT for enough time. It also increments
 * various timers such as the inactivity timer in each PCB.
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  8087f9:	55                   	push   %ebp
  8087fa:	89 e5                	mov    %esp,%ebp
  8087fc:	57                   	push   %edi
  8087fd:	56                   	push   %esi
  8087fe:	53                   	push   %ebx
  8087ff:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  808802:	c6 45 f3 00          	movb   $0x0,0xfffffff3(%ebp)

  ++tcp_ticks;
  808806:	ff 05 6c e6 b3 00    	incl   0xb3e66c

  /* Steps through all of the active PCBs. */
  prev = NULL;
  80880c:	bf 00 00 00 00       	mov    $0x0,%edi
  pcb = tcp_active_pcbs;
  808811:	8b 1d 68 e6 b3 00    	mov    0xb3e668,%ebx
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
          pcb->persist_cnt = 0;
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
            pcb->persist_backoff++;
          }
          tcp_zero_window_probe(pcb);
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
          ++pcb->rtime;

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
          /* Time for a retransmission. */
          LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %"S16_F
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
          if (pcb->ssthresh < pcb->mss) {
            pcb->ssthresh = pcb->mss * 2;
          }
          pcb->cwnd = pcb->mss;
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"U16_F
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
      if ((u32_t)(tcp_ticks - pcb->tmr) >
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
       ((pcb->state == ESTABLISHED) || 
        (pcb->state == CLOSE_WAIT))) {
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
      }
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
        pcb->keep_cnt_sent++;
      }
    }

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
      pcb->ooseq = NULL;
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
      if ((u32_t)(tcp_ticks - pcb->tmr) >
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      tcp_pcb_purge(pcb);      
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);

      pcb2 = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb);
      pcb = pcb2;
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
      if (pcb->polltmr >= pcb->pollinterval) {
        pcb->polltmr = 0;
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
        if (err == ERR_OK) {
          tcp_output(pcb);
        }
      }
      
      prev = pcb;
      pcb = pcb->next;
  808817:	85 db                	test   %ebx,%ebx
  808819:	0f 84 3d 03 00 00    	je     808b5c <tcp_slowtmr+0x363>
  80881f:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  808823:	75 17                	jne    80883c <tcp_slowtmr+0x43>
  808825:	83 ec 04             	sub    $0x4,%esp
  808828:	68 f4 30 81 00       	push   $0x8130f4
  80882d:	68 36 02 00 00       	push   $0x236
  808832:	68 52 32 81 00       	push   $0x813252
  808837:	e8 90 82 ff ff       	call   800acc <_panic>
  80883c:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  808840:	75 17                	jne    808859 <tcp_slowtmr+0x60>
  808842:	83 ec 04             	sub    $0x4,%esp
  808845:	68 20 31 81 00       	push   $0x813120
  80884a:	68 37 02 00 00       	push   $0x237
  80884f:	68 52 32 81 00       	push   $0x813252
  808854:	e8 73 82 ff ff       	call   800acc <_panic>
  808859:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80885d:	75 17                	jne    808876 <tcp_slowtmr+0x7d>
  80885f:	83 ec 04             	sub    $0x4,%esp
  808862:	68 4c 31 81 00       	push   $0x81314c
  808867:	68 38 02 00 00       	push   $0x238
  80886c:	68 52 32 81 00       	push   $0x813252
  808871:	e8 56 82 ff ff       	call   800acc <_panic>
  808876:	be 00 00 00 00       	mov    $0x0,%esi
  80887b:	83 7b 10 02          	cmpl   $0x2,0x10(%ebx)
  80887f:	75 10                	jne    808891 <tcp_slowtmr+0x98>
  808881:	80 7b 46 06          	cmpb   $0x6,0x46(%ebx)
  808885:	75 0a                	jne    808891 <tcp_slowtmr+0x98>
  808887:	be 01 00 00 00       	mov    $0x1,%esi
  80888c:	e9 df 00 00 00       	jmp    808970 <tcp_slowtmr+0x177>
  808891:	80 7b 46 0c          	cmpb   $0xc,0x46(%ebx)
  808895:	75 06                	jne    80889d <tcp_slowtmr+0xa4>
  808897:	46                   	inc    %esi
  808898:	e9 d3 00 00 00       	jmp    808970 <tcp_slowtmr+0x177>
  80889d:	80 bb a4 00 00 00 00 	cmpb   $0x0,0xa4(%ebx)
  8088a4:	74 4a                	je     8088f0 <tcp_slowtmr+0xf7>
  8088a6:	ff 83 a0 00 00 00    	incl   0xa0(%ebx)
  8088ac:	0f b6 83 a4 00 00 00 	movzbl 0xa4(%ebx),%eax
  8088b3:	0f b6 80 48 30 81 00 	movzbl 0x813048(%eax),%eax
  8088ba:	39 83 a0 00 00 00    	cmp    %eax,0xa0(%ebx)
  8088c0:	0f 82 aa 00 00 00    	jb     808970 <tcp_slowtmr+0x177>
  8088c6:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  8088cd:	00 00 00 
  8088d0:	80 bb a4 00 00 00 06 	cmpb   $0x6,0xa4(%ebx)
  8088d7:	77 06                	ja     8088df <tcp_slowtmr+0xe6>
  8088d9:	fe 83 a4 00 00 00    	incb   0xa4(%ebx)
  8088df:	83 ec 0c             	sub    $0xc,%esp
  8088e2:	53                   	push   %ebx
  8088e3:	e8 75 2c 00 00       	call   80b55d <tcp_zero_window_probe>
  8088e8:	83 c4 10             	add    $0x10,%esp
  8088eb:	e9 80 00 00 00       	jmp    808970 <tcp_slowtmr+0x177>
  8088f0:	66 83 7b 32 00       	cmpw   $0x0,0x32(%ebx)
  8088f5:	78 04                	js     8088fb <tcp_slowtmr+0x102>
  8088f7:	66 ff 43 32          	incw   0x32(%ebx)
  8088fb:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  8088ff:	74 6f                	je     808970 <tcp_slowtmr+0x177>
  808901:	66 8b 43 32          	mov    0x32(%ebx),%ax
  808905:	66 3b 43 44          	cmp    0x44(%ebx),%ax
  808909:	7c 65                	jl     808970 <tcp_slowtmr+0x177>
  80890b:	83 7b 10 02          	cmpl   $0x2,0x10(%ebx)
  80890f:	74 20                	je     808931 <tcp_slowtmr+0x138>
  808911:	66 8b 43 40          	mov    0x40(%ebx),%ax
  808915:	66 c1 f8 03          	sar    $0x3,%ax
  808919:	98                   	cwtl   
  80891a:	0f bf 53 42          	movswl 0x42(%ebx),%edx
  80891e:	01 d0                	add    %edx,%eax
  808920:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  808924:	0f b6 8a 3c 30 81 00 	movzbl 0x81303c(%edx),%ecx
  80892b:	d3 e0                	shl    %cl,%eax
  80892d:	66 89 43 44          	mov    %ax,0x44(%ebx)
  808931:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
  808937:	66 8b 43 5c          	mov    0x5c(%ebx),%ax
  80893b:	66 3b 43 4e          	cmp    0x4e(%ebx),%ax
  80893f:	76 04                	jbe    808945 <tcp_slowtmr+0x14c>
  808941:	66 8b 43 4e          	mov    0x4e(%ebx),%ax
  808945:	66 d1 e8             	shr    %ax
  808948:	66 89 43 50          	mov    %ax,0x50(%ebx)
  80894c:	66 3b 43 34          	cmp    0x34(%ebx),%ax
  808950:	73 0a                	jae    80895c <tcp_slowtmr+0x163>
  808952:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  808956:	d1 e0                	shl    %eax
  808958:	66 89 43 50          	mov    %ax,0x50(%ebx)
  80895c:	66 8b 43 34          	mov    0x34(%ebx),%ax
  808960:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  808964:	83 ec 0c             	sub    $0xc,%esp
  808967:	53                   	push   %ebx
  808968:	e8 1d 2a 00 00       	call   80b38a <tcp_rexmit_rto>
  80896d:	83 c4 10             	add    $0x10,%esp
  808970:	83 7b 10 06          	cmpl   $0x6,0x10(%ebx)
  808974:	75 11                	jne    808987 <tcp_slowtmr+0x18e>
  808976:	a1 6c e6 b3 00       	mov    0xb3e66c,%eax
  80897b:	2b 43 2c             	sub    0x2c(%ebx),%eax
  80897e:	83 f8 29             	cmp    $0x29,%eax
  808981:	89 f0                	mov    %esi,%eax
  808983:	1c ff                	sbb    $0xff,%al
  808985:	89 c6                	mov    %eax,%esi
  808987:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  80898b:	0f 84 88 00 00 00    	je     808a19 <tcp_slowtmr+0x220>
  808991:	83 7b 10 04          	cmpl   $0x4,0x10(%ebx)
  808995:	74 06                	je     80899d <tcp_slowtmr+0x1a4>
  808997:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  80899b:	75 7c                	jne    808a19 <tcp_slowtmr+0x220>
  80899d:	8b 0d 6c e6 b3 00    	mov    0xb3e66c,%ecx
  8089a3:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
  8089a6:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
  8089ac:	81 c2 b8 4c 0a 00    	add    $0xa4cb8,%edx
  8089b2:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  8089b7:	f7 e2                	mul    %edx
  8089b9:	89 d0                	mov    %edx,%eax
  8089bb:	c1 e8 05             	shr    $0x5,%eax
  8089be:	39 c1                	cmp    %eax,%ecx
  8089c0:	76 0e                	jbe    8089d0 <tcp_slowtmr+0x1d7>
  8089c2:	83 ec 0c             	sub    $0xc,%esp
  8089c5:	53                   	push   %ebx
  8089c6:	e8 7e f8 ff ff       	call   808249 <tcp_abort>
  8089cb:	83 c4 10             	add    $0x10,%esp
  8089ce:	eb 49                	jmp    808a19 <tcp_slowtmr+0x220>
  8089d0:	8b 0d 6c e6 b3 00    	mov    0xb3e66c,%ecx
  8089d6:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
  8089d9:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  8089e0:	8d 04 d2             	lea    (%edx,%edx,8),%eax
  8089e3:	8d 04 c2             	lea    (%edx,%eax,8),%eax
  8089e6:	8d 04 82             	lea    (%edx,%eax,4),%eax
  8089e9:	c1 e0 05             	shl    $0x5,%eax
  8089ec:	29 d0                	sub    %edx,%eax
  8089ee:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
  8089f4:	8d 04 c2             	lea    (%edx,%eax,8),%eax
  8089f7:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8089fc:	f7 e2                	mul    %edx
  8089fe:	89 d0                	mov    %edx,%eax
  808a00:	c1 e8 05             	shr    $0x5,%eax
  808a03:	39 c1                	cmp    %eax,%ecx
  808a05:	76 12                	jbe    808a19 <tcp_slowtmr+0x220>
  808a07:	83 ec 0c             	sub    $0xc,%esp
  808a0a:	53                   	push   %ebx
  808a0b:	e8 1e 2a 00 00       	call   80b42e <tcp_keepalive>
  808a10:	fe 83 a5 00 00 00    	incb   0xa5(%ebx)
  808a16:	83 c4 10             	add    $0x10,%esp
  808a19:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  808a1d:	74 2b                	je     808a4a <tcp_slowtmr+0x251>
  808a1f:	8b 15 6c e6 b3 00    	mov    0xb3e66c,%edx
  808a25:	2b 53 2c             	sub    0x2c(%ebx),%edx
  808a28:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  808a2c:	8d 04 40             	lea    (%eax,%eax,2),%eax
  808a2f:	d1 e0                	shl    %eax
  808a31:	39 c2                	cmp    %eax,%edx
  808a33:	72 15                	jb     808a4a <tcp_slowtmr+0x251>
  808a35:	83 ec 0c             	sub    $0xc,%esp
  808a38:	ff 73 7c             	pushl  0x7c(%ebx)
  808a3b:	e8 84 02 00 00       	call   808cc4 <tcp_segs_free>
  808a40:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
  808a47:	83 c4 10             	add    $0x10,%esp
  808a4a:	83 7b 10 03          	cmpl   $0x3,0x10(%ebx)
  808a4e:	75 11                	jne    808a61 <tcp_slowtmr+0x268>
  808a50:	a1 6c e6 b3 00       	mov    0xb3e66c,%eax
  808a55:	2b 43 2c             	sub    0x2c(%ebx),%eax
  808a58:	83 f8 29             	cmp    $0x29,%eax
  808a5b:	89 f0                	mov    %esi,%eax
  808a5d:	1c ff                	sbb    $0xff,%al
  808a5f:	89 c6                	mov    %eax,%esi
  808a61:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  808a65:	75 13                	jne    808a7a <tcp_slowtmr+0x281>
  808a67:	a1 6c e6 b3 00       	mov    0xb3e66c,%eax
  808a6c:	2b 43 2c             	sub    0x2c(%ebx),%eax
  808a6f:	3d f1 00 00 00       	cmp    $0xf1,%eax
  808a74:	89 f0                	mov    %esi,%eax
  808a76:	1c ff                	sbb    $0xff,%al
  808a78:	89 c6                	mov    %eax,%esi
  808a7a:	89 f0                	mov    %esi,%eax
  808a7c:	84 c0                	test   %al,%al
  808a7e:	0f 84 8d 00 00 00    	je     808b11 <tcp_slowtmr+0x318>
  808a84:	83 ec 0c             	sub    $0xc,%esp
  808a87:	53                   	push   %ebx
  808a88:	e8 50 05 00 00       	call   808fdd <tcp_pcb_purge>
  808a8d:	83 c4 10             	add    $0x10,%esp
  808a90:	85 ff                	test   %edi,%edi
  808a92:	74 27                	je     808abb <tcp_slowtmr+0x2c2>
  808a94:	3b 1d 68 e6 b3 00    	cmp    0xb3e668,%ebx
  808a9a:	75 17                	jne    808ab3 <tcp_slowtmr+0x2ba>
  808a9c:	83 ec 04             	sub    $0x4,%esp
  808a9f:	68 7c 31 81 00       	push   $0x81317c
  808aa4:	68 c1 02 00 00       	push   $0x2c1
  808aa9:	68 52 32 81 00       	push   $0x813252
  808aae:	e8 19 80 ff ff       	call   800acc <_panic>
  808ab3:	8b 43 0c             	mov    0xc(%ebx),%eax
  808ab6:	89 47 0c             	mov    %eax,0xc(%edi)
  808ab9:	eb 27                	jmp    808ae2 <tcp_slowtmr+0x2e9>
  808abb:	39 1d 68 e6 b3 00    	cmp    %ebx,0xb3e668
  808ac1:	74 17                	je     808ada <tcp_slowtmr+0x2e1>
  808ac3:	83 ec 04             	sub    $0x4,%esp
  808ac6:	68 a8 31 81 00       	push   $0x8131a8
  808acb:	68 c5 02 00 00       	push   $0x2c5
  808ad0:	68 52 32 81 00       	push   $0x813252
  808ad5:	e8 f2 7f ff ff       	call   800acc <_panic>
  808ada:	8b 43 0c             	mov    0xc(%ebx),%eax
  808add:	a3 68 e6 b3 00       	mov    %eax,0xb3e668
  808ae2:	83 bb 98 00 00 00 00 	cmpl   $0x0,0x98(%ebx)
  808ae9:	74 11                	je     808afc <tcp_slowtmr+0x303>
  808aeb:	83 ec 08             	sub    $0x8,%esp
  808aee:	6a fb                	push   $0xfffffffb
  808af0:	ff 73 18             	pushl  0x18(%ebx)
  808af3:	ff 93 98 00 00 00    	call   *0x98(%ebx)
  808af9:	83 c4 10             	add    $0x10,%esp
  808afc:	8b 73 0c             	mov    0xc(%ebx),%esi
  808aff:	83 ec 08             	sub    $0x8,%esp
  808b02:	53                   	push   %ebx
  808b03:	6a 02                	push   $0x2
  808b05:	e8 e7 e6 ff ff       	call   8071f1 <memp_free>
  808b0a:	89 f3                	mov    %esi,%ebx
  808b0c:	83 c4 10             	add    $0x10,%esp
  808b0f:	eb 43                	jmp    808b54 <tcp_slowtmr+0x35b>
  808b11:	8a 43 30             	mov    0x30(%ebx),%al
  808b14:	40                   	inc    %eax
  808b15:	88 43 30             	mov    %al,0x30(%ebx)
  808b18:	3a 43 31             	cmp    0x31(%ebx),%al
  808b1b:	72 32                	jb     808b4f <tcp_slowtmr+0x356>
  808b1d:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
  808b21:	83 bb 94 00 00 00 00 	cmpl   $0x0,0x94(%ebx)
  808b28:	74 13                	je     808b3d <tcp_slowtmr+0x344>
  808b2a:	83 ec 08             	sub    $0x8,%esp
  808b2d:	53                   	push   %ebx
  808b2e:	ff 73 18             	pushl  0x18(%ebx)
  808b31:	ff 93 94 00 00 00    	call   *0x94(%ebx)
  808b37:	88 45 f3             	mov    %al,0xfffffff3(%ebp)
  808b3a:	83 c4 10             	add    $0x10,%esp
  808b3d:	80 7d f3 00          	cmpb   $0x0,0xfffffff3(%ebp)
  808b41:	75 0c                	jne    808b4f <tcp_slowtmr+0x356>
  808b43:	83 ec 0c             	sub    $0xc,%esp
  808b46:	53                   	push   %ebx
  808b47:	e8 66 22 00 00       	call   80adb2 <tcp_output>
  808b4c:	83 c4 10             	add    $0x10,%esp
  808b4f:	89 df                	mov    %ebx,%edi
  808b51:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808b54:	85 db                	test   %ebx,%ebx
  808b56:	0f 85 c3 fc ff ff    	jne    80881f <tcp_slowtmr+0x26>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  808b5c:	bf 00 00 00 00       	mov    $0x0,%edi
  pcb = tcp_tw_pcbs;
  808b61:	8b 1d 7c e6 b3 00    	mov    0xb3e67c,%ebx
  while (pcb != NULL) {
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
      ++pcb_remove;
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      tcp_pcb_purge(pcb);      
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
      }
      pcb2 = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb);
      pcb = pcb2;
    } else {
      prev = pcb;
      pcb = pcb->next;
  808b67:	85 db                	test   %ebx,%ebx
  808b69:	0f 84 bc 00 00 00    	je     808c2b <tcp_slowtmr+0x432>
  808b6f:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  808b73:	74 17                	je     808b8c <tcp_slowtmr+0x393>
  808b75:	83 ec 04             	sub    $0x4,%esp
  808b78:	68 d4 31 81 00       	push   $0x8131d4
  808b7d:	68 e5 02 00 00       	push   $0x2e5
  808b82:	68 52 32 81 00       	push   $0x813252
  808b87:	e8 40 7f ff ff       	call   800acc <_panic>
  808b8c:	be 00 00 00 00       	mov    $0x0,%esi
  808b91:	a1 6c e6 b3 00       	mov    0xb3e66c,%eax
  808b96:	2b 43 2c             	sub    0x2c(%ebx),%eax
  808b99:	3d f0 00 00 00       	cmp    $0xf0,%eax
  808b9e:	76 05                	jbe    808ba5 <tcp_slowtmr+0x3ac>
  808ba0:	be 01 00 00 00       	mov    $0x1,%esi
  808ba5:	89 f0                	mov    %esi,%eax
  808ba7:	84 c0                	test   %al,%al
  808ba9:	74 73                	je     808c1e <tcp_slowtmr+0x425>
  808bab:	83 ec 0c             	sub    $0xc,%esp
  808bae:	53                   	push   %ebx
  808baf:	e8 29 04 00 00       	call   808fdd <tcp_pcb_purge>
  808bb4:	83 c4 10             	add    $0x10,%esp
  808bb7:	85 ff                	test   %edi,%edi
  808bb9:	74 27                	je     808be2 <tcp_slowtmr+0x3e9>
  808bbb:	3b 1d 7c e6 b3 00    	cmp    0xb3e67c,%ebx
  808bc1:	75 17                	jne    808bda <tcp_slowtmr+0x3e1>
  808bc3:	83 ec 04             	sub    $0x4,%esp
  808bc6:	68 04 32 81 00       	push   $0x813204
  808bcb:	68 f4 02 00 00       	push   $0x2f4
  808bd0:	68 52 32 81 00       	push   $0x813252
  808bd5:	e8 f2 7e ff ff       	call   800acc <_panic>
  808bda:	8b 43 0c             	mov    0xc(%ebx),%eax
  808bdd:	89 47 0c             	mov    %eax,0xc(%edi)
  808be0:	eb 27                	jmp    808c09 <tcp_slowtmr+0x410>
  808be2:	39 1d 7c e6 b3 00    	cmp    %ebx,0xb3e67c
  808be8:	74 17                	je     808c01 <tcp_slowtmr+0x408>
  808bea:	83 ec 04             	sub    $0x4,%esp
  808bed:	68 2c 32 81 00       	push   $0x81322c
  808bf2:	68 f8 02 00 00       	push   $0x2f8
  808bf7:	68 52 32 81 00       	push   $0x813252
  808bfc:	e8 cb 7e ff ff       	call   800acc <_panic>
  808c01:	8b 43 0c             	mov    0xc(%ebx),%eax
  808c04:	a3 7c e6 b3 00       	mov    %eax,0xb3e67c
  808c09:	8b 73 0c             	mov    0xc(%ebx),%esi
  808c0c:	83 ec 08             	sub    $0x8,%esp
  808c0f:	53                   	push   %ebx
  808c10:	6a 02                	push   $0x2
  808c12:	e8 da e5 ff ff       	call   8071f1 <memp_free>
  808c17:	89 f3                	mov    %esi,%ebx
  808c19:	83 c4 10             	add    $0x10,%esp
  808c1c:	eb 05                	jmp    808c23 <tcp_slowtmr+0x42a>
  808c1e:	89 df                	mov    %ebx,%edi
  808c20:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808c23:	85 db                	test   %ebx,%ebx
  808c25:	0f 85 44 ff ff ff    	jne    808b6f <tcp_slowtmr+0x376>
    }
  }
}
  808c2b:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  808c2e:	5b                   	pop    %ebx
  808c2f:	5e                   	pop    %esi
  808c30:	5f                   	pop    %edi
  808c31:	c9                   	leave  
  808c32:	c3                   	ret    

00808c33 <tcp_fasttmr>:

/**
 * Is called every TCP_FAST_INTERVAL (250 ms) and process data previously
 * "refused" by upper layer (application) and sends delayed ACKs.
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  808c33:	55                   	push   %ebp
  808c34:	89 e5                	mov    %esp,%ebp
  808c36:	56                   	push   %esi
  808c37:	53                   	push   %ebx
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808c38:	8b 1d 68 e6 b3 00    	mov    0xb3e668,%ebx
  808c3e:	85 db                	test   %ebx,%ebx
  808c40:	74 7b                	je     808cbd <tcp_fasttmr+0x8a>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  808c42:	83 bb 80 00 00 00 00 	cmpl   $0x0,0x80(%ebx)
  808c49:	74 51                	je     808c9c <tcp_fasttmr+0x69>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  808c4b:	83 bb 88 00 00 00 00 	cmpl   $0x0,0x88(%ebx)
  808c52:	74 19                	je     808c6d <tcp_fasttmr+0x3a>
  808c54:	6a 00                	push   $0x0
  808c56:	ff b3 80 00 00 00    	pushl  0x80(%ebx)
  808c5c:	53                   	push   %ebx
  808c5d:	ff 73 18             	pushl  0x18(%ebx)
  808c60:	ff 93 88 00 00 00    	call   *0x88(%ebx)
  808c66:	89 c6                	mov    %eax,%esi
  808c68:	83 c4 10             	add    $0x10,%esp
  808c6b:	eb 1f                	jmp    808c8c <tcp_fasttmr+0x59>
  808c6d:	be 00 00 00 00       	mov    $0x0,%esi
  808c72:	83 bb 80 00 00 00 00 	cmpl   $0x0,0x80(%ebx)
  808c79:	74 11                	je     808c8c <tcp_fasttmr+0x59>
  808c7b:	83 ec 0c             	sub    $0xc,%esp
  808c7e:	ff b3 80 00 00 00    	pushl  0x80(%ebx)
  808c84:	e8 90 ec ff ff       	call   807919 <pbuf_free>
  808c89:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
  808c8c:	89 f0                	mov    %esi,%eax
  808c8e:	84 c0                	test   %al,%al
  808c90:	75 0a                	jne    808c9c <tcp_fasttmr+0x69>
        pcb->refused_data = NULL;
  808c92:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  808c99:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  808c9c:	f6 43 20 01          	testb  $0x1,0x20(%ebx)
  808ca0:	74 14                	je     808cb6 <tcp_fasttmr+0x83>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  808ca2:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  808ca6:	83 ec 0c             	sub    $0xc,%esp
  808ca9:	53                   	push   %ebx
  808caa:	e8 03 21 00 00       	call   80adb2 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  808caf:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
  808cb3:	83 c4 10             	add    $0x10,%esp
  808cb6:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808cb9:	85 db                	test   %ebx,%ebx
  808cbb:	75 85                	jne    808c42 <tcp_fasttmr+0xf>
    }
  }
}
  808cbd:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  808cc0:	5b                   	pop    %ebx
  808cc1:	5e                   	pop    %esi
  808cc2:	c9                   	leave  
  808cc3:	c3                   	ret    

00808cc4 <tcp_segs_free>:

/**
 * Deallocates a list of TCP segments (tcp_seg structures).
 *
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  808cc4:	55                   	push   %ebp
  808cc5:	89 e5                	mov    %esp,%ebp
  808cc7:	56                   	push   %esi
  808cc8:	53                   	push   %ebx
  808cc9:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  808ccc:	be 00 00 00 00       	mov    $0x0,%esi
  struct tcp_seg *next;
  while (seg != NULL) {
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  808cd1:	85 c0                	test   %eax,%eax
  808cd3:	74 16                	je     808ceb <tcp_segs_free+0x27>
  808cd5:	8b 18                	mov    (%eax),%ebx
  808cd7:	83 ec 0c             	sub    $0xc,%esp
  808cda:	50                   	push   %eax
  808cdb:	e8 17 00 00 00       	call   808cf7 <tcp_seg_free>
  808ce0:	01 c6                	add    %eax,%esi
  808ce2:	89 d8                	mov    %ebx,%eax
  808ce4:	83 c4 10             	add    $0x10,%esp
  808ce7:	85 db                	test   %ebx,%ebx
  808ce9:	75 ea                	jne    808cd5 <tcp_segs_free+0x11>
  }
  return count;
  808ceb:	89 f2                	mov    %esi,%edx
  808ced:	0f b6 c2             	movzbl %dl,%eax
}
  808cf0:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  808cf3:	5b                   	pop    %ebx
  808cf4:	5e                   	pop    %esi
  808cf5:	c9                   	leave  
  808cf6:	c3                   	ret    

00808cf7 <tcp_seg_free>:

/**
 * Frees a TCP segment (tcp_seg structure).
 *
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  808cf7:	55                   	push   %ebp
  808cf8:	89 e5                	mov    %esp,%ebp
  808cfa:	56                   	push   %esi
  808cfb:	53                   	push   %ebx
  808cfc:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  808cff:	be 00 00 00 00       	mov    $0x0,%esi
  
  if (seg != NULL) {
  808d04:	85 db                	test   %ebx,%ebx
  808d06:	74 24                	je     808d2c <tcp_seg_free+0x35>
    if (seg->p != NULL) {
  808d08:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  808d0c:	74 10                	je     808d1e <tcp_seg_free+0x27>
      count = pbuf_free(seg->p);
  808d0e:	83 ec 0c             	sub    $0xc,%esp
  808d11:	ff 73 04             	pushl  0x4(%ebx)
  808d14:	e8 00 ec ff ff       	call   807919 <pbuf_free>
  808d19:	89 c6                	mov    %eax,%esi
  808d1b:	83 c4 10             	add    $0x10,%esp
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  808d1e:	83 ec 08             	sub    $0x8,%esp
  808d21:	53                   	push   %ebx
  808d22:	6a 04                	push   $0x4
  808d24:	e8 c8 e4 ff ff       	call   8071f1 <memp_free>
  808d29:	83 c4 10             	add    $0x10,%esp
  }
  return count;
  808d2c:	89 f2                	mov    %esi,%edx
  808d2e:	0f b6 c2             	movzbl %dl,%eax
}
  808d31:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  808d34:	5b                   	pop    %ebx
  808d35:	5e                   	pop    %esi
  808d36:	c9                   	leave  
  808d37:	c3                   	ret    

00808d38 <tcp_setprio>:

/**
 * Sets the priority of a connection.
 *
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  808d38:	55                   	push   %ebp
  808d39:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  808d3b:	8b 55 0c             	mov    0xc(%ebp),%edx
  808d3e:	8b 45 08             	mov    0x8(%ebp),%eax
  808d41:	88 50 14             	mov    %dl,0x14(%eax)
}
  808d44:	c9                   	leave  
  808d45:	c3                   	ret    

00808d46 <tcp_seg_copy>:
#if TCP_QUEUE_OOSEQ

/**
 * Returns a copy of the given TCP segment.
 * The pbuf and data are not copied, only the pointers
 *
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  808d46:	55                   	push   %ebp
  808d47:	89 e5                	mov    %esp,%ebp
  808d49:	53                   	push   %ebx
  808d4a:	83 ec 10             	sub    $0x10,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  808d4d:	6a 04                	push   $0x4
  808d4f:	e8 43 e4 ff ff       	call   807197 <memp_malloc>
  808d54:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  808d56:	83 c4 10             	add    $0x10,%esp
    return NULL;
  808d59:	b8 00 00 00 00       	mov    $0x0,%eax
  808d5e:	85 db                	test   %ebx,%ebx
  808d60:	74 1b                	je     808d7d <tcp_seg_copy+0x37>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  808d62:	83 ec 04             	sub    $0x4,%esp
  808d65:	6a 14                	push   $0x14
  808d67:	ff 75 08             	pushl  0x8(%ebp)
  808d6a:	53                   	push   %ebx
  808d6b:	e8 37 86 ff ff       	call   8013a7 <memcpy>
  pbuf_ref(cseg->p);
  808d70:	83 c4 04             	add    $0x4,%esp
  808d73:	ff 73 04             	pushl  0x4(%ebx)
  808d76:	e8 85 ec ff ff       	call   807a00 <pbuf_ref>
  return cseg;
  808d7b:	89 d8                	mov    %ebx,%eax
}
  808d7d:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  808d80:	c9                   	leave  
  808d81:	c3                   	ret    

00808d82 <tcp_recv_null>:
#endif

#if LWIP_CALLBACK_API
/**
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  808d82:	55                   	push   %ebp
  808d83:	89 e5                	mov    %esp,%ebp
  808d85:	83 ec 08             	sub    $0x8,%esp
  808d88:	8b 55 10             	mov    0x10(%ebp),%edx
  808d8b:	8a 45 14             	mov    0x14(%ebp),%al
  arg = arg;
  if (p != NULL) {
  808d8e:	85 d2                	test   %edx,%edx
  808d90:	74 0e                	je     808da0 <tcp_recv_null+0x1e>
    pbuf_free(p);
  808d92:	83 ec 0c             	sub    $0xc,%esp
  808d95:	52                   	push   %edx
  808d96:	e8 7e eb ff ff       	call   807919 <pbuf_free>
  808d9b:	83 c4 10             	add    $0x10,%esp
  808d9e:	eb 14                	jmp    808db4 <tcp_recv_null+0x32>
  } else if (err == ERR_OK) {
  808da0:	84 c0                	test   %al,%al
  808da2:	75 10                	jne    808db4 <tcp_recv_null+0x32>
    return tcp_close(pcb);
  808da4:	83 ec 0c             	sub    $0xc,%esp
  808da7:	ff 75 0c             	pushl  0xc(%ebp)
  808daa:	e8 3a f3 ff ff       	call   8080e9 <tcp_close>
  808daf:	0f be c0             	movsbl %al,%eax
  808db2:	eb 05                	jmp    808db9 <tcp_recv_null+0x37>
  }
  return ERR_OK;
  808db4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808db9:	c9                   	leave  
  808dba:	c3                   	ret    

00808dbb <tcp_kill_prio>:
#endif /* LWIP_CALLBACK_API */

/**
 * Kills the oldest active connection that has lower priority than prio.
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
  808dbb:	55                   	push   %ebp
  808dbc:	89 e5                	mov    %esp,%ebp
  808dbe:	57                   	push   %edi
  808dbf:	56                   	push   %esi
  808dc0:	53                   	push   %ebx
  808dc1:	83 ec 0c             	sub    $0xc,%esp
  808dc4:	8a 4d 08             	mov    0x8(%ebp),%cl
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  808dc7:	bf 7f 00 00 00       	mov    $0x7f,%edi
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  808dcc:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  inactive = NULL;
  808dd3:	bb 00 00 00 00       	mov    $0x0,%ebx
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808dd8:	a1 68 e6 b3 00       	mov    0xb3e668,%eax
  808ddd:	85 c0                	test   %eax,%eax
  808ddf:	74 2c                	je     808e0d <tcp_kill_prio+0x52>
  808de1:	8b 35 6c e6 b3 00    	mov    0xb3e66c,%esi
    if (pcb->prio <= prio &&
  808de7:	38 48 14             	cmp    %cl,0x14(%eax)
  808dea:	77 1a                	ja     808e06 <tcp_kill_prio+0x4b>
  808dec:	89 fa                	mov    %edi,%edx
  808dee:	38 50 14             	cmp    %dl,0x14(%eax)
  808df1:	77 13                	ja     808e06 <tcp_kill_prio+0x4b>
  808df3:	89 f2                	mov    %esi,%edx
  808df5:	2b 50 2c             	sub    0x2c(%eax),%edx
  808df8:	3b 55 f0             	cmp    0xfffffff0(%ebp),%edx
  808dfb:	72 09                	jb     808e06 <tcp_kill_prio+0x4b>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  808dfd:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
      inactive = pcb;
  808e00:	89 c3                	mov    %eax,%ebx
      mprio = pcb->prio;
  808e02:	0f b6 78 14          	movzbl 0x14(%eax),%edi
  808e06:	8b 40 0c             	mov    0xc(%eax),%eax
  808e09:	85 c0                	test   %eax,%eax
  808e0b:	75 da                	jne    808de7 <tcp_kill_prio+0x2c>
    }
  }
  if (inactive != NULL) {
  808e0d:	85 db                	test   %ebx,%ebx
  808e0f:	74 0c                	je     808e1d <tcp_kill_prio+0x62>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  808e11:	83 ec 0c             	sub    $0xc,%esp
  808e14:	53                   	push   %ebx
  808e15:	e8 2f f4 ff ff       	call   808249 <tcp_abort>
  808e1a:	83 c4 10             	add    $0x10,%esp
  }      
}
  808e1d:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  808e20:	5b                   	pop    %ebx
  808e21:	5e                   	pop    %esi
  808e22:	5f                   	pop    %edi
  808e23:	c9                   	leave  
  808e24:	c3                   	ret    

00808e25 <tcp_kill_timewait>:

/**
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
  808e25:	55                   	push   %ebp
  808e26:	89 e5                	mov    %esp,%ebp
  808e28:	56                   	push   %esi
  808e29:	53                   	push   %ebx
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  808e2a:	bb 00 00 00 00       	mov    $0x0,%ebx
  inactive = NULL;
  808e2f:	be 00 00 00 00       	mov    $0x0,%esi
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808e34:	a1 7c e6 b3 00       	mov    0xb3e67c,%eax
  808e39:	85 c0                	test   %eax,%eax
  808e3b:	74 1a                	je     808e57 <tcp_kill_timewait+0x32>
  808e3d:	8b 0d 6c e6 b3 00    	mov    0xb3e66c,%ecx
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  808e43:	89 ca                	mov    %ecx,%edx
  808e45:	2b 50 2c             	sub    0x2c(%eax),%edx
  808e48:	39 da                	cmp    %ebx,%edx
  808e4a:	72 04                	jb     808e50 <tcp_kill_timewait+0x2b>
      inactivity = tcp_ticks - pcb->tmr;
  808e4c:	89 d3                	mov    %edx,%ebx
      inactive = pcb;
  808e4e:	89 c6                	mov    %eax,%esi
  808e50:	8b 40 0c             	mov    0xc(%eax),%eax
  808e53:	85 c0                	test   %eax,%eax
  808e55:	75 ec                	jne    808e43 <tcp_kill_timewait+0x1e>
    }
  }
  if (inactive != NULL) {
  808e57:	85 f6                	test   %esi,%esi
  808e59:	74 0c                	je     808e67 <tcp_kill_timewait+0x42>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  808e5b:	83 ec 0c             	sub    $0xc,%esp
  808e5e:	56                   	push   %esi
  808e5f:	e8 e5 f3 ff ff       	call   808249 <tcp_abort>
  808e64:	83 c4 10             	add    $0x10,%esp
  }      
}
  808e67:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  808e6a:	5b                   	pop    %ebx
  808e6b:	5e                   	pop    %esi
  808e6c:	c9                   	leave  
  808e6d:	c3                   	ret    

00808e6e <tcp_alloc>:

/**
 * Allocate a new tcp_pcb structure.
 *
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  808e6e:	55                   	push   %ebp
  808e6f:	89 e5                	mov    %esp,%ebp
  808e71:	56                   	push   %esi
  808e72:	53                   	push   %ebx
  808e73:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  808e77:	83 ec 0c             	sub    $0xc,%esp
  808e7a:	6a 02                	push   $0x2
  808e7c:	e8 16 e3 ff ff       	call   807197 <memp_malloc>
  808e81:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  808e83:	83 c4 10             	add    $0x10,%esp
  808e86:	85 c0                	test   %eax,%eax
  808e88:	75 3f                	jne    808ec9 <tcp_alloc+0x5b>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
  808e8a:	e8 96 ff ff ff       	call   808e25 <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  808e8f:	83 ec 0c             	sub    $0xc,%esp
  808e92:	6a 02                	push   $0x2
  808e94:	e8 fe e2 ff ff       	call   807197 <memp_malloc>
  808e99:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  808e9b:	83 c4 10             	add    $0x10,%esp
  808e9e:	85 c0                	test   %eax,%eax
  808ea0:	75 27                	jne    808ec9 <tcp_alloc+0x5b>
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
  808ea2:	83 ec 0c             	sub    $0xc,%esp
  808ea5:	89 f2                	mov    %esi,%edx
  808ea7:	0f b6 c2             	movzbl %dl,%eax
  808eaa:	50                   	push   %eax
  808eab:	e8 0b ff ff ff       	call   808dbb <tcp_kill_prio>
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  808eb0:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808eb7:	e8 db e2 ff ff       	call   807197 <memp_malloc>
  808ebc:	89 c3                	mov    %eax,%ebx
  808ebe:	83 c4 10             	add    $0x10,%esp
    }
  }
  if (pcb != NULL) {
  808ec1:	85 c0                	test   %eax,%eax
  808ec3:	0f 84 96 00 00 00    	je     808f5f <tcp_alloc+0xf1>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  808ec9:	83 ec 04             	sub    $0x4,%esp
  808ecc:	68 a8 00 00 00       	push   $0xa8
  808ed1:	6a 00                	push   $0x0
  808ed3:	53                   	push   %ebx
  808ed4:	e8 10 84 ff ff       	call   8012e9 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  808ed9:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  808edd:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  808ee3:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  808ee9:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  808eef:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  808ef5:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  808ef9:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  808efd:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  808f03:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  808f09:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  808f0f:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  808f15:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  808f1b:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  808f21:	e8 26 02 00 00       	call   80914c <tcp_next_iss>
    pcb->snd_wl2 = iss;
  808f26:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  808f29:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  808f2c:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  808f2f:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  808f32:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  808f35:	a1 6c e6 b3 00       	mov    0xb3e66c,%eax
  808f3a:	89 43 2c             	mov    %eax,0x2c(%ebx)

    pcb->polltmr = 0;
  808f3d:	c6 43 30 00          	movb   $0x0,0x30(%ebx)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  808f41:	c7 83 88 00 00 00 82 	movl   $0x808d82,0x88(%ebx)
  808f48:	8d 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  808f4b:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  808f52:	dd 6d 00 
    
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  808f55:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  808f5c:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  808f5f:	89 d8                	mov    %ebx,%eax
  808f61:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  808f64:	5b                   	pop    %ebx
  808f65:	5e                   	pop    %esi
  808f66:	c9                   	leave  
  808f67:	c3                   	ret    

00808f68 <tcp_new>:

/**
 * Creates a new TCP protocol control block but doesn't place it on
 * any of the TCP PCB lists.
 * The pcb is not put on any list until binding using tcp_bind().
 *
 * @internal: Maybe there should be a idle TCP PCB list where these
 * PCBs are put on. Port reservation using tcp_bind() is implemented but
 * allocated pcbs that are not bound can't be killed automatically if wanting
 * to allocate a pcb with higher prio (@see tcp_kill_prio())
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  808f68:	55                   	push   %ebp
  808f69:	89 e5                	mov    %esp,%ebp
  808f6b:	83 ec 14             	sub    $0x14,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  808f6e:	6a 40                	push   $0x40
  808f70:	e8 f9 fe ff ff       	call   808e6e <tcp_alloc>
}
  808f75:	c9                   	leave  
  808f76:	c3                   	ret    

00808f77 <tcp_arg>:

/**
 * Used to specify the argument that should be passed callback
 * functions.
 *
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  808f77:	55                   	push   %ebp
  808f78:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  808f7a:	8b 55 0c             	mov    0xc(%ebp),%edx
  808f7d:	8b 45 08             	mov    0x8(%ebp),%eax
  808f80:	89 50 18             	mov    %edx,0x18(%eax)
}
  808f83:	c9                   	leave  
  808f84:	c3                   	ret    

00808f85 <tcp_recv>:
#if LWIP_CALLBACK_API

/**
 * Used to specify the function that should be called when a TCP
 * connection receives data.
 *
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  808f85:	55                   	push   %ebp
  808f86:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  808f88:	8b 55 0c             	mov    0xc(%ebp),%edx
  808f8b:	8b 45 08             	mov    0x8(%ebp),%eax
  808f8e:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  808f94:	c9                   	leave  
  808f95:	c3                   	ret    

00808f96 <tcp_sent>:

/**
 * Used to specify the function that should be called when TCP data
 * has been successfully delivered to the remote host.
 *
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  808f96:	55                   	push   %ebp
  808f97:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  808f99:	8b 55 0c             	mov    0xc(%ebp),%edx
  808f9c:	8b 45 08             	mov    0x8(%ebp),%eax
  808f9f:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  808fa5:	c9                   	leave  
  808fa6:	c3                   	ret    

00808fa7 <tcp_err>:

/**
 * Used to specify the function that should be called when a fatal error
 * has occured on the connection.
 *
 * @param pcb tcp_pcb to set the err callback
 * @param errf callback function to call for this pcb when a fatal error
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  808fa7:	55                   	push   %ebp
  808fa8:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  808faa:	8b 55 0c             	mov    0xc(%ebp),%edx
  808fad:	8b 45 08             	mov    0x8(%ebp),%eax
  808fb0:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  808fb6:	c9                   	leave  
  808fb7:	c3                   	ret    

00808fb8 <tcp_accept>:

/**
 * Used for specifying the function that should be called when a
 * LISTENing connection has been connected to another host.
 *
 * @param pcb tcp_pcb to set the accept callback
 * @param accept callback function to call for this pcb when LISTENing
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  808fb8:	55                   	push   %ebp
  808fb9:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  808fbb:	8b 55 0c             	mov    0xc(%ebp),%edx
  808fbe:	8b 45 08             	mov    0x8(%ebp),%eax
  808fc1:	89 50 20             	mov    %edx,0x20(%eax)
}
  808fc4:	c9                   	leave  
  808fc5:	c3                   	ret    

00808fc6 <tcp_poll>:
#endif /* LWIP_CALLBACK_API */


/**
 * Used to specify the function that should be called periodically
 * from TCP. The interval is specified in terms of the TCP coarse
 * timer interval, which is called twice a second.
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  808fc6:	55                   	push   %ebp
  808fc7:	89 e5                	mov    %esp,%ebp
  808fc9:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  808fcc:	8b 55 0c             	mov    0xc(%ebp),%edx
  808fcf:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  808fd5:	8b 55 10             	mov    0x10(%ebp),%edx
  808fd8:	88 50 31             	mov    %dl,0x31(%eax)
}
  808fdb:	c9                   	leave  
  808fdc:	c3                   	ret    

00808fdd <tcp_pcb_purge>:

/**
 * Purges a TCP PCB. Removes any buffered data and frees the buffer memory
 * (pcb->ooseq, pcb->unsent and pcb->unacked are freed).
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  808fdd:	55                   	push   %ebp
  808fde:	89 e5                	mov    %esp,%ebp
  808fe0:	53                   	push   %ebx
  808fe1:	83 ec 04             	sub    $0x4,%esp
  808fe4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  808fe7:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  808feb:	74 6f                	je     80905c <tcp_pcb_purge+0x7f>
  808fed:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  808ff1:	74 69                	je     80905c <tcp_pcb_purge+0x7f>
  808ff3:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  808ff7:	74 63                	je     80905c <tcp_pcb_purge+0x7f>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  808ff9:	83 bb 80 00 00 00 00 	cmpl   $0x0,0x80(%ebx)
  809000:	74 1b                	je     80901d <tcp_pcb_purge+0x40>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  809002:	83 ec 0c             	sub    $0xc,%esp
  809005:	ff b3 80 00 00 00    	pushl  0x80(%ebx)
  80900b:	e8 09 e9 ff ff       	call   807919 <pbuf_free>
      pcb->refused_data = NULL;
  809010:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  809017:	00 00 00 
  80901a:	83 c4 10             	add    $0x10,%esp
    }
    if (pcb->unsent != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
    }
    if (pcb->unacked != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
    }
#if TCP_QUEUE_OOSEQ /* LW */
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  80901d:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  809023:	83 ec 0c             	sub    $0xc,%esp
  809026:	ff 73 7c             	pushl  0x7c(%ebx)
  809029:	e8 96 fc ff ff       	call   808cc4 <tcp_segs_free>
    pcb->ooseq = NULL;
  80902e:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  809035:	83 c4 04             	add    $0x4,%esp
  809038:	ff 73 74             	pushl  0x74(%ebx)
  80903b:	e8 84 fc ff ff       	call   808cc4 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  809040:	83 c4 04             	add    $0x4,%esp
  809043:	ff 73 78             	pushl  0x78(%ebx)
  809046:	e8 79 fc ff ff       	call   808cc4 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  80904b:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  809052:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  809059:	83 c4 10             	add    $0x10,%esp
  }
}
  80905c:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80905f:	c9                   	leave  
  809060:	c3                   	ret    

00809061 <tcp_pcb_remove>:

/**
 * Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.
 *
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  809061:	55                   	push   %ebp
  809062:	89 e5                	mov    %esp,%ebp
  809064:	53                   	push   %ebx
  809065:	83 ec 04             	sub    $0x4,%esp
  809068:	8b 55 08             	mov    0x8(%ebp),%edx
  80906b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  80906e:	39 1a                	cmp    %ebx,(%edx)
  809070:	75 0f                	jne    809081 <tcp_pcb_remove+0x20>
  809072:	8b 43 0c             	mov    0xc(%ebx),%eax
  809075:	89 02                	mov    %eax,(%edx)
  809077:	eb 35                	jmp    8090ae <tcp_pcb_remove+0x4d>
  809079:	8b 43 0c             	mov    0xc(%ebx),%eax
  80907c:	89 42 0c             	mov    %eax,0xc(%edx)
  80907f:	eb 2d                	jmp    8090ae <tcp_pcb_remove+0x4d>
  809081:	8b 02                	mov    (%edx),%eax
  809083:	a3 74 e6 b3 00       	mov    %eax,0xb3e674
  809088:	85 c0                	test   %eax,%eax
  80908a:	74 22                	je     8090ae <tcp_pcb_remove+0x4d>
  80908c:	8b 15 74 e6 b3 00    	mov    0xb3e674,%edx
  809092:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  809096:	74 05                	je     80909d <tcp_pcb_remove+0x3c>
  809098:	39 5a 0c             	cmp    %ebx,0xc(%edx)
  80909b:	74 dc                	je     809079 <tcp_pcb_remove+0x18>
  80909d:	a1 74 e6 b3 00       	mov    0xb3e674,%eax
  8090a2:	8b 40 0c             	mov    0xc(%eax),%eax
  8090a5:	a3 74 e6 b3 00       	mov    %eax,0xb3e674
  8090aa:	85 c0                	test   %eax,%eax
  8090ac:	75 de                	jne    80908c <tcp_pcb_remove+0x2b>
  8090ae:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  8090b5:	83 ec 0c             	sub    $0xc,%esp
  8090b8:	53                   	push   %ebx
  8090b9:	e8 1f ff ff ff       	call   808fdd <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  8090be:	83 c4 10             	add    $0x10,%esp
  8090c1:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  8090c5:	74 1c                	je     8090e3 <tcp_pcb_remove+0x82>
  8090c7:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  8090cb:	74 73                	je     809140 <tcp_pcb_remove+0xdf>
  8090cd:	f6 43 20 01          	testb  $0x1,0x20(%ebx)
  8090d1:	74 10                	je     8090e3 <tcp_pcb_remove+0x82>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  8090d3:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
    tcp_output(pcb);
  8090d7:	83 ec 0c             	sub    $0xc,%esp
  8090da:	53                   	push   %ebx
  8090db:	e8 d2 1c 00 00       	call   80adb2 <tcp_output>
  8090e0:	83 c4 10             	add    $0x10,%esp
  }

  if (pcb->state != LISTEN) {
  8090e3:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  8090e7:	74 57                	je     809140 <tcp_pcb_remove+0xdf>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  8090e9:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  8090ed:	74 17                	je     809106 <tcp_pcb_remove+0xa5>
  8090ef:	83 ec 04             	sub    $0x4,%esp
  8090f2:	68 66 32 81 00       	push   $0x813266
  8090f7:	68 b4 04 00 00       	push   $0x4b4
  8090fc:	68 52 32 81 00       	push   $0x813252
  809101:	e8 c6 79 ff ff       	call   800acc <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  809106:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80910a:	74 17                	je     809123 <tcp_pcb_remove+0xc2>
  80910c:	83 ec 04             	sub    $0x4,%esp
  80910f:	68 7e 32 81 00       	push   $0x81327e
  809114:	68 b5 04 00 00       	push   $0x4b5
  809119:	68 52 32 81 00       	push   $0x813252
  80911e:	e8 a9 79 ff ff       	call   800acc <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  809123:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  809127:	74 17                	je     809140 <tcp_pcb_remove+0xdf>
  809129:	83 ec 04             	sub    $0x4,%esp
  80912c:	68 97 32 81 00       	push   $0x813297
  809131:	68 b7 04 00 00       	push   $0x4b7
  809136:	68 52 32 81 00       	push   $0x813252
  80913b:	e8 8c 79 ff ff       	call   800acc <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  809140:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  809147:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80914a:	c9                   	leave  
  80914b:	c3                   	ret    

0080914c <tcp_next_iss>:

/**
 * Calculates a new initial sequence number for new connections.
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  80914c:	55                   	push   %ebp
  80914d:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  80914f:	a1 fc 80 81 00       	mov    0x8180fc,%eax
  809154:	03 05 6c e6 b3 00    	add    0xb3e66c,%eax
  80915a:	a3 fc 80 81 00       	mov    %eax,0x8180fc
  return iss;
}
  80915f:	c9                   	leave  
  809160:	c3                   	ret    

00809161 <tcp_eff_send_mss>:

#if TCP_CALCULATE_EFF_SEND_MSS
/**
 * Calcluates the effective send mss that can be used for a specific IP address
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  809161:	55                   	push   %ebp
  809162:	89 e5                	mov    %esp,%ebp
  809164:	53                   	push   %ebx
  809165:	83 ec 10             	sub    $0x10,%esp
  809168:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  80916b:	ff 75 0c             	pushl  0xc(%ebp)
  80916e:	e8 81 00 00 00       	call   8091f4 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  809173:	83 c4 10             	add    $0x10,%esp
  809176:	85 c0                	test   %eax,%eax
  809178:	74 15                	je     80918f <tcp_eff_send_mss+0x2e>
  80917a:	66 83 78 2c 00       	cmpw   $0x0,0x2c(%eax)
  80917f:	74 0e                	je     80918f <tcp_eff_send_mss+0x2e>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  809181:	66 8b 40 2c          	mov    0x2c(%eax),%ax
  809185:	83 e8 28             	sub    $0x28,%eax
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  809188:	66 39 c3             	cmp    %ax,%bx
  80918b:	76 02                	jbe    80918f <tcp_eff_send_mss+0x2e>
  80918d:	89 c3                	mov    %eax,%ebx
  }
  return sendmss;
  80918f:	0f b7 c3             	movzwl %bx,%eax
}
  809192:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  809195:	c9                   	leave  
  809196:	c3                   	ret    
	...

00809198 <ip_addr_isbroadcast>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  809198:	55                   	push   %ebp
  809199:	89 e5                	mov    %esp,%ebp
  80919b:	53                   	push   %ebx
  80919c:	8b 55 08             	mov    0x8(%ebp),%edx
  80919f:	8b 45 0c             	mov    0xc(%ebp),%eax
  u32_t addr2test;

  addr2test = addr->addr;
  8091a2:	8b 0a                	mov    (%edx),%ecx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8091a4:	83 f9 ff             	cmp    $0xffffffff,%ecx
  8091a7:	74 04                	je     8091ad <ip_addr_isbroadcast+0x15>
  8091a9:	85 c9                	test   %ecx,%ecx
  8091ab:	75 07                	jne    8091b4 <ip_addr_isbroadcast+0x1c>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  8091ad:	bb 01 00 00 00       	mov    $0x1,%ebx
  8091b2:	eb 3b                	jmp    8091ef <ip_addr_isbroadcast+0x57>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  8091b4:	bb 00 00 00 00       	mov    $0x0,%ebx
  8091b9:	f6 40 2e 02          	testb  $0x2,0x2e(%eax)
  8091bd:	74 30                	je     8091ef <ip_addr_isbroadcast+0x57>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  8091bf:	bb 00 00 00 00       	mov    $0x0,%ebx
  8091c4:	39 48 04             	cmp    %ecx,0x4(%eax)
  8091c7:	74 26                	je     8091ef <ip_addr_isbroadcast+0x57>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  8091c9:	8b 58 08             	mov    0x8(%eax),%ebx
  8091cc:	8b 12                	mov    (%edx),%edx
  8091ce:	21 da                	and    %ebx,%edx
  8091d0:	8b 40 04             	mov    0x4(%eax),%eax
  8091d3:	21 d8                	and    %ebx,%eax
  8091d5:	39 c2                	cmp    %eax,%edx
  8091d7:	75 11                	jne    8091ea <ip_addr_isbroadcast+0x52>
  8091d9:	89 d8                	mov    %ebx,%eax
  8091db:	f7 d0                	not    %eax
  8091dd:	89 c2                	mov    %eax,%edx
  8091df:	21 ca                	and    %ecx,%edx
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  8091e1:	bb 01 00 00 00       	mov    $0x1,%ebx
  8091e6:	39 c2                	cmp    %eax,%edx
  8091e8:	74 05                	je     8091ef <ip_addr_isbroadcast+0x57>
  else
    return 0;
  8091ea:	bb 00 00 00 00       	mov    $0x0,%ebx
}
  8091ef:	89 d8                	mov    %ebx,%eax
  8091f1:	5b                   	pop    %ebx
  8091f2:	c9                   	leave  
  8091f3:	c3                   	ret    

008091f4 <ip_route>:
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  8091f4:	55                   	push   %ebp
  8091f5:	89 e5                	mov    %esp,%ebp
  8091f7:	56                   	push   %esi
  8091f8:	53                   	push   %ebx
  8091f9:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8091fc:	8b 1d 60 e6 b3 00    	mov    0xb3e660,%ebx
  809202:	85 db                	test   %ebx,%ebx
  809204:	74 24                	je     80922a <ip_route+0x36>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  809206:	83 ec 0c             	sub    $0xc,%esp
  809209:	53                   	push   %ebx
  80920a:	e8 67 e2 ff ff       	call   807476 <netif_is_up>
  80920f:	83 c4 10             	add    $0x10,%esp
  809212:	84 c0                	test   %al,%al
  809214:	74 0e                	je     809224 <ip_route+0x30>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  809216:	8b 43 08             	mov    0x8(%ebx),%eax
  809219:	8b 16                	mov    (%esi),%edx
  80921b:	21 c2                	and    %eax,%edx
  80921d:	23 43 04             	and    0x4(%ebx),%eax
  809220:	39 c2                	cmp    %eax,%edx
  809222:	74 2b                	je     80924f <ip_route+0x5b>
  809224:	8b 1b                	mov    (%ebx),%ebx
  809226:	85 db                	test   %ebx,%ebx
  809228:	75 dc                	jne    809206 <ip_route+0x12>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  80922a:	83 3d 64 e6 b3 00 00 	cmpl   $0x0,0xb3e664
  809231:	74 15                	je     809248 <ip_route+0x54>
  809233:	83 ec 0c             	sub    $0xc,%esp
  809236:	ff 35 64 e6 b3 00    	pushl  0xb3e664
  80923c:	e8 35 e2 ff ff       	call   807476 <netif_is_up>
  809241:	83 c4 10             	add    $0x10,%esp
  809244:	84 c0                	test   %al,%al
  809246:	75 0b                	jne    809253 <ip_route+0x5f>
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  809248:	b8 00 00 00 00       	mov    $0x0,%eax
  80924d:	eb 09                	jmp    809258 <ip_route+0x64>
  80924f:	89 d8                	mov    %ebx,%eax
  809251:	eb 05                	jmp    809258 <ip_route+0x64>
  }
  /* no matching netif found, use default netif */
  return netif_default;
  809253:	a1 64 e6 b3 00       	mov    0xb3e664,%eax
}
  809258:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80925b:	5b                   	pop    %ebx
  80925c:	5e                   	pop    %esi
  80925d:	c9                   	leave  
  80925e:	c3                   	ret    

0080925f <ip_input>:

#if IP_FORWARD
/**
 * Forwards an IP packet. It finds an appropriate route for the
 * packet, decrements the TTL value of the packet, adjusts the
 * checksum and outputs the packet on the appropriate interface.
 *
 * @param p the packet to forward (p->payload points to IP header)
 * @param iphdr the IP header of the input packet
 * @param inp the netif on which this packet was received
 * @return the netif on which the packet was sent (NULL if it wasn't sent)
 */
static struct netif *
ip_forward(struct pbuf *p, struct ip_hdr *iphdr, struct netif *inp)
{
  struct netif *netif;

  PERF_START;
  /* Find network interface where to forward this IP packet to. */
  netif = ip_route((struct ip_addr *)&(iphdr->dest));
  if (netif == NULL) {
    LWIP_DEBUGF(IP_DEBUG, ("ip_forward: no forwarding route for 0x%"X32_F" found\n",
                      iphdr->dest.addr));
    snmp_inc_ipoutnoroutes();
    return (struct netif *)NULL;
  }
  /* Do not forward packets onto the same network interface on which
   * they arrived. */
  if (netif == inp) {
    LWIP_DEBUGF(IP_DEBUG, ("ip_forward: not bouncing packets back on incoming interface.\n"));
    snmp_inc_ipoutnoroutes();
    return (struct netif *)NULL;
  }

  /* decrement TTL */
  IPH_TTL_SET(iphdr, IPH_TTL(iphdr) - 1);
  /* send ICMP if TTL == 0 */
  if (IPH_TTL(iphdr) == 0) {
    snmp_inc_ipinhdrerrors();
#if LWIP_ICMP
    /* Don't send ICMP messages in response to ICMP messages */
    if (IPH_PROTO(iphdr) != IP_PROTO_ICMP) {
      icmp_time_exceeded(p, ICMP_TE_TTL);
    }
#endif /* LWIP_ICMP */
    return (struct netif *)NULL;
  }

  /* Incrementally update the IP checksum. */
  if (IPH_CHKSUM(iphdr) >= htons(0xffff - 0x100)) {
    IPH_CHKSUM_SET(iphdr, IPH_CHKSUM(iphdr) + htons(0x100) + 1);
  } else {
    IPH_CHKSUM_SET(iphdr, IPH_CHKSUM(iphdr) + htons(0x100));
  }

  LWIP_DEBUGF(IP_DEBUG, ("ip_forward: forwarding packet to 0x%"X32_F"\n",
                    iphdr->dest.addr));

  IP_STATS_INC(ip.fw);
  IP_STATS_INC(ip.xmit);
  snmp_inc_ipforwdatagrams();

  PERF_STOP("ip_forward");
  /* transmit pbuf on chosen interface */
  netif->output(netif, p, (struct ip_addr *)&(iphdr->dest));
  return netif;
}
#endif /* IP_FORWARD */

/**
 * This function is called by the network interface device driver when
 * an IP packet is received. The function does the basic checks of the
 * IP header such as packet size being at least larger than the header
 * size etc. If the packet was not destined for us, the packet is
 * forwarded (using ip_forward). The IP checksum is always checked.
 *
 * Finally, the packet is sent to the upper layer protocol input function.
 * 
 * @param p the received IP packet (p->payload points to IP header)
 * @param inp the netif on which this packet was received
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  80925f:	55                   	push   %ebp
  809260:	89 e5                	mov    %esp,%ebp
  809262:	57                   	push   %edi
  809263:	56                   	push   %esi
  809264:	53                   	push   %ebx
  809265:	83 ec 28             	sub    $0x28,%esp
  809268:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if LWIP_DHCP
  int check_ip_src=1;
  80926b:	c7 45 ec 01 00 00 00 	movl   $0x1,0xffffffec(%ebp)
#endif /* LWIP_DHCP */

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  809272:	8b 73 04             	mov    0x4(%ebx),%esi
  if (IPH_V(iphdr) != 4) {
  809275:	0f b7 06             	movzwl (%esi),%eax
  809278:	50                   	push   %eax
  809279:	e8 f7 13 00 00       	call   80a675 <ntohs>
  80927e:	66 c1 e8 0c          	shr    $0xc,%ax
  809282:	83 c4 10             	add    $0x10,%esp
  809285:	66 83 f8 04          	cmp    $0x4,%ax
  809289:	74 13                	je     80929e <ip_input+0x3f>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  80928b:	83 ec 0c             	sub    $0xc,%esp
  80928e:	53                   	push   %ebx
  80928f:	e8 85 e6 ff ff       	call   807919 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  809294:	b8 00 00 00 00       	mov    $0x0,%eax
  809299:	e9 9a 02 00 00       	jmp    809538 <ip_input+0x2d9>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  80929e:	83 ec 0c             	sub    $0xc,%esp
  8092a1:	0f b7 06             	movzwl (%esi),%eax
  8092a4:	50                   	push   %eax
  8092a5:	e8 cb 13 00 00       	call   80a675 <ntohs>
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  8092aa:	66 c1 e8 06          	shr    $0x6,%ax
  8092ae:	83 e0 3c             	and    $0x3c,%eax
  8092b1:	66 89 45 f2          	mov    %ax,0xfffffff2(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  8092b5:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8092b9:	89 04 24             	mov    %eax,(%esp)
  8092bc:	e8 b4 13 00 00       	call   80a675 <ntohs>
  8092c1:	89 c7                	mov    %eax,%edi

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  8092c3:	83 c4 10             	add    $0x10,%esp
  8092c6:	66 8b 45 f2          	mov    0xfffffff2(%ebp),%ax
  8092ca:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  8092ce:	72 06                	jb     8092d6 <ip_input+0x77>
  8092d0:	66 39 7b 08          	cmp    %di,0x8(%ebx)
  8092d4:	73 13                	jae    8092e9 <ip_input+0x8a>
    if (iphdr_hlen > p->len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP header (len %"U16_F") does not fit in first pbuf (len %"U16_F"), IP packet dropped.\n",
                               iphdr_hlen, p->len));
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  8092d6:	83 ec 0c             	sub    $0xc,%esp
  8092d9:	53                   	push   %ebx
  8092da:	e8 3a e6 ff ff       	call   807919 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  8092df:	b8 00 00 00 00       	mov    $0x0,%eax
  8092e4:	e9 4f 02 00 00       	jmp    809538 <ip_input+0x2d9>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  8092e9:	83 ec 08             	sub    $0x8,%esp
  8092ec:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  8092f0:	50                   	push   %eax
  8092f1:	56                   	push   %esi
  8092f2:	e8 50 10 00 00       	call   80a347 <inet_chksum>
  8092f7:	83 c4 10             	add    $0x10,%esp
  8092fa:	66 85 c0             	test   %ax,%ax
  8092fd:	74 13                	je     809312 <ip_input+0xb3>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  8092ff:	83 ec 0c             	sub    $0xc,%esp
  809302:	53                   	push   %ebx
  809303:	e8 11 e6 ff ff       	call   807919 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  809308:	b8 00 00 00 00       	mov    $0x0,%eax
  80930d:	e9 26 02 00 00       	jmp    809538 <ip_input+0x2d9>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  809312:	83 ec 08             	sub    $0x8,%esp
  809315:	0f b7 c7             	movzwl %di,%eax
  809318:	50                   	push   %eax
  809319:	53                   	push   %ebx
  80931a:	e8 03 e4 ff ff       	call   807722 <pbuf_realloc>

  /* match packet against an interface, i.e. is this packet for us? */
#if LWIP_IGMP
  if (ip_addr_ismulticast(&(iphdr->dest))) {
    if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, &(iphdr->dest)))) {
      netif = inp;
    } else {
      netif = NULL;
    }
  } else
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  80931f:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
    netif = inp;
  809326:	8b 7d 0c             	mov    0xc(%ebp),%edi
    do {
  809329:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(IP_DEBUG, ("ip_input: iphdr->dest 0x%"X32_F" netif->ip_addr 0x%"X32_F" (0x%"X32_F", 0x%"X32_F", 0x%"X32_F")\n",
          iphdr->dest.addr, netif->ip_addr.addr,
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  80932c:	83 ec 0c             	sub    $0xc,%esp
  80932f:	57                   	push   %edi
  809330:	e8 41 e1 ff ff       	call   807476 <netif_is_up>
  809335:	83 c4 10             	add    $0x10,%esp
  809338:	84 c0                	test   %al,%al
  80933a:	74 27                	je     809363 <ip_input+0x104>
  80933c:	83 ff fc             	cmp    $0xfffffffc,%edi
  80933f:	74 22                	je     809363 <ip_input+0x104>
  809341:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
  809345:	74 1c                	je     809363 <ip_input+0x104>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  809347:	8b 46 10             	mov    0x10(%esi),%eax
  80934a:	3b 47 04             	cmp    0x4(%edi),%eax
  80934d:	74 3b                	je     80938a <ip_input+0x12b>
  80934f:	83 ec 08             	sub    $0x8,%esp
  809352:	57                   	push   %edi
  809353:	8d 46 10             	lea    0x10(%esi),%eax
  809356:	50                   	push   %eax
  809357:	e8 3c fe ff ff       	call   809198 <ip_addr_isbroadcast>
  80935c:	83 c4 10             	add    $0x10,%esp
  80935f:	84 c0                	test   %al,%al
  809361:	75 27                	jne    80938a <ip_input+0x12b>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
          LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  809363:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
  809367:	74 0f                	je     809378 <ip_input+0x119>
        first = 0;
  809369:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
        netif = netif_list;
  809370:	8b 3d 60 e6 b3 00    	mov    0xb3e660,%edi
  809376:	eb 02                	jmp    80937a <ip_input+0x11b>
      } else {
        netif = netif->next;
  809378:	8b 3f                	mov    (%edi),%edi
      }
      if (netif == inp) {
  80937a:	3b 7d 0c             	cmp    0xc(%ebp),%edi
  80937d:	75 05                	jne    809384 <ip_input+0x125>
        netif = netif->next;
  80937f:	8b 45 0c             	mov    0xc(%ebp),%eax
  809382:	8b 38                	mov    (%eax),%edi
      }
    } while(netif != NULL);
  809384:	85 ff                	test   %edi,%edi
  809386:	75 a4                	jne    80932c <ip_input+0xcd>
  809388:	eb 04                	jmp    80938e <ip_input+0x12f>
  }

#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  80938a:	85 ff                	test   %edi,%edi
  80938c:	75 39                	jne    8093c7 <ip_input+0x168>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  80938e:	83 ec 0c             	sub    $0xc,%esp
  809391:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  809395:	50                   	push   %eax
  809396:	e8 da 12 00 00       	call   80a675 <ntohs>
  80939b:	83 c4 10             	add    $0x10,%esp
  80939e:	3c 11                	cmp    $0x11,%al
  8093a0:	75 25                	jne    8093c7 <ip_input+0x168>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  8093a2:	83 ec 0c             	sub    $0xc,%esp
  8093a5:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  8093a9:	0f b7 44 30 02       	movzwl 0x2(%eax,%esi,1),%eax
  8093ae:	50                   	push   %eax
  8093af:	e8 c1 12 00 00       	call   80a675 <ntohs>
  8093b4:	83 c4 10             	add    $0x10,%esp
  8093b7:	66 83 f8 44          	cmp    $0x44,%ax
  8093bb:	75 0a                	jne    8093c7 <ip_input+0x168>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  8093bd:	8b 7d 0c             	mov    0xc(%ebp),%edi
        check_ip_src = 0;
  8093c0:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
      }
    }
  }
#endif /* LWIP_DHCP */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
  8093c7:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  8093cb:	74 50                	je     80941d <ip_input+0x1be>
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  8093cd:	83 ec 08             	sub    $0x8,%esp
  8093d0:	ff 75 0c             	pushl  0xc(%ebp)
  8093d3:	8d 46 0c             	lea    0xc(%esi),%eax
  8093d6:	50                   	push   %eax
  8093d7:	e8 bc fd ff ff       	call   809198 <ip_addr_isbroadcast>
  8093dc:	83 c4 10             	add    $0x10,%esp
  8093df:	84 c0                	test   %al,%al
  8093e1:	75 27                	jne    80940a <ip_input+0x1ab>
  8093e3:	83 ec 0c             	sub    $0xc,%esp
  8093e6:	68 00 00 00 f0       	push   $0xf0000000
  8093eb:	e8 c6 12 00 00       	call   80a6b6 <ntohl>
  8093f0:	23 46 0c             	and    0xc(%esi),%eax
  8093f3:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  8093f6:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8093fd:	e8 b4 12 00 00       	call   80a6b6 <ntohl>
  809402:	83 c4 10             	add    $0x10,%esp
  809405:	39 45 e4             	cmp    %eax,0xffffffe4(%ebp)
  809408:	75 13                	jne    80941d <ip_input+0x1be>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  80940a:	83 ec 0c             	sub    $0xc,%esp
  80940d:	53                   	push   %ebx
  80940e:	e8 06 e5 ff ff       	call   807919 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  809413:	b8 00 00 00 00       	mov    $0x0,%eax
  809418:	e9 1b 01 00 00       	jmp    809538 <ip_input+0x2d9>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  80941d:	85 ff                	test   %edi,%edi
  80941f:	75 13                	jne    809434 <ip_input+0x1d5>
    /* packet not for us, route or discard */
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet not for us.\n"));
#if IP_FORWARD
    /* non-broadcast packet? */
    if (!ip_addr_isbroadcast(&(iphdr->dest), inp)) {
      /* try to forward IP packet on (other) interfaces */
      ip_forward(p, iphdr, inp);
    } else
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  809421:	83 ec 0c             	sub    $0xc,%esp
  809424:	53                   	push   %ebx
  809425:	e8 ef e4 ff ff       	call   807919 <pbuf_free>
    return ERR_OK;
  80942a:	b8 00 00 00 00       	mov    $0x0,%eax
  80942f:	e9 04 01 00 00       	jmp    809538 <ip_input+0x2d9>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  809434:	83 ec 0c             	sub    $0xc,%esp
  809437:	68 ff 3f 00 00       	push   $0x3fff
  80943c:	e8 1e 12 00 00       	call   80a65f <htons>
  809441:	83 c4 10             	add    $0x10,%esp
  809444:	66 85 46 06          	test   %ax,0x6(%esi)
  809448:	74 1e                	je     809468 <ip_input+0x209>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  80944a:	83 ec 0c             	sub    $0xc,%esp
  80944d:	53                   	push   %ebx
  80944e:	e8 0f 08 00 00       	call   809c62 <ip_reass>
  809453:	89 c3                	mov    %eax,%ebx
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  809455:	83 c4 10             	add    $0x10,%esp
      return ERR_OK;
  809458:	b8 00 00 00 00       	mov    $0x0,%eax
  80945d:	85 db                	test   %ebx,%ebx
  80945f:	0f 84 d3 00 00 00    	je     809538 <ip_input+0x2d9>
    }
    iphdr = p->payload;
  809465:	8b 73 04             	mov    0x4(%ebx),%esi
#else /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */
    pbuf_free(p);
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP packet dropped since it was fragmented (0x%"X16_F") (while IP_REASSEMBLY == 0).\n",
      ntohs(IPH_OFFSET(iphdr))));
    IP_STATS_INC(ip.opterr);
    IP_STATS_INC(ip.drop);
    /* unsupported protocol feature */
    snmp_inc_ipinunknownprotos();
    return ERR_OK;
#endif /* IP_REASSEMBLY */
  }

#if IP_OPTIONS_ALLOWED == 0 /* no support for IP options in the IP header? */

#if LWIP_IGMP
  /* there is an extra "router alert" option in IGMP messages which we allow for but do not police */
  if((iphdr_hlen > IP_HLEN &&  (IPH_PROTO(iphdr) != IP_PROTO_IGMP)) {
#else
  if (iphdr_hlen > IP_HLEN) {
#endif /* LWIP_IGMP */
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP packet dropped since there were IP options (while IP_OPTIONS_ALLOWED == 0).\n"));
    pbuf_free(p);
    IP_STATS_INC(ip.opterr);
    IP_STATS_INC(ip.drop);
    /* unsupported protocol feature */
    snmp_inc_ipinunknownprotos();
    return ERR_OK;
  }
#endif /* IP_OPTIONS_ALLOWED == 0 */

  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  809468:	83 ec 08             	sub    $0x8,%esp
  80946b:	ff 75 0c             	pushl  0xc(%ebp)
  80946e:	53                   	push   %ebx
  80946f:	e8 9c 7a 00 00       	call   810f10 <raw_input>
  809474:	83 c4 10             	add    $0x10,%esp
  809477:	84 c0                	test   %al,%al
  809479:	0f 85 b4 00 00 00    	jne    809533 <ip_input+0x2d4>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  80947f:	83 ec 0c             	sub    $0xc,%esp
  809482:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  809486:	50                   	push   %eax
  809487:	e8 e9 11 00 00       	call   80a675 <ntohs>
  80948c:	0f b6 c0             	movzbl %al,%eax
  80948f:	83 c4 10             	add    $0x10,%esp
  809492:	83 f8 06             	cmp    $0x6,%eax
  809495:	74 22                	je     8094b9 <ip_input+0x25a>
  809497:	83 f8 06             	cmp    $0x6,%eax
  80949a:	7f 07                	jg     8094a3 <ip_input+0x244>
  80949c:	83 f8 01             	cmp    $0x1,%eax
  80949f:	74 29                	je     8094ca <ip_input+0x26b>
  8094a1:	eb 38                	jmp    8094db <ip_input+0x27c>
  8094a3:	83 f8 11             	cmp    $0x11,%eax
  8094a6:	75 33                	jne    8094db <ip_input+0x27c>
#if LWIP_UDP
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  8094a8:	83 ec 08             	sub    $0x8,%esp
  8094ab:	ff 75 0c             	pushl  0xc(%ebp)
  8094ae:	53                   	push   %ebx
  8094af:	e8 f4 21 00 00       	call   80b6a8 <udp_input>
      break;
  8094b4:	83 c4 10             	add    $0x10,%esp
  8094b7:	eb 7a                	jmp    809533 <ip_input+0x2d4>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  8094b9:	83 ec 08             	sub    $0x8,%esp
  8094bc:	ff 75 0c             	pushl  0xc(%ebp)
  8094bf:	53                   	push   %ebx
  8094c0:	e8 87 5e 00 00       	call   80f34c <tcp_input>
      break;
  8094c5:	83 c4 10             	add    $0x10,%esp
  8094c8:	eb 69                	jmp    809533 <ip_input+0x2d4>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  8094ca:	83 ec 08             	sub    $0x8,%esp
  8094cd:	ff 75 0c             	pushl  0xc(%ebp)
  8094d0:	53                   	push   %ebx
  8094d1:	e8 ca 7c 00 00       	call   8111a0 <icmp_input>
      break;
  8094d6:	83 c4 10             	add    $0x10,%esp
  8094d9:	eb 58                	jmp    809533 <ip_input+0x2d4>
#endif /* LWIP_ICMP */
#if LWIP_IGMP
    case IP_PROTO_IGMP:
      igmp_input(p,inp,&(iphdr->dest));
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8094db:	83 ec 08             	sub    $0x8,%esp
  8094de:	ff 75 0c             	pushl  0xc(%ebp)
  8094e1:	8d 46 10             	lea    0x10(%esi),%eax
  8094e4:	50                   	push   %eax
  8094e5:	e8 ae fc ff ff       	call   809198 <ip_addr_isbroadcast>
  8094ea:	83 c4 10             	add    $0x10,%esp
  8094ed:	84 c0                	test   %al,%al
  8094ef:	75 36                	jne    809527 <ip_input+0x2c8>
  8094f1:	83 ec 0c             	sub    $0xc,%esp
  8094f4:	68 00 00 00 f0       	push   $0xf0000000
  8094f9:	e8 b8 11 00 00       	call   80a6b6 <ntohl>
  8094fe:	89 c7                	mov    %eax,%edi
  809500:	23 7e 10             	and    0x10(%esi),%edi
  809503:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80950a:	e8 a7 11 00 00       	call   80a6b6 <ntohl>
  80950f:	83 c4 10             	add    $0x10,%esp
  809512:	39 c7                	cmp    %eax,%edi
  809514:	74 11                	je     809527 <ip_input+0x2c8>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  809516:	89 73 04             	mov    %esi,0x4(%ebx)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  809519:	83 ec 08             	sub    $0x8,%esp
  80951c:	6a 02                	push   $0x2
  80951e:	53                   	push   %ebx
  80951f:	e8 82 7f 00 00       	call   8114a6 <icmp_dest_unreach>
  809524:	83 c4 10             	add    $0x10,%esp
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  809527:	83 ec 0c             	sub    $0xc,%esp
  80952a:	53                   	push   %ebx
  80952b:	e8 e9 e3 ff ff       	call   807919 <pbuf_free>

      LWIP_DEBUGF(IP_DEBUG | 2, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));
  809530:	83 c4 10             	add    $0x10,%esp

      IP_STATS_INC(ip.proterr);
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
  809533:	b8 00 00 00 00       	mov    $0x0,%eax
}
  809538:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80953b:	5b                   	pop    %ebx
  80953c:	5e                   	pop    %esi
  80953d:	5f                   	pop    %edi
  80953e:	c9                   	leave  
  80953f:	c3                   	ret    

00809540 <ip_output_if>:

/**
 * Sends an IP packet on a network interface. This function constructs
 * the IP header and calculates the IP header checksum. If the source
 * IP address is NULL, the IP address of the outgoing network
 * interface is filled in as source address.
 * If the destination IP address is IP_HDRINCL, p is assumed to already
 * include an IP header and p->payload points to it instead of the data.
 *
 * @param p the packet to send (p->payload points to the data, e.g. next
            protocol header; if dest == IP_HDRINCL, p already includes an IP
            header and p->payload points to that IP header)
 * @param src the source IP address to send from (if src == IP_ADDR_ANY, the
 *         IP  address of the netif used to send is used as source address)
 * @param dest the destination IP address to send the packet to
 * @param ttl the TTL value to be set in the IP header
 * @param tos the TOS value to be set in the IP header
 * @param proto the PROTOCOL to be set in the IP header
 * @param netif the netif on which to send this packet
 * @return ERR_OK if the packet was sent OK
 *         ERR_BUF if p doesn't have enough space for IP/LINK headers
 *         returns errors returned by netif->output
 *
 * @note ip_id: RFC791 "some host may be able to simply use
 *  unique identifiers independent of destination"
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  809540:	55                   	push   %ebp
  809541:	89 e5                	mov    %esp,%ebp
  809543:	57                   	push   %edi
  809544:	56                   	push   %esi
  809545:	53                   	push   %ebx
  809546:	83 ec 2c             	sub    $0x2c,%esp
  809549:	8b 7d 10             	mov    0x10(%ebp),%edi
  80954c:	8a 5d 14             	mov    0x14(%ebp),%bl
  80954f:	8a 45 18             	mov    0x18(%ebp),%al
  809552:	88 45 d8             	mov    %al,0xffffffd8(%ebp)
  809555:	8a 55 1c             	mov    0x1c(%ebp),%dl
  809558:	88 55 d7             	mov    %dl,0xffffffd7(%ebp)
  struct ip_hdr *iphdr;
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  80955b:	85 ff                	test   %edi,%edi
  80955d:	0f 84 3a 01 00 00    	je     80969d <ip_output_if+0x15d>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  809563:	83 ec 08             	sub    $0x8,%esp
  809566:	6a 14                	push   $0x14
  809568:	ff 75 08             	pushl  0x8(%ebp)
  80956b:	e8 d3 e2 ff ff       	call   807843 <pbuf_header>
  809570:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  809573:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
  809578:	84 c0                	test   %al,%al
  80957a:	0f 85 65 01 00 00    	jne    8096e5 <ip_output_if+0x1a5>
    }

    iphdr = p->payload;
  809580:	8b 45 08             	mov    0x8(%ebp),%eax
  809583:	8b 70 04             	mov    0x4(%eax),%esi
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  809586:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80958b:	77 17                	ja     8095a4 <ip_output_if+0x64>
  80958d:	83 ec 04             	sub    $0x4,%esp
  809590:	68 b8 32 81 00       	push   $0x8132b8
  809595:	68 ee 01 00 00       	push   $0x1ee
  80959a:	68 e5 32 81 00       	push   $0x8132e5
  80959f:	e8 28 75 ff ff       	call   800acc <_panic>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  8095a4:	83 ec 0c             	sub    $0xc,%esp
  8095a7:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8095ab:	50                   	push   %eax
  8095ac:	e8 c4 10 00 00       	call   80a675 <ntohs>
  8095b1:	0f b6 d3             	movzbl %bl,%edx
  8095b4:	c1 e2 08             	shl    $0x8,%edx
  8095b7:	0f b6 c0             	movzbl %al,%eax
  8095ba:	09 d0                	or     %edx,%eax
  8095bc:	89 04 24             	mov    %eax,(%esp)
  8095bf:	e8 9b 10 00 00       	call   80a65f <htons>
  8095c4:	66 89 46 08          	mov    %ax,0x8(%esi)
    IPH_PROTO_SET(iphdr, proto);
  8095c8:	66 0f b6 5d d7       	movzbw 0xffffffd7(%ebp),%bx
  8095cd:	0f b7 c0             	movzwl %ax,%eax
  8095d0:	89 04 24             	mov    %eax,(%esp)
  8095d3:	e8 9d 10 00 00       	call   80a675 <ntohs>
  8095d8:	25 00 ff 00 00       	and    $0xff00,%eax
  8095dd:	09 c3                	or     %eax,%ebx
  8095df:	0f b7 db             	movzwl %bx,%ebx
  8095e2:	89 1c 24             	mov    %ebx,(%esp)
  8095e5:	e8 75 10 00 00       	call   80a65f <htons>
  8095ea:	66 89 46 08          	mov    %ax,0x8(%esi)

    ip_addr_set(&(iphdr->dest), dest);
  8095ee:	83 c4 10             	add    $0x10,%esp
  8095f1:	b8 00 00 00 00       	mov    $0x0,%eax
  8095f6:	85 ff                	test   %edi,%edi
  8095f8:	74 02                	je     8095fc <ip_output_if+0xbc>
  8095fa:	8b 07                	mov    (%edi),%eax
  8095fc:	89 46 10             	mov    %eax,0x10(%esi)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  8095ff:	83 ec 0c             	sub    $0xc,%esp
  809602:	8a 45 d8             	mov    0xffffffd8(%ebp),%al
  809605:	80 cc 45             	or     $0x45,%ah
  809608:	25 ff 45 00 00       	and    $0x45ff,%eax
  80960d:	50                   	push   %eax
  80960e:	e8 4c 10 00 00       	call   80a65f <htons>
  809613:	66 89 06             	mov    %ax,(%esi)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  809616:	8b 55 08             	mov    0x8(%ebp),%edx
  809619:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  80961d:	89 04 24             	mov    %eax,(%esp)
  809620:	e8 3a 10 00 00       	call   80a65f <htons>
  809625:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(iphdr, 0);
  809629:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_ID_SET(iphdr, htons(ip_id));
  80962f:	0f b7 05 0c 78 b3 00 	movzwl 0xb3780c,%eax
  809636:	89 04 24             	mov    %eax,(%esp)
  809639:	e8 21 10 00 00       	call   80a65f <htons>
  80963e:	66 89 46 04          	mov    %ax,0x4(%esi)
    ++ip_id;
  809642:	66 ff 05 0c 78 b3 00 	incw   0xb3780c

    if (ip_addr_isany(src)) {
  809649:	83 c4 10             	add    $0x10,%esp
  80964c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  809650:	74 08                	je     80965a <ip_output_if+0x11a>
  809652:	8b 45 0c             	mov    0xc(%ebp),%eax
  809655:	83 38 00             	cmpl   $0x0,(%eax)
  809658:	75 16                	jne    809670 <ip_output_if+0x130>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  80965a:	b8 00 00 00 00       	mov    $0x0,%eax
  80965f:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  809663:	74 06                	je     80966b <ip_output_if+0x12b>
  809665:	8b 55 20             	mov    0x20(%ebp),%edx
  809668:	8b 42 04             	mov    0x4(%edx),%eax
  80966b:	89 46 0c             	mov    %eax,0xc(%esi)
  80966e:	eb 13                	jmp    809683 <ip_output_if+0x143>
    } else {
      ip_addr_set(&(iphdr->src), src);
  809670:	b8 00 00 00 00       	mov    $0x0,%eax
  809675:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  809679:	74 05                	je     809680 <ip_output_if+0x140>
  80967b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80967e:	8b 02                	mov    (%edx),%eax
  809680:	89 46 0c             	mov    %eax,0xc(%esi)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  809683:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  809689:	83 ec 08             	sub    $0x8,%esp
  80968c:	6a 14                	push   $0x14
  80968e:	56                   	push   %esi
  80968f:	e8 b3 0c 00 00       	call   80a347 <inet_chksum>
  809694:	66 89 46 0a          	mov    %ax,0xa(%esi)
  809698:	83 c4 10             	add    $0x10,%esp
  80969b:	eb 09                	jmp    8096a6 <ip_output_if+0x166>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  80969d:	8b 45 08             	mov    0x8(%ebp),%eax
  8096a0:	8b 78 04             	mov    0x4(%eax),%edi
  8096a3:	83 c7 10             	add    $0x10,%edi
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  8096a6:	8b 55 20             	mov    0x20(%ebp),%edx
  8096a9:	66 83 7a 2c 00       	cmpw   $0x0,0x2c(%edx)
  8096ae:	74 22                	je     8096d2 <ip_output_if+0x192>
  8096b0:	8b 55 08             	mov    0x8(%ebp),%edx
  8096b3:	66 8b 42 08          	mov    0x8(%edx),%ax
  8096b7:	8b 55 20             	mov    0x20(%ebp),%edx
  8096ba:	66 3b 42 2c          	cmp    0x2c(%edx),%ax
  8096be:	76 12                	jbe    8096d2 <ip_output_if+0x192>
    return ip_frag(p,netif,dest);
  8096c0:	83 ec 04             	sub    $0x4,%esp
  8096c3:	57                   	push   %edi
  8096c4:	52                   	push   %edx
  8096c5:	ff 75 08             	pushl  0x8(%ebp)
  8096c8:	e8 e1 07 00 00       	call   809eae <ip_frag>
  8096cd:	0f be d0             	movsbl %al,%edx
  8096d0:	eb 13                	jmp    8096e5 <ip_output_if+0x1a5>
#endif

  IP_STATS_INC(ip.xmit);

  LWIP_DEBUGF(IP_DEBUG, ("ip_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], netif->num));
  ip_debug_print(p);

#if (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF)
  if (ip_addr_cmp(dest, &netif->ip_addr)) {
    /* Packet to self, enqueue it for loopback */
    LWIP_DEBUGF(IP_DEBUG, ("netif_loop_output()"));

    return netif_loop_output(netif, p, dest);
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  8096d2:	83 ec 04             	sub    $0x4,%esp
  8096d5:	57                   	push   %edi
  8096d6:	ff 75 08             	pushl  0x8(%ebp)
  8096d9:	ff 75 20             	pushl  0x20(%ebp)
  8096dc:	8b 55 20             	mov    0x20(%ebp),%edx
  8096df:	ff 52 14             	call   *0x14(%edx)
  8096e2:	0f be d0             	movsbl %al,%edx
  }
}
  8096e5:	89 d0                	mov    %edx,%eax
  8096e7:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8096ea:	5b                   	pop    %ebx
  8096eb:	5e                   	pop    %esi
  8096ec:	5f                   	pop    %edi
  8096ed:	c9                   	leave  
  8096ee:	c3                   	ret    

008096ef <ip_output>:

/**
 * Simple interface to ip_output_if. It finds the outgoing network
 * interface and calls upon ip_output_if to do the actual work.
 *
 * @param p the packet to send (p->payload points to the data, e.g. next
            protocol header; if dest == IP_HDRINCL, p already includes an IP
            header and p->payload points to that IP header)
 * @param src the source IP address to send from (if src == IP_ADDR_ANY, the
 *         IP  address of the netif used to send is used as source address)
 * @param dest the destination IP address to send the packet to
 * @param ttl the TTL value to be set in the IP header
 * @param tos the TOS value to be set in the IP header
 * @param proto the PROTOCOL to be set in the IP header
 *
 * @return ERR_RTE if no route is found
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  8096ef:	55                   	push   %ebp
  8096f0:	89 e5                	mov    %esp,%ebp
  8096f2:	57                   	push   %edi
  8096f3:	56                   	push   %esi
  8096f4:	53                   	push   %ebx
  8096f5:	83 ec 18             	sub    $0x18,%esp
  8096f8:	0f b6 7d 14          	movzbl 0x14(%ebp),%edi
  8096fc:	0f b6 75 18          	movzbl 0x18(%ebp),%esi
  809700:	8a 5d 1c             	mov    0x1c(%ebp),%bl
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  809703:	ff 75 10             	pushl  0x10(%ebp)
  809706:	e8 e9 fa ff ff       	call   8091f4 <ip_route>
  80970b:	83 c4 10             	add    $0x10,%esp
    return ERR_RTE;
  80970e:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
  809713:	85 c0                	test   %eax,%eax
  809715:	74 25                	je     80973c <ip_output+0x4d>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  809717:	83 ec 04             	sub    $0x4,%esp
  80971a:	50                   	push   %eax
  80971b:	0f b6 c3             	movzbl %bl,%eax
  80971e:	50                   	push   %eax
  80971f:	89 f2                	mov    %esi,%edx
  809721:	0f b6 c2             	movzbl %dl,%eax
  809724:	50                   	push   %eax
  809725:	89 fa                	mov    %edi,%edx
  809727:	0f b6 c2             	movzbl %dl,%eax
  80972a:	50                   	push   %eax
  80972b:	ff 75 10             	pushl  0x10(%ebp)
  80972e:	ff 75 0c             	pushl  0xc(%ebp)
  809731:	ff 75 08             	pushl  0x8(%ebp)
  809734:	e8 07 fe ff ff       	call   809540 <ip_output_if>
  809739:	0f be d0             	movsbl %al,%edx
}
  80973c:	89 d0                	mov    %edx,%eax
  80973e:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  809741:	5b                   	pop    %ebx
  809742:	5e                   	pop    %esi
  809743:	5f                   	pop    %edi
  809744:	c9                   	leave  
  809745:	c3                   	ret    
	...

00809748 <ip_reass_tmr>:
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  809748:	55                   	push   %ebp
  809749:	89 e5                	mov    %esp,%ebp
  80974b:	56                   	push   %esi
  80974c:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;
  80974d:	be 00 00 00 00       	mov    $0x0,%esi

  r = reassdatagrams;
  809752:	8b 1d 20 78 b3 00    	mov    0xb37820,%ebx
  while (r != NULL) {
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
      r->timer--;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
      r = r->next;
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  809758:	85 db                	test   %ebx,%ebx
  80975a:	74 24                	je     809780 <ip_reass_tmr+0x38>
  80975c:	80 7b 1f 00          	cmpb   $0x0,0x1f(%ebx)
  809760:	74 09                	je     80976b <ip_reass_tmr+0x23>
  809762:	fe 4b 1f             	decb   0x1f(%ebx)
  809765:	89 de                	mov    %ebx,%esi
  809767:	8b 1b                	mov    (%ebx),%ebx
  809769:	eb 11                	jmp    80977c <ip_reass_tmr+0x34>
  80976b:	89 d8                	mov    %ebx,%eax
  80976d:	8b 1b                	mov    (%ebx),%ebx
  80976f:	83 ec 08             	sub    $0x8,%esp
  809772:	56                   	push   %esi
  809773:	50                   	push   %eax
  809774:	e8 0e 00 00 00       	call   809787 <ip_reass_free_complete_datagram>
  809779:	83 c4 10             	add    $0x10,%esp
  80977c:	85 db                	test   %ebx,%ebx
  80977e:	75 dc                	jne    80975c <ip_reass_tmr+0x14>
     }
   }
}
  809780:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  809783:	5b                   	pop    %ebx
  809784:	5e                   	pop    %esi
  809785:	c9                   	leave  
  809786:	c3                   	ret    

00809787 <ip_reass_free_complete_datagram>:

/**
 * Free a datagram (struct ip_reassdata) and all its pbufs.
 * Updates the total count of enqueued pbufs (ip_reass_pbufcount),
 * SNMP counters and sends an ICMP time exceeded packet.
 *
 * @param ipr datagram to free
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  809787:	55                   	push   %ebp
  809788:	89 e5                	mov    %esp,%ebp
  80978a:	57                   	push   %edi
  80978b:	56                   	push   %esi
  80978c:	53                   	push   %ebx
  80978d:	83 ec 0c             	sub    $0xc,%esp
  int pbufs_freed = 0;
  809790:	bf 00 00 00 00       	mov    $0x0,%edi
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  809795:	8b 45 08             	mov    0x8(%ebp),%eax
  809798:	39 45 0c             	cmp    %eax,0xc(%ebp)
  80979b:	75 17                	jne    8097b4 <ip_reass_free_complete_datagram+0x2d>
  80979d:	83 ec 04             	sub    $0x4,%esp
  8097a0:	68 fd 32 81 00       	push   $0x8132fd
  8097a5:	68 99 00 00 00       	push   $0x99
  8097aa:	68 09 33 81 00       	push   $0x813309
  8097af:	e8 18 73 ff ff       	call   800acc <_panic>
  if (prev != NULL) {
  8097b4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8097b8:	74 21                	je     8097db <ip_reass_free_complete_datagram+0x54>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  8097ba:	8b 45 08             	mov    0x8(%ebp),%eax
  8097bd:	8b 55 0c             	mov    0xc(%ebp),%edx
  8097c0:	39 02                	cmp    %eax,(%edx)
  8097c2:	74 17                	je     8097db <ip_reass_free_complete_datagram+0x54>
  8097c4:	83 ec 04             	sub    $0x4,%esp
  8097c7:	68 26 33 81 00       	push   $0x813326
  8097cc:	68 9b 00 00 00       	push   $0x9b
  8097d1:	68 09 33 81 00       	push   $0x813309
  8097d6:	e8 f1 72 ff ff       	call   800acc <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  8097db:	8b 45 08             	mov    0x8(%ebp),%eax
  8097de:	8b 50 04             	mov    0x4(%eax),%edx
  8097e1:	8b 42 04             	mov    0x4(%edx),%eax
  if (iprh->start == 0) {
  8097e4:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  8097e9:	75 40                	jne    80982b <ip_reass_free_complete_datagram+0xa4>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
  8097eb:	89 d6                	mov    %edx,%esi
    ipr->p = iprh->next_pbuf;
  8097ed:	8b 00                	mov    (%eax),%eax
  8097ef:	8b 55 08             	mov    0x8(%ebp),%edx
  8097f2:	89 42 04             	mov    %eax,0x4(%edx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  8097f5:	83 ec 04             	sub    $0x4,%esp
  8097f8:	6a 14                	push   $0x14
  8097fa:	89 d0                	mov    %edx,%eax
  8097fc:	83 c0 08             	add    $0x8,%eax
  8097ff:	50                   	push   %eax
  809800:	ff 76 04             	pushl  0x4(%esi)
  809803:	e8 9f 7b ff ff       	call   8013a7 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  809808:	83 c4 08             	add    $0x8,%esp
  80980b:	6a 01                	push   $0x1
  80980d:	56                   	push   %esi
  80980e:	e8 70 7d 00 00       	call   811583 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  809813:	89 34 24             	mov    %esi,(%esp)
  809816:	e8 cd e1 ff ff       	call   8079e8 <pbuf_clen>
  80981b:	0f b6 c0             	movzbl %al,%eax
  80981e:	01 c7                	add    %eax,%edi
    pbuf_free(p);
  809820:	89 34 24             	mov    %esi,(%esp)
  809823:	e8 f1 e0 ff ff       	call   807919 <pbuf_free>
  809828:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  80982b:	8b 45 08             	mov    0x8(%ebp),%eax
  80982e:	8b 70 04             	mov    0x4(%eax),%esi
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  809831:	85 f6                	test   %esi,%esi
  809833:	74 24                	je     809859 <ip_reass_free_complete_datagram+0xd2>
  809835:	8b 46 04             	mov    0x4(%esi),%eax
  809838:	89 f3                	mov    %esi,%ebx
  80983a:	8b 30                	mov    (%eax),%esi
  80983c:	83 ec 0c             	sub    $0xc,%esp
  80983f:	53                   	push   %ebx
  809840:	e8 a3 e1 ff ff       	call   8079e8 <pbuf_clen>
  809845:	0f b6 c0             	movzbl %al,%eax
  809848:	01 c7                	add    %eax,%edi
  80984a:	89 1c 24             	mov    %ebx,(%esp)
  80984d:	e8 c7 e0 ff ff       	call   807919 <pbuf_free>
  809852:	83 c4 10             	add    $0x10,%esp
  809855:	85 f6                	test   %esi,%esi
  809857:	75 dc                	jne    809835 <ip_reass_free_complete_datagram+0xae>
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  809859:	83 ec 08             	sub    $0x8,%esp
  80985c:	ff 75 0c             	pushl  0xc(%ebp)
  80985f:	ff 75 08             	pushl  0x8(%ebp)
  809862:	e8 47 01 00 00       	call   8099ae <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  809867:	0f b7 05 24 78 b3 00 	movzwl 0xb37824,%eax
  80986e:	83 c4 10             	add    $0x10,%esp
  809871:	39 f8                	cmp    %edi,%eax
  809873:	7d 17                	jge    80988c <ip_reass_free_complete_datagram+0x105>
  809875:	83 ec 04             	sub    $0x4,%esp
  809878:	68 38 33 81 00       	push   $0x813338
  80987d:	68 bc 00 00 00       	push   $0xbc
  809882:	68 09 33 81 00       	push   $0x813309
  809887:	e8 40 72 ff ff       	call   800acc <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  80988c:	66 29 3d 24 78 b3 00 	sub    %di,0xb37824

  return pbufs_freed;
}
  809893:	89 f8                	mov    %edi,%eax
  809895:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  809898:	5b                   	pop    %ebx
  809899:	5e                   	pop    %esi
  80989a:	5f                   	pop    %edi
  80989b:	c9                   	leave  
  80989c:	c3                   	ret    

0080989d <ip_reass_remove_oldest_datagram>:

#if IP_REASS_FREE_OLDEST
/**
 * Free the oldest datagram to make room for enqueueing new fragments.
 * The datagram 'fraghdr' belongs to is not freed!
 *
 * @param fraghdr IP header of the current fragment
 * @param pbufs_needed number of pbufs needed to enqueue
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  80989d:	55                   	push   %ebp
  80989e:	89 e5                	mov    %esp,%ebp
  8098a0:	57                   	push   %edi
  8098a1:	56                   	push   %esi
  8098a2:	53                   	push   %ebx
  8098a3:	83 ec 0c             	sub    $0xc,%esp
  8098a6:	8b 75 08             	mov    0x8(%ebp),%esi
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  8098a9:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  8098b0:	b9 00 00 00 00       	mov    $0x0,%ecx
    prev = NULL;
  8098b5:	bf 00 00 00 00       	mov    $0x0,%edi
    other_datagrams = 0;
  8098ba:	bb 00 00 00 00       	mov    $0x0,%ebx
    r = reassdatagrams;
  8098bf:	8b 15 20 78 b3 00    	mov    0xb37820,%edx
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
        /* Not the same datagram as fraghdr */
        other_datagrams++;
        if (oldest == NULL) {
          oldest = r;
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
  8098c5:	85 d2                	test   %edx,%edx
  8098c7:	74 3a                	je     809903 <ip_reass_remove_oldest_datagram+0x66>
  8098c9:	8b 42 14             	mov    0x14(%edx),%eax
  8098cc:	3b 46 0c             	cmp    0xc(%esi),%eax
  8098cf:	75 12                	jne    8098e3 <ip_reass_remove_oldest_datagram+0x46>
  8098d1:	8b 42 18             	mov    0x18(%edx),%eax
  8098d4:	3b 46 10             	cmp    0x10(%esi),%eax
  8098d7:	75 0a                	jne    8098e3 <ip_reass_remove_oldest_datagram+0x46>
  8098d9:	66 8b 42 0c          	mov    0xc(%edx),%ax
  8098dd:	66 3b 46 04          	cmp    0x4(%esi),%ax
  8098e1:	74 13                	je     8098f6 <ip_reass_remove_oldest_datagram+0x59>
  8098e3:	43                   	inc    %ebx
  8098e4:	85 c9                	test   %ecx,%ecx
  8098e6:	75 04                	jne    8098ec <ip_reass_remove_oldest_datagram+0x4f>
  8098e8:	89 d1                	mov    %edx,%ecx
  8098ea:	eb 0a                	jmp    8098f6 <ip_reass_remove_oldest_datagram+0x59>
  8098ec:	8a 42 1f             	mov    0x1f(%edx),%al
  8098ef:	3a 41 1f             	cmp    0x1f(%ecx),%al
  8098f2:	77 02                	ja     8098f6 <ip_reass_remove_oldest_datagram+0x59>
  8098f4:	89 d1                	mov    %edx,%ecx
  8098f6:	83 3a 00             	cmpl   $0x0,(%edx)
  8098f9:	74 02                	je     8098fd <ip_reass_remove_oldest_datagram+0x60>
  8098fb:	89 d7                	mov    %edx,%edi
  8098fd:	8b 12                	mov    (%edx),%edx
  8098ff:	85 d2                	test   %edx,%edx
  809901:	75 c6                	jne    8098c9 <ip_reass_remove_oldest_datagram+0x2c>
    }
    if (oldest != NULL) {
  809903:	85 c9                	test   %ecx,%ecx
  809905:	74 10                	je     809917 <ip_reass_remove_oldest_datagram+0x7a>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  809907:	83 ec 08             	sub    $0x8,%esp
  80990a:	57                   	push   %edi
  80990b:	51                   	push   %ecx
  80990c:	e8 76 fe ff ff       	call   809787 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  809911:	01 45 f0             	add    %eax,0xfffffff0(%ebp)
  809914:	83 c4 10             	add    $0x10,%esp
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  809917:	8b 45 0c             	mov    0xc(%ebp),%eax
  80991a:	39 45 f0             	cmp    %eax,0xfffffff0(%ebp)
  80991d:	7d 05                	jge    809924 <ip_reass_remove_oldest_datagram+0x87>
  80991f:	83 fb 01             	cmp    $0x1,%ebx
  809922:	7f 8c                	jg     8098b0 <ip_reass_remove_oldest_datagram+0x13>
  return pbufs_freed;
}
  809924:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  809927:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80992a:	5b                   	pop    %ebx
  80992b:	5e                   	pop    %esi
  80992c:	5f                   	pop    %edi
  80992d:	c9                   	leave  
  80992e:	c3                   	ret    

0080992f <ip_reass_enqueue_new_datagram>:
#endif /* IP_REASS_FREE_OLDEST */

/**
 * Enqueues a new fragment into the fragment queue
 * @param fraghdr points to the new fragments IP hdr
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  80992f:	55                   	push   %ebp
  809930:	89 e5                	mov    %esp,%ebp
  809932:	57                   	push   %edi
  809933:	56                   	push   %esi
  809934:	53                   	push   %ebx
  809935:	83 ec 18             	sub    $0x18,%esp
  809938:	8b 7d 08             	mov    0x8(%ebp),%edi
  80993b:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  80993e:	6a 05                	push   $0x5
  809940:	e8 52 d8 ff ff       	call   807197 <memp_malloc>
  809945:	89 c3                	mov    %eax,%ebx
  if (ipr == NULL) {
  809947:	83 c4 10             	add    $0x10,%esp
  80994a:	85 c0                	test   %eax,%eax
  80994c:	75 29                	jne    809977 <ip_reass_enqueue_new_datagram+0x48>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  80994e:	83 ec 08             	sub    $0x8,%esp
  809951:	56                   	push   %esi
  809952:	57                   	push   %edi
  809953:	e8 45 ff ff ff       	call   80989d <ip_reass_remove_oldest_datagram>
  809958:	83 c4 10             	add    $0x10,%esp
  80995b:	39 f0                	cmp    %esi,%eax
  80995d:	7c 0f                	jl     80996e <ip_reass_enqueue_new_datagram+0x3f>
      ipr = memp_malloc(MEMP_REASSDATA);
  80995f:	83 ec 0c             	sub    $0xc,%esp
  809962:	6a 05                	push   $0x5
  809964:	e8 2e d8 ff ff       	call   807197 <memp_malloc>
  809969:	89 c3                	mov    %eax,%ebx
  80996b:	83 c4 10             	add    $0x10,%esp
    }
    if (ipr == NULL)
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
  80996e:	b8 00 00 00 00       	mov    $0x0,%eax
  809973:	85 db                	test   %ebx,%ebx
  809975:	74 2f                	je     8099a6 <ip_reass_enqueue_new_datagram+0x77>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  809977:	83 ec 04             	sub    $0x4,%esp
  80997a:	6a 20                	push   $0x20
  80997c:	6a 00                	push   $0x0
  80997e:	53                   	push   %ebx
  80997f:	e8 65 79 ff ff       	call   8012e9 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  809984:	c6 43 1f 03          	movb   $0x3,0x1f(%ebx)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  809988:	a1 20 78 b3 00       	mov    0xb37820,%eax
  80998d:	89 03                	mov    %eax,(%ebx)
  reassdatagrams = ipr;
  80998f:	89 1d 20 78 b3 00    	mov    %ebx,0xb37820
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  809995:	83 c4 0c             	add    $0xc,%esp
  809998:	6a 14                	push   $0x14
  80999a:	57                   	push   %edi
  80999b:	8d 43 08             	lea    0x8(%ebx),%eax
  80999e:	50                   	push   %eax
  80999f:	e8 03 7a ff ff       	call   8013a7 <memcpy>
  return ipr;
  8099a4:	89 d8                	mov    %ebx,%eax
}
  8099a6:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8099a9:	5b                   	pop    %ebx
  8099aa:	5e                   	pop    %esi
  8099ab:	5f                   	pop    %edi
  8099ac:	c9                   	leave  
  8099ad:	c3                   	ret    

008099ae <ip_reass_dequeue_datagram>:

/**
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  8099ae:	55                   	push   %ebp
  8099af:	89 e5                	mov    %esp,%ebp
  8099b1:	83 ec 08             	sub    $0x8,%esp
  8099b4:	8b 55 08             	mov    0x8(%ebp),%edx
  8099b7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  8099ba:	39 15 20 78 b3 00    	cmp    %edx,0xb37820
  8099c0:	75 09                	jne    8099cb <ip_reass_dequeue_datagram+0x1d>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  8099c2:	8b 02                	mov    (%edx),%eax
  8099c4:	a3 20 78 b3 00       	mov    %eax,0xb37820
  8099c9:	eb 1f                	jmp    8099ea <ip_reass_dequeue_datagram+0x3c>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  8099cb:	85 c9                	test   %ecx,%ecx
  8099cd:	75 17                	jne    8099e6 <ip_reass_dequeue_datagram+0x38>
  8099cf:	83 ec 04             	sub    $0x4,%esp
  8099d2:	68 53 33 81 00       	push   $0x813353
  8099d7:	68 29 01 00 00       	push   $0x129
  8099dc:	68 09 33 81 00       	push   $0x813309
  8099e1:	e8 e6 70 ff ff       	call   800acc <_panic>
    prev->next = ipr->next;
  8099e6:	8b 02                	mov    (%edx),%eax
  8099e8:	89 01                	mov    %eax,(%ecx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  8099ea:	83 ec 08             	sub    $0x8,%esp
  8099ed:	52                   	push   %edx
  8099ee:	6a 05                	push   $0x5
  8099f0:	e8 fc d7 ff ff       	call   8071f1 <memp_free>
}
  8099f5:	c9                   	leave  
  8099f6:	c3                   	ret    

008099f7 <ip_reass_chain_frag_into_datagram_and_validate>:

/**
 * Chain a new pbuf into the pbuf list that composes the datagram.  The pbuf list
 * will grow over time as  new pbufs are rx.
 * Also checks that the datagram passes basic continuity checks (if the last
 * fragment was received at least once).
 * @param root_p points to the 'root' pbuf for the current datagram being assembled.
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  8099f7:	55                   	push   %ebp
  8099f8:	89 e5                	mov    %esp,%ebp
  8099fa:	57                   	push   %edi
  8099fb:	56                   	push   %esi
  8099fc:	53                   	push   %ebx
  8099fd:	83 ec 18             	sub    $0x18,%esp
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  809a00:	bf 00 00 00 00       	mov    $0x0,%edi
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  809a05:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  809a0c:	8b 45 0c             	mov    0xc(%ebp),%eax
  809a0f:	8b 58 04             	mov    0x4(%eax),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  809a12:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  809a16:	50                   	push   %eax
  809a17:	e8 59 0c 00 00       	call   80a675 <ntohs>
  809a1c:	89 c6                	mov    %eax,%esi
  809a1e:	0f b7 03             	movzwl (%ebx),%eax
  809a21:	89 04 24             	mov    %eax,(%esp)
  809a24:	e8 4c 0c 00 00       	call   80a675 <ntohs>
  809a29:	c1 e8 06             	shr    $0x6,%eax
  809a2c:	83 e0 3c             	and    $0x3c,%eax
  809a2f:	66 29 c6             	sub    %ax,%si
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  809a32:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809a36:	89 04 24             	mov    %eax,(%esp)
  809a39:	e8 37 0c 00 00       	call   80a675 <ntohs>
  809a3e:	25 ff 1f 00 00       	and    $0x1fff,%eax
  809a43:	c1 e0 03             	shl    $0x3,%eax

  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
  809a46:	83 c4 10             	add    $0x10,%esp
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  809a49:	8b 55 0c             	mov    0xc(%ebp),%edx
  809a4c:	8b 5a 04             	mov    0x4(%edx),%ebx
  iprh->next_pbuf = NULL;
  809a4f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  iprh->start = offset;
  809a55:	66 89 43 04          	mov    %ax,0x4(%ebx)
  iprh->end = offset + len;
  809a59:	8d 04 06             	lea    (%esi,%eax,1),%eax
  809a5c:	66 89 43 06          	mov    %ax,0x6(%ebx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  809a60:	8b 45 08             	mov    0x8(%ebp),%eax
  809a63:	8b 48 04             	mov    0x4(%eax),%ecx
  809a66:	85 c9                	test   %ecx,%ecx
  809a68:	74 78                	je     809ae2 <ip_reass_chain_frag_into_datagram_and_validate+0xeb>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  809a6a:	8b 51 04             	mov    0x4(%ecx),%edx
    if (iprh->start < iprh_tmp->start) {
  809a6d:	66 8b 43 04          	mov    0x4(%ebx),%ax
  809a71:	66 3b 42 04          	cmp    0x4(%edx),%ax
  809a75:	73 30                	jae    809aa7 <ip_reass_chain_frag_into_datagram_and_validate+0xb0>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  809a77:	89 0b                	mov    %ecx,(%ebx)
      if (iprh_prev != NULL) {
  809a79:	85 ff                	test   %edi,%edi
  809a7b:	74 1f                	je     809a9c <ip_reass_chain_frag_into_datagram_and_validate+0xa5>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  809a7d:	66 3b 47 06          	cmp    0x6(%edi),%ax
  809a81:	0f 82 ad 01 00 00    	jb     809c34 <ip_reass_chain_frag_into_datagram_and_validate+0x23d>
  809a87:	66 8b 43 06          	mov    0x6(%ebx),%ax
  809a8b:	66 3b 42 04          	cmp    0x4(%edx),%ax
  809a8f:	0f 87 9f 01 00 00    	ja     809c34 <ip_reass_chain_frag_into_datagram_and_validate+0x23d>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  809a95:	8b 55 0c             	mov    0xc(%ebp),%edx
  809a98:	89 17                	mov    %edx,(%edi)
  809a9a:	eb 42                	jmp    809ade <ip_reass_chain_frag_into_datagram_and_validate+0xe7>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  809a9c:	8b 55 0c             	mov    0xc(%ebp),%edx
  809a9f:	8b 45 08             	mov    0x8(%ebp),%eax
  809aa2:	89 50 04             	mov    %edx,0x4(%eax)
      }
      break;
  809aa5:	eb 37                	jmp    809ade <ip_reass_chain_frag_into_datagram_and_validate+0xe7>
    } else if(iprh->start == iprh_tmp->start) {
  809aa7:	66 8b 43 04          	mov    0x4(%ebx),%ax
  809aab:	66 3b 42 04          	cmp    0x4(%edx),%ax
  809aaf:	0f 84 7f 01 00 00    	je     809c34 <ip_reass_chain_frag_into_datagram_and_validate+0x23d>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  809ab5:	66 3b 42 06          	cmp    0x6(%edx),%ax
  809ab9:	0f 82 75 01 00 00    	jb     809c34 <ip_reass_chain_frag_into_datagram_and_validate+0x23d>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  809abf:	85 ff                	test   %edi,%edi
  809ac1:	74 11                	je     809ad4 <ip_reass_chain_frag_into_datagram_and_validate+0xdd>
        if (iprh_prev->end != iprh_tmp->start) {
  809ac3:	66 8b 47 06          	mov    0x6(%edi),%ax
  809ac7:	66 3b 42 04          	cmp    0x4(%edx),%ax
  809acb:	74 07                	je     809ad4 <ip_reass_chain_frag_into_datagram_and_validate+0xdd>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  809acd:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  809ad4:	8b 0a                	mov    (%edx),%ecx
    iprh_prev = iprh_tmp;
  809ad6:	89 d7                	mov    %edx,%edi
  809ad8:	85 c9                	test   %ecx,%ecx
  809ada:	75 8e                	jne    809a6a <ip_reass_chain_frag_into_datagram_and_validate+0x73>
  809adc:	eb 04                	jmp    809ae2 <ip_reass_chain_frag_into_datagram_and_validate+0xeb>
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  809ade:	85 c9                	test   %ecx,%ecx
  809ae0:	75 66                	jne    809b48 <ip_reass_chain_frag_into_datagram_and_validate+0x151>
    if (iprh_prev != NULL) {
  809ae2:	85 ff                	test   %edi,%edi
  809ae4:	74 39                	je     809b1f <ip_reass_chain_frag_into_datagram_and_validate+0x128>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  809ae6:	66 8b 47 06          	mov    0x6(%edi),%ax
  809aea:	66 3b 43 04          	cmp    0x4(%ebx),%ax
  809aee:	76 17                	jbe    809b07 <ip_reass_chain_frag_into_datagram_and_validate+0x110>
  809af0:	83 ec 04             	sub    $0x4,%esp
  809af3:	68 6c 33 81 00       	push   $0x81336c
  809af8:	68 83 01 00 00       	push   $0x183
  809afd:	68 09 33 81 00       	push   $0x813309
  809b02:	e8 c5 6f ff ff       	call   800acc <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  809b07:	8b 45 0c             	mov    0xc(%ebp),%eax
  809b0a:	89 07                	mov    %eax,(%edi)
      if (iprh_prev->end != iprh->start) {
  809b0c:	66 8b 47 06          	mov    0x6(%edi),%ax
  809b10:	66 3b 43 04          	cmp    0x4(%ebx),%ax
  809b14:	74 32                	je     809b48 <ip_reass_chain_frag_into_datagram_and_validate+0x151>
        valid = 0;
  809b16:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  809b1d:	eb 29                	jmp    809b48 <ip_reass_chain_frag_into_datagram_and_validate+0x151>
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  809b1f:	8b 55 08             	mov    0x8(%ebp),%edx
  809b22:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
  809b26:	74 17                	je     809b3f <ip_reass_chain_frag_into_datagram_and_validate+0x148>
  809b28:	83 ec 04             	sub    $0x4,%esp
  809b2b:	68 98 33 81 00       	push   $0x813398
  809b30:	68 8c 01 00 00       	push   $0x18c
  809b35:	68 09 33 81 00       	push   $0x813309
  809b3a:	e8 8d 6f ff ff       	call   800acc <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  809b3f:	8b 55 0c             	mov    0xc(%ebp),%edx
  809b42:	8b 45 08             	mov    0x8(%ebp),%eax
  809b45:	89 50 04             	mov    %edx,0x4(%eax)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
    /* and had no wholes so far */
    if (valid) {
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
          if (iprh_prev->end != iprh->start) {
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
          LWIP_ASSERT("sanity check",
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
            iprh->end == ipr->datagram_len);
        }
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
  809b48:	b8 00 00 00 00       	mov    $0x0,%eax
  809b4d:	8b 55 08             	mov    0x8(%ebp),%edx
  809b50:	f6 42 1e 01          	testb  $0x1,0x1e(%edx)
  809b54:	0f 84 00 01 00 00    	je     809c5a <ip_reass_chain_frag_into_datagram_and_validate+0x263>
  809b5a:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  809b5e:	0f 84 cb 00 00 00    	je     809c2f <ip_reass_chain_frag_into_datagram_and_validate+0x238>
  809b64:	8b 42 04             	mov    0x4(%edx),%eax
  809b67:	8b 40 04             	mov    0x4(%eax),%eax
  809b6a:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  809b6f:	74 15                	je     809b86 <ip_reass_chain_frag_into_datagram_and_validate+0x18f>
  809b71:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  809b78:	e9 b2 00 00 00       	jmp    809c2f <ip_reass_chain_frag_into_datagram_and_validate+0x238>
  809b7d:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  809b84:	eb 1d                	jmp    809ba3 <ip_reass_chain_frag_into_datagram_and_validate+0x1ac>
  809b86:	89 df                	mov    %ebx,%edi
  809b88:	8b 0b                	mov    (%ebx),%ecx
  809b8a:	85 c9                	test   %ecx,%ecx
  809b8c:	74 15                	je     809ba3 <ip_reass_chain_frag_into_datagram_and_validate+0x1ac>
  809b8e:	8b 59 04             	mov    0x4(%ecx),%ebx
  809b91:	66 8b 47 06          	mov    0x6(%edi),%ax
  809b95:	66 3b 43 04          	cmp    0x4(%ebx),%ax
  809b99:	75 e2                	jne    809b7d <ip_reass_chain_frag_into_datagram_and_validate+0x186>
  809b9b:	89 df                	mov    %ebx,%edi
  809b9d:	8b 0b                	mov    (%ebx),%ecx
  809b9f:	85 c9                	test   %ecx,%ecx
  809ba1:	75 eb                	jne    809b8e <ip_reass_chain_frag_into_datagram_and_validate+0x197>
  809ba3:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  809ba7:	0f 84 82 00 00 00    	je     809c2f <ip_reass_chain_frag_into_datagram_and_validate+0x238>
  809bad:	8b 45 08             	mov    0x8(%ebp),%eax
  809bb0:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  809bb4:	75 17                	jne    809bcd <ip_reass_chain_frag_into_datagram_and_validate+0x1d6>
  809bb6:	83 ec 04             	sub    $0x4,%esp
  809bb9:	68 8a 33 81 00       	push   $0x81338a
  809bbe:	68 ac 01 00 00       	push   $0x1ac
  809bc3:	68 09 33 81 00       	push   $0x813309
  809bc8:	e8 ff 6e ff ff       	call   800acc <_panic>
  809bcd:	8b 55 08             	mov    0x8(%ebp),%edx
  809bd0:	8b 42 04             	mov    0x4(%edx),%eax
  809bd3:	39 58 04             	cmp    %ebx,0x4(%eax)
  809bd6:	75 17                	jne    809bef <ip_reass_chain_frag_into_datagram_and_validate+0x1f8>
  809bd8:	83 ec 04             	sub    $0x4,%esp
  809bdb:	68 8a 33 81 00       	push   $0x81338a
  809be0:	68 ae 01 00 00       	push   $0x1ae
  809be5:	68 09 33 81 00       	push   $0x813309
  809bea:	e8 dd 6e ff ff       	call   800acc <_panic>
  809bef:	83 3b 00             	cmpl   $0x0,(%ebx)
  809bf2:	74 17                	je     809c0b <ip_reass_chain_frag_into_datagram_and_validate+0x214>
  809bf4:	83 ec 04             	sub    $0x4,%esp
  809bf7:	68 d0 33 81 00       	push   $0x8133d0
  809bfc:	68 b0 01 00 00       	push   $0x1b0
  809c01:	68 09 33 81 00       	push   $0x813309
  809c06:	e8 c1 6e ff ff       	call   800acc <_panic>
  809c0b:	66 8b 43 06          	mov    0x6(%ebx),%ax
  809c0f:	8b 55 08             	mov    0x8(%ebp),%edx
  809c12:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  809c16:	74 17                	je     809c2f <ip_reass_chain_frag_into_datagram_and_validate+0x238>
  809c18:	83 ec 04             	sub    $0x4,%esp
  809c1b:	68 f4 33 81 00       	push   $0x8133f4
  809c20:	68 b2 01 00 00       	push   $0x1b2
  809c25:	68 09 33 81 00       	push   $0x813309
  809c2a:	e8 9d 6e ff ff       	call   800acc <_panic>
  809c2f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  809c32:	eb 26                	jmp    809c5a <ip_reass_chain_frag_into_datagram_and_validate+0x263>
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  809c34:	83 ec 0c             	sub    $0xc,%esp
  809c37:	ff 75 0c             	pushl  0xc(%ebp)
  809c3a:	e8 a9 dd ff ff       	call   8079e8 <pbuf_clen>
  809c3f:	66 0f b6 c0          	movzbw %al,%ax
  809c43:	66 29 05 24 78 b3 00 	sub    %ax,0xb37824
  pbuf_free(new_p);
  809c4a:	83 c4 04             	add    $0x4,%esp
  809c4d:	ff 75 0c             	pushl  0xc(%ebp)
  809c50:	e8 c4 dc ff ff       	call   807919 <pbuf_free>
  return 0;
  809c55:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* IP_REASS_CHECK_OVERLAP */
}
  809c5a:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  809c5d:	5b                   	pop    %ebx
  809c5e:	5e                   	pop    %esi
  809c5f:	5f                   	pop    %edi
  809c60:	c9                   	leave  
  809c61:	c3                   	ret    

00809c62 <ip_reass>:

/**
 * Reassembles incoming IP fragments into an IP datagram.
 *
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  809c62:	55                   	push   %ebp
  809c63:	89 e5                	mov    %esp,%ebp
  809c65:	57                   	push   %edi
  809c66:	56                   	push   %esi
  809c67:	53                   	push   %ebx
  809c68:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *r;
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  809c6b:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  809c72:	8b 45 08             	mov    0x8(%ebp),%eax
  809c75:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  809c78:	0f b7 03             	movzwl (%ebx),%eax
  809c7b:	50                   	push   %eax
  809c7c:	e8 f4 09 00 00       	call   80a675 <ntohs>
  809c81:	c1 e8 06             	shr    $0x6,%eax
  809c84:	83 e0 3c             	and    $0x3c,%eax
  809c87:	83 c4 10             	add    $0x10,%esp
  809c8a:	83 f8 14             	cmp    $0x14,%eax
  809c8d:	0f 85 01 02 00 00    	jne    809e94 <ip_reass+0x232>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  809c93:	83 ec 0c             	sub    $0xc,%esp
  809c96:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809c9a:	50                   	push   %eax
  809c9b:	e8 d5 09 00 00       	call   80a675 <ntohs>
  809ca0:	c1 e0 03             	shl    $0x3,%eax
  809ca3:	66 89 45 f2          	mov    %ax,0xfffffff2(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  809ca7:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  809cab:	89 04 24             	mov    %eax,(%esp)
  809cae:	e8 c2 09 00 00       	call   80a675 <ntohs>
  809cb3:	66 89 45 f0          	mov    %ax,0xfffffff0(%ebp)
  809cb7:	0f b7 03             	movzwl (%ebx),%eax
  809cba:	89 04 24             	mov    %eax,(%esp)
  809cbd:	e8 b3 09 00 00       	call   80a675 <ntohs>
  809cc2:	c1 e8 06             	shr    $0x6,%eax
  809cc5:	83 e0 3c             	and    $0x3c,%eax
  809cc8:	66 29 45 f0          	sub    %ax,0xfffffff0(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  809ccc:	83 c4 04             	add    $0x4,%esp
  809ccf:	ff 75 08             	pushl  0x8(%ebp)
  809cd2:	e8 11 dd ff ff       	call   8079e8 <pbuf_clen>
  809cd7:	89 c7                	mov    %eax,%edi
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  809cd9:	0f b7 05 24 78 b3 00 	movzwl 0xb37824,%eax
  809ce0:	89 fa                	mov    %edi,%edx
  809ce2:	0f b6 f2             	movzbl %dl,%esi
  809ce5:	01 f0                	add    %esi,%eax
  809ce7:	83 c4 10             	add    $0x10,%esp
  809cea:	83 f8 0a             	cmp    $0xa,%eax
  809ced:	7e 27                	jle    809d16 <ip_reass+0xb4>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  809cef:	83 ec 08             	sub    $0x8,%esp
  809cf2:	56                   	push   %esi
  809cf3:	53                   	push   %ebx
  809cf4:	e8 a4 fb ff ff       	call   80989d <ip_reass_remove_oldest_datagram>
  809cf9:	83 c4 10             	add    $0x10,%esp
  809cfc:	85 c0                	test   %eax,%eax
  809cfe:	0f 84 90 01 00 00    	je     809e94 <ip_reass+0x232>
  809d04:	0f b7 05 24 78 b3 00 	movzwl 0xb37824,%eax
  809d0b:	01 f0                	add    %esi,%eax
  809d0d:	83 f8 0a             	cmp    $0xa,%eax
  809d10:	0f 8f 7e 01 00 00    	jg     809e94 <ip_reass+0x232>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
#endif /* IP_REASS_FREE_OLDEST */
    {
      /* No datagram could be freed and still too many pbufs enqueued */
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  809d16:	8b 35 20 78 b3 00    	mov    0xb37820,%esi
  809d1c:	85 f6                	test   %esi,%esi
  809d1e:	74 29                	je     809d49 <ip_reass+0xe7>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  809d20:	8b 46 14             	mov    0x14(%esi),%eax
  809d23:	3b 43 0c             	cmp    0xc(%ebx),%eax
  809d26:	75 12                	jne    809d3a <ip_reass+0xd8>
  809d28:	8b 46 18             	mov    0x18(%esi),%eax
  809d2b:	3b 43 10             	cmp    0x10(%ebx),%eax
  809d2e:	75 0a                	jne    809d3a <ip_reass+0xd8>
  809d30:	66 8b 46 0c          	mov    0xc(%esi),%ax
  809d34:	66 3b 43 04          	cmp    0x4(%ebx),%ax
  809d38:	74 0b                	je     809d45 <ip_reass+0xe3>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
    }
    ipr_prev = ipr;
  809d3a:	89 75 ec             	mov    %esi,0xffffffec(%ebp)
  809d3d:	8b 36                	mov    (%esi),%esi
  809d3f:	85 f6                	test   %esi,%esi
  809d41:	75 dd                	jne    809d20 <ip_reass+0xbe>
  809d43:	eb 04                	jmp    809d49 <ip_reass+0xe7>
  }

  if (ipr == NULL) {
  809d45:	85 f6                	test   %esi,%esi
  809d47:	75 1e                	jne    809d67 <ip_reass+0x105>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
  809d49:	83 ec 08             	sub    $0x8,%esp
  809d4c:	89 fa                	mov    %edi,%edx
  809d4e:	0f b6 c2             	movzbl %dl,%eax
  809d51:	50                   	push   %eax
  809d52:	53                   	push   %ebx
  809d53:	e8 d7 fb ff ff       	call   80992f <ip_reass_enqueue_new_datagram>
  809d58:	89 c6                	mov    %eax,%esi
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
  809d5a:	83 c4 10             	add    $0x10,%esp
  809d5d:	85 c0                	test   %eax,%eax
  809d5f:	0f 84 2f 01 00 00    	je     809e94 <ip_reass+0x232>
      goto nullreturn;
  809d65:	eb 40                	jmp    809da7 <ip_reass+0x145>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  809d67:	83 ec 0c             	sub    $0xc,%esp
  809d6a:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809d6e:	50                   	push   %eax
  809d6f:	e8 01 09 00 00       	call   80a675 <ntohs>
  809d74:	83 c4 10             	add    $0x10,%esp
  809d77:	a9 ff 1f 00 00       	test   $0x1fff,%eax
  809d7c:	75 29                	jne    809da7 <ip_reass+0x145>
  809d7e:	83 ec 0c             	sub    $0xc,%esp
  809d81:	0f b7 46 0e          	movzwl 0xe(%esi),%eax
  809d85:	50                   	push   %eax
  809d86:	e8 ea 08 00 00       	call   80a675 <ntohs>
  809d8b:	83 c4 10             	add    $0x10,%esp
  809d8e:	a9 ff 1f 00 00       	test   $0x1fff,%eax
  809d93:	74 12                	je     809da7 <ip_reass+0x145>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  809d95:	83 ec 04             	sub    $0x4,%esp
  809d98:	6a 14                	push   $0x14
  809d9a:	53                   	push   %ebx
  809d9b:	8d 46 08             	lea    0x8(%esi),%eax
  809d9e:	50                   	push   %eax
  809d9f:	e8 03 76 ff ff       	call   8013a7 <memcpy>
  809da4:	83 c4 10             	add    $0x10,%esp
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  809da7:	89 fa                	mov    %edi,%edx
  809da9:	66 0f b6 c2          	movzbw %dl,%ax
  809dad:	66 01 05 24 78 b3 00 	add    %ax,0xb37824

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  809db4:	83 ec 0c             	sub    $0xc,%esp
  809db7:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809dbb:	50                   	push   %eax
  809dbc:	e8 b4 08 00 00       	call   80a675 <ntohs>
  809dc1:	83 c4 10             	add    $0x10,%esp
  809dc4:	f6 c4 20             	test   $0x20,%ah
  809dc7:	75 0f                	jne    809dd8 <ip_reass+0x176>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  809dc9:	80 4e 1e 01          	orb    $0x1,0x1e(%esi)
    ipr->datagram_len = offset + len;
  809dcd:	66 8b 45 f2          	mov    0xfffffff2(%ebp),%ax
  809dd1:	03 45 f0             	add    0xfffffff0(%ebp),%eax
  809dd4:	66 89 46 1c          	mov    %ax,0x1c(%esi)
    LWIP_DEBUGF(IP_REASS_DEBUG,
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
  809dd8:	83 ec 08             	sub    $0x8,%esp
  809ddb:	ff 75 08             	pushl  0x8(%ebp)
  809dde:	56                   	push   %esi
  809ddf:	e8 13 fc ff ff       	call   8099f7 <ip_reass_chain_frag_into_datagram_and_validate>
  809de4:	83 c4 10             	add    $0x10,%esp
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    IPH_OFFSET_SET(fraghdr, 0);
    IPH_CHKSUM_SET(fraghdr, 0);
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
      iprh = (struct ip_reass_helper*)r->payload;

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);

    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  809de7:	ba 00 00 00 00       	mov    $0x0,%edx
  809dec:	85 c0                	test   %eax,%eax
  809dee:	0f 84 b0 00 00 00    	je     809ea4 <ip_reass+0x242>
  809df4:	66 83 46 1c 14       	addw   $0x14,0x1c(%esi)
  809df9:	8b 46 04             	mov    0x4(%esi),%eax
  809dfc:	8b 40 04             	mov    0x4(%eax),%eax
  809dff:	8b 38                	mov    (%eax),%edi
  809e01:	89 c3                	mov    %eax,%ebx
  809e03:	83 ec 04             	sub    $0x4,%esp
  809e06:	6a 14                	push   $0x14
  809e08:	8d 46 08             	lea    0x8(%esi),%eax
  809e0b:	50                   	push   %eax
  809e0c:	53                   	push   %ebx
  809e0d:	e8 95 75 ff ff       	call   8013a7 <memcpy>
  809e12:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  809e16:	89 04 24             	mov    %eax,(%esp)
  809e19:	e8 41 08 00 00       	call   80a65f <htons>
  809e1e:	66 89 43 02          	mov    %ax,0x2(%ebx)
  809e22:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
  809e28:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
  809e2e:	83 c4 08             	add    $0x8,%esp
  809e31:	6a 14                	push   $0x14
  809e33:	53                   	push   %ebx
  809e34:	e8 0e 05 00 00       	call   80a347 <inet_chksum>
  809e39:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  809e3d:	8b 46 04             	mov    0x4(%esi),%eax
  809e40:	89 45 08             	mov    %eax,0x8(%ebp)
  809e43:	83 c4 10             	add    $0x10,%esp
  809e46:	85 ff                	test   %edi,%edi
  809e48:	74 23                	je     809e6d <ip_reass+0x20b>
  809e4a:	8b 5f 04             	mov    0x4(%edi),%ebx
  809e4d:	83 ec 08             	sub    $0x8,%esp
  809e50:	6a ec                	push   $0xffffffec
  809e52:	57                   	push   %edi
  809e53:	e8 eb d9 ff ff       	call   807843 <pbuf_header>
  809e58:	83 c4 08             	add    $0x8,%esp
  809e5b:	57                   	push   %edi
  809e5c:	ff 75 08             	pushl  0x8(%ebp)
  809e5f:	e8 ac db ff ff       	call   807a10 <pbuf_cat>
  809e64:	8b 3b                	mov    (%ebx),%edi
  809e66:	83 c4 10             	add    $0x10,%esp
  809e69:	85 ff                	test   %edi,%edi
  809e6b:	75 dd                	jne    809e4a <ip_reass+0x1e8>
  809e6d:	83 ec 08             	sub    $0x8,%esp
  809e70:	ff 75 ec             	pushl  0xffffffec(%ebp)
  809e73:	56                   	push   %esi
  809e74:	e8 35 fb ff ff       	call   8099ae <ip_reass_dequeue_datagram>
  809e79:	83 c4 04             	add    $0x4,%esp
  809e7c:	ff 75 08             	pushl  0x8(%ebp)
  809e7f:	e8 64 db ff ff       	call   8079e8 <pbuf_clen>
  809e84:	66 0f b6 c0          	movzbw %al,%ax
  809e88:	66 29 05 24 78 b3 00 	sub    %ax,0xb37824
  809e8f:	8b 55 08             	mov    0x8(%ebp),%edx
  809e92:	eb 10                	jmp    809ea4 <ip_reass+0x242>

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  809e94:	83 ec 0c             	sub    $0xc,%esp
  809e97:	ff 75 08             	pushl  0x8(%ebp)
  809e9a:	e8 7a da ff ff       	call   807919 <pbuf_free>
  return NULL;
  809e9f:	ba 00 00 00 00       	mov    $0x0,%edx
}
  809ea4:	89 d0                	mov    %edx,%eax
  809ea6:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  809ea9:	5b                   	pop    %ebx
  809eaa:	5e                   	pop    %esi
  809eab:	5f                   	pop    %edi
  809eac:	c9                   	leave  
  809ead:	c3                   	ret    

00809eae <ip_frag>:
#endif /* IP_REASSEMBLY */

#if IP_FRAG
#if IP_FRAG_USES_STATIC_BUF
static u8_t buf[LWIP_MEM_ALIGN_SIZE(IP_FRAG_MAX_MTU)];
#endif /* IP_FRAG_USES_STATIC_BUF */

/**
 * Fragment an IP datagram if too large for the netif.
 *
 * Chop the datagram in MTU sized chunks and send them in order
 * by using a fixed size static memory buffer (PBUF_REF) or
 * point PBUF_REFs into p (depending on IP_FRAG_USES_STATIC_BUF).
 *
 * @param p ip packet to send
 * @param netif the netif on which to send
 * @param dest destination ip address to which to send
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  809eae:	55                   	push   %ebp
  809eaf:	89 e5                	mov    %esp,%ebp
  809eb1:	57                   	push   %edi
  809eb2:	56                   	push   %esi
  809eb3:	53                   	push   %ebx
  809eb4:	83 ec 40             	sub    $0x40,%esp
  struct pbuf *rambuf;
#if IP_FRAG_USES_STATIC_BUF
  struct pbuf *header;
#else
  struct pbuf *newpbuf;
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  809eb7:	8b 45 0c             	mov    0xc(%ebp),%eax
  809eba:	66 8b 40 2c          	mov    0x2c(%eax),%ax
  809ebe:	66 89 45 c4          	mov    %ax,0xffffffc4(%ebp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  809ec2:	66 c7 45 bc 14 00    	movw   $0x14,0xffffffbc(%ebp)
  u16_t tmp;
#if !IP_FRAG_USES_STATIC_BUF
  u16_t newpbuflen = 0;
  u16_t left_to_copy;
#endif

  /* Get a RAM based MTU sized pbuf */
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  809ec8:	6a 02                	push   $0x2
  809eca:	6a 00                	push   $0x0
  809ecc:	6a 02                	push   $0x2
  809ece:	e8 b5 d5 ff ff       	call   807488 <pbuf_alloc>
  809ed3:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  if (rambuf == NULL) {
  809ed6:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  809ed9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809ede:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
  809ee2:	0f 84 99 01 00 00    	je     80a081 <ip_frag+0x1d3>
  }
  rambuf->tot_len = rambuf->len = mtu;
  809ee8:	8b 45 c4             	mov    0xffffffc4(%ebp),%eax
  809eeb:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  809eee:	66 89 42 0a          	mov    %ax,0xa(%edx)
  809ef2:	66 89 42 08          	mov    %ax,0x8(%edx)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  809ef6:	b8 43 78 b3 00       	mov    $0xb37843,%eax
  809efb:	83 e0 fc             	and    $0xfffffffc,%eax
  809efe:	89 42 04             	mov    %eax,0x4(%edx)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  809f01:	89 c6                	mov    %eax,%esi
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  809f03:	83 ec 04             	sub    $0x4,%esp
  809f06:	6a 14                	push   $0x14
  809f08:	8b 55 08             	mov    0x8(%ebp),%edx
  809f0b:	ff 72 04             	pushl  0x4(%edx)
  809f0e:	50                   	push   %eax
  809f0f:	e8 93 74 ff ff       	call   8013a7 <memcpy>
#else /* IP_FRAG_USES_STATIC_BUF */
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  809f14:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  809f18:	89 04 24             	mov    %eax,(%esp)
  809f1b:	e8 55 07 00 00       	call   80a675 <ntohs>
  809f20:	89 c3                	mov    %eax,%ebx
  ofo = tmp & IP_OFFMASK;
  809f22:	25 ff 1f 00 00       	and    $0x1fff,%eax
  809f27:	66 89 45 c2          	mov    %ax,0xffffffc2(%ebp)
  omf = tmp & IP_MF;
  809f2b:	81 e3 00 20 00 00    	and    $0x2000,%ebx
  809f31:	66 89 5d c0          	mov    %bx,0xffffffc0(%ebp)

  left = p->tot_len - IP_HLEN;
  809f35:	8b 55 08             	mov    0x8(%ebp),%edx
  809f38:	66 8b 7a 08          	mov    0x8(%edx),%di
  809f3c:	83 ef 14             	sub    $0x14,%edi

  nfb = (mtu - IP_HLEN) / 8;
  809f3f:	0f b7 45 c4          	movzwl 0xffffffc4(%ebp),%eax
  809f43:	89 c2                	mov    %eax,%edx
  809f45:	83 ea 14             	sub    $0x14,%edx
  809f48:	79 03                	jns    809f4d <ip_frag+0x9f>
  809f4a:	8d 50 f3             	lea    0xfffffff3(%eax),%edx
  809f4d:	c1 ea 03             	shr    $0x3,%edx
  809f50:	66 89 55 c8          	mov    %dx,0xffffffc8(%ebp)

  while (left) {
  809f54:	83 c4 10             	add    $0x10,%esp
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
#else /* IP_FRAG_USES_STATIC_BUF */
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    if (rambuf == NULL) {
      return ERR_MEM;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
    iphdr = rambuf->payload;

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
    p->len -= poff;

    left_to_copy = cop;
    while (left_to_copy) {
      newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
      /* Is this pbuf already empty? */
      if (!newpbuflen) {
        p = p->next;
        continue;
      }
      newpbuf = pbuf_alloc(PBUF_RAW, 0, PBUF_REF);
      if (newpbuf == NULL) {
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf->payload = p->payload;
      newpbuf->len = newpbuf->tot_len = newpbuflen;
      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
      left_to_copy -= newpbuflen;
      if (left_to_copy)
        p = p->next;
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    IPH_CHKSUM_SET(iphdr, 0);
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));

#if IP_FRAG_USES_STATIC_BUF
    if (last)
      pbuf_realloc(rambuf, left + IP_HLEN);

    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    if (header != NULL) {
      pbuf_chain(header, rambuf);
      netif->output(netif, header, dest);
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
      return ERR_MEM;
    }
#else /* IP_FRAG_USES_STATIC_BUF */
    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
    IPFRAG_STATS_INC(ip_frag.xmit);

    /* Unfortunately we can't reuse rambuf - the hardware may still be
     * using the buffer. Instead we free it (and the ensuing chain) and
     * recreate it next time round the loop. If we're lucky the hardware
     * will have already sent the packet, the free will really free, and
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  809f57:	66 85 ff             	test   %di,%di
  809f5a:	0f 84 11 01 00 00    	je     80a071 <ip_frag+0x1c3>
  809f60:	0f b7 d7             	movzwl %di,%edx
  809f63:	0f b7 45 c4          	movzwl 0xffffffc4(%ebp),%eax
  809f67:	83 e8 14             	sub    $0x14,%eax
  809f6a:	39 c2                	cmp    %eax,%edx
  809f6c:	0f 9e c0             	setle  %al
  809f6f:	66 0f b6 c0          	movzbw %al,%ax
  809f73:	66 89 45 be          	mov    %ax,0xffffffbe(%ebp)
  809f77:	66 8b 45 c2          	mov    0xffffffc2(%ebp),%ax
  809f7b:	25 ff 1f 00 00       	and    $0x1fff,%eax
  809f80:	8b 5d c0             	mov    0xffffffc0(%ebp),%ebx
  809f83:	09 c3                	or     %eax,%ebx
  809f85:	66 89 7d c6          	mov    %di,0xffffffc6(%ebp)
  809f89:	66 83 7d be 00       	cmpw   $0x0,0xffffffbe(%ebp)
  809f8e:	75 0d                	jne    809f9d <ip_frag+0xef>
  809f90:	80 cf 20             	or     $0x20,%bh
  809f93:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
  809f96:	c1 e0 03             	shl    $0x3,%eax
  809f99:	66 89 45 c6          	mov    %ax,0xffffffc6(%ebp)
  809f9d:	0f b7 45 bc          	movzwl 0xffffffbc(%ebp),%eax
  809fa1:	50                   	push   %eax
  809fa2:	0f b7 45 c6          	movzwl 0xffffffc6(%ebp),%eax
  809fa6:	50                   	push   %eax
  809fa7:	8d 46 14             	lea    0x14(%esi),%eax
  809faa:	50                   	push   %eax
  809fab:	ff 75 08             	pushl  0x8(%ebp)
  809fae:	e8 24 dd ff ff       	call   807cd7 <pbuf_copy_partial>
  809fb3:	66 01 45 bc          	add    %ax,0xffffffbc(%ebp)
  809fb7:	0f b7 c3             	movzwl %bx,%eax
  809fba:	89 04 24             	mov    %eax,(%esp)
  809fbd:	e8 9d 06 00 00       	call   80a65f <htons>
  809fc2:	66 89 46 06          	mov    %ax,0x6(%esi)
  809fc6:	66 8b 45 c6          	mov    0xffffffc6(%ebp),%ax
  809fca:	83 c0 14             	add    $0x14,%eax
  809fcd:	0f b7 c0             	movzwl %ax,%eax
  809fd0:	89 04 24             	mov    %eax,(%esp)
  809fd3:	e8 87 06 00 00       	call   80a65f <htons>
  809fd8:	66 89 46 02          	mov    %ax,0x2(%esi)
  809fdc:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
  809fe2:	83 c4 08             	add    $0x8,%esp
  809fe5:	6a 14                	push   $0x14
  809fe7:	56                   	push   %esi
  809fe8:	e8 5a 03 00 00       	call   80a347 <inet_chksum>
  809fed:	66 89 46 0a          	mov    %ax,0xa(%esi)
  809ff1:	83 c4 10             	add    $0x10,%esp
  809ff4:	66 83 7d be 00       	cmpw   $0x0,0xffffffbe(%ebp)
  809ff9:	74 15                	je     80a010 <ip_frag+0x162>
  809ffb:	83 ec 08             	sub    $0x8,%esp
  809ffe:	8d 47 14             	lea    0x14(%edi),%eax
  80a001:	0f b7 c0             	movzwl %ax,%eax
  80a004:	50                   	push   %eax
  80a005:	ff 75 e4             	pushl  0xffffffe4(%ebp)
  80a008:	e8 15 d7 ff ff       	call   807722 <pbuf_realloc>
  80a00d:	83 c4 10             	add    $0x10,%esp
  80a010:	83 ec 04             	sub    $0x4,%esp
  80a013:	6a 00                	push   $0x0
  80a015:	6a 00                	push   $0x0
  80a017:	6a 02                	push   $0x2
  80a019:	e8 6a d4 ff ff       	call   807488 <pbuf_alloc>
  80a01e:	89 c3                	mov    %eax,%ebx
  80a020:	83 c4 10             	add    $0x10,%esp
  80a023:	85 c0                	test   %eax,%eax
  80a025:	75 12                	jne    80a039 <ip_frag+0x18b>
  80a027:	83 ec 0c             	sub    $0xc,%esp
  80a02a:	ff 75 e4             	pushl  0xffffffe4(%ebp)
  80a02d:	e8 e7 d8 ff ff       	call   807919 <pbuf_free>
  80a032:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a037:	eb 48                	jmp    80a081 <ip_frag+0x1d3>
  80a039:	83 ec 08             	sub    $0x8,%esp
  80a03c:	ff 75 e4             	pushl  0xffffffe4(%ebp)
  80a03f:	50                   	push   %eax
  80a040:	e8 5d da ff ff       	call   807aa2 <pbuf_chain>
  80a045:	83 c4 0c             	add    $0xc,%esp
  80a048:	ff 75 10             	pushl  0x10(%ebp)
  80a04b:	53                   	push   %ebx
  80a04c:	ff 75 0c             	pushl  0xc(%ebp)
  80a04f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a052:	ff 52 14             	call   *0x14(%edx)
  80a055:	89 1c 24             	mov    %ebx,(%esp)
  80a058:	e8 bc d8 ff ff       	call   807919 <pbuf_free>
  80a05d:	83 c4 10             	add    $0x10,%esp
  80a060:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
  80a063:	66 01 45 c2          	add    %ax,0xffffffc2(%ebp)
  80a067:	66 2b 7d c6          	sub    0xffffffc6(%ebp),%di
  80a06b:	0f 85 ef fe ff ff    	jne    809f60 <ip_frag+0xb2>
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  80a071:	83 ec 0c             	sub    $0xc,%esp
  80a074:	ff 75 e4             	pushl  0xffffffe4(%ebp)
  80a077:	e8 9d d8 ff ff       	call   807919 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  80a07c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a081:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80a084:	5b                   	pop    %ebx
  80a085:	5e                   	pop    %esi
  80a086:	5f                   	pop    %edi
  80a087:	c9                   	leave  
  80a088:	c3                   	ret    
  80a089:	00 00                	add    %al,(%eax)
	...

0080a08c <lwip_standard_chksum>:
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  80a08c:	55                   	push   %ebp
  80a08d:	89 e5                	mov    %esp,%ebp
  80a08f:	56                   	push   %esi
  80a090:	53                   	push   %ebx
  80a091:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  80a094:	be 00 00 00 00       	mov    $0x0,%esi
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  80a099:	8b 4d 08             	mov    0x8(%ebp),%ecx
  while (len > 1) {
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  80a09c:	66 83 fb 01          	cmp    $0x1,%bx
  80a0a0:	76 1f                	jbe    80a0c1 <lwip_standard_chksum+0x35>
  80a0a2:	66 0f b6 01          	movzbw (%ecx),%ax
  80a0a6:	89 c2                	mov    %eax,%edx
  80a0a8:	c1 e2 08             	shl    $0x8,%edx
  80a0ab:	41                   	inc    %ecx
  80a0ac:	66 0f b6 01          	movzbw (%ecx),%ax
  80a0b0:	09 c2                	or     %eax,%edx
  80a0b2:	41                   	inc    %ecx
  80a0b3:	0f b7 c2             	movzwl %dx,%eax
  80a0b6:	01 c6                	add    %eax,%esi
  80a0b8:	83 eb 02             	sub    $0x2,%ebx
  80a0bb:	66 83 fb 01          	cmp    $0x1,%bx
  80a0bf:	77 e1                	ja     80a0a2 <lwip_standard_chksum+0x16>
  }
  if (len > 0) {
  80a0c1:	66 85 db             	test   %bx,%bx
  80a0c4:	74 0c                	je     80a0d2 <lwip_standard_chksum+0x46>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  80a0c6:	66 0f b6 11          	movzbw (%ecx),%dx
  80a0ca:	c1 e2 08             	shl    $0x8,%edx
    acc += src;
  80a0cd:	0f b7 c2             	movzwl %dx,%eax
  80a0d0:	01 c6                	add    %eax,%esi
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80a0d2:	89 f2                	mov    %esi,%edx
  80a0d4:	c1 ea 10             	shr    $0x10,%edx
  80a0d7:	89 f0                	mov    %esi,%eax
  80a0d9:	25 ff ff 00 00       	and    $0xffff,%eax
  80a0de:	8d 34 02             	lea    (%edx,%eax,1),%esi
  if ((acc & 0xffff0000) != 0) {
  80a0e1:	f7 c6 00 00 ff ff    	test   $0xffff0000,%esi
  80a0e7:	74 0f                	je     80a0f8 <lwip_standard_chksum+0x6c>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80a0e9:	89 f2                	mov    %esi,%edx
  80a0eb:	c1 ea 10             	shr    $0x10,%edx
  80a0ee:	89 f0                	mov    %esi,%eax
  80a0f0:	25 ff ff 00 00       	and    $0xffff,%eax
  80a0f5:	8d 34 02             	lea    (%edx,%eax,1),%esi
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  80a0f8:	83 ec 0c             	sub    $0xc,%esp
  80a0fb:	0f b7 c6             	movzwl %si,%eax
  80a0fe:	50                   	push   %eax
  80a0ff:	e8 5b 05 00 00       	call   80a65f <htons>
  80a104:	0f b7 c0             	movzwl %ax,%eax
}
  80a107:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80a10a:	5b                   	pop    %ebx
  80a10b:	5e                   	pop    %esi
  80a10c:	c9                   	leave  
  80a10d:	c3                   	ret    

0080a10e <inet_chksum_pseudo>:
#endif

#if (LWIP_CHKSUM_ALGORITHM == 2) /* Alternative version #2 */
/*
 * Curt McDowell
 * Broadcom Corp.
 * csm@broadcom.com
 *
 * IP checksum two bytes at a time with support for
 * unaligned buffer.
 * Works for len up to and including 0x20000.
 * by Curt McDowell, Broadcom Corp. 12/08/2005
 *
 * @param dataptr points to start of data to be summed at any boundary
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum) 
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
  u8_t *pb = dataptr;
  u16_t *ps, t = 0;
  u32_t sum = 0;
  int odd = ((u32_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
    ((u8_t *)&t)[1] = *pb++;
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)pb;
  while (len > 1) {
    sum += *ps++;
    len -= 2;
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
    ((u8_t *)&t)[0] = *(u8_t *)ps;;
  }

  /* Add end bytes */
  sum += t;

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
  sum = FOLD_U32T(sum);

  /* Swap if alignment was odd */
  if (odd) {
    sum = SWAP_BYTES_IN_WORD(sum);
  }

  return sum;
}
#endif

#if (LWIP_CHKSUM_ALGORITHM == 3) /* Alternative version #3 */
/**
 * An optimized checksum routine. Basically, it uses loop-unrolling on
 * the checksum loop, treating the head and tail bytes specially, whereas
 * the inner loop acts on 8 bytes at a time. 
 *
 * @arg start of buffer to be checksummed. May be an odd byte address.
 * @len number of bytes in the buffer to be checksummed.
 * @return host order (!) lwip checksum (non-inverted Internet sum) 
 * 
 * by Curt McDowell, Broadcom Corp. December 8th, 2005
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
  u8_t *pb = dataptr;
  u16_t *ps, t = 0;
  u32_t *pl;
  u32_t sum = 0, tmp;
  /* starts at odd byte address? */
  int odd = ((u32_t)pb & 1);

  if (odd && len > 0) {
    ((u8_t *)&t)[1] = *pb++;
    len--;
  }

  ps = (u16_t *)pb;

  if (((u32_t)ps & 3) && len > 1) {
    sum += *ps++;
    len -= 2;
  }

  pl = (u32_t *)ps;

  while (len > 7)  {
    tmp = sum + *pl++;          /* ping */
    if (tmp < sum) {
      tmp++;                    /* add back carry */
    }

    sum = tmp + *pl++;          /* pong */
    if (sum < tmp) {
      sum++;                    /* add back carry */
    }

    len -= 8;
  }

  /* make room in upper bits */
  sum = FOLD_U32T(sum);

  ps = (u16_t *)pl;

  /* 16-bit aligned word remaining? */
  while (len > 1) {
    sum += *ps++;
    len -= 2;
  }

  /* dangling tail byte remaining? */
  if (len > 0) {                /* include odd byte */
    ((u8_t *)&t)[0] = *(u8_t *)ps;
  }

  sum += t;                     /* add end bytes */

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
  sum = FOLD_U32T(sum);

  if (odd) {
    sum = SWAP_BYTES_IN_WORD(sum);
  }

  return sum;
}
#endif

/* inet_chksum_pseudo:
 *
 * Calculates the pseudo Internet checksum used by TCP and UDP for a pbuf chain.
 * IP addresses are expected to be in network byte order.
 *
 * @param p chain of pbufs over that a checksum should be calculated (ip data part)
 * @param src source ip address (used for checksum of pseudo header)
 * @param dst destination ip address (used for checksum of pseudo header)
 * @param proto ip protocol (used for checksum of pseudo header)
 * @param proto_len length of the ip data part (used for checksum of pseudo header)
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  80a10e:	55                   	push   %ebp
  80a10f:	89 e5                	mov    %esp,%ebp
  80a111:	57                   	push   %edi
  80a112:	56                   	push   %esi
  80a113:	53                   	push   %ebx
  80a114:	83 ec 0c             	sub    $0xc,%esp
  80a117:	0f b6 7d 14          	movzbl 0x14(%ebp),%edi
  80a11b:	8b 45 18             	mov    0x18(%ebp),%eax
  80a11e:	66 89 45 f2          	mov    %ax,0xfffffff2(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  80a122:	be 00 00 00 00       	mov    $0x0,%esi
  swapped = 0;
  80a127:	c6 45 f1 00          	movb   $0x0,0xfffffff1(%ebp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80a12b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a12e:	85 db                	test   %ebx,%ebx
  80a130:	74 4e                	je     80a180 <inet_chksum_pseudo+0x72>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  80a132:	83 ec 08             	sub    $0x8,%esp
  80a135:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a139:	50                   	push   %eax
  80a13a:	ff 73 04             	pushl  0x4(%ebx)
  80a13d:	e8 4a ff ff ff       	call   80a08c <lwip_standard_chksum>
  80a142:	0f b7 c0             	movzwl %ax,%eax
  80a145:	01 c6                	add    %eax,%esi
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  80a147:	89 f2                	mov    %esi,%edx
  80a149:	c1 ea 10             	shr    $0x10,%edx
  80a14c:	89 f0                	mov    %esi,%eax
  80a14e:	25 ff ff 00 00       	and    $0xffff,%eax
  80a153:	8d 34 02             	lea    (%edx,%eax,1),%esi
    if (q->len % 2 != 0) {
  80a156:	83 c4 10             	add    $0x10,%esp
  80a159:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80a15d:	74 1b                	je     80a17a <inet_chksum_pseudo+0x6c>
      swapped = 1 - swapped;
  80a15f:	b0 01                	mov    $0x1,%al
  80a161:	2a 45 f1             	sub    0xfffffff1(%ebp),%al
  80a164:	88 45 f1             	mov    %al,0xfffffff1(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80a167:	89 f0                	mov    %esi,%eax
  80a169:	25 ff 00 00 00       	and    $0xff,%eax
  80a16e:	c1 e0 08             	shl    $0x8,%eax
  80a171:	89 f1                	mov    %esi,%ecx
  80a173:	0f b6 d5             	movzbl %ch,%edx
  80a176:	89 c6                	mov    %eax,%esi
  80a178:	09 d6                	or     %edx,%esi
  80a17a:	8b 1b                	mov    (%ebx),%ebx
  80a17c:	85 db                	test   %ebx,%ebx
  80a17e:	75 b2                	jne    80a132 <inet_chksum_pseudo+0x24>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80a180:	80 7d f1 00          	cmpb   $0x0,0xfffffff1(%ebp)
  80a184:	74 13                	je     80a199 <inet_chksum_pseudo+0x8b>
    acc = SWAP_BYTES_IN_WORD(acc);
  80a186:	89 f0                	mov    %esi,%eax
  80a188:	25 ff 00 00 00       	and    $0xff,%eax
  80a18d:	c1 e0 08             	shl    $0x8,%eax
  80a190:	89 f1                	mov    %esi,%ecx
  80a192:	0f b6 d5             	movzbl %ch,%edx
  80a195:	89 c6                	mov    %eax,%esi
  80a197:	09 d6                	or     %edx,%esi
  }
  acc += (src->addr & 0xffffUL);
  80a199:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a19c:	8b 00                	mov    (%eax),%eax
  80a19e:	0f b7 d0             	movzwl %ax,%edx
  80a1a1:	01 d6                	add    %edx,%esi
  acc += ((src->addr >> 16) & 0xffffUL);
  80a1a3:	c1 e8 10             	shr    $0x10,%eax
  80a1a6:	01 c6                	add    %eax,%esi
  acc += (dest->addr & 0xffffUL);
  80a1a8:	8b 45 10             	mov    0x10(%ebp),%eax
  80a1ab:	8b 00                	mov    (%eax),%eax
  80a1ad:	0f b7 d0             	movzwl %ax,%edx
  80a1b0:	01 d6                	add    %edx,%esi
  acc += ((dest->addr >> 16) & 0xffffUL);
  80a1b2:	c1 e8 10             	shr    $0x10,%eax
  80a1b5:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons((u16_t)proto);
  80a1b7:	83 ec 0c             	sub    $0xc,%esp
  80a1ba:	89 fa                	mov    %edi,%edx
  80a1bc:	0f b6 c2             	movzbl %dl,%eax
  80a1bf:	50                   	push   %eax
  80a1c0:	e8 9a 04 00 00       	call   80a65f <htons>
  80a1c5:	0f b7 c0             	movzwl %ax,%eax
  80a1c8:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons(proto_len);
  80a1ca:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  80a1ce:	89 04 24             	mov    %eax,(%esp)
  80a1d1:	e8 89 04 00 00       	call   80a65f <htons>
  80a1d6:	0f b7 c0             	movzwl %ax,%eax
  80a1d9:	01 c6                	add    %eax,%esi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80a1db:	89 f2                	mov    %esi,%edx
  80a1dd:	c1 ea 10             	shr    $0x10,%edx
  80a1e0:	89 f0                	mov    %esi,%eax
  80a1e2:	25 ff ff 00 00       	and    $0xffff,%eax
  80a1e7:	8d 34 02             	lea    (%edx,%eax,1),%esi
  acc = FOLD_U32T(acc);
  80a1ea:	89 f2                	mov    %esi,%edx
  80a1ec:	c1 ea 10             	shr    $0x10,%edx
  80a1ef:	89 f0                	mov    %esi,%eax
  80a1f1:	25 ff ff 00 00       	and    $0xffff,%eax
  80a1f6:	8d 34 02             	lea    (%edx,%eax,1),%esi
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  80a1f9:	83 c4 10             	add    $0x10,%esp
  return (u16_t)~(acc & 0xffffUL);
  80a1fc:	89 f0                	mov    %esi,%eax
  80a1fe:	f7 d0                	not    %eax
  80a200:	0f b7 c0             	movzwl %ax,%eax
}
  80a203:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80a206:	5b                   	pop    %ebx
  80a207:	5e                   	pop    %esi
  80a208:	5f                   	pop    %edi
  80a209:	c9                   	leave  
  80a20a:	c3                   	ret    

0080a20b <inet_chksum_pseudo_partial>:

/* inet_chksum_pseudo:
 *
 * Calculates the pseudo Internet checksum used by TCP and UDP for a pbuf chain.
 * IP addresses are expected to be in network byte order.
 *
 * @param p chain of pbufs over that a checksum should be calculated (ip data part)
 * @param src source ip address (used for checksum of pseudo header)
 * @param dst destination ip address (used for checksum of pseudo header)
 * @param proto ip protocol (used for checksum of pseudo header)
 * @param proto_len length of the ip data part (used for checksum of pseudo header)
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  80a20b:	55                   	push   %ebp
  80a20c:	89 e5                	mov    %esp,%ebp
  80a20e:	57                   	push   %edi
  80a20f:	56                   	push   %esi
  80a210:	53                   	push   %ebx
  80a211:	83 ec 0c             	sub    $0xc,%esp
  80a214:	8a 45 14             	mov    0x14(%ebp),%al
  80a217:	88 45 f3             	mov    %al,0xfffffff3(%ebp)
  80a21a:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80a21d:	66 89 4d f0          	mov    %cx,0xfffffff0(%ebp)
  80a221:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  80a224:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  swapped = 0;
  80a22b:	c6 45 eb 00          	movb   $0x0,0xffffffeb(%ebp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80a22f:	8b 75 08             	mov    0x8(%ebp),%esi
  80a232:	85 f6                	test   %esi,%esi
  80a234:	0f 84 80 00 00 00    	je     80a2ba <inet_chksum_pseudo_partial+0xaf>
  80a23a:	66 85 ff             	test   %di,%di
  80a23d:	74 7b                	je     80a2ba <inet_chksum_pseudo_partial+0xaf>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  80a23f:	66 8b 5e 0a          	mov    0xa(%esi),%bx
    if (chklen > chksum_len) {
  80a243:	66 39 fb             	cmp    %di,%bx
  80a246:	76 02                	jbe    80a24a <inet_chksum_pseudo_partial+0x3f>
      chklen = chksum_len;
  80a248:	89 fb                	mov    %edi,%ebx
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80a24a:	83 ec 08             	sub    $0x8,%esp
  80a24d:	0f b7 c3             	movzwl %bx,%eax
  80a250:	50                   	push   %eax
  80a251:	ff 76 04             	pushl  0x4(%esi)
  80a254:	e8 33 fe ff ff       	call   80a08c <lwip_standard_chksum>
  80a259:	0f b7 c0             	movzwl %ax,%eax
  80a25c:	01 45 ec             	add    %eax,0xffffffec(%ebp)
    chksum_len -= chklen;
  80a25f:	66 29 df             	sub    %bx,%di
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  80a262:	83 c4 10             	add    $0x10,%esp
  80a265:	66 81 ff fe 7f       	cmp    $0x7ffe,%di
  80a26a:	76 17                	jbe    80a283 <inet_chksum_pseudo_partial+0x78>
  80a26c:	83 ec 04             	sub    $0x4,%esp
  80a26f:	68 21 34 81 00       	push   $0x813421
  80a274:	68 60 01 00 00       	push   $0x160
  80a279:	68 2c 34 81 00       	push   $0x81342c
  80a27e:	e8 49 68 ff ff       	call   800acc <_panic>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  80a283:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  80a286:	c1 ea 10             	shr    $0x10,%edx
  80a289:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  80a28d:	01 c2                	add    %eax,%edx
  80a28f:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
    if (q->len % 2 != 0) {
  80a292:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  80a296:	74 17                	je     80a2af <inet_chksum_pseudo_partial+0xa4>
      swapped = 1 - swapped;
  80a298:	b0 01                	mov    $0x1,%al
  80a29a:	2a 45 eb             	sub    0xffffffeb(%ebp),%al
  80a29d:	88 45 eb             	mov    %al,0xffffffeb(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80a2a0:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  80a2a4:	c1 e0 08             	shl    $0x8,%eax
  80a2a7:	0f b6 d6             	movzbl %dh,%edx
  80a2aa:	09 d0                	or     %edx,%eax
  80a2ac:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  80a2af:	8b 36                	mov    (%esi),%esi
  80a2b1:	85 f6                	test   %esi,%esi
  80a2b3:	74 05                	je     80a2ba <inet_chksum_pseudo_partial+0xaf>
  80a2b5:	66 85 ff             	test   %di,%di
  80a2b8:	75 85                	jne    80a23f <inet_chksum_pseudo_partial+0x34>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80a2ba:	80 7d eb 00          	cmpb   $0x0,0xffffffeb(%ebp)
  80a2be:	74 12                	je     80a2d2 <inet_chksum_pseudo_partial+0xc7>
    acc = SWAP_BYTES_IN_WORD(acc);
  80a2c0:	0f b6 45 ec          	movzbl 0xffffffec(%ebp),%eax
  80a2c4:	c1 e0 08             	shl    $0x8,%eax
  80a2c7:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  80a2ca:	0f b6 d5             	movzbl %ch,%edx
  80a2cd:	09 d0                	or     %edx,%eax
  80a2cf:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  80a2d2:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a2d5:	8b 00                	mov    (%eax),%eax
  80a2d7:	0f b7 d0             	movzwl %ax,%edx
  80a2da:	01 55 ec             	add    %edx,0xffffffec(%ebp)
  acc += ((src->addr >> 16) & 0xffffUL);
  80a2dd:	c1 e8 10             	shr    $0x10,%eax
  80a2e0:	01 45 ec             	add    %eax,0xffffffec(%ebp)
  acc += (dest->addr & 0xffffUL);
  80a2e3:	8b 45 10             	mov    0x10(%ebp),%eax
  80a2e6:	8b 00                	mov    (%eax),%eax
  80a2e8:	0f b7 d0             	movzwl %ax,%edx
  80a2eb:	01 55 ec             	add    %edx,0xffffffec(%ebp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  80a2ee:	c1 e8 10             	shr    $0x10,%eax
  80a2f1:	01 45 ec             	add    %eax,0xffffffec(%ebp)
  acc += (u32_t)htons((u16_t)proto);
  80a2f4:	83 ec 0c             	sub    $0xc,%esp
  80a2f7:	0f b6 45 f3          	movzbl 0xfffffff3(%ebp),%eax
  80a2fb:	50                   	push   %eax
  80a2fc:	e8 5e 03 00 00       	call   80a65f <htons>
  80a301:	0f b7 c0             	movzwl %ax,%eax
  80a304:	01 45 ec             	add    %eax,0xffffffec(%ebp)
  acc += (u32_t)htons(proto_len);
  80a307:	0f b7 45 f0          	movzwl 0xfffffff0(%ebp),%eax
  80a30b:	89 04 24             	mov    %eax,(%esp)
  80a30e:	e8 4c 03 00 00       	call   80a65f <htons>
  80a313:	0f b7 c0             	movzwl %ax,%eax
  80a316:	01 45 ec             	add    %eax,0xffffffec(%ebp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80a319:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  80a31c:	c1 ea 10             	shr    $0x10,%edx
  80a31f:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  80a323:	01 c2                	add    %eax,%edx
  80a325:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
  acc = FOLD_U32T(acc);
  80a328:	c1 ea 10             	shr    $0x10,%edx
  80a32b:	0f b7 45 ec          	movzwl 0xffffffec(%ebp),%eax
  80a32f:	01 c2                	add    %eax,%edx
  80a331:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  80a334:	83 c4 10             	add    $0x10,%esp
  return (u16_t)~(acc & 0xffffUL);
  80a337:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  80a33a:	f7 d0                	not    %eax
  80a33c:	0f b7 c0             	movzwl %ax,%eax
}
  80a33f:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80a342:	5b                   	pop    %ebx
  80a343:	5e                   	pop    %esi
  80a344:	5f                   	pop    %edi
  80a345:	c9                   	leave  
  80a346:	c3                   	ret    

0080a347 <inet_chksum>:

/* inet_chksum:
 *
 * Calculates the Internet checksum over a portion of memory. Used primarily for IP
 * and ICMP.
 *
 * @param dataptr start of the buffer to calculate the checksum (no alignment needed)
 * @param len length of the buffer to calculate the checksum
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  80a347:	55                   	push   %ebp
  80a348:	89 e5                	mov    %esp,%ebp
  80a34a:	83 ec 10             	sub    $0x10,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  80a34d:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  80a351:	50                   	push   %eax
  80a352:	ff 75 08             	pushl  0x8(%ebp)
  80a355:	e8 32 fd ff ff       	call   80a08c <lwip_standard_chksum>
  80a35a:	f7 d0                	not    %eax
  80a35c:	0f b7 c0             	movzwl %ax,%eax
}
  80a35f:	c9                   	leave  
  80a360:	c3                   	ret    

0080a361 <inet_chksum_pbuf>:

/**
 * Calculate a checksum over a chain of pbufs (without pseudo-header, much like
 * inet_chksum only pbufs are used).
 *
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  80a361:	55                   	push   %ebp
  80a362:	89 e5                	mov    %esp,%ebp
  80a364:	56                   	push   %esi
  80a365:	53                   	push   %ebx
  80a366:	83 ec 10             	sub    $0x10,%esp
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  80a369:	be 00 00 00 00       	mov    $0x0,%esi
  swapped = 0;
  80a36e:	c6 45 f7 00          	movb   $0x0,0xfffffff7(%ebp)
  for(q = p; q != NULL; q = q->next) {
  80a372:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a375:	85 db                	test   %ebx,%ebx
  80a377:	74 4e                	je     80a3c7 <inet_chksum_pbuf+0x66>
    acc += LWIP_CHKSUM(q->payload, q->len);
  80a379:	83 ec 08             	sub    $0x8,%esp
  80a37c:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a380:	50                   	push   %eax
  80a381:	ff 73 04             	pushl  0x4(%ebx)
  80a384:	e8 03 fd ff ff       	call   80a08c <lwip_standard_chksum>
  80a389:	0f b7 c0             	movzwl %ax,%eax
  80a38c:	01 c6                	add    %eax,%esi
    acc = FOLD_U32T(acc);
  80a38e:	89 f2                	mov    %esi,%edx
  80a390:	c1 ea 10             	shr    $0x10,%edx
  80a393:	89 f0                	mov    %esi,%eax
  80a395:	25 ff ff 00 00       	and    $0xffff,%eax
  80a39a:	8d 34 02             	lea    (%edx,%eax,1),%esi
    if (q->len % 2 != 0) {
  80a39d:	83 c4 10             	add    $0x10,%esp
  80a3a0:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80a3a4:	74 1b                	je     80a3c1 <inet_chksum_pbuf+0x60>
      swapped = 1 - swapped;
  80a3a6:	b0 01                	mov    $0x1,%al
  80a3a8:	2a 45 f7             	sub    0xfffffff7(%ebp),%al
  80a3ab:	88 45 f7             	mov    %al,0xfffffff7(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80a3ae:	89 f0                	mov    %esi,%eax
  80a3b0:	25 ff 00 00 00       	and    $0xff,%eax
  80a3b5:	c1 e0 08             	shl    $0x8,%eax
  80a3b8:	89 f1                	mov    %esi,%ecx
  80a3ba:	0f b6 d5             	movzbl %ch,%edx
  80a3bd:	89 c6                	mov    %eax,%esi
  80a3bf:	09 d6                	or     %edx,%esi
  80a3c1:	8b 1b                	mov    (%ebx),%ebx
  80a3c3:	85 db                	test   %ebx,%ebx
  80a3c5:	75 b2                	jne    80a379 <inet_chksum_pbuf+0x18>
    }
  }

  if (swapped) {
  80a3c7:	80 7d f7 00          	cmpb   $0x0,0xfffffff7(%ebp)
  80a3cb:	74 13                	je     80a3e0 <inet_chksum_pbuf+0x7f>
    acc = SWAP_BYTES_IN_WORD(acc);
  80a3cd:	89 f0                	mov    %esi,%eax
  80a3cf:	25 ff 00 00 00       	and    $0xff,%eax
  80a3d4:	c1 e0 08             	shl    $0x8,%eax
  80a3d7:	89 f1                	mov    %esi,%ecx
  80a3d9:	0f b6 d5             	movzbl %ch,%edx
  80a3dc:	89 c6                	mov    %eax,%esi
  80a3de:	09 d6                	or     %edx,%esi
  }
  return (u16_t)~(acc & 0xffffUL);
  80a3e0:	89 f0                	mov    %esi,%eax
  80a3e2:	f7 d0                	not    %eax
  80a3e4:	0f b7 c0             	movzwl %ax,%eax
}
  80a3e7:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80a3ea:	5b                   	pop    %ebx
  80a3eb:	5e                   	pop    %esi
  80a3ec:	c9                   	leave  
  80a3ed:	c3                   	ret    
	...

0080a3f0 <inet_addr>:
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  80a3f0:	55                   	push   %ebp
  80a3f1:	89 e5                	mov    %esp,%ebp
  80a3f3:	83 ec 10             	sub    $0x10,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  80a3f6:	8d 45 fc             	lea    0xfffffffc(%ebp),%eax
  80a3f9:	50                   	push   %eax
  80a3fa:	ff 75 08             	pushl  0x8(%ebp)
  80a3fd:	e8 13 00 00 00       	call   80a415 <inet_aton>
  80a402:	83 c4 10             	add    $0x10,%esp
    return (val.s_addr);
  }
  return (INADDR_NONE);
  80a405:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80a40a:	85 c0                	test   %eax,%eax
  80a40c:	74 03                	je     80a411 <inet_addr+0x21>
  80a40e:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
}
  80a411:	89 d0                	mov    %edx,%eax
  80a413:	c9                   	leave  
  80a414:	c3                   	ret    

0080a415 <inet_aton>:

/**
 * Check whether "cp" is a valid ascii representation
 * of an Internet address and convert to a binary address.
 * Returns 1 if the address is valid, 0 if not.
 * This replaces inet_addr, the return value from which
 * cannot distinguish between failure and a local broadcast address.
 *
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  80a415:	55                   	push   %ebp
  80a416:	89 e5                	mov    %esp,%ebp
  80a418:	57                   	push   %edi
  80a419:	56                   	push   %esi
  80a41a:	53                   	push   %ebx
  80a41b:	83 ec 2c             	sub    $0x2c,%esp
  80a41e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  80a421:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  80a424:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)

  c = *cp;
  80a427:	0f be 11             	movsbl (%ecx),%edx
  for (;;) {
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  80a42a:	8d 42 d0             	lea    0xffffffd0(%edx),%eax
  80a42d:	3c 09                	cmp    $0x9,%al
  80a42f:	0f 87 4b 01 00 00    	ja     80a580 <inet_aton+0x16b>
      return (0);
    val = 0;
  80a435:	bb 00 00 00 00       	mov    $0x0,%ebx
    base = 10;
  80a43a:	bf 0a 00 00 00       	mov    $0xa,%edi
    if (c == '0') {
  80a43f:	83 fa 30             	cmp    $0x30,%edx
  80a442:	75 1b                	jne    80a45f <inet_aton+0x4a>
      c = *++cp;
  80a444:	41                   	inc    %ecx
  80a445:	0f be 11             	movsbl (%ecx),%edx
      if (c == 'x' || c == 'X') {
  80a448:	83 fa 78             	cmp    $0x78,%edx
  80a44b:	74 09                	je     80a456 <inet_aton+0x41>
        base = 16;
        c = *++cp;
      } else
        base = 8;
  80a44d:	66 bf 08 00          	mov    $0x8,%di
  80a451:	83 fa 58             	cmp    $0x58,%edx
  80a454:	75 09                	jne    80a45f <inet_aton+0x4a>
  80a456:	bf 10 00 00 00       	mov    $0x10,%edi
  80a45b:	41                   	inc    %ecx
  80a45c:	0f be 11             	movsbl (%ecx),%edx
    }
    for (;;) {
      if (isdigit(c)) {
  80a45f:	8d 42 d0             	lea    0xffffffd0(%edx),%eax
  80a462:	3c 09                	cmp    $0x9,%al
  80a464:	77 0f                	ja     80a475 <inet_aton+0x60>
        val = (val * base) + (int)(c - '0');
  80a466:	89 d8                	mov    %ebx,%eax
  80a468:	0f af c7             	imul   %edi,%eax
  80a46b:	8d 5c 10 d0          	lea    0xffffffd0(%eax,%edx,1),%ebx
        c = *++cp;
  80a46f:	41                   	inc    %ecx
  80a470:	0f be 11             	movsbl (%ecx),%edx
  80a473:	eb ea                	jmp    80a45f <inet_aton+0x4a>
      } else if (base == 16 && isxdigit(c)) {
  80a475:	83 ff 10             	cmp    $0x10,%edi
  80a478:	75 36                	jne    80a4b0 <inet_aton+0x9b>
  80a47a:	8d 42 d0             	lea    0xffffffd0(%edx),%eax
  80a47d:	3c 09                	cmp    $0x9,%al
  80a47f:	76 0e                	jbe    80a48f <inet_aton+0x7a>
  80a481:	8d 42 9f             	lea    0xffffff9f(%edx),%eax
  80a484:	3c 05                	cmp    $0x5,%al
  80a486:	76 07                	jbe    80a48f <inet_aton+0x7a>
  80a488:	8d 42 bf             	lea    0xffffffbf(%edx),%eax
  80a48b:	3c 05                	cmp    $0x5,%al
  80a48d:	77 21                	ja     80a4b0 <inet_aton+0x9b>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  80a48f:	89 de                	mov    %ebx,%esi
  80a491:	c1 e6 04             	shl    $0x4,%esi
  80a494:	8d 5a 0a             	lea    0xa(%edx),%ebx
  80a497:	8d 42 9f             	lea    0xffffff9f(%edx),%eax
  80a49a:	3c 19                	cmp    $0x19,%al
  80a49c:	77 05                	ja     80a4a3 <inet_aton+0x8e>
  80a49e:	8d 42 a9             	lea    0xffffffa9(%edx),%eax
  80a4a1:	eb 03                	jmp    80a4a6 <inet_aton+0x91>
  80a4a3:	8d 43 bf             	lea    0xffffffbf(%ebx),%eax
  80a4a6:	89 f3                	mov    %esi,%ebx
  80a4a8:	09 c3                	or     %eax,%ebx
        c = *++cp;
  80a4aa:	41                   	inc    %ecx
  80a4ab:	0f be 11             	movsbl (%ecx),%edx
  80a4ae:	eb af                	jmp    80a45f <inet_aton+0x4a>
      } else
        break;
    }
    if (c == '.') {
  80a4b0:	83 fa 2e             	cmp    $0x2e,%edx
  80a4b3:	75 20                	jne    80a4d5 <inet_aton+0xc0>
      /*
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  80a4b5:	8d 45 e4             	lea    0xffffffe4(%ebp),%eax
  80a4b8:	3b 45 d4             	cmp    0xffffffd4(%ebp),%eax
  80a4bb:	0f 86 c6 00 00 00    	jbe    80a587 <inet_aton+0x172>
        return (0);
      *pp++ = val;
  80a4c1:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
  80a4c4:	89 1a                	mov    %ebx,(%edx)
  80a4c6:	83 c2 04             	add    $0x4,%edx
  80a4c9:	89 55 d4             	mov    %edx,0xffffffd4(%ebp)
      c = *++cp;
  80a4cc:	41                   	inc    %ecx
  80a4cd:	0f be 11             	movsbl (%ecx),%edx
  80a4d0:	e9 55 ff ff ff       	jmp    80a42a <inet_aton+0x15>
    } else
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  80a4d5:	85 d2                	test   %edx,%edx
  80a4d7:	74 2f                	je     80a508 <inet_aton+0xf3>
  80a4d9:	8d 42 e0             	lea    0xffffffe0(%edx),%eax
  80a4dc:	3c 5f                	cmp    $0x5f,%al
  80a4de:	77 1e                	ja     80a4fe <inet_aton+0xe9>
  80a4e0:	83 fa 20             	cmp    $0x20,%edx
  80a4e3:	74 23                	je     80a508 <inet_aton+0xf3>
  80a4e5:	83 fa 0c             	cmp    $0xc,%edx
  80a4e8:	74 1e                	je     80a508 <inet_aton+0xf3>
  80a4ea:	83 fa 0a             	cmp    $0xa,%edx
  80a4ed:	74 19                	je     80a508 <inet_aton+0xf3>
  80a4ef:	83 fa 0d             	cmp    $0xd,%edx
  80a4f2:	74 14                	je     80a508 <inet_aton+0xf3>
  80a4f4:	83 fa 09             	cmp    $0x9,%edx
  80a4f7:	74 0f                	je     80a508 <inet_aton+0xf3>
  80a4f9:	83 fa 0b             	cmp    $0xb,%edx
  80a4fc:	74 0a                	je     80a508 <inet_aton+0xf3>
    return (0);
  80a4fe:	ba 00 00 00 00       	mov    $0x0,%edx
  80a503:	e9 ba 00 00 00       	jmp    80a5c2 <inet_aton+0x1ad>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  80a508:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  80a50b:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
  80a50e:	29 c2                	sub    %eax,%edx
  80a510:	89 d0                	mov    %edx,%eax
  80a512:	c1 f8 02             	sar    $0x2,%eax
  80a515:	40                   	inc    %eax
  switch (n) {
  80a516:	83 f8 02             	cmp    $0x2,%eax
  80a519:	74 20                	je     80a53b <inet_aton+0x126>
  80a51b:	83 f8 02             	cmp    $0x2,%eax
  80a51e:	7f 0f                	jg     80a52f <inet_aton+0x11a>

  case 0:
    return (0);       /* initial nondigit */
  80a520:	ba 00 00 00 00       	mov    $0x0,%edx
  80a525:	85 c0                	test   %eax,%eax
  80a527:	0f 84 95 00 00 00    	je     80a5c2 <inet_aton+0x1ad>
  80a52d:	eb 77                	jmp    80a5a6 <inet_aton+0x191>
  80a52f:	83 f8 03             	cmp    $0x3,%eax
  80a532:	74 1e                	je     80a552 <inet_aton+0x13d>
  80a534:	83 f8 04             	cmp    $0x4,%eax
  80a537:	74 38                	je     80a571 <inet_aton+0x15c>
  80a539:	eb 6b                	jmp    80a5a6 <inet_aton+0x191>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
      return (0);
  80a53b:	ba 00 00 00 00       	mov    $0x0,%edx
  80a540:	81 fb ff ff ff 00    	cmp    $0xffffff,%ebx
  80a546:	77 7a                	ja     80a5c2 <inet_aton+0x1ad>
    val |= parts[0] << 24;
  80a548:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  80a54b:	c1 e0 18             	shl    $0x18,%eax
  80a54e:	09 c3                	or     %eax,%ebx
    break;
  80a550:	eb 54                	jmp    80a5a6 <inet_aton+0x191>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
      return (0);
  80a552:	ba 00 00 00 00       	mov    $0x0,%edx
  80a557:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  80a55d:	77 63                	ja     80a5c2 <inet_aton+0x1ad>
    val |= (parts[0] << 24) | (parts[1] << 16);
  80a55f:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
  80a562:	c1 e2 18             	shl    $0x18,%edx
  80a565:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  80a568:	c1 e0 10             	shl    $0x10,%eax
  80a56b:	09 c2                	or     %eax,%edx
  80a56d:	09 d3                	or     %edx,%ebx
    break;
  80a56f:	eb 35                	jmp    80a5a6 <inet_aton+0x191>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
      return (0);
  80a571:	ba 00 00 00 00       	mov    $0x0,%edx
  80a576:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  80a57c:	77 44                	ja     80a5c2 <inet_aton+0x1ad>
  80a57e:	eb 0e                	jmp    80a58e <inet_aton+0x179>
  80a580:	ba 00 00 00 00       	mov    $0x0,%edx
  80a585:	eb 3b                	jmp    80a5c2 <inet_aton+0x1ad>
  80a587:	ba 00 00 00 00       	mov    $0x0,%edx
  80a58c:	eb 34                	jmp    80a5c2 <inet_aton+0x1ad>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  80a58e:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  80a591:	c1 e0 18             	shl    $0x18,%eax
  80a594:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  80a597:	c1 e2 10             	shl    $0x10,%edx
  80a59a:	09 d0                	or     %edx,%eax
  80a59c:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  80a59f:	c1 e2 08             	shl    $0x8,%edx
  80a5a2:	09 d0                	or     %edx,%eax
  80a5a4:	09 c3                	or     %eax,%ebx
    break;
  }
  if (addr)
  80a5a6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80a5aa:	74 11                	je     80a5bd <inet_aton+0x1a8>
    addr->s_addr = htonl(val);
  80a5ac:	83 ec 0c             	sub    $0xc,%esp
  80a5af:	53                   	push   %ebx
  80a5b0:	e8 d5 00 00 00       	call   80a68a <htonl>
  80a5b5:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a5b8:	89 02                	mov    %eax,(%edx)
  80a5ba:	83 c4 10             	add    $0x10,%esp
  return (1);
  80a5bd:	ba 01 00 00 00       	mov    $0x1,%edx
}
  80a5c2:	89 d0                	mov    %edx,%eax
  80a5c4:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80a5c7:	5b                   	pop    %ebx
  80a5c8:	5e                   	pop    %esi
  80a5c9:	5f                   	pop    %edi
  80a5ca:	c9                   	leave  
  80a5cb:	c3                   	ret    

0080a5cc <inet_ntoa>:

/**
 * Convert numeric IP address into decimal dotted ASCII representation.
 * returns ptr to static buffer; not reentrant!
 *
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  80a5cc:	55                   	push   %ebp
  80a5cd:	89 e5                	mov    %esp,%ebp
  80a5cf:	57                   	push   %edi
  80a5d0:	56                   	push   %esi
  80a5d1:	53                   	push   %ebx
  80a5d2:	83 ec 3c             	sub    $0x3c,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  80a5d5:	8b 45 08             	mov    0x8(%ebp),%eax
  80a5d8:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  char inv[3];
  char *rp;
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  80a5db:	be 1c 7e b3 00       	mov    $0xb37e1c,%esi
  ap = (u8_t *)&s_addr;
  80a5e0:	8d 7d d4             	lea    0xffffffd4(%ebp),%edi
  for(n = 0; n < 4; n++) {
  80a5e3:	c6 45 d3 00          	movb   $0x0,0xffffffd3(%ebp)
    i = 0;
  80a5e7:	b3 00                	mov    $0x0,%bl
    do {
      rem = *ap % (u8_t)10;
  80a5e9:	66 0f b6 07          	movzbw (%edi),%ax
  80a5ed:	66 89 45 c4          	mov    %ax,0xffffffc4(%ebp)
  80a5f1:	ba 00 00 00 00       	mov    $0x0,%edx
  80a5f6:	b9 0a 00 00 00       	mov    $0xa,%ecx
  80a5fb:	66 f7 f1             	div    %cx
  80a5fe:	66 89 55 c6          	mov    %dx,0xffffffc6(%ebp)
      *ap /= (u8_t)10;
  80a602:	8b 55 c4             	mov    0xffffffc4(%ebp),%edx
  80a605:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80a608:	8d 04 c2             	lea    (%edx,%eax,8),%eax
  80a60b:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a60e:	66 c1 e8 08          	shr    $0x8,%ax
  80a612:	c0 e8 03             	shr    $0x3,%al
  80a615:	88 07                	mov    %al,(%edi)
      inv[i++] = '0' + rem;
  80a617:	0f b6 c3             	movzbl %bl,%eax
  80a61a:	8a 4d c6             	mov    0xffffffc6(%ebp),%cl
  80a61d:	83 c1 30             	add    $0x30,%ecx
  80a620:	88 4c 05 d8          	mov    %cl,0xffffffd8(%ebp,%eax,1)
  80a624:	43                   	inc    %ebx
    } while(*ap);
  80a625:	80 3f 00             	cmpb   $0x0,(%edi)
  80a628:	75 bf                	jne    80a5e9 <inet_ntoa+0x1d>
    while(i--)
      *rp++ = inv[i];
  80a62a:	4b                   	dec    %ebx
  80a62b:	80 fb ff             	cmp    $0xff,%bl
  80a62e:	74 10                	je     80a640 <inet_ntoa+0x74>
  80a630:	0f b6 c3             	movzbl %bl,%eax
  80a633:	8a 44 05 d8          	mov    0xffffffd8(%ebp,%eax,1),%al
  80a637:	88 06                	mov    %al,(%esi)
  80a639:	46                   	inc    %esi
  80a63a:	4b                   	dec    %ebx
  80a63b:	80 fb ff             	cmp    $0xff,%bl
  80a63e:	75 f0                	jne    80a630 <inet_ntoa+0x64>
    *rp++ = '.';
  80a640:	c6 06 2e             	movb   $0x2e,(%esi)
  80a643:	46                   	inc    %esi
    ap++;
  80a644:	47                   	inc    %edi
  80a645:	fe 45 d3             	incb   0xffffffd3(%ebp)
  80a648:	80 7d d3 03          	cmpb   $0x3,0xffffffd3(%ebp)
  80a64c:	76 99                	jbe    80a5e7 <inet_ntoa+0x1b>
  }
  *--rp = 0;
  80a64e:	c6 46 ff 00          	movb   $0x0,0xffffffff(%esi)
  return str;
}
  80a652:	b8 1c 7e b3 00       	mov    $0xb37e1c,%eax
  80a657:	83 c4 3c             	add    $0x3c,%esp
  80a65a:	5b                   	pop    %ebx
  80a65b:	5e                   	pop    %esi
  80a65c:	5f                   	pop    %edi
  80a65d:	c9                   	leave  
  80a65e:	c3                   	ret    

0080a65f <htons>:

/**
 * These are reference implementations of the byte swapping functions.
 * Again with the aim of being simple, correct and fully portable.
 * Byte swapping is the second thing you would want to optimize. You will
 * need to port it to your architecture and in your cc.h:
 * 
 * #define LWIP_PLATFORM_BYTESWAP 1
 * #define LWIP_PLATFORM_HTONS(x) <your_htons>
 * #define LWIP_PLATFORM_HTONL(x) <your_htonl>
 *
 * Note ntohs() and ntohl() are merely references to the htonx counterparts.
 */

#if (LWIP_PLATFORM_BYTESWAP == 0) && (BYTE_ORDER == LITTLE_ENDIAN)

/**
 * Convert an u16_t from host- to network byte order.
 *
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  80a65f:	55                   	push   %ebp
  80a660:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  80a662:	0f b7 55 08          	movzwl 0x8(%ebp),%edx
  80a666:	89 d0                	mov    %edx,%eax
  80a668:	c1 e0 08             	shl    $0x8,%eax
  80a66b:	c1 ea 08             	shr    $0x8,%edx
  80a66e:	09 d0                	or     %edx,%eax
  80a670:	0f b7 c0             	movzwl %ax,%eax
}
  80a673:	c9                   	leave  
  80a674:	c3                   	ret    

0080a675 <ntohs>:

/**
 * Convert an u16_t from network- to host byte order.
 *
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  80a675:	55                   	push   %ebp
  80a676:	89 e5                	mov    %esp,%ebp
  return htons(n);
  80a678:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80a67c:	50                   	push   %eax
  80a67d:	e8 dd ff ff ff       	call   80a65f <htons>
  80a682:	83 c4 04             	add    $0x4,%esp
  80a685:	0f b7 c0             	movzwl %ax,%eax
}
  80a688:	c9                   	leave  
  80a689:	c3                   	ret    

0080a68a <htonl>:

/**
 * Convert an u32_t from host- to network byte order.
 *
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  80a68a:	55                   	push   %ebp
  80a68b:	89 e5                	mov    %esp,%ebp
  80a68d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  return ((n & 0xff) << 24) |
  80a690:	89 c8                	mov    %ecx,%eax
  80a692:	c1 e0 18             	shl    $0x18,%eax
  80a695:	89 ca                	mov    %ecx,%edx
  80a697:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  80a69d:	c1 e2 08             	shl    $0x8,%edx
  80a6a0:	09 d0                	or     %edx,%eax
  80a6a2:	89 ca                	mov    %ecx,%edx
  80a6a4:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  80a6aa:	c1 ea 08             	shr    $0x8,%edx
  80a6ad:	09 d0                	or     %edx,%eax
  80a6af:	c1 e9 18             	shr    $0x18,%ecx
  80a6b2:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  80a6b4:	c9                   	leave  
  80a6b5:	c3                   	ret    

0080a6b6 <ntohl>:

/**
 * Convert an u32_t from network- to host byte order.
 *
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  80a6b6:	55                   	push   %ebp
  80a6b7:	89 e5                	mov    %esp,%ebp
  return htonl(n);
  80a6b9:	ff 75 08             	pushl  0x8(%ebp)
  80a6bc:	e8 c9 ff ff ff       	call   80a68a <htonl>
  80a6c1:	83 c4 04             	add    $0x4,%esp
}
  80a6c4:	c9                   	leave  
  80a6c5:	c3                   	ret    
	...

0080a6c8 <tcp_send_ctrl>:
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  80a6c8:	55                   	push   %ebp
  80a6c9:	89 e5                	mov    %esp,%ebp
  80a6cb:	83 ec 0c             	sub    $0xc,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  80a6ce:	6a 00                	push   $0x0
  80a6d0:	6a 00                	push   $0x0
  80a6d2:	6a 01                	push   $0x1
  80a6d4:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  80a6d8:	50                   	push   %eax
  80a6d9:	6a 00                	push   $0x0
  80a6db:	6a 00                	push   $0x0
  80a6dd:	ff 75 08             	pushl  0x8(%ebp)
  80a6e0:	e8 5e 00 00 00       	call   80a743 <tcp_enqueue>
  80a6e5:	0f be c0             	movsbl %al,%eax
}
  80a6e8:	c9                   	leave  
  80a6e9:	c3                   	ret    

0080a6ea <tcp_write>:

/**
 * Write data for sending (but does not send it immediately).
 *
 * It waits in the expectation of more data being sent soon (as
 * it can send them more efficiently by combining them together).
 * To prompt the system to send data now, call tcp_output() after
 * calling tcp_write().
 * 
 * @param pcb Protocol control block of the TCP connection to enqueue data for.
 * @param data pointer to the data to send
 * @param len length (in bytes) of the data to send
 * @param apiflags combination of following flags :
 * - TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  80a6ea:	55                   	push   %ebp
  80a6eb:	89 e5                	mov    %esp,%ebp
  80a6ed:	53                   	push   %ebx
  80a6ee:	83 ec 04             	sub    $0x4,%esp
  80a6f1:	8b 55 08             	mov    0x8(%ebp),%edx
  80a6f4:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80a6f7:	8a 5d 14             	mov    0x14(%ebp),%bl
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  80a6fa:	83 7a 10 04          	cmpl   $0x4,0x10(%edx)
  80a6fe:	74 17                	je     80a717 <tcp_write+0x2d>
  80a700:	83 7a 10 07          	cmpl   $0x7,0x10(%edx)
  80a704:	74 11                	je     80a717 <tcp_write+0x2d>
  80a706:	83 7a 10 02          	cmpl   $0x2,0x10(%edx)
  80a70a:	74 0b                	je     80a717 <tcp_write+0x2d>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
    }
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  80a70c:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  80a711:	83 7a 10 03          	cmpl   $0x3,0x10(%edx)
  80a715:	75 27                	jne    80a73e <tcp_write+0x54>
  80a717:	b8 00 00 00 00       	mov    $0x0,%eax
  80a71c:	66 85 c9             	test   %cx,%cx
  80a71f:	74 1d                	je     80a73e <tcp_write+0x54>
  80a721:	83 ec 04             	sub    $0x4,%esp
  80a724:	6a 00                	push   $0x0
  80a726:	6a 00                	push   $0x0
  80a728:	0f b6 c3             	movzbl %bl,%eax
  80a72b:	50                   	push   %eax
  80a72c:	6a 00                	push   $0x0
  80a72e:	0f b7 c1             	movzwl %cx,%eax
  80a731:	50                   	push   %eax
  80a732:	ff 75 0c             	pushl  0xc(%ebp)
  80a735:	52                   	push   %edx
  80a736:	e8 08 00 00 00       	call   80a743 <tcp_enqueue>
  80a73b:	0f be c0             	movsbl %al,%eax
  }
}
  80a73e:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80a741:	c9                   	leave  
  80a742:	c3                   	ret    

0080a743 <tcp_enqueue>:

/**
 * Enqueue either data or TCP options (but not both) for tranmission
 *
 * Called by tcp_connect(), tcp_listen_input(), tcp_send_ctrl() and tcp_write().
 *
 * @param pcb Protocol control block for the TCP connection to enqueue data for.
 * @param arg Pointer to the data to be enqueued for sending.
 * @param len Data length in bytes
 * @param flags tcp header flags to set in the outgoing segment
 * @param apiflags combination of following flags :
 * - TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @param optdata
 * @param optlen
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  80a743:	55                   	push   %ebp
  80a744:	89 e5                	mov    %esp,%ebp
  80a746:	57                   	push   %edi
  80a747:	56                   	push   %esi
  80a748:	53                   	push   %ebx
  80a749:	83 ec 2c             	sub    $0x2c,%esp
  80a74c:	8b 45 10             	mov    0x10(%ebp),%eax
  80a74f:	66 89 45 f2          	mov    %ax,0xfffffff2(%ebp)
  80a753:	8a 55 14             	mov    0x14(%ebp),%dl
  80a756:	88 55 f1             	mov    %dl,0xfffffff1(%ebp)
  80a759:	8a 4d 18             	mov    0x18(%ebp),%cl
  80a75c:	88 4d f0             	mov    %cl,0xfffffff0(%ebp)
  80a75f:	8a 45 20             	mov    0x20(%ebp),%al
  80a762:	88 45 ef             	mov    %al,0xffffffef(%ebp)
  struct pbuf *p;
  struct tcp_seg *seg, *useg, *queue;
  u32_t seqno;
  u16_t left, seglen;
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  80a765:	66 83 7d f2 00       	cmpw   $0x0,0xfffffff2(%ebp)
  80a76a:	74 1b                	je     80a787 <tcp_enqueue+0x44>
  80a76c:	84 c0                	test   %al,%al
  80a76e:	74 17                	je     80a787 <tcp_enqueue+0x44>
  80a770:	83 ec 04             	sub    $0x4,%esp
  80a773:	68 50 34 81 00       	push   $0x813450
  80a778:	68 90 00 00 00       	push   $0x90
  80a77d:	68 f2 35 81 00       	push   $0x8135f2
  80a782:	e8 45 63 ff ff       	call   800acc <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  80a787:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80a78b:	74 1d                	je     80a7aa <tcp_enqueue+0x67>
  80a78d:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80a791:	74 17                	je     80a7aa <tcp_enqueue+0x67>
  80a793:	83 ec 04             	sub    $0x4,%esp
  80a796:	68 90 34 81 00       	push   $0x813490
  80a79b:	68 92 00 00 00       	push   $0x92
  80a7a0:	68 f2 35 81 00       	push   $0x8135f2
  80a7a5:	e8 22 63 ff ff       	call   800acc <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  80a7aa:	66 8b 4d f2          	mov    0xfffffff2(%ebp),%cx
  80a7ae:	8b 55 08             	mov    0x8(%ebp),%edx
  80a7b1:	66 39 4a 6e          	cmp    %cx,0x6e(%edx)
  80a7b5:	73 0e                	jae    80a7c5 <tcp_enqueue+0x82>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  80a7b7:	80 4a 20 80          	orb    $0x80,0x20(%edx)
    return ERR_MEM;
  80a7bb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a7c0:	e9 e5 05 00 00       	jmp    80adaa <tcp_enqueue+0x667>
  }
  left = len;
  80a7c5:	66 8b 45 f2          	mov    0xfffffff2(%ebp),%ax
  80a7c9:	66 89 45 de          	mov    %ax,0xffffffde(%ebp)
  ptr = arg;
  80a7cd:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a7d0:	89 55 d8             	mov    %edx,0xffffffd8(%ebp)

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  80a7d3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a7d6:	8b 49 68             	mov    0x68(%ecx),%ecx
  80a7d9:	89 4d e0             	mov    %ecx,0xffffffe0(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  80a7dc:	8b 45 08             	mov    0x8(%ebp),%eax
  80a7df:	66 8b 40 70          	mov    0x70(%eax),%ax
  80a7e3:	66 89 45 d6          	mov    %ax,0xffffffd6(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80a7e7:	66 83 f8 1f          	cmp    $0x1f,%ax
  80a7eb:	76 11                	jbe    80a7fe <tcp_enqueue+0xbb>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  80a7ed:	8b 55 08             	mov    0x8(%ebp),%edx
  80a7f0:	80 4a 20 80          	orb    $0x80,0x20(%edx)
    return ERR_MEM;
  80a7f4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a7f9:	e9 ac 05 00 00       	jmp    80adaa <tcp_enqueue+0x667>
  }
  if (queuelen != 0) {
  80a7fe:	66 83 7d d6 00       	cmpw   $0x0,0xffffffd6(%ebp)
  80a803:	74 26                	je     80a82b <tcp_enqueue+0xe8>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80a805:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a808:	83 79 78 00          	cmpl   $0x0,0x78(%ecx)
  80a80c:	75 43                	jne    80a851 <tcp_enqueue+0x10e>
  80a80e:	83 79 74 00          	cmpl   $0x0,0x74(%ecx)
  80a812:	75 3d                	jne    80a851 <tcp_enqueue+0x10e>
  80a814:	83 ec 04             	sub    $0x4,%esp
  80a817:	68 d8 34 81 00       	push   $0x8134d8
  80a81c:	68 ae 00 00 00       	push   $0xae
  80a821:	68 f2 35 81 00       	push   $0x8135f2
  80a826:	e8 a1 62 ff ff       	call   800acc <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  80a82b:	8b 45 08             	mov    0x8(%ebp),%eax
  80a82e:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80a832:	75 06                	jne    80a83a <tcp_enqueue+0xf7>
  80a834:	83 78 74 00          	cmpl   $0x0,0x74(%eax)
  80a838:	74 17                	je     80a851 <tcp_enqueue+0x10e>
  80a83a:	83 ec 04             	sub    $0x4,%esp
  80a83d:	68 14 35 81 00       	push   $0x813514
  80a842:	68 b1 00 00 00       	push   $0xb1
  80a847:	68 f2 35 81 00       	push   $0x8135f2
  80a84c:	e8 7b 62 ff ff       	call   800acc <_panic>
      pcb->unacked == NULL && pcb->unsent == NULL);
  }

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  80a851:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  80a858:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  80a85f:	8a 45 ef             	mov    0xffffffef(%ebp),%al
  80a862:	c0 e8 02             	shr    $0x2,%al
  80a865:	c1 e0 0c             	shl    $0xc,%eax
  80a868:	05 00 50 00 00       	add    $0x5000,%eax
  80a86d:	66 89 45 d4          	mov    %ax,0xffffffd4(%ebp)
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80a871:	8b 55 08             	mov    0x8(%ebp),%edx
  80a874:	66 8b 7a 34          	mov    0x34(%edx),%di
  80a878:	66 3b 7d de          	cmp    0xffffffde(%ebp),%di
  80a87c:	76 04                	jbe    80a882 <tcp_enqueue+0x13f>
  80a87e:	66 8b 7d de          	mov    0xffffffde(%ebp),%di

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80a882:	83 ec 0c             	sub    $0xc,%esp
  80a885:	6a 04                	push   $0x4
  80a887:	e8 0b c9 ff ff       	call   807197 <memp_malloc>
  80a88c:	89 c6                	mov    %eax,%esi
    if (seg == NULL) {
  80a88e:	83 c4 10             	add    $0x10,%esp
  80a891:	85 c0                	test   %eax,%eax
  80a893:	0f 84 c4 04 00 00    	je     80ad5d <tcp_enqueue+0x61a>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  80a899:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  80a89f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  80a8a6:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
  80a8aa:	75 05                	jne    80a8b1 <tcp_enqueue+0x16e>
      queue = seg;
  80a8ac:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  80a8af:	eb 22                	jmp    80a8d3 <tcp_enqueue+0x190>
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  80a8b1:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
  80a8b5:	75 17                	jne    80a8ce <tcp_enqueue+0x18b>
  80a8b7:	83 ec 04             	sub    $0x4,%esp
  80a8ba:	68 0a 36 81 00       	push   $0x81360a
  80a8bf:	68 ce 00 00 00       	push   $0xce
  80a8c4:	68 f2 35 81 00       	push   $0x8135f2
  80a8c9:	e8 fe 61 ff ff       	call   800acc <_panic>
      useg->next = seg;
  80a8ce:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
  80a8d1:	89 01                	mov    %eax,(%ecx)
    }
    /* remember last segment of to-be-queued data for next iteration */
    useg = seg;
  80a8d3:	89 75 e8             	mov    %esi,0xffffffe8(%ebp)

    /* If copy is set, memory should be allocated
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  80a8d6:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80a8da:	74 67                	je     80a943 <tcp_enqueue+0x200>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80a8dc:	83 ec 04             	sub    $0x4,%esp
  80a8df:	6a 00                	push   $0x0
  80a8e1:	0f b6 45 ef          	movzbl 0xffffffef(%ebp),%eax
  80a8e5:	50                   	push   %eax
  80a8e6:	6a 00                	push   $0x0
  80a8e8:	e8 9b cb ff ff       	call   807488 <pbuf_alloc>
  80a8ed:	89 c2                	mov    %eax,%edx
  80a8ef:	89 46 04             	mov    %eax,0x4(%esi)
  80a8f2:	83 c4 10             	add    $0x10,%esp
  80a8f5:	85 c0                	test   %eax,%eax
  80a8f7:	0f 84 60 04 00 00    	je     80ad5d <tcp_enqueue+0x61a>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  80a8fd:	66 0f b6 45 ef       	movzbw 0xffffffef(%ebp),%ax
  80a902:	66 39 42 0a          	cmp    %ax,0xa(%edx)
  80a906:	73 17                	jae    80a91f <tcp_enqueue+0x1dc>
  80a908:	83 ec 04             	sub    $0x4,%esp
  80a90b:	68 48 35 81 00       	push   $0x813548
  80a910:	68 df 00 00 00       	push   $0xdf
  80a915:	68 f2 35 81 00       	push   $0x8135f2
  80a91a:	e8 ad 61 ff ff       	call   800acc <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  80a91f:	83 ec 0c             	sub    $0xc,%esp
  80a922:	ff 76 04             	pushl  0x4(%esi)
  80a925:	e8 be d0 ff ff       	call   8079e8 <pbuf_clen>
  80a92a:	66 0f b6 c0          	movzbw %al,%ax
  80a92e:	66 01 45 d6          	add    %ax,0xffffffd6(%ebp)
      seg->dataptr = seg->p->payload;
  80a932:	8b 46 04             	mov    0x4(%esi),%eax
  80a935:	8b 40 04             	mov    0x4(%eax),%eax
  80a938:	89 46 08             	mov    %eax,0x8(%esi)
  80a93b:	83 c4 10             	add    $0x10,%esp
  80a93e:	e9 f5 00 00 00       	jmp    80aa38 <tcp_enqueue+0x2f5>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  80a943:	f6 45 f0 01          	testb  $0x1,0xfffffff0(%ebp)
  80a947:	74 7a                	je     80a9c3 <tcp_enqueue+0x280>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  80a949:	83 ec 04             	sub    $0x4,%esp
  80a94c:	6a 00                	push   $0x0
  80a94e:	0f b7 c7             	movzwl %di,%eax
  80a951:	50                   	push   %eax
  80a952:	6a 00                	push   $0x0
  80a954:	e8 2f cb ff ff       	call   807488 <pbuf_alloc>
  80a959:	89 46 04             	mov    %eax,0x4(%esi)
  80a95c:	83 c4 10             	add    $0x10,%esp
  80a95f:	85 c0                	test   %eax,%eax
  80a961:	0f 84 f6 03 00 00    	je     80ad5d <tcp_enqueue+0x61a>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  80a967:	66 39 78 0a          	cmp    %di,0xa(%eax)
  80a96b:	73 17                	jae    80a984 <tcp_enqueue+0x241>
  80a96d:	83 ec 04             	sub    $0x4,%esp
  80a970:	68 70 35 81 00       	push   $0x813570
  80a975:	68 ea 00 00 00       	push   $0xea
  80a97a:	68 f2 35 81 00       	push   $0x8135f2
  80a97f:	e8 48 61 ff ff       	call   800acc <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  80a984:	83 ec 0c             	sub    $0xc,%esp
  80a987:	ff 76 04             	pushl  0x4(%esi)
  80a98a:	e8 59 d0 ff ff       	call   8079e8 <pbuf_clen>
  80a98f:	66 0f b6 c0          	movzbw %al,%ax
  80a993:	66 01 45 d6          	add    %ax,0xffffffd6(%ebp)
      if (arg != NULL) {
  80a997:	83 c4 10             	add    $0x10,%esp
  80a99a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80a99e:	74 18                	je     80a9b8 <tcp_enqueue+0x275>
        MEMCPY(seg->p->payload, ptr, seglen);
  80a9a0:	83 ec 04             	sub    $0x4,%esp
  80a9a3:	0f b7 c7             	movzwl %di,%eax
  80a9a6:	50                   	push   %eax
  80a9a7:	ff 75 d8             	pushl  0xffffffd8(%ebp)
  80a9aa:	8b 46 04             	mov    0x4(%esi),%eax
  80a9ad:	ff 70 04             	pushl  0x4(%eax)
  80a9b0:	e8 f2 69 ff ff       	call   8013a7 <memcpy>
  80a9b5:	83 c4 10             	add    $0x10,%esp
      }
      seg->dataptr = seg->p->payload;
  80a9b8:	8b 46 04             	mov    0x4(%esi),%eax
  80a9bb:	8b 40 04             	mov    0x4(%eax),%eax
  80a9be:	89 46 08             	mov    %eax,0x8(%esi)
  80a9c1:	eb 75                	jmp    80aa38 <tcp_enqueue+0x2f5>
    }
    /* do not copy data */
    else {
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  80a9c3:	83 ec 04             	sub    $0x4,%esp
  80a9c6:	6a 01                	push   $0x1
  80a9c8:	0f b7 c7             	movzwl %di,%eax
  80a9cb:	50                   	push   %eax
  80a9cc:	6a 00                	push   $0x0
  80a9ce:	e8 b5 ca ff ff       	call   807488 <pbuf_alloc>
  80a9d3:	89 c3                	mov    %eax,%ebx
  80a9d5:	83 c4 10             	add    $0x10,%esp
  80a9d8:	85 c0                	test   %eax,%eax
  80a9da:	0f 84 7d 03 00 00    	je     80ad5d <tcp_enqueue+0x61a>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
  80a9e0:	66 ff 45 d6          	incw   0xffffffd6(%ebp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  80a9e4:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  80a9e7:	89 43 04             	mov    %eax,0x4(%ebx)
      seg->dataptr = ptr;
  80a9ea:	89 46 08             	mov    %eax,0x8(%esi)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  80a9ed:	83 ec 04             	sub    $0x4,%esp
  80a9f0:	6a 00                	push   $0x0
  80a9f2:	6a 00                	push   $0x0
  80a9f4:	6a 00                	push   $0x0
  80a9f6:	e8 8d ca ff ff       	call   807488 <pbuf_alloc>
  80a9fb:	89 46 04             	mov    %eax,0x4(%esi)
  80a9fe:	83 c4 10             	add    $0x10,%esp
  80aa01:	85 c0                	test   %eax,%eax
  80aa03:	75 11                	jne    80aa16 <tcp_enqueue+0x2d3>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  80aa05:	83 ec 0c             	sub    $0xc,%esp
  80aa08:	53                   	push   %ebx
  80aa09:	e8 0b cf ff ff       	call   807919 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
  80aa0e:	83 c4 10             	add    $0x10,%esp
        goto memerr;
  80aa11:	e9 47 03 00 00       	jmp    80ad5d <tcp_enqueue+0x61a>
      }
      queuelen += pbuf_clen(seg->p);
  80aa16:	83 ec 0c             	sub    $0xc,%esp
  80aa19:	ff 76 04             	pushl  0x4(%esi)
  80aa1c:	e8 c7 cf ff ff       	call   8079e8 <pbuf_clen>
  80aa21:	66 0f b6 c0          	movzbw %al,%ax
  80aa25:	66 01 45 d6          	add    %ax,0xffffffd6(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  80aa29:	83 c4 08             	add    $0x8,%esp
  80aa2c:	53                   	push   %ebx
  80aa2d:	ff 76 04             	pushl  0x4(%esi)
  80aa30:	e8 db cf ff ff       	call   807a10 <pbuf_cat>
      p = NULL;
  80aa35:	83 c4 10             	add    $0x10,%esp
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80aa38:	66 83 7d d6 20       	cmpw   $0x20,0xffffffd6(%ebp)
  80aa3d:	0f 87 1a 03 00 00    	ja     80ad5d <tcp_enqueue+0x61a>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  80aa43:	66 89 7e 0c          	mov    %di,0xc(%esi)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  80aa47:	83 ec 08             	sub    $0x8,%esp
  80aa4a:	6a 14                	push   $0x14
  80aa4c:	ff 76 04             	pushl  0x4(%esi)
  80aa4f:	e8 ef cd ff ff       	call   807843 <pbuf_header>
  80aa54:	83 c4 10             	add    $0x10,%esp
  80aa57:	84 c0                	test   %al,%al
  80aa59:	0f 85 fe 02 00 00    	jne    80ad5d <tcp_enqueue+0x61a>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  80aa5f:	8b 46 04             	mov    0x4(%esi),%eax
  80aa62:	8b 58 04             	mov    0x4(%eax),%ebx
  80aa65:	89 5e 10             	mov    %ebx,0x10(%esi)
    seg->tcphdr->src = htons(pcb->local_port);
  80aa68:	83 ec 0c             	sub    $0xc,%esp
  80aa6b:	8b 55 08             	mov    0x8(%ebp),%edx
  80aa6e:	0f b7 42 1c          	movzwl 0x1c(%edx),%eax
  80aa72:	50                   	push   %eax
  80aa73:	e8 e7 fb ff ff       	call   80a65f <htons>
  80aa78:	66 89 03             	mov    %ax,(%ebx)
    seg->tcphdr->dest = htons(pcb->remote_port);
  80aa7b:	8b 5e 10             	mov    0x10(%esi),%ebx
  80aa7e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80aa81:	0f b7 41 1e          	movzwl 0x1e(%ecx),%eax
  80aa85:	89 04 24             	mov    %eax,(%esp)
  80aa88:	e8 d2 fb ff ff       	call   80a65f <htons>
  80aa8d:	66 89 43 02          	mov    %ax,0x2(%ebx)
    seg->tcphdr->seqno = htonl(seqno);
  80aa91:	8b 5e 10             	mov    0x10(%esi),%ebx
  80aa94:	83 c4 04             	add    $0x4,%esp
  80aa97:	ff 75 e0             	pushl  0xffffffe0(%ebp)
  80aa9a:	e8 eb fb ff ff       	call   80a68a <htonl>
  80aa9f:	89 43 04             	mov    %eax,0x4(%ebx)
    seg->tcphdr->urgp = 0;
  80aaa2:	8b 46 10             	mov    0x10(%esi),%eax
  80aaa5:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  80aaab:	8b 5e 10             	mov    0x10(%esi),%ebx
  80aaae:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80aab2:	89 04 24             	mov    %eax,(%esp)
  80aab5:	e8 bb fb ff ff       	call   80a675 <ntohs>
  80aaba:	83 e0 c0             	and    $0xffffffc0,%eax
  80aabd:	66 0f b6 55 f1       	movzbw 0xfffffff1(%ebp),%dx
  80aac2:	09 d0                	or     %edx,%eax
  80aac4:	0f b7 c0             	movzwl %ax,%eax
  80aac7:	89 04 24             	mov    %eax,(%esp)
  80aaca:	e8 90 fb ff ff       	call   80a65f <htons>
  80aacf:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  80aad3:	83 c4 10             	add    $0x10,%esp
  80aad6:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80aada:	75 29                	jne    80ab05 <tcp_enqueue+0x3c2>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  80aadc:	8b 5e 10             	mov    0x10(%esi),%ebx
  80aadf:	83 ec 0c             	sub    $0xc,%esp
  80aae2:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80aae6:	50                   	push   %eax
  80aae7:	e8 89 fb ff ff       	call   80a675 <ntohs>
  80aaec:	80 cc 50             	or     $0x50,%ah
  80aaef:	25 3f 50 00 00       	and    $0x503f,%eax
  80aaf4:	89 04 24             	mov    %eax,(%esp)
  80aaf7:	e8 63 fb ff ff       	call   80a65f <htons>
  80aafc:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  80ab00:	83 c4 10             	add    $0x10,%esp
  80ab03:	eb 3b                	jmp    80ab40 <tcp_enqueue+0x3fd>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80ab05:	8b 5e 10             	mov    0x10(%esi),%ebx
  80ab08:	83 ec 0c             	sub    $0xc,%esp
  80ab0b:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80ab0f:	50                   	push   %eax
  80ab10:	e8 60 fb ff ff       	call   80a675 <ntohs>
  80ab15:	83 e0 3f             	and    $0x3f,%eax
  80ab18:	0b 45 d4             	or     0xffffffd4(%ebp),%eax
  80ab1b:	0f b7 c0             	movzwl %ax,%eax
  80ab1e:	89 04 24             	mov    %eax,(%esp)
  80ab21:	e8 39 fb ff ff       	call   80a65f <htons>
  80ab26:	66 89 43 0c          	mov    %ax,0xc(%ebx)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  80ab2a:	83 c4 0c             	add    $0xc,%esp
  80ab2d:	0f b6 45 ef          	movzbl 0xffffffef(%ebp),%eax
  80ab31:	50                   	push   %eax
  80ab32:	ff 75 1c             	pushl  0x1c(%ebp)
  80ab35:	ff 76 08             	pushl  0x8(%esi)
  80ab38:	e8 6a 68 ff ff       	call   8013a7 <memcpy>
  80ab3d:	83 c4 10             	add    $0x10,%esp
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  80ab40:	66 29 7d de          	sub    %di,0xffffffde(%ebp)
    seqno += seglen;
  80ab44:	0f b7 c7             	movzwl %di,%eax
  80ab47:	01 45 e0             	add    %eax,0xffffffe0(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  80ab4a:	01 45 d8             	add    %eax,0xffffffd8(%ebp)
  80ab4d:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
  80ab51:	0f 84 1a fd ff ff    	je     80a871 <tcp_enqueue+0x12e>
  80ab57:	66 83 7d de 00       	cmpw   $0x0,0xffffffde(%ebp)
  80ab5c:	0f 85 0f fd ff ff    	jne    80a871 <tcp_enqueue+0x12e>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
    useg = NULL;
  80ab62:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  80ab69:	8b 45 08             	mov    0x8(%ebp),%eax
  80ab6c:	83 78 74 00          	cmpl   $0x0,0x74(%eax)
  80ab70:	74 1b                	je     80ab8d <tcp_enqueue+0x44a>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  80ab72:	8b 55 08             	mov    0x8(%ebp),%edx
  80ab75:	8b 52 74             	mov    0x74(%edx),%edx
  80ab78:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)
  80ab7b:	83 3a 00             	cmpl   $0x0,(%edx)
  80ab7e:	74 0d                	je     80ab8d <tcp_enqueue+0x44a>
  80ab80:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
  80ab83:	8b 09                	mov    (%ecx),%ecx
  80ab85:	89 4d e8             	mov    %ecx,0xffffffe8(%ebp)
  80ab88:	83 39 00             	cmpl   $0x0,(%ecx)
  80ab8b:	75 f3                	jne    80ab80 <tcp_enqueue+0x43d>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80ab8d:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
  80ab91:	0f 84 13 01 00 00    	je     80acaa <tcp_enqueue+0x567>
  80ab97:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  80ab9a:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80ab9e:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  80aba5:	83 ec 0c             	sub    $0xc,%esp
  80aba8:	8b 40 10             	mov    0x10(%eax),%eax
  80abab:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80abaf:	50                   	push   %eax
  80abb0:	e8 c0 fa ff ff       	call   80a675 <ntohs>
  80abb5:	83 c4 10             	add    $0x10,%esp
  80abb8:	a8 01                	test   $0x1,%al
  80abba:	75 1a                	jne    80abd6 <tcp_enqueue+0x493>
  80abbc:	83 ec 0c             	sub    $0xc,%esp
  80abbf:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
  80abc2:	8b 41 10             	mov    0x10(%ecx),%eax
  80abc5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80abc9:	50                   	push   %eax
  80abca:	e8 a6 fa ff ff       	call   80a675 <ntohs>
  80abcf:	83 c4 10             	add    $0x10,%esp
  80abd2:	a8 02                	test   $0x2,%al
  80abd4:	74 07                	je     80abdd <tcp_enqueue+0x49a>
  80abd6:	c7 45 d0 01 00 00 00 	movl   $0x1,0xffffffd0(%ebp)
  80abdd:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
  80abe0:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80abe3:	85 c0                	test   %eax,%eax
  80abe5:	0f 84 b9 00 00 00    	je     80aca4 <tcp_enqueue+0x561>
  80abeb:	83 ec 0c             	sub    $0xc,%esp
  80abee:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
  80abf1:	8b 41 10             	mov    0x10(%ecx),%eax
  80abf4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80abf8:	50                   	push   %eax
  80abf9:	e8 77 fa ff ff       	call   80a675 <ntohs>
  80abfe:	83 c4 10             	add    $0x10,%esp
  80ac01:	a8 03                	test   $0x3,%al
  80ac03:	0f 85 9b 00 00 00    	jne    80aca4 <tcp_enqueue+0x561>
  80ac09:	f6 45 f1 03          	testb  $0x3,0xfffffff1(%ebp)
  80ac0d:	0f 85 91 00 00 00    	jne    80aca4 <tcp_enqueue+0x561>
  80ac13:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  80ac16:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80ac1a:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
  80ac1d:	0f b7 51 0c          	movzwl 0xc(%ecx),%edx
  80ac21:	01 d0                	add    %edx,%eax
  80ac23:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ac26:	0f b7 51 34          	movzwl 0x34(%ecx),%edx
  80ac2a:	39 d0                	cmp    %edx,%eax
  80ac2c:	7f 76                	jg     80aca4 <tcp_enqueue+0x561>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  80ac2e:	83 ec 08             	sub    $0x8,%esp
  80ac31:	6a ec                	push   $0xffffffec
  80ac33:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  80ac36:	ff 70 04             	pushl  0x4(%eax)
  80ac39:	e8 05 cc ff ff       	call   807843 <pbuf_header>
  80ac3e:	83 c4 10             	add    $0x10,%esp
  80ac41:	84 c0                	test   %al,%al
  80ac43:	74 17                	je     80ac5c <tcp_enqueue+0x519>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80ac45:	83 ec 04             	sub    $0x4,%esp
  80ac48:	68 17 36 81 00       	push   $0x813617
  80ac4d:	68 52 01 00 00       	push   $0x152
  80ac52:	68 f2 35 81 00       	push   $0x8135f2
  80ac57:	e8 70 5e ff ff       	call   800acc <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  80ac5c:	83 ec 08             	sub    $0x8,%esp
  80ac5f:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  80ac62:	ff 72 04             	pushl  0x4(%edx)
  80ac65:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
  80ac68:	ff 71 04             	pushl  0x4(%ecx)
  80ac6b:	e8 a0 cd ff ff       	call   807a10 <pbuf_cat>
    useg->len += queue->len;
  80ac70:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  80ac73:	66 8b 42 0c          	mov    0xc(%edx),%ax
  80ac77:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
  80ac7a:	66 03 41 0c          	add    0xc(%ecx),%ax
  80ac7e:	66 89 42 0c          	mov    %ax,0xc(%edx)
    useg->next = queue->next;
  80ac82:	8b 01                	mov    (%ecx),%eax
  80ac84:	89 02                	mov    %eax,(%edx)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
  80ac86:	83 c4 10             	add    $0x10,%esp
    if (seg == queue) {
  80ac89:	39 ce                	cmp    %ecx,%esi
  80ac8b:	75 05                	jne    80ac92 <tcp_enqueue+0x54f>
      seg = NULL;
  80ac8d:	be 00 00 00 00       	mov    $0x0,%esi
    }
    memp_free(MEMP_TCP_SEG, queue);
  80ac92:	83 ec 08             	sub    $0x8,%esp
  80ac95:	ff 75 e4             	pushl  0xffffffe4(%ebp)
  80ac98:	6a 04                	push   $0x4
  80ac9a:	e8 52 c5 ff ff       	call   8071f1 <memp_free>
  80ac9f:	83 c4 10             	add    $0x10,%esp
  80aca2:	eb 19                	jmp    80acbd <tcp_enqueue+0x57a>
  }
  else {
    /* empty list */
    if (useg == NULL) {
  80aca4:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
  80aca8:	75 0b                	jne    80acb5 <tcp_enqueue+0x572>
      /* initialize list with this segment */
      pcb->unsent = queue;
  80acaa:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  80acad:	8b 45 08             	mov    0x8(%ebp),%eax
  80acb0:	89 50 74             	mov    %edx,0x74(%eax)
  80acb3:	eb 08                	jmp    80acbd <tcp_enqueue+0x57a>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  80acb5:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  80acb8:	8b 4d e8             	mov    0xffffffe8(%ebp),%ecx
  80acbb:	89 01                	mov    %eax,(%ecx)
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  80acbd:	0f b6 45 f1          	movzbl 0xfffffff1(%ebp),%eax
  80acc1:	a8 02                	test   $0x2,%al
  80acc3:	75 04                	jne    80acc9 <tcp_enqueue+0x586>
  80acc5:	a8 01                	test   $0x1,%al
  80acc7:	74 04                	je     80accd <tcp_enqueue+0x58a>
    ++len;
  80acc9:	66 ff 45 f2          	incw   0xfffffff2(%ebp)
  }
  if (flags & TCP_FIN) {
  80accd:	f6 45 f1 01          	testb  $0x1,0xfffffff1(%ebp)
  80acd1:	74 07                	je     80acda <tcp_enqueue+0x597>
    pcb->flags |= TF_FIN;
  80acd3:	8b 55 08             	mov    0x8(%ebp),%edx
  80acd6:	80 4a 20 20          	orb    $0x20,0x20(%edx)
  }
  pcb->snd_lbb += len;
  80acda:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  80acde:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ace1:	01 41 68             	add    %eax,0x68(%ecx)

  pcb->snd_buf -= len;
  80ace4:	66 8b 45 f2          	mov    0xfffffff2(%ebp),%ax
  80ace8:	66 29 41 6e          	sub    %ax,0x6e(%ecx)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  80acec:	66 8b 55 d6          	mov    0xffffffd6(%ebp),%dx
  80acf0:	66 89 51 70          	mov    %dx,0x70(%ecx)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  80acf4:	66 85 d2             	test   %dx,%dx
  80acf7:	74 23                	je     80ad1c <tcp_enqueue+0x5d9>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  80acf9:	83 79 78 00          	cmpl   $0x0,0x78(%ecx)
  80acfd:	75 1d                	jne    80ad1c <tcp_enqueue+0x5d9>
  80acff:	83 79 74 00          	cmpl   $0x0,0x74(%ecx)
  80ad03:	75 17                	jne    80ad1c <tcp_enqueue+0x5d9>
  80ad05:	83 ec 04             	sub    $0x4,%esp
  80ad08:	68 a4 35 81 00       	push   $0x8135a4
  80ad0d:	68 7a 01 00 00       	push   $0x17a
  80ad12:	68 f2 35 81 00       	push   $0x8135f2
  80ad17:	e8 b0 5d ff ff       	call   800acc <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  80ad1c:	85 f6                	test   %esi,%esi
  80ad1e:	74 36                	je     80ad56 <tcp_enqueue+0x613>
  80ad20:	66 85 ff             	test   %di,%di
  80ad23:	74 31                	je     80ad56 <tcp_enqueue+0x613>
  80ad25:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  80ad29:	74 2b                	je     80ad56 <tcp_enqueue+0x613>
  80ad2b:	f6 45 f0 02          	testb  $0x2,0xfffffff0(%ebp)
  80ad2f:	75 25                	jne    80ad56 <tcp_enqueue+0x613>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  80ad31:	8b 5e 10             	mov    0x10(%esi),%ebx
  80ad34:	83 ec 0c             	sub    $0xc,%esp
  80ad37:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80ad3b:	50                   	push   %eax
  80ad3c:	e8 34 f9 ff ff       	call   80a675 <ntohs>
  80ad41:	83 c8 08             	or     $0x8,%eax
  80ad44:	0f b7 c0             	movzwl %ax,%eax
  80ad47:	89 04 24             	mov    %eax,(%esp)
  80ad4a:	e8 10 f9 ff ff       	call   80a65f <htons>
  80ad4f:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  80ad53:	83 c4 10             	add    $0x10,%esp
  }

  return ERR_OK;
  80ad56:	b8 00 00 00 00       	mov    $0x0,%eax
  80ad5b:	eb 4d                	jmp    80adaa <tcp_enqueue+0x667>
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  80ad5d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ad60:	80 49 20 80          	orb    $0x80,0x20(%ecx)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  80ad64:	83 7d e4 00          	cmpl   $0x0,0xffffffe4(%ebp)
  80ad68:	74 0e                	je     80ad78 <tcp_enqueue+0x635>
    tcp_segs_free(queue);
  80ad6a:	83 ec 0c             	sub    $0xc,%esp
  80ad6d:	ff 75 e4             	pushl  0xffffffe4(%ebp)
  80ad70:	e8 4f df ff ff       	call   808cc4 <tcp_segs_free>
  80ad75:	83 c4 10             	add    $0x10,%esp
  }
  if (pcb->snd_queuelen != 0) {
  80ad78:	8b 45 08             	mov    0x8(%ebp),%eax
  80ad7b:	66 83 78 70 00       	cmpw   $0x0,0x70(%eax)
  80ad80:	74 23                	je     80ada5 <tcp_enqueue+0x662>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  80ad82:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80ad86:	75 1d                	jne    80ada5 <tcp_enqueue+0x662>
  80ad88:	83 78 74 00          	cmpl   $0x0,0x74(%eax)
  80ad8c:	75 17                	jne    80ada5 <tcp_enqueue+0x662>
  80ad8e:	83 ec 04             	sub    $0x4,%esp
  80ad91:	68 a4 35 81 00       	push   $0x8135a4
  80ad96:	68 8d 01 00 00       	push   $0x18d
  80ad9b:	68 f2 35 81 00       	push   $0x8135f2
  80ada0:	e8 27 5d ff ff       	call   800acc <_panic>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  80ada5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80adaa:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80adad:	5b                   	pop    %ebx
  80adae:	5e                   	pop    %esi
  80adaf:	5f                   	pop    %edi
  80adb0:	c9                   	leave  
  80adb1:	c3                   	ret    

0080adb2 <tcp_output>:

/**
 * Find out what we can send and send it
 *
 * @param pcb Protocol control block for the TCP connection to send data
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  80adb2:	55                   	push   %ebp
  80adb3:	89 e5                	mov    %esp,%ebp
  80adb5:	57                   	push   %edi
  80adb6:	56                   	push   %esi
  80adb7:	53                   	push   %ebx
  80adb8:	83 ec 1c             	sub    $0x1c,%esp
  80adbb:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  struct tcp_seg *seg, *useg;
  u32_t wnd;
#if TCP_CWND_DEBUG
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  80adbe:	b8 00 00 00 00       	mov    $0x0,%eax
  80adc3:	39 3d 84 e6 b3 00    	cmp    %edi,0xb3e684
  80adc9:	0f 84 84 03 00 00    	je     80b153 <tcp_output+0x3a1>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  80adcf:	66 8b 47 5c          	mov    0x5c(%edi),%ax
  80add3:	66 3b 47 4e          	cmp    0x4e(%edi),%ax
  80add7:	73 08                	jae    80ade1 <tcp_output+0x2f>
  80add9:	0f b7 c0             	movzwl %ax,%eax
  80addc:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  80addf:	eb 07                	jmp    80ade8 <tcp_output+0x36>
  80ade1:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80ade5:	89 55 e8             	mov    %edx,0xffffffe8(%ebp)

  seg = pcb->unsent;
  80ade8:	8b 77 74             	mov    0x74(%edi),%esi

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  80adeb:	8b 47 78             	mov    0x78(%edi),%eax
  80adee:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  if (useg != NULL) {
  80adf1:	85 c0                	test   %eax,%eax
  80adf3:	74 12                	je     80ae07 <tcp_output+0x55>
    for (; useg->next != NULL; useg = useg->next);
  80adf5:	83 38 00             	cmpl   $0x0,(%eax)
  80adf8:	74 0d                	je     80ae07 <tcp_output+0x55>
  80adfa:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  80adfd:	8b 12                	mov    (%edx),%edx
  80adff:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
  80ae02:	83 3a 00             	cmpl   $0x0,(%edx)
  80ae05:	75 f3                	jne    80adfa <tcp_output+0x48>
  }                                                                             
   
  /* If the TF_ACK_NOW flag is set and no data will be sent (either
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80ae07:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  80ae0b:	0f 84 d2 02 00 00    	je     80b0e3 <tcp_output+0x331>
  80ae11:	85 f6                	test   %esi,%esi
  80ae13:	74 23                	je     80ae38 <tcp_output+0x86>
  80ae15:	83 ec 0c             	sub    $0xc,%esp
  80ae18:	8b 46 10             	mov    0x10(%esi),%eax
  80ae1b:	ff 70 04             	pushl  0x4(%eax)
  80ae1e:	e8 93 f8 ff ff       	call   80a6b6 <ntohl>
  80ae23:	2b 47 48             	sub    0x48(%edi),%eax
  80ae26:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80ae2a:	01 d0                	add    %edx,%eax
  80ae2c:	83 c4 10             	add    $0x10,%esp
  80ae2f:	3b 45 e8             	cmp    0xffffffe8(%ebp),%eax
  80ae32:	0f 86 ab 02 00 00    	jbe    80b0e3 <tcp_output+0x331>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80ae38:	83 ec 04             	sub    $0x4,%esp
  80ae3b:	6a 00                	push   $0x0
  80ae3d:	6a 14                	push   $0x14
  80ae3f:	6a 01                	push   $0x1
  80ae41:	e8 42 c6 ff ff       	call   807488 <pbuf_alloc>
  80ae46:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    if (p == NULL) {
  80ae49:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  80ae4c:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80ae51:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  80ae55:	0f 84 f8 02 00 00    	je     80b153 <tcp_output+0x3a1>
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80ae5b:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  80ae5f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  80ae62:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  80ae65:	83 ec 0c             	sub    $0xc,%esp
  80ae68:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  80ae6c:	50                   	push   %eax
  80ae6d:	e8 ed f7 ff ff       	call   80a65f <htons>
  80ae72:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  80ae75:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  80ae79:	89 04 24             	mov    %eax,(%esp)
  80ae7c:	e8 de f7 ff ff       	call   80a65f <htons>
  80ae81:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  80ae85:	83 c4 04             	add    $0x4,%esp
  80ae88:	ff 77 54             	pushl  0x54(%edi)
  80ae8b:	e8 fa f7 ff ff       	call   80a68a <htonl>
  80ae90:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  80ae93:	83 c4 04             	add    $0x4,%esp
  80ae96:	ff 77 24             	pushl  0x24(%edi)
  80ae99:	e8 ec f7 ff ff       	call   80a68a <htonl>
  80ae9e:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  80aea1:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80aea5:	89 04 24             	mov    %eax,(%esp)
  80aea8:	e8 c8 f7 ff ff       	call   80a675 <ntohs>
  80aead:	83 c8 10             	or     $0x10,%eax
  80aeb0:	25 d0 ff 00 00       	and    $0xffd0,%eax
  80aeb5:	89 04 24             	mov    %eax,(%esp)
  80aeb8:	e8 a2 f7 ff ff       	call   80a65f <htons>
  80aebd:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80aec1:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80aec5:	89 04 24             	mov    %eax,(%esp)
  80aec8:	e8 92 f7 ff ff       	call   80a65f <htons>
  80aecd:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  80aed1:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  80aed7:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80aedb:	89 04 24             	mov    %eax,(%esp)
  80aede:	e8 92 f7 ff ff       	call   80a675 <ntohs>
  80aee3:	80 cc 50             	or     $0x50,%ah
  80aee6:	25 3f 50 00 00       	and    $0x503f,%eax
  80aeeb:	89 04 24             	mov    %eax,(%esp)
  80aeee:	e8 6c f7 ff ff       	call   80a65f <htons>
  80aef3:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  80aef7:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  80aefd:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  80af00:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  80af04:	89 04 24             	mov    %eax,(%esp)
  80af07:	6a 06                	push   $0x6
  80af09:	8d 77 04             	lea    0x4(%edi),%esi
  80af0c:	56                   	push   %esi
  80af0d:	57                   	push   %edi
  80af0e:	52                   	push   %edx
  80af0f:	e8 fa f1 ff ff       	call   80a10e <inet_chksum_pseudo>
  80af14:	66 89 43 10          	mov    %ax,0x10(%ebx)
          IP_PROTO_TCP, p->tot_len);
#endif
#if LWIP_NETIF_HWADDRHINT
    {
      struct netif *netif;
      netif = ip_route(&pcb->remote_ip);
      if(netif != NULL){
        netif->addr_hint = &(pcb->addr_hint);
        ip_output_if(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl,
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80af18:	83 c4 18             	add    $0x18,%esp
  80af1b:	6a 06                	push   $0x6
  80af1d:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  80af21:	50                   	push   %eax
  80af22:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80af26:	50                   	push   %eax
  80af27:	56                   	push   %esi
  80af28:	57                   	push   %edi
  80af29:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  80af2c:	e8 be e7 ff ff       	call   8096ef <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  80af31:	83 c4 14             	add    $0x14,%esp
  80af34:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  80af37:	e8 dd c9 ff ff       	call   807919 <pbuf_free>

    return ERR_OK;
  80af3c:	b8 00 00 00 00       	mov    $0x0,%eax
  80af41:	e9 0d 02 00 00       	jmp    80b153 <tcp_output+0x3a1>
  }

#if TCP_OUTPUT_DEBUG
  if (seg == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n",
                                   (void*)pcb->unsent));
  }
#endif /* TCP_OUTPUT_DEBUG */
#if TCP_CWND_DEBUG
  if (seg == NULL) {
    LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F
                                 ", cwnd %"U16_F", wnd %"U32_F
                                 ", seg == NULL, ack %"U32_F"\n",
                                 pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));
  } else {
    LWIP_DEBUGF(TCP_CWND_DEBUG, 
                ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F
                 ", effwnd %"U32_F", seq %"U32_F", ack %"U32_F"\n",
                 pcb->snd_wnd, pcb->cwnd, wnd,
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  80af46:	83 ec 0c             	sub    $0xc,%esp
  80af49:	8b 46 10             	mov    0x10(%esi),%eax
  80af4c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80af50:	50                   	push   %eax
  80af51:	e8 1f f7 ff ff       	call   80a675 <ntohs>
  80af56:	83 c4 10             	add    $0x10,%esp
  80af59:	a8 04                	test   $0x4,%al
  80af5b:	74 17                	je     80af74 <tcp_output+0x1c2>
  80af5d:	83 ec 04             	sub    $0x4,%esp
  80af60:	68 2b 36 81 00       	push   $0x81362b
  80af65:	68 05 02 00 00       	push   $0x205
  80af6a:	68 f2 35 81 00       	push   $0x8135f2
  80af6f:	e8 58 5b ff ff       	call   800acc <_panic>
                (TCPH_FLAGS(seg->tcphdr) & TCP_RST) == 0);
    /* Stop sending if the nagle algorithm would prevent it
     * Don't stop:
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  80af74:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80af78:	74 1e                	je     80af98 <tcp_output+0x1e6>
  80af7a:	f6 47 20 40          	testb  $0x40,0x20(%edi)
  80af7e:	75 18                	jne    80af98 <tcp_output+0x1e6>
  80af80:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80af84:	74 08                	je     80af8e <tcp_output+0x1dc>
  80af86:	8b 47 74             	mov    0x74(%edi),%eax
  80af89:	83 38 00             	cmpl   $0x0,(%eax)
  80af8c:	75 0a                	jne    80af98 <tcp_output+0x1e6>
  80af8e:	f6 47 20 a0          	testb  $0xa0,0x20(%edi)
  80af92:	0f 84 72 01 00 00    	je     80b10a <tcp_output+0x358>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
    }
#if TCP_CWND_DEBUG
    LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F", effwnd %"U32_F", seq %"U32_F", ack %"U32_F", i %"S16_F"\n",
                            pcb->snd_wnd, pcb->cwnd, wnd,
                            ntohl(seg->tcphdr->seqno) + seg->len -
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  80af98:	8b 06                	mov    (%esi),%eax
  80af9a:	89 47 74             	mov    %eax,0x74(%edi)

    if (pcb->state != SYN_SENT) {
  80af9d:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  80afa1:	74 29                	je     80afcc <tcp_output+0x21a>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  80afa3:	8b 5e 10             	mov    0x10(%esi),%ebx
  80afa6:	83 ec 0c             	sub    $0xc,%esp
  80afa9:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80afad:	50                   	push   %eax
  80afae:	e8 c2 f6 ff ff       	call   80a675 <ntohs>
  80afb3:	83 c8 10             	or     $0x10,%eax
  80afb6:	0f b7 c0             	movzwl %ax,%eax
  80afb9:	89 04 24             	mov    %eax,(%esp)
  80afbc:	e8 9e f6 ff ff       	call   80a65f <htons>
  80afc1:	66 89 43 0c          	mov    %ax,0xc(%ebx)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80afc5:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  80afc9:	83 c4 10             	add    $0x10,%esp
    }

    tcp_output_segment(seg, pcb);
  80afcc:	83 ec 08             	sub    $0x8,%esp
  80afcf:	57                   	push   %edi
  80afd0:	56                   	push   %esi
  80afd1:	e8 85 01 00 00       	call   80b15b <tcp_output_segment>
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  80afd6:	83 c4 04             	add    $0x4,%esp
  80afd9:	8b 46 10             	mov    0x10(%esi),%eax
  80afdc:	ff 70 04             	pushl  0x4(%eax)
  80afdf:	e8 d2 f6 ff ff       	call   80a6b6 <ntohl>
  80afe4:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  80afe7:	0f b7 5e 0c          	movzwl 0xc(%esi),%ebx
  80afeb:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  80aff2:	8b 46 10             	mov    0x10(%esi),%eax
  80aff5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80aff9:	89 04 24             	mov    %eax,(%esp)
  80affc:	e8 74 f6 ff ff       	call   80a675 <ntohs>
  80b001:	83 c4 10             	add    $0x10,%esp
  80b004:	a8 01                	test   $0x1,%al
  80b006:	75 17                	jne    80b01f <tcp_output+0x26d>
  80b008:	83 ec 0c             	sub    $0xc,%esp
  80b00b:	8b 46 10             	mov    0x10(%esi),%eax
  80b00e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b012:	50                   	push   %eax
  80b013:	e8 5d f6 ff ff       	call   80a675 <ntohs>
  80b018:	83 c4 10             	add    $0x10,%esp
  80b01b:	a8 02                	test   $0x2,%al
  80b01d:	74 07                	je     80b026 <tcp_output+0x274>
  80b01f:	c7 45 e0 01 00 00 00 	movl   $0x1,0xffffffe0(%ebp)
  80b026:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  80b029:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80b02c:	03 45 e4             	add    0xffffffe4(%ebp),%eax
  80b02f:	89 47 54             	mov    %eax,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  80b032:	39 47 58             	cmp    %eax,0x58(%edi)
  80b035:	79 03                	jns    80b03a <tcp_output+0x288>
      pcb->snd_max = pcb->snd_nxt;
  80b037:	89 47 58             	mov    %eax,0x58(%edi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  80b03a:	0f b7 5e 0c          	movzwl 0xc(%esi),%ebx
  80b03e:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  80b045:	83 ec 0c             	sub    $0xc,%esp
  80b048:	8b 46 10             	mov    0x10(%esi),%eax
  80b04b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b04f:	50                   	push   %eax
  80b050:	e8 20 f6 ff ff       	call   80a675 <ntohs>
  80b055:	83 c4 10             	add    $0x10,%esp
  80b058:	a8 01                	test   $0x1,%al
  80b05a:	75 17                	jne    80b073 <tcp_output+0x2c1>
  80b05c:	83 ec 0c             	sub    $0xc,%esp
  80b05f:	8b 46 10             	mov    0x10(%esi),%eax
  80b062:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b066:	50                   	push   %eax
  80b067:	e8 09 f6 ff ff       	call   80a675 <ntohs>
  80b06c:	83 c4 10             	add    $0x10,%esp
  80b06f:	a8 02                	test   $0x2,%al
  80b071:	74 07                	je     80b07a <tcp_output+0x2c8>
  80b073:	c7 45 dc 01 00 00 00 	movl   $0x1,0xffffffdc(%ebp)
  80b07a:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  80b07d:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80b080:	85 c0                	test   %eax,%eax
  80b082:	7e 50                	jle    80b0d4 <tcp_output+0x322>
      seg->next = NULL;
  80b084:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  80b08a:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80b08e:	75 08                	jne    80b098 <tcp_output+0x2e6>
        pcb->unacked = seg;
  80b090:	89 77 78             	mov    %esi,0x78(%edi)
        useg = seg;
  80b093:	89 75 ec             	mov    %esi,0xffffffec(%ebp)
  80b096:	eb 48                	jmp    80b0e0 <tcp_output+0x32e>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  80b098:	83 ec 0c             	sub    $0xc,%esp
  80b09b:	8b 46 10             	mov    0x10(%esi),%eax
  80b09e:	ff 70 04             	pushl  0x4(%eax)
  80b0a1:	e8 10 f6 ff ff       	call   80a6b6 <ntohl>
  80b0a6:	89 c3                	mov    %eax,%ebx
  80b0a8:	83 c4 04             	add    $0x4,%esp
  80b0ab:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  80b0ae:	8b 42 10             	mov    0x10(%edx),%eax
  80b0b1:	ff 70 04             	pushl  0x4(%eax)
  80b0b4:	e8 fd f5 ff ff       	call   80a6b6 <ntohl>
  80b0b9:	83 c4 10             	add    $0x10,%esp
  80b0bc:	39 c3                	cmp    %eax,%ebx
  80b0be:	79 0a                	jns    80b0ca <tcp_output+0x318>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  80b0c0:	8b 47 78             	mov    0x78(%edi),%eax
  80b0c3:	89 06                	mov    %eax,(%esi)
          pcb->unacked = seg;
  80b0c5:	89 77 78             	mov    %esi,0x78(%edi)
  80b0c8:	eb 16                	jmp    80b0e0 <tcp_output+0x32e>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  80b0ca:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  80b0cd:	89 30                	mov    %esi,(%eax)
          useg = useg->next;
  80b0cf:	89 75 ec             	mov    %esi,0xffffffec(%ebp)
  80b0d2:	eb 0c                	jmp    80b0e0 <tcp_output+0x32e>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  80b0d4:	83 ec 0c             	sub    $0xc,%esp
  80b0d7:	56                   	push   %esi
  80b0d8:	e8 1a dc ff ff       	call   808cf7 <tcp_seg_free>
  80b0dd:	83 c4 10             	add    $0x10,%esp
    }
    seg = pcb->unsent;
  80b0e0:	8b 77 74             	mov    0x74(%edi),%esi
  80b0e3:	85 f6                	test   %esi,%esi
  80b0e5:	74 63                	je     80b14a <tcp_output+0x398>
  80b0e7:	83 ec 0c             	sub    $0xc,%esp
  80b0ea:	8b 46 10             	mov    0x10(%esi),%eax
  80b0ed:	ff 70 04             	pushl  0x4(%eax)
  80b0f0:	e8 c1 f5 ff ff       	call   80a6b6 <ntohl>
  80b0f5:	2b 47 48             	sub    0x48(%edi),%eax
  80b0f8:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80b0fc:	01 d0                	add    %edx,%eax
  80b0fe:	83 c4 10             	add    $0x10,%esp
  80b101:	3b 45 e8             	cmp    0xffffffe8(%ebp),%eax
  80b104:	0f 86 3c fe ff ff    	jbe    80af46 <tcp_output+0x194>
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  80b10a:	85 f6                	test   %esi,%esi
  80b10c:	74 3c                	je     80b14a <tcp_output+0x398>
  80b10e:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80b115:	75 33                	jne    80b14a <tcp_output+0x398>
  80b117:	83 ec 0c             	sub    $0xc,%esp
  80b11a:	8b 46 10             	mov    0x10(%esi),%eax
  80b11d:	ff 70 04             	pushl  0x4(%eax)
  80b120:	e8 91 f5 ff ff       	call   80a6b6 <ntohl>
  80b125:	2b 47 48             	sub    0x48(%edi),%eax
  80b128:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80b12c:	01 d0                	add    %edx,%eax
  80b12e:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80b132:	83 c4 10             	add    $0x10,%esp
  80b135:	39 d0                	cmp    %edx,%eax
  80b137:	76 11                	jbe    80b14a <tcp_output+0x398>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  80b139:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  80b140:	00 00 00 
    pcb->persist_backoff = 1;
  80b143:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  80b14a:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  80b14e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b153:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80b156:	5b                   	pop    %ebx
  80b157:	5e                   	pop    %esi
  80b158:	5f                   	pop    %edi
  80b159:	c9                   	leave  
  80b15a:	c3                   	ret    

0080b15b <tcp_output_segment>:

/**
 * Called by tcp_output() to actually send a TCP segment over IP.
 *
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
  80b15b:	55                   	push   %ebp
  80b15c:	89 e5                	mov    %esp,%ebp
  80b15e:	57                   	push   %edi
  80b15f:	56                   	push   %esi
  80b160:	53                   	push   %ebx
  80b161:	83 ec 18             	sub    $0x18,%esp
  80b164:	8b 7d 0c             	mov    0xc(%ebp),%edi
  u16_t len;
  struct netif *netif;

  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b167:	8b 45 08             	mov    0x8(%ebp),%eax
  80b16a:	8b 58 10             	mov    0x10(%eax),%ebx
  80b16d:	ff 77 24             	pushl  0x24(%edi)
  80b170:	e8 15 f5 ff ff       	call   80a68a <htonl>
  80b175:	89 43 08             	mov    %eax,0x8(%ebx)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b178:	8b 55 08             	mov    0x8(%ebp),%edx
  80b17b:	8b 5a 10             	mov    0x10(%edx),%ebx
  80b17e:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80b182:	89 04 24             	mov    %eax,(%esp)
  80b185:	e8 d5 f4 ff ff       	call   80a65f <htons>
  80b18a:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  80b18e:	83 c4 10             	add    $0x10,%esp
  80b191:	85 ff                	test   %edi,%edi
  80b193:	74 05                	je     80b19a <tcp_output_segment+0x3f>
  80b195:	83 3f 00             	cmpl   $0x0,(%edi)
  80b198:	75 26                	jne    80b1c0 <tcp_output_segment+0x65>
    netif = ip_route(&(pcb->remote_ip));
  80b19a:	83 ec 0c             	sub    $0xc,%esp
  80b19d:	8d 47 04             	lea    0x4(%edi),%eax
  80b1a0:	50                   	push   %eax
  80b1a1:	e8 4e e0 ff ff       	call   8091f4 <ip_route>
    if (netif == NULL) {
  80b1a6:	83 c4 10             	add    $0x10,%esp
  80b1a9:	85 c0                	test   %eax,%eax
  80b1ab:	0f 84 a9 00 00 00    	je     80b25a <tcp_output_segment+0xff>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  80b1b1:	ba 00 00 00 00       	mov    $0x0,%edx
  80b1b6:	83 f8 fc             	cmp    $0xfffffffc,%eax
  80b1b9:	74 03                	je     80b1be <tcp_output_segment+0x63>
  80b1bb:	8b 50 04             	mov    0x4(%eax),%edx
  80b1be:	89 17                	mov    %edx,(%edi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  80b1c0:	66 83 7f 32 ff       	cmpw   $0xffffffff,0x32(%edi)
  80b1c5:	75 06                	jne    80b1cd <tcp_output_segment+0x72>
    pcb->rtime = 0;
  80b1c7:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

  if (pcb->rttest == 0) {
  80b1cd:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  80b1d1:	75 1f                	jne    80b1f2 <tcp_output_segment+0x97>
    pcb->rttest = tcp_ticks;
  80b1d3:	a1 6c e6 b3 00       	mov    0xb3e66c,%eax
  80b1d8:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  80b1db:	83 ec 0c             	sub    $0xc,%esp
  80b1de:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80b1e1:	8b 41 10             	mov    0x10(%ecx),%eax
  80b1e4:	ff 70 04             	pushl  0x4(%eax)
  80b1e7:	e8 ca f4 ff ff       	call   80a6b6 <ntohl>
  80b1ec:	89 47 3c             	mov    %eax,0x3c(%edi)

    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %"U32_F"\n", pcb->rtseq));
  80b1ef:	83 c4 10             	add    $0x10,%esp
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  80b1f2:	8b 45 08             	mov    0x8(%ebp),%eax
  80b1f5:	66 8b 50 10          	mov    0x10(%eax),%dx
  80b1f9:	89 c1                	mov    %eax,%ecx
  80b1fb:	8b 40 04             	mov    0x4(%eax),%eax
  80b1fe:	66 2b 50 04          	sub    0x4(%eax),%dx

  seg->p->len -= len;
  80b202:	66 29 50 0a          	sub    %dx,0xa(%eax)
  seg->p->tot_len -= len;
  80b206:	8b 41 04             	mov    0x4(%ecx),%eax
  80b209:	66 29 50 08          	sub    %dx,0x8(%eax)

  seg->p->payload = seg->tcphdr;
  80b20d:	8b 51 04             	mov    0x4(%ecx),%edx
  80b210:	8b 41 10             	mov    0x10(%ecx),%eax
  80b213:	89 42 04             	mov    %eax,0x4(%edx)

  seg->tcphdr->chksum = 0;
  80b216:	8b 41 10             	mov    0x10(%ecx),%eax
  80b219:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80b21f:	8b 71 10             	mov    0x10(%ecx),%esi
  80b222:	83 ec 0c             	sub    $0xc,%esp
  80b225:	8b 51 04             	mov    0x4(%ecx),%edx
  80b228:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  80b22c:	50                   	push   %eax
  80b22d:	6a 06                	push   $0x6
  80b22f:	8d 5f 04             	lea    0x4(%edi),%ebx
  80b232:	53                   	push   %ebx
  80b233:	57                   	push   %edi
  80b234:	52                   	push   %edx
  80b235:	e8 d4 ee ff ff       	call   80a10e <inet_chksum_pseudo>
  80b23a:	66 89 46 10          	mov    %ax,0x10(%esi)
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);

#if LWIP_NETIF_HWADDRHINT
  {
    struct netif *netif;
    netif = ip_route(&pcb->remote_ip);
    if(netif != NULL){
      netif->addr_hint = &(pcb->addr_hint);
      ip_output_if(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl,
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80b23e:	83 c4 18             	add    $0x18,%esp
  80b241:	6a 06                	push   $0x6
  80b243:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  80b247:	50                   	push   %eax
  80b248:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80b24c:	50                   	push   %eax
  80b24d:	53                   	push   %ebx
  80b24e:	57                   	push   %edi
  80b24f:	8b 45 08             	mov    0x8(%ebp),%eax
  80b252:	ff 70 04             	pushl  0x4(%eax)
  80b255:	e8 95 e4 ff ff       	call   8096ef <ip_output>
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
  80b25a:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80b25d:	5b                   	pop    %ebx
  80b25e:	5e                   	pop    %esi
  80b25f:	5f                   	pop    %edi
  80b260:	c9                   	leave  
  80b261:	c3                   	ret    

0080b262 <tcp_rst>:

/**
 * Send a TCP RESET packet (empty segment with RST flag set) either to
 * abort a connection or to show that there is no matching local connection
 * for a received segment.
 *
 * Called by tcp_abort() (to abort a local connection), tcp_input() (if no
 * matching local pcb was found), tcp_listen_input() (if incoming segment
 * has ACK flag set) and tcp_process() (received segment in the wrong state)
 *
 * Since a RST segment is in most cases not sent for an active connection,
 * tcp_rst() has a number of arguments that are taken from a tcp_pcb for
 * most other segment output functions.
 *
 * @param seqno the sequence number to use for the outgoing segment
 * @param ackno the acknowledge number to use for the outgoing segment
 * @param local_ip the local IP address to send the segment from
 * @param remote_ip the remote IP address to send the segment to
 * @param local_port the local TCP port to send the segment from
 * @param remote_port the remote TCP port to send the segment to
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  80b262:	55                   	push   %ebp
  80b263:	89 e5                	mov    %esp,%ebp
  80b265:	57                   	push   %edi
  80b266:	56                   	push   %esi
  80b267:	53                   	push   %ebx
  80b268:	83 ec 10             	sub    $0x10,%esp
  80b26b:	8b 7d 18             	mov    0x18(%ebp),%edi
  80b26e:	8b 45 1c             	mov    0x1c(%ebp),%eax
  80b271:	66 89 45 f2          	mov    %ax,0xfffffff2(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80b275:	6a 00                	push   $0x0
  80b277:	6a 14                	push   $0x14
  80b279:	6a 01                	push   $0x1
  80b27b:	e8 08 c2 ff ff       	call   807488 <pbuf_alloc>
  80b280:	89 c6                	mov    %eax,%esi
  if (p == NULL) {
  80b282:	83 c4 10             	add    $0x10,%esp
  80b285:	85 c0                	test   %eax,%eax
  80b287:	0f 84 f5 00 00 00    	je     80b382 <tcp_rst+0x120>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80b28d:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80b292:	77 17                	ja     80b2ab <tcp_rst+0x49>
  80b294:	83 ec 04             	sub    $0x4,%esp
  80b297:	68 c4 35 81 00       	push   $0x8135c4
  80b29c:	68 be 02 00 00       	push   $0x2be
  80b2a1:	68 f2 35 81 00       	push   $0x8135f2
  80b2a6:	e8 21 58 ff ff       	call   800acc <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80b2ab:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  80b2ae:	83 ec 0c             	sub    $0xc,%esp
  80b2b1:	0f b7 c7             	movzwl %di,%eax
  80b2b4:	50                   	push   %eax
  80b2b5:	e8 a5 f3 ff ff       	call   80a65f <htons>
  80b2ba:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  80b2bd:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  80b2c1:	89 04 24             	mov    %eax,(%esp)
  80b2c4:	e8 96 f3 ff ff       	call   80a65f <htons>
  80b2c9:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  80b2cd:	83 c4 04             	add    $0x4,%esp
  80b2d0:	ff 75 08             	pushl  0x8(%ebp)
  80b2d3:	e8 b2 f3 ff ff       	call   80a68a <htonl>
  80b2d8:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  80b2db:	83 c4 04             	add    $0x4,%esp
  80b2de:	ff 75 0c             	pushl  0xc(%ebp)
  80b2e1:	e8 a4 f3 ff ff       	call   80a68a <htonl>
  80b2e6:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  80b2e9:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b2ed:	89 04 24             	mov    %eax,(%esp)
  80b2f0:	e8 80 f3 ff ff       	call   80a675 <ntohs>
  80b2f5:	83 c8 14             	or     $0x14,%eax
  80b2f8:	25 d4 ff 00 00       	and    $0xffd4,%eax
  80b2fd:	89 04 24             	mov    %eax,(%esp)
  80b300:	e8 5a f3 ff ff       	call   80a65f <htons>
  80b305:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  80b309:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  80b310:	e8 4a f3 ff ff       	call   80a65f <htons>
  80b315:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80b319:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80b31f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b323:	89 04 24             	mov    %eax,(%esp)
  80b326:	e8 4a f3 ff ff       	call   80a675 <ntohs>
  80b32b:	80 cc 50             	or     $0x50,%ah
  80b32e:	25 3f 50 00 00       	and    $0x503f,%eax
  80b333:	89 04 24             	mov    %eax,(%esp)
  80b336:	e8 24 f3 ff ff       	call   80a65f <htons>
  80b33b:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80b33f:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  80b345:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b349:	89 04 24             	mov    %eax,(%esp)
  80b34c:	6a 06                	push   $0x6
  80b34e:	ff 75 14             	pushl  0x14(%ebp)
  80b351:	ff 75 10             	pushl  0x10(%ebp)
  80b354:	56                   	push   %esi
  80b355:	e8 b4 ed ff ff       	call   80a10e <inet_chksum_pseudo>
  80b35a:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  80b35e:	83 c4 18             	add    $0x18,%esp
  80b361:	6a 06                	push   $0x6
  80b363:	6a 00                	push   $0x0
  80b365:	68 ff 00 00 00       	push   $0xff
  80b36a:	ff 75 14             	pushl  0x14(%ebp)
  80b36d:	ff 75 10             	pushl  0x10(%ebp)
  80b370:	56                   	push   %esi
  80b371:	e8 79 e3 ff ff       	call   8096ef <ip_output>
  pbuf_free(p);
  80b376:	83 c4 14             	add    $0x14,%esp
  80b379:	56                   	push   %esi
  80b37a:	e8 9a c5 ff ff       	call   807919 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
  80b37f:	83 c4 10             	add    $0x10,%esp
}
  80b382:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80b385:	5b                   	pop    %ebx
  80b386:	5e                   	pop    %esi
  80b387:	5f                   	pop    %edi
  80b388:	c9                   	leave  
  80b389:	c3                   	ret    

0080b38a <tcp_rexmit_rto>:

/**
 * Requeue all unacked segments for retransmission
 *
 * Called by tcp_slowtmr() for slow retransmission.
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  80b38a:	55                   	push   %ebp
  80b38b:	89 e5                	mov    %esp,%ebp
  80b38d:	53                   	push   %ebx
  80b38e:	83 ec 04             	sub    $0x4,%esp
  80b391:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80b394:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80b398:	74 44                	je     80b3de <tcp_rexmit_rto+0x54>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  80b39a:	8b 53 78             	mov    0x78(%ebx),%edx
  80b39d:	83 3a 00             	cmpl   $0x0,(%edx)
  80b3a0:	74 07                	je     80b3a9 <tcp_rexmit_rto+0x1f>
  80b3a2:	8b 12                	mov    (%edx),%edx
  80b3a4:	83 3a 00             	cmpl   $0x0,(%edx)
  80b3a7:	75 f9                	jne    80b3a2 <tcp_rexmit_rto+0x18>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  80b3a9:	8b 43 74             	mov    0x74(%ebx),%eax
  80b3ac:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  80b3ae:	8b 43 78             	mov    0x78(%ebx),%eax
  80b3b1:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  80b3b4:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80b3bb:	83 ec 0c             	sub    $0xc,%esp
  80b3be:	8b 40 10             	mov    0x10(%eax),%eax
  80b3c1:	ff 70 04             	pushl  0x4(%eax)
  80b3c4:	e8 ed f2 ff ff       	call   80a6b6 <ntohl>
  80b3c9:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  80b3cc:	fe 43 46             	incb   0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  80b3cf:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  80b3d6:	89 1c 24             	mov    %ebx,(%esp)
  80b3d9:	e8 d4 f9 ff ff       	call   80adb2 <tcp_output>
}
  80b3de:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80b3e1:	c9                   	leave  
  80b3e2:	c3                   	ret    

0080b3e3 <tcp_rexmit>:

/**
 * Requeue the first unacked segment for retransmission
 *
 * Called by tcp_receive() for fast retramsmit.
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  80b3e3:	55                   	push   %ebp
  80b3e4:	89 e5                	mov    %esp,%ebp
  80b3e6:	53                   	push   %ebx
  80b3e7:	83 ec 04             	sub    $0x4,%esp
  80b3ea:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80b3ed:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80b3f1:	74 36                	je     80b429 <tcp_rexmit+0x46>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  80b3f3:	8b 53 78             	mov    0x78(%ebx),%edx
  80b3f6:	8b 0a                	mov    (%edx),%ecx
  pcb->unacked->next = pcb->unsent;
  80b3f8:	8b 43 74             	mov    0x74(%ebx),%eax
  80b3fb:	89 02                	mov    %eax,(%edx)
  pcb->unsent = pcb->unacked;
  80b3fd:	8b 43 78             	mov    0x78(%ebx),%eax
  80b400:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  80b403:	89 4b 78             	mov    %ecx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80b406:	83 ec 0c             	sub    $0xc,%esp
  80b409:	8b 40 10             	mov    0x10(%eax),%eax
  80b40c:	ff 70 04             	pushl  0x4(%eax)
  80b40f:	e8 a2 f2 ff ff       	call   80a6b6 <ntohl>
  80b414:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  80b417:	fe 43 46             	incb   0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  80b41a:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  80b421:	89 1c 24             	mov    %ebx,(%esp)
  80b424:	e8 89 f9 ff ff       	call   80adb2 <tcp_output>
}
  80b429:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80b42c:	c9                   	leave  
  80b42d:	c3                   	ret    

0080b42e <tcp_keepalive>:

/**
 * Send keepalive packets to keep a connection active although
 * no data is sent over it.
 *
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  80b42e:	55                   	push   %ebp
  80b42f:	89 e5                	mov    %esp,%ebp
  80b431:	57                   	push   %edi
  80b432:	56                   	push   %esi
  80b433:	53                   	push   %ebx
  80b434:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *p;
  struct tcp_hdr *tcphdr;

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
                          ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80b437:	6a 00                	push   $0x0
  80b439:	6a 14                	push   $0x14
  80b43b:	6a 01                	push   $0x1
  80b43d:	e8 46 c0 ff ff       	call   807488 <pbuf_alloc>
  80b442:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80b444:	83 c4 10             	add    $0x10,%esp
  80b447:	85 c0                	test   %eax,%eax
  80b449:	0f 84 06 01 00 00    	je     80b555 <tcp_keepalive+0x127>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80b44f:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80b454:	77 17                	ja     80b46d <tcp_keepalive+0x3f>
  80b456:	83 ec 04             	sub    $0x4,%esp
  80b459:	68 c4 35 81 00       	push   $0x8135c4
  80b45e:	68 3a 03 00 00       	push   $0x33a
  80b463:	68 f2 35 81 00       	push   $0x8135f2
  80b468:	e8 5f 56 ff ff       	call   800acc <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80b46d:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80b470:	83 ec 0c             	sub    $0xc,%esp
  80b473:	8b 55 08             	mov    0x8(%ebp),%edx
  80b476:	0f b7 42 1c          	movzwl 0x1c(%edx),%eax
  80b47a:	50                   	push   %eax
  80b47b:	e8 df f1 ff ff       	call   80a65f <htons>
  80b480:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80b483:	8b 55 08             	mov    0x8(%ebp),%edx
  80b486:	0f b7 42 1e          	movzwl 0x1e(%edx),%eax
  80b48a:	89 04 24             	mov    %eax,(%esp)
  80b48d:	e8 cd f1 ff ff       	call   80a65f <htons>
  80b492:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  80b496:	8b 55 08             	mov    0x8(%ebp),%edx
  80b499:	8b 42 54             	mov    0x54(%edx),%eax
  80b49c:	48                   	dec    %eax
  80b49d:	89 04 24             	mov    %eax,(%esp)
  80b4a0:	e8 e5 f1 ff ff       	call   80a68a <htonl>
  80b4a5:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b4a8:	83 c4 04             	add    $0x4,%esp
  80b4ab:	8b 45 08             	mov    0x8(%ebp),%eax
  80b4ae:	ff 70 24             	pushl  0x24(%eax)
  80b4b1:	e8 d4 f1 ff ff       	call   80a68a <htonl>
  80b4b6:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80b4b9:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b4bd:	89 04 24             	mov    %eax,(%esp)
  80b4c0:	e8 b0 f1 ff ff       	call   80a675 <ntohs>
  80b4c5:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80b4ca:	89 04 24             	mov    %eax,(%esp)
  80b4cd:	e8 8d f1 ff ff       	call   80a65f <htons>
  80b4d2:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b4d6:	8b 55 08             	mov    0x8(%ebp),%edx
  80b4d9:	0f b7 42 2a          	movzwl 0x2a(%edx),%eax
  80b4dd:	89 04 24             	mov    %eax,(%esp)
  80b4e0:	e8 7a f1 ff ff       	call   80a65f <htons>
  80b4e5:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80b4e9:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80b4ef:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b4f3:	89 04 24             	mov    %eax,(%esp)
  80b4f6:	e8 7a f1 ff ff       	call   80a675 <ntohs>
  80b4fb:	80 cc 50             	or     $0x50,%ah
  80b4fe:	25 3f 50 00 00       	and    $0x503f,%eax
  80b503:	89 04 24             	mov    %eax,(%esp)
  80b506:	e8 54 f1 ff ff       	call   80a65f <htons>
  80b50b:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80b50f:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80b515:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b519:	89 04 24             	mov    %eax,(%esp)
  80b51c:	6a 06                	push   $0x6
  80b51e:	8b 75 08             	mov    0x8(%ebp),%esi
  80b521:	83 c6 04             	add    $0x4,%esi
  80b524:	56                   	push   %esi
  80b525:	ff 75 08             	pushl  0x8(%ebp)
  80b528:	57                   	push   %edi
  80b529:	e8 e0 eb ff ff       	call   80a10e <inet_chksum_pseudo>
  80b52e:	66 89 43 10          	mov    %ax,0x10(%ebx)
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);

  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  {
    struct netif *netif;
    netif = ip_route(&pcb->remote_ip);
    if(netif != NULL){
      netif->addr_hint = &(pcb->addr_hint);
      ip_output_if(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl,
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80b532:	83 c4 18             	add    $0x18,%esp
  80b535:	6a 06                	push   $0x6
  80b537:	6a 00                	push   $0x0
  80b539:	8b 55 08             	mov    0x8(%ebp),%edx
  80b53c:	0f b6 42 0b          	movzbl 0xb(%edx),%eax
  80b540:	50                   	push   %eax
  80b541:	56                   	push   %esi
  80b542:	52                   	push   %edx
  80b543:	57                   	push   %edi
  80b544:	e8 a6 e1 ff ff       	call   8096ef <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80b549:	83 c4 14             	add    $0x14,%esp
  80b54c:	57                   	push   %edi
  80b54d:	e8 c7 c3 ff ff       	call   807919 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
  80b552:	83 c4 10             	add    $0x10,%esp
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80b555:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80b558:	5b                   	pop    %ebx
  80b559:	5e                   	pop    %esi
  80b55a:	5f                   	pop    %edi
  80b55b:	c9                   	leave  
  80b55c:	c3                   	ret    

0080b55d <tcp_zero_window_probe>:


/**
 * Send persist timer zero-window probes to keep a connection active
 * when a window update is lost.
 *
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  80b55d:	55                   	push   %ebp
  80b55e:	89 e5                	mov    %esp,%ebp
  80b560:	57                   	push   %edi
  80b561:	56                   	push   %esi
  80b562:	53                   	push   %ebx
  80b563:	83 ec 0c             	sub    $0xc,%esp
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  struct tcp_seg *seg;

  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: sending ZERO WINDOW probe to %"
               U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
               ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
               ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  80b566:	8b 45 08             	mov    0x8(%ebp),%eax
  80b569:	8b 70 78             	mov    0x78(%eax),%esi

  if(seg == NULL)
  80b56c:	85 f6                	test   %esi,%esi
  80b56e:	75 0b                	jne    80b57b <tcp_zero_window_probe+0x1e>
    seg = pcb->unsent;
  80b570:	8b 70 74             	mov    0x74(%eax),%esi

  if(seg == NULL)
  80b573:	85 f6                	test   %esi,%esi
  80b575:	0f 84 23 01 00 00    	je     80b69e <tcp_zero_window_probe+0x141>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  80b57b:	83 ec 04             	sub    $0x4,%esp
  80b57e:	6a 00                	push   $0x0
  80b580:	6a 15                	push   $0x15
  80b582:	6a 01                	push   $0x1
  80b584:	e8 ff be ff ff       	call   807488 <pbuf_alloc>
  80b589:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80b58b:	83 c4 10             	add    $0x10,%esp
  80b58e:	85 c0                	test   %eax,%eax
  80b590:	0f 84 08 01 00 00    	je     80b69e <tcp_zero_window_probe+0x141>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80b596:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80b59b:	77 17                	ja     80b5b4 <tcp_zero_window_probe+0x57>
  80b59d:	83 ec 04             	sub    $0x4,%esp
  80b5a0:	68 c4 35 81 00       	push   $0x8135c4
  80b5a5:	68 8d 03 00 00       	push   $0x38d
  80b5aa:	68 f2 35 81 00       	push   $0x8135f2
  80b5af:	e8 18 55 ff ff       	call   800acc <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80b5b4:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80b5b7:	83 ec 0c             	sub    $0xc,%esp
  80b5ba:	8b 55 08             	mov    0x8(%ebp),%edx
  80b5bd:	0f b7 42 1c          	movzwl 0x1c(%edx),%eax
  80b5c1:	50                   	push   %eax
  80b5c2:	e8 98 f0 ff ff       	call   80a65f <htons>
  80b5c7:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80b5ca:	8b 55 08             	mov    0x8(%ebp),%edx
  80b5cd:	0f b7 42 1e          	movzwl 0x1e(%edx),%eax
  80b5d1:	89 04 24             	mov    %eax,(%esp)
  80b5d4:	e8 86 f0 ff ff       	call   80a65f <htons>
  80b5d9:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  80b5dd:	8b 46 10             	mov    0x10(%esi),%eax
  80b5e0:	8b 40 04             	mov    0x4(%eax),%eax
  80b5e3:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b5e6:	83 c4 04             	add    $0x4,%esp
  80b5e9:	8b 45 08             	mov    0x8(%ebp),%eax
  80b5ec:	ff 70 24             	pushl  0x24(%eax)
  80b5ef:	e8 96 f0 ff ff       	call   80a68a <htonl>
  80b5f4:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80b5f7:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b5fb:	89 04 24             	mov    %eax,(%esp)
  80b5fe:	e8 72 f0 ff ff       	call   80a675 <ntohs>
  80b603:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80b608:	89 04 24             	mov    %eax,(%esp)
  80b60b:	e8 4f f0 ff ff       	call   80a65f <htons>
  80b610:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b614:	8b 55 08             	mov    0x8(%ebp),%edx
  80b617:	0f b7 42 2a          	movzwl 0x2a(%edx),%eax
  80b61b:	89 04 24             	mov    %eax,(%esp)
  80b61e:	e8 3c f0 ff ff       	call   80a65f <htons>
  80b623:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80b627:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80b62d:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b631:	89 04 24             	mov    %eax,(%esp)
  80b634:	e8 3c f0 ff ff       	call   80a675 <ntohs>
  80b639:	80 cc 50             	or     $0x50,%ah
  80b63c:	25 3f 50 00 00       	and    $0x503f,%eax
  80b641:	89 04 24             	mov    %eax,(%esp)
  80b644:	e8 16 f0 ff ff       	call   80a65f <htons>
  80b649:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  80b64d:	8b 57 04             	mov    0x4(%edi),%edx
  80b650:	8b 46 08             	mov    0x8(%esi),%eax
  80b653:	8a 00                	mov    (%eax),%al
  80b655:	88 42 14             	mov    %al,0x14(%edx)

  tcphdr->chksum = 0;
  80b658:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80b65e:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b662:	89 04 24             	mov    %eax,(%esp)
  80b665:	6a 06                	push   $0x6
  80b667:	8b 75 08             	mov    0x8(%ebp),%esi
  80b66a:	83 c6 04             	add    $0x4,%esi
  80b66d:	56                   	push   %esi
  80b66e:	ff 75 08             	pushl  0x8(%ebp)
  80b671:	57                   	push   %edi
  80b672:	e8 97 ea ff ff       	call   80a10e <inet_chksum_pseudo>
  80b677:	66 89 43 10          	mov    %ax,0x10(%ebx)
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);

  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  {
    struct netif *netif;
    netif = ip_route(&pcb->remote_ip);
    if(netif != NULL){
      netif->addr_hint = &(pcb->addr_hint);
      ip_output_if(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl,
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80b67b:	83 c4 18             	add    $0x18,%esp
  80b67e:	6a 06                	push   $0x6
  80b680:	6a 00                	push   $0x0
  80b682:	8b 55 08             	mov    0x8(%ebp),%edx
  80b685:	0f b6 42 0b          	movzbl 0xb(%edx),%eax
  80b689:	50                   	push   %eax
  80b68a:	56                   	push   %esi
  80b68b:	52                   	push   %edx
  80b68c:	57                   	push   %edi
  80b68d:	e8 5d e0 ff ff       	call   8096ef <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80b692:	83 c4 14             	add    $0x14,%esp
  80b695:	57                   	push   %edi
  80b696:	e8 7e c2 ff ff       	call   807919 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
  80b69b:	83 c4 10             	add    $0x10,%esp
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80b69e:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80b6a1:	5b                   	pop    %ebx
  80b6a2:	5e                   	pop    %esi
  80b6a3:	5f                   	pop    %edi
  80b6a4:	c9                   	leave  
  80b6a5:	c3                   	ret    
	...

0080b6a8 <udp_input>:
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  80b6a8:	55                   	push   %ebp
  80b6a9:	89 e5                	mov    %esp,%ebp
  80b6ab:	57                   	push   %edi
  80b6ac:	56                   	push   %esi
  80b6ad:	53                   	push   %ebx
  80b6ae:	83 ec 28             	sub    $0x28,%esp
  80b6b1:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct udp_hdr *udphdr;
  struct udp_pcb *pcb, *prev;
  struct udp_pcb *uncon_pcb;
  struct ip_hdr *iphdr;
  u16_t src, dest;
  u8_t local_match;

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  80b6b4:	8b 77 04             	mov    0x4(%edi),%esi

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  80b6b7:	0f b7 5f 08          	movzwl 0x8(%edi),%ebx
  80b6bb:	0f b7 06             	movzwl (%esi),%eax
  80b6be:	50                   	push   %eax
  80b6bf:	e8 b1 ef ff ff       	call   80a675 <ntohs>
  80b6c4:	c1 e8 06             	shr    $0x6,%eax
  80b6c7:	83 e0 3c             	and    $0x3c,%eax
  80b6ca:	83 c0 08             	add    $0x8,%eax
  80b6cd:	83 c4 10             	add    $0x10,%esp
  80b6d0:	39 c3                	cmp    %eax,%ebx
  80b6d2:	7c 26                	jl     80b6fa <udp_input+0x52>
  80b6d4:	83 ec 0c             	sub    $0xc,%esp
  80b6d7:	0f b7 06             	movzwl (%esi),%eax
  80b6da:	50                   	push   %eax
  80b6db:	e8 95 ef ff ff       	call   80a675 <ntohs>
  80b6e0:	83 c4 08             	add    $0x8,%esp
  80b6e3:	c1 e8 06             	shr    $0x6,%eax
  80b6e6:	83 e0 3c             	and    $0x3c,%eax
  80b6e9:	f7 d8                	neg    %eax
  80b6eb:	98                   	cwtl   
  80b6ec:	50                   	push   %eax
  80b6ed:	57                   	push   %edi
  80b6ee:	e8 50 c1 ff ff       	call   807843 <pbuf_header>
  80b6f3:	83 c4 10             	add    $0x10,%esp
  80b6f6:	84 c0                	test   %al,%al
  80b6f8:	74 11                	je     80b70b <udp_input+0x63>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  80b6fa:	83 ec 0c             	sub    $0xc,%esp
  80b6fd:	57                   	push   %edi
  80b6fe:	e8 16 c2 ff ff       	call   807919 <pbuf_free>
    goto end;
  80b703:	83 c4 10             	add    $0x10,%esp
  80b706:	e9 90 02 00 00       	jmp    80b99b <udp_input+0x2f3>
  }

  udphdr = (struct udp_hdr *)p->payload;
  80b70b:	8b 47 04             	mov    0x4(%edi),%eax
  80b70e:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  80b711:	83 ec 0c             	sub    $0xc,%esp
  80b714:	0f b7 00             	movzwl (%eax),%eax
  80b717:	50                   	push   %eax
  80b718:	e8 58 ef ff ff       	call   80a675 <ntohs>
  80b71d:	66 89 45 e6          	mov    %ax,0xffffffe6(%ebp)
  dest = ntohs(udphdr->dest);
  80b721:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  80b724:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80b728:	89 04 24             	mov    %eax,(%esp)
  80b72b:	e8 45 ef ff ff       	call   80a675 <ntohs>
  80b730:	66 89 45 e4          	mov    %ax,0xffffffe4(%ebp)

  udp_debug_print(udphdr);

  /* print the UDP source and destination */
  LWIP_DEBUGF(UDP_DEBUG,
  80b734:	83 c4 10             	add    $0x10,%esp
              ("udp (%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F") <-- "
               "(%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F")\n",
               ip4_addr1(&iphdr->dest), ip4_addr2(&iphdr->dest),
               ip4_addr3(&iphdr->dest), ip4_addr4(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1(&iphdr->src), ip4_addr2(&iphdr->src),
               ip4_addr3(&iphdr->src), ip4_addr4(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
  80b737:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  80b73c:	66 83 f8 44          	cmp    $0x44,%ax
  80b740:	75 4e                	jne    80b790 <udp_input+0xe8>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  80b742:	66 83 7d e6 43       	cmpw   $0x43,0xffffffe6(%ebp)
  80b747:	0f 85 fe 00 00 00    	jne    80b84b <udp_input+0x1a3>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  80b74d:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b750:	83 78 20 00          	cmpl   $0x0,0x20(%eax)
  80b754:	0f 84 f1 00 00 00    	je     80b84b <udp_input+0x1a3>
  80b75a:	8b 40 20             	mov    0x20(%eax),%eax
  80b75d:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80b761:	0f 84 e4 00 00 00    	je     80b84b <udp_input+0x1a3>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  80b767:	83 78 08 fc          	cmpl   $0xfffffffc,0x8(%eax)
  80b76b:	74 15                	je     80b782 <udp_input+0xda>
  80b76d:	8b 40 08             	mov    0x8(%eax),%eax
  80b770:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  80b774:	74 0c                	je     80b782 <udp_input+0xda>
  80b776:	8b 40 04             	mov    0x4(%eax),%eax
  80b779:	3b 46 0c             	cmp    0xc(%esi),%eax
  80b77c:	0f 85 c9 00 00 00    	jne    80b84b <udp_input+0x1a3>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
          pcb = inp->dhcp->pcb;
  80b782:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b785:	8b 42 20             	mov    0x20(%edx),%eax
  80b788:	8b 58 08             	mov    0x8(%eax),%ebx
  80b78b:	e9 bb 00 00 00       	jmp    80b84b <udp_input+0x1a3>
        }
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  80b790:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
    local_match = 0;
    uncon_pcb = NULL;
  80b797:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80b79e:	8b 1d 80 e6 b3 00    	mov    0xb3e680,%ebx
  80b7a4:	85 db                	test   %ebx,%ebx
  80b7a6:	0f 84 9c 00 00 00    	je     80b848 <udp_input+0x1a0>
      local_match = 0;
  80b7ac:	c6 45 e3 00          	movb   $0x0,0xffffffe3(%ebp)
      /* print the PCB local and remote address */
      LWIP_DEBUGF(UDP_DEBUG,
                  ("pcb (%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F") --- "
                   "(%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F")\n",
                   ip4_addr1(&pcb->local_ip), ip4_addr2(&pcb->local_ip),
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80b7b0:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  80b7b3:	66 39 43 12          	cmp    %ax,0x12(%ebx)
  80b7b7:	75 39                	jne    80b7f2 <udp_input+0x14a>
  80b7b9:	85 db                	test   %ebx,%ebx
  80b7bb:	74 22                	je     80b7df <udp_input+0x137>
  80b7bd:	83 3b 00             	cmpl   $0x0,(%ebx)
  80b7c0:	74 1d                	je     80b7df <udp_input+0x137>
  80b7c2:	8b 03                	mov    (%ebx),%eax
  80b7c4:	3b 46 10             	cmp    0x10(%esi),%eax
  80b7c7:	74 16                	je     80b7df <udp_input+0x137>
  80b7c9:	83 ec 08             	sub    $0x8,%esp
  80b7cc:	ff 75 0c             	pushl  0xc(%ebp)
  80b7cf:	8d 46 10             	lea    0x10(%esi),%eax
  80b7d2:	50                   	push   %eax
  80b7d3:	e8 c0 d9 ff ff       	call   809198 <ip_addr_isbroadcast>
  80b7d8:	83 c4 10             	add    $0x10,%esp
  80b7db:	84 c0                	test   %al,%al
  80b7dd:	74 13                	je     80b7f2 <udp_input+0x14a>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
  80b7df:	c6 45 e3 01          	movb   $0x1,0xffffffe3(%ebp)
        if ((uncon_pcb == NULL) && 
  80b7e3:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
  80b7e7:	75 09                	jne    80b7f2 <udp_input+0x14a>
  80b7e9:	f6 43 10 04          	testb  $0x4,0x10(%ebx)
  80b7ed:	75 03                	jne    80b7f2 <udp_input+0x14a>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
  80b7ef:	89 5d e8             	mov    %ebx,0xffffffe8(%ebp)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  80b7f2:	80 7d e3 00          	cmpb   $0x0,0xffffffe3(%ebp)
  80b7f6:	74 3c                	je     80b834 <udp_input+0x18c>
  80b7f8:	66 8b 55 e6          	mov    0xffffffe6(%ebp),%dx
  80b7fc:	66 39 53 14          	cmp    %dx,0x14(%ebx)
  80b800:	75 32                	jne    80b834 <udp_input+0x18c>
  80b802:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80b805:	74 0e                	je     80b815 <udp_input+0x16d>
  80b807:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  80b80b:	74 08                	je     80b815 <udp_input+0x16d>
  80b80d:	8b 43 04             	mov    0x4(%ebx),%eax
  80b810:	3b 46 0c             	cmp    0xc(%esi),%eax
  80b813:	75 1f                	jne    80b834 <udp_input+0x18c>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  80b815:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  80b819:	74 29                	je     80b844 <udp_input+0x19c>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  80b81b:	8b 43 0c             	mov    0xc(%ebx),%eax
  80b81e:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  80b821:	89 42 0c             	mov    %eax,0xc(%edx)
          pcb->next = udp_pcbs;
  80b824:	a1 80 e6 b3 00       	mov    0xb3e680,%eax
  80b829:	89 43 0c             	mov    %eax,0xc(%ebx)
          udp_pcbs = pcb;
  80b82c:	89 1d 80 e6 b3 00    	mov    %ebx,0xb3e680
  80b832:	eb 10                	jmp    80b844 <udp_input+0x19c>
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
      }
      prev = pcb;
  80b834:	89 5d ec             	mov    %ebx,0xffffffec(%ebp)
  80b837:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80b83a:	85 db                	test   %ebx,%ebx
  80b83c:	0f 85 6a ff ff ff    	jne    80b7ac <udp_input+0x104>
  80b842:	eb 04                	jmp    80b848 <udp_input+0x1a0>
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
  80b844:	85 db                	test   %ebx,%ebx
  80b846:	75 16                	jne    80b85e <udp_input+0x1b6>
      pcb = uncon_pcb;
  80b848:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  80b84b:	85 db                	test   %ebx,%ebx
  80b84d:	75 0f                	jne    80b85e <udp_input+0x1b6>
  80b84f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b852:	8b 42 04             	mov    0x4(%edx),%eax
  80b855:	3b 46 10             	cmp    0x10(%esi),%eax
  80b858:	0f 85 31 01 00 00    	jne    80b98f <udp_input+0x2e7>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: calculating checksum\n"));
#if LWIP_UDPLITE
    if (IPH_PROTO(iphdr) == IP_PROTO_UDPLITE) {
      /* Do the UDP Lite checksum */
#if CHECKSUM_CHECK_UDP
      u16_t chklen = ntohs(udphdr->len);
      if (chklen < sizeof(struct udp_hdr)) {
        if (chklen == 0) {
          /* For UDP-Lite, checksum length of 0 means checksum
             over the complete packet (See RFC 3828 chap. 3.1) */
          chklen = p->tot_len;
        } else {
          /* At least the UDP-Lite header must be covered by the
             checksum! (Again, see RFC 3828 chap. 3.1) */
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
          goto end;
        }
      }
      if (inet_chksum_pseudo_partial(p, (struct ip_addr *)&(iphdr->src),
                             (struct ip_addr *)&(iphdr->dest),
                             IP_PROTO_UDPLITE, p->tot_len, chklen) != 0) {
        LWIP_DEBUGF(UDP_DEBUG | 2,
                    ("udp_input: UDP Lite datagram discarded due to failing checksum\n"));
        UDP_STATS_INC(udp.chkerr);
        UDP_STATS_INC(udp.drop);
        snmp_inc_udpinerrors();
        pbuf_free(p);
        goto end;
      }
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  80b85e:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  80b861:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  80b866:	74 31                	je     80b899 <udp_input+0x1f1>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80b868:	83 ec 0c             	sub    $0xc,%esp
  80b86b:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b86f:	50                   	push   %eax
  80b870:	6a 11                	push   $0x11
  80b872:	8d 46 10             	lea    0x10(%esi),%eax
  80b875:	50                   	push   %eax
  80b876:	8d 46 0c             	lea    0xc(%esi),%eax
  80b879:	50                   	push   %eax
  80b87a:	57                   	push   %edi
  80b87b:	e8 8e e8 ff ff       	call   80a10e <inet_chksum_pseudo>
  80b880:	83 c4 20             	add    $0x20,%esp
  80b883:	66 85 c0             	test   %ax,%ax
  80b886:	74 11                	je     80b899 <udp_input+0x1f1>
                               (struct ip_addr *)&(iphdr->dest),
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  80b888:	83 ec 0c             	sub    $0xc,%esp
  80b88b:	57                   	push   %edi
  80b88c:	e8 88 c0 ff ff       	call   807919 <pbuf_free>
          goto end;
  80b891:	83 c4 10             	add    $0x10,%esp
  80b894:	e9 02 01 00 00       	jmp    80b99b <udp_input+0x2f3>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  80b899:	83 ec 08             	sub    $0x8,%esp
  80b89c:	6a f8                	push   $0xfffffff8
  80b89e:	57                   	push   %edi
  80b89f:	e8 9f bf ff ff       	call   807843 <pbuf_header>
  80b8a4:	83 c4 10             	add    $0x10,%esp
  80b8a7:	84 c0                	test   %al,%al
  80b8a9:	74 17                	je     80b8c2 <udp_input+0x21a>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80b8ab:	83 ec 04             	sub    $0x4,%esp
  80b8ae:	68 17 36 81 00       	push   $0x813617
  80b8b3:	68 0a 01 00 00       	push   $0x10a
  80b8b8:	68 42 36 81 00       	push   $0x813642
  80b8bd:	e8 0a 52 ff ff       	call   800acc <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  80b8c2:	85 db                	test   %ebx,%ebx
  80b8c4:	74 33                	je     80b8f9 <udp_input+0x251>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  80b8c6:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
  80b8ca:	74 1c                	je     80b8e8 <udp_input+0x240>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  80b8cc:	83 ec 0c             	sub    $0xc,%esp
  80b8cf:	0f b7 45 e6          	movzwl 0xffffffe6(%ebp),%eax
  80b8d3:	50                   	push   %eax
  80b8d4:	8d 46 0c             	lea    0xc(%esi),%eax
  80b8d7:	50                   	push   %eax
  80b8d8:	57                   	push   %edi
  80b8d9:	53                   	push   %ebx
  80b8da:	ff 73 1c             	pushl  0x1c(%ebx)
  80b8dd:	ff 53 18             	call   *0x18(%ebx)
  80b8e0:	83 c4 20             	add    $0x20,%esp
  80b8e3:	e9 b3 00 00 00       	jmp    80b99b <udp_input+0x2f3>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  80b8e8:	83 ec 0c             	sub    $0xc,%esp
  80b8eb:	57                   	push   %edi
  80b8ec:	e8 28 c0 ff ff       	call   807919 <pbuf_free>
        goto end;
  80b8f1:	83 c4 10             	add    $0x10,%esp
  80b8f4:	e9 a2 00 00 00       	jmp    80b99b <udp_input+0x2f3>
      }
    } else {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80b8f9:	83 ec 08             	sub    $0x8,%esp
  80b8fc:	ff 75 0c             	pushl  0xc(%ebp)
  80b8ff:	8d 46 10             	lea    0x10(%esi),%eax
  80b902:	50                   	push   %eax
  80b903:	e8 90 d8 ff ff       	call   809198 <ip_addr_isbroadcast>
  80b908:	83 c4 10             	add    $0x10,%esp
  80b90b:	84 c0                	test   %al,%al
  80b90d:	75 72                	jne    80b981 <udp_input+0x2d9>
  80b90f:	83 ec 0c             	sub    $0xc,%esp
  80b912:	68 00 00 00 f0       	push   $0xf0000000
  80b917:	e8 9a ed ff ff       	call   80a6b6 <ntohl>
  80b91c:	89 c3                	mov    %eax,%ebx
  80b91e:	23 5e 10             	and    0x10(%esi),%ebx
  80b921:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80b928:	e8 89 ed ff ff       	call   80a6b6 <ntohl>
  80b92d:	83 c4 10             	add    $0x10,%esp
  80b930:	39 c3                	cmp    %eax,%ebx
  80b932:	74 4d                	je     80b981 <udp_input+0x2d9>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  80b934:	83 ec 0c             	sub    $0xc,%esp
  80b937:	0f b7 06             	movzwl (%esi),%eax
  80b93a:	50                   	push   %eax
  80b93b:	e8 35 ed ff ff       	call   80a675 <ntohs>
  80b940:	83 c4 08             	add    $0x8,%esp
  80b943:	c1 e8 06             	shr    $0x6,%eax
  80b946:	83 e0 3c             	and    $0x3c,%eax
  80b949:	83 c0 08             	add    $0x8,%eax
  80b94c:	98                   	cwtl   
  80b94d:	50                   	push   %eax
  80b94e:	57                   	push   %edi
  80b94f:	e8 ef be ff ff       	call   807843 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  80b954:	83 c4 10             	add    $0x10,%esp
  80b957:	39 77 04             	cmp    %esi,0x4(%edi)
  80b95a:	74 17                	je     80b973 <udp_input+0x2cb>
  80b95c:	83 ec 04             	sub    $0x4,%esp
  80b95f:	68 56 36 81 00       	push   $0x813656
  80b964:	68 25 01 00 00       	push   $0x125
  80b969:	68 42 36 81 00       	push   $0x813642
  80b96e:	e8 59 51 ff ff       	call   800acc <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  80b973:	83 ec 08             	sub    $0x8,%esp
  80b976:	6a 03                	push   $0x3
  80b978:	57                   	push   %edi
  80b979:	e8 28 5b 00 00       	call   8114a6 <icmp_dest_unreach>
  80b97e:	83 c4 10             	add    $0x10,%esp
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  80b981:	83 ec 0c             	sub    $0xc,%esp
  80b984:	57                   	push   %edi
  80b985:	e8 8f bf ff ff       	call   807919 <pbuf_free>
  80b98a:	83 c4 10             	add    $0x10,%esp
  80b98d:	eb 0c                	jmp    80b99b <udp_input+0x2f3>
    }
  } else {
    pbuf_free(p);
  80b98f:	83 ec 0c             	sub    $0xc,%esp
  80b992:	57                   	push   %edi
  80b993:	e8 81 bf ff ff       	call   807919 <pbuf_free>
  80b998:	83 c4 10             	add    $0x10,%esp
  }
end:
  PERF_STOP("udp_input");
}
  80b99b:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80b99e:	5b                   	pop    %ebx
  80b99f:	5e                   	pop    %esi
  80b9a0:	5f                   	pop    %edi
  80b9a1:	c9                   	leave  
  80b9a2:	c3                   	ret    

0080b9a3 <udp_send>:

/**
 * Send data using UDP.
 *
 * @param pcb UDP PCB used to send the data.
 * @param p chain of pbuf's to be sent.
 *
 * The datagram will be sent to the current remote_ip & remote_port
 * stored in pcb. If the pcb is not bound to a port, it will
 * automatically be bound to a random port.
 *
 * @return lwIP error code.
 * - ERR_OK. Successful. No error occured.
 * - ERR_MEM. Out of memory.
 * - ERR_RTE. Could not find route to destination address.
 * - More errors could be returned by lower protocol layers.
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  80b9a3:	55                   	push   %ebp
  80b9a4:	89 e5                	mov    %esp,%ebp
  80b9a6:	83 ec 08             	sub    $0x8,%esp
  80b9a9:	8b 55 08             	mov    0x8(%ebp),%edx
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  80b9ac:	0f b7 42 14          	movzwl 0x14(%edx),%eax
  80b9b0:	50                   	push   %eax
  80b9b1:	8d 42 04             	lea    0x4(%edx),%eax
  80b9b4:	50                   	push   %eax
  80b9b5:	ff 75 0c             	pushl  0xc(%ebp)
  80b9b8:	52                   	push   %edx
  80b9b9:	e8 05 00 00 00       	call   80b9c3 <udp_sendto>
  80b9be:	0f be c0             	movsbl %al,%eax
}
  80b9c1:	c9                   	leave  
  80b9c2:	c3                   	ret    

0080b9c3 <udp_sendto>:

/**
 * Send data to a specified address using UDP.
 *
 * @param pcb UDP PCB used to send the data.
 * @param p chain of pbuf's to be sent.
 * @param dst_ip Destination IP address.
 * @param dst_port Destination UDP port.
 *
 * dst_ip & dst_port are expected to be in the same byte order as in the pcb.
 *
 * If the PCB already has a remote address association, it will
 * be restored after the data is sent.
 * 
 * @return lwIP error code (@see udp_send for possible error codes)
 *
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  80b9c3:	55                   	push   %ebp
  80b9c4:	89 e5                	mov    %esp,%ebp
  80b9c6:	56                   	push   %esi
  80b9c7:	53                   	push   %ebx
  80b9c8:	8b 75 10             	mov    0x10(%ebp),%esi
  80b9cb:	8b 5d 14             	mov    0x14(%ebp),%ebx
  struct netif *netif;

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_send\n"));

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  80b9ce:	83 ec 0c             	sub    $0xc,%esp
  80b9d1:	56                   	push   %esi
  80b9d2:	e8 1d d8 ff ff       	call   8091f4 <ip_route>
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  80b9d7:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  80b9da:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
  80b9df:	85 c0                	test   %eax,%eax
  80b9e1:	74 17                	je     80b9fa <udp_sendto+0x37>
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  80b9e3:	83 ec 0c             	sub    $0xc,%esp
  80b9e6:	50                   	push   %eax
  80b9e7:	0f b7 c3             	movzwl %bx,%eax
  80b9ea:	50                   	push   %eax
  80b9eb:	56                   	push   %esi
  80b9ec:	ff 75 0c             	pushl  0xc(%ebp)
  80b9ef:	ff 75 08             	pushl  0x8(%ebp)
  80b9f2:	e8 0c 00 00 00       	call   80ba03 <udp_sendto_if>
  80b9f7:	0f be d0             	movsbl %al,%edx
}
  80b9fa:	89 d0                	mov    %edx,%eax
  80b9fc:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80b9ff:	5b                   	pop    %ebx
  80ba00:	5e                   	pop    %esi
  80ba01:	c9                   	leave  
  80ba02:	c3                   	ret    

0080ba03 <udp_sendto_if>:

/**
 * Send data to a specified address using UDP.
 * The netif used for sending can be specified.
 *
 * This function exists mainly for DHCP, to be able to send UDP packets
 * on a netif that is still down.
 *
 * @param pcb UDP PCB used to send the data.
 * @param p chain of pbuf's to be sent.
 * @param dst_ip Destination IP address.
 * @param dst_port Destination UDP port.
 * @param netif the netif used for sending.
 *
 * dst_ip & dst_port are expected to be in the same byte order as in the pcb.
 *
 * @return lwIP error code (@see udp_send for possible error codes)
 *
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  80ba03:	55                   	push   %ebp
  80ba04:	89 e5                	mov    %esp,%ebp
  80ba06:	57                   	push   %edi
  80ba07:	56                   	push   %esi
  80ba08:	53                   	push   %ebx
  80ba09:	83 ec 0c             	sub    $0xc,%esp
  80ba0c:	8b 7d 08             	mov    0x8(%ebp),%edi
  80ba0f:	8b 45 14             	mov    0x14(%ebp),%eax
  80ba12:	66 89 45 f2          	mov    %ax,0xfffffff2(%ebp)
  struct udp_hdr *udphdr;
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  80ba16:	66 83 7f 12 00       	cmpw   $0x0,0x12(%edi)
  80ba1b:	75 1f                	jne    80ba3c <udp_sendto_if+0x39>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80ba1d:	83 ec 04             	sub    $0x4,%esp
  80ba20:	0f b7 47 12          	movzwl 0x12(%edi),%eax
  80ba24:	50                   	push   %eax
  80ba25:	57                   	push   %edi
  80ba26:	57                   	push   %edi
  80ba27:	e8 5a 01 00 00       	call   80bb86 <udp_bind>
  80ba2c:	88 c3                	mov    %al,%bl
    if (err != ERR_OK) {
  80ba2e:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: forced port bind failed\n"));
      return err;
  80ba31:	0f be c0             	movsbl %al,%eax
  80ba34:	84 db                	test   %bl,%bl
  80ba36:	0f 85 42 01 00 00    	jne    80bb7e <udp_sendto_if+0x17b>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  80ba3c:	83 ec 08             	sub    $0x8,%esp
  80ba3f:	6a 08                	push   $0x8
  80ba41:	ff 75 0c             	pushl  0xc(%ebp)
  80ba44:	e8 fa bd ff ff       	call   807843 <pbuf_header>
  80ba49:	83 c4 10             	add    $0x10,%esp
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
    /* first pbuf q points to header pbuf */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  80ba4c:	8b 75 0c             	mov    0xc(%ebp),%esi
  80ba4f:	84 c0                	test   %al,%al
  80ba51:	74 2f                	je     80ba82 <udp_sendto_if+0x7f>
  80ba53:	83 ec 04             	sub    $0x4,%esp
  80ba56:	6a 00                	push   $0x0
  80ba58:	6a 08                	push   $0x8
  80ba5a:	6a 01                	push   $0x1
  80ba5c:	e8 27 ba ff ff       	call   807488 <pbuf_alloc>
  80ba61:	89 c6                	mov    %eax,%esi
  80ba63:	83 c4 10             	add    $0x10,%esp
  80ba66:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80ba6b:	85 f6                	test   %esi,%esi
  80ba6d:	0f 84 0b 01 00 00    	je     80bb7e <udp_sendto_if+0x17b>
  80ba73:	83 ec 08             	sub    $0x8,%esp
  80ba76:	ff 75 0c             	pushl  0xc(%ebp)
  80ba79:	56                   	push   %esi
  80ba7a:	e8 23 c0 ff ff       	call   807aa2 <pbuf_chain>
  80ba7f:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  80ba82:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  80ba87:	77 17                	ja     80baa0 <udp_sendto_if+0x9d>
  80ba89:	83 ec 04             	sub    $0x4,%esp
  80ba8c:	68 78 36 81 00       	push   $0x813678
  80ba91:	68 b2 01 00 00       	push   $0x1b2
  80ba96:	68 42 36 81 00       	push   $0x813642
  80ba9b:	e8 2c 50 ff ff       	call   800acc <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  80baa0:	8b 5e 04             	mov    0x4(%esi),%ebx
  udphdr->src = htons(pcb->local_port);
  80baa3:	83 ec 0c             	sub    $0xc,%esp
  80baa6:	0f b7 47 12          	movzwl 0x12(%edi),%eax
  80baaa:	50                   	push   %eax
  80baab:	e8 af eb ff ff       	call   80a65f <htons>
  80bab0:	66 89 03             	mov    %ax,(%ebx)
  udphdr->dest = htons(dst_port);
  80bab3:	0f b7 45 f2          	movzwl 0xfffffff2(%ebp),%eax
  80bab7:	89 04 24             	mov    %eax,(%esp)
  80baba:	e8 a0 eb ff ff       	call   80a65f <htons>
  80babf:	66 89 43 02          	mov    %ax,0x2(%ebx)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  80bac3:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  80bac9:	83 c4 10             	add    $0x10,%esp
  80bacc:	85 ff                	test   %edi,%edi
  80bace:	74 05                	je     80bad5 <udp_sendto_if+0xd2>
  80bad0:	83 3f 00             	cmpl   $0x0,(%edi)
  80bad3:	75 0b                	jne    80bae0 <udp_sendto_if+0xdd>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80bad5:	8b 55 18             	mov    0x18(%ebp),%edx
  80bad8:	83 c2 04             	add    $0x4,%edx
  80badb:	89 55 ec             	mov    %edx,0xffffffec(%ebp)
  80bade:	eb 25                	jmp    80bb05 <udp_sendto_if+0x102>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80bae0:	8b 07                	mov    (%edi),%eax
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
        /* free the header pbuf */
        pbuf_free(q);
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  80bae2:	89 7d ec             	mov    %edi,0xffffffec(%ebp)
  80bae5:	8b 55 18             	mov    0x18(%ebp),%edx
  80bae8:	3b 42 04             	cmp    0x4(%edx),%eax
  80baeb:	74 18                	je     80bb05 <udp_sendto_if+0x102>
  80baed:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80baf0:	74 0c                	je     80bafe <udp_sendto_if+0xfb>
  80baf2:	83 ec 0c             	sub    $0xc,%esp
  80baf5:	56                   	push   %esi
  80baf6:	e8 1e be ff ff       	call   807919 <pbuf_free>
  80bafb:	83 c4 10             	add    $0x10,%esp
  80bafe:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80bb03:	eb 79                	jmp    80bb7e <udp_sendto_if+0x17b>
  }

  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: sending datagram of length %"U16_F"\n", q->tot_len));

#if LWIP_UDPLITE
  /* UDP Lite protocol? */
  if (pcb->flags & UDP_FLAGS_UDPLITE) {
    u16_t chklen, chklen_hdr;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE packet length %"U16_F"\n", q->tot_len));
    /* set UDP message length in UDP header */
    chklen_hdr = chklen = pcb->chksum_len_tx;
    if ((chklen < sizeof(struct udp_hdr)) || (chklen > q->tot_len)) {
      if (chklen != 0) {
        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE pcb->chksum_len is illegal: %"U16_F"\n", chklen));
      }
      /* For UDP-Lite, checksum length of 0 means checksum
         over the complete packet. (See RFC 3828 chap. 3.1)
         At least the UDP-Lite header must be covered by the
         checksum, therefore, if chksum_len has an illegal
         value, we generate the checksum over the complete
         packet to be safe. */
      chklen_hdr = 0;
      chklen = q->tot_len;
    }
    udphdr->len = htons(chklen_hdr);
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    udphdr->chksum = inet_chksum_pseudo_partial(q, src_ip, dst_ip,
                                        IP_PROTO_UDPLITE, q->tot_len, chklen);
    /* chksum zero must become 0xffff, as zero means 'no checksum' */
    if (udphdr->chksum == 0x0000)
      udphdr->chksum = 0xffff;
#endif /* CHECKSUM_CHECK_UDP */
    /* output to IP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDPLITE,)\n"));
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDPLITE, netif);    
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  80bb05:	83 ec 0c             	sub    $0xc,%esp
  80bb08:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80bb0c:	50                   	push   %eax
  80bb0d:	e8 4d eb ff ff       	call   80a65f <htons>
  80bb12:	66 89 43 04          	mov    %ax,0x4(%ebx)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  80bb16:	83 c4 10             	add    $0x10,%esp
  80bb19:	f6 47 10 01          	testb  $0x1,0x10(%edi)
  80bb1d:	75 28                	jne    80bb47 <udp_sendto_if+0x144>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  80bb1f:	83 ec 0c             	sub    $0xc,%esp
  80bb22:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80bb26:	50                   	push   %eax
  80bb27:	6a 11                	push   $0x11
  80bb29:	ff 75 10             	pushl  0x10(%ebp)
  80bb2c:	ff 75 ec             	pushl  0xffffffec(%ebp)
  80bb2f:	56                   	push   %esi
  80bb30:	e8 d9 e5 ff ff       	call   80a10e <inet_chksum_pseudo>
  80bb35:	66 89 43 06          	mov    %ax,0x6(%ebx)
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  80bb39:	83 c4 20             	add    $0x20,%esp
  80bb3c:	66 85 c0             	test   %ax,%ax
  80bb3f:	75 06                	jne    80bb47 <udp_sendto_if+0x144>
  80bb41:	66 c7 43 06 ff ff    	movw   $0xffff,0x6(%ebx)
    }
#endif /* CHECKSUM_CHECK_UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  80bb47:	83 ec 04             	sub    $0x4,%esp
  80bb4a:	ff 75 18             	pushl  0x18(%ebp)
  80bb4d:	6a 11                	push   $0x11
  80bb4f:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  80bb53:	50                   	push   %eax
  80bb54:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80bb58:	50                   	push   %eax
  80bb59:	ff 75 10             	pushl  0x10(%ebp)
  80bb5c:	ff 75 ec             	pushl  0xffffffec(%ebp)
  80bb5f:	56                   	push   %esi
  80bb60:	e8 db d9 ff ff       	call   809540 <ip_output_if>
  80bb65:	88 c3                	mov    %al,%bl
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  80bb67:	83 c4 20             	add    $0x20,%esp
  80bb6a:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80bb6d:	74 0c                	je     80bb7b <udp_sendto_if+0x178>
    /* free the header pbuf */
    pbuf_free(q);
  80bb6f:	83 ec 0c             	sub    $0xc,%esp
  80bb72:	56                   	push   %esi
  80bb73:	e8 a1 bd ff ff       	call   807919 <pbuf_free>
    q = NULL;
  80bb78:	83 c4 10             	add    $0x10,%esp
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  80bb7b:	0f be c3             	movsbl %bl,%eax
}
  80bb7e:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80bb81:	5b                   	pop    %ebx
  80bb82:	5e                   	pop    %esi
  80bb83:	5f                   	pop    %edi
  80bb84:	c9                   	leave  
  80bb85:	c3                   	ret    

0080bb86 <udp_bind>:

/**
 * Bind an UDP PCB.
 *
 * @param pcb UDP PCB to be bound with a local address ipaddr and port.
 * @param ipaddr local IP address to bind with. Use IP_ADDR_ANY to
 * bind to all local interfaces.
 * @param port local UDP port to bind with. Use 0 to automatically bind
 * to a random port between UDP_LOCAL_PORT_RANGE_START and
 * UDP_LOCAL_PORT_RANGE_END.
 *
 * ipaddr & port are expected to be in the same byte order as in the pcb.
 *
 * @return lwIP error code.
 * - ERR_OK. Successful. No error occured.
 * - ERR_USE. The specified ipaddr and port are already bound to by
 * another UDP PCB.
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80bb86:	55                   	push   %ebp
  80bb87:	89 e5                	mov    %esp,%ebp
  80bb89:	57                   	push   %edi
  80bb8a:	56                   	push   %esi
  80bb8b:	53                   	push   %ebx
  80bb8c:	83 ec 0c             	sub    $0xc,%esp
  80bb8f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bb92:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80bb95:	8b 4d 10             	mov    0x10(%ebp),%ecx
  struct udp_pcb *ipcb;
  u8_t rebind;

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  80bb98:	be 00 00 00 00       	mov    $0x0,%esi
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80bb9d:	8b 15 80 e6 b3 00    	mov    0xb3e680,%edx
  80bba3:	85 d2                	test   %edx,%edx
  80bba5:	74 2d                	je     80bbd4 <udp_bind+0x4e>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  80bba7:	39 d3                	cmp    %edx,%ebx
  80bba9:	75 22                	jne    80bbcd <udp_bind+0x47>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  80bbab:	89 f0                	mov    %esi,%eax
  80bbad:	84 c0                	test   %al,%al
  80bbaf:	74 17                	je     80bbc8 <udp_bind+0x42>
  80bbb1:	83 ec 04             	sub    $0x4,%esp
  80bbb4:	68 6a 36 81 00       	push   $0x81366a
  80bbb9:	68 41 02 00 00       	push   $0x241
  80bbbe:	68 42 36 81 00       	push   $0x813642
  80bbc3:	e8 04 4f ff ff       	call   800acc <_panic>
      /* pcb already in list, just rebind */
      rebind = 1;
  80bbc8:	be 01 00 00 00       	mov    $0x1,%esi
  80bbcd:	8b 52 0c             	mov    0xc(%edx),%edx
  80bbd0:	85 d2                	test   %edx,%edx
  80bbd2:	75 d3                	jne    80bba7 <udp_bind+0x21>
    }

    /* this code does not allow upper layer to share a UDP port for
       listening to broadcast or multicast traffic (See SO_REUSE_ADDR and
       SO_REUSE_PORT under *BSD). TODO: See where it fits instead, OR
       combine with implementation of UDP PCB flags. Leon Woestenberg. */
#ifdef LWIP_UDP_TODO
    /* port matches that of PCB in list? */
    else
      if ((ipcb->local_port == port) &&
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
           ip_addr_isany(ipaddr) ||
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
        /* other PCB already binds to this local IP and port */
        LWIP_DEBUGF(UDP_DEBUG,
                    ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  80bbd4:	b8 00 00 00 00       	mov    $0x0,%eax
  80bbd9:	85 ff                	test   %edi,%edi
  80bbdb:	74 02                	je     80bbdf <udp_bind+0x59>
  80bbdd:	8b 07                	mov    (%edi),%eax
  80bbdf:	89 03                	mov    %eax,(%ebx)

  /* no port specified? */
  if (port == 0) {
  80bbe1:	66 85 c9             	test   %cx,%cx
  80bbe4:	75 33                	jne    80bc19 <udp_bind+0x93>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  80bbe6:	b9 00 10 00 00       	mov    $0x1000,%ecx
    ipcb = udp_pcbs;
  80bbeb:	8b 15 80 e6 b3 00    	mov    0xb3e680,%edx
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
      if (ipcb->local_port == port) {
        /* port is already used by another udp_pcb */
        port++;
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  80bbf1:	85 d2                	test   %edx,%edx
  80bbf3:	74 24                	je     80bc19 <udp_bind+0x93>
  80bbf5:	89 d0                	mov    %edx,%eax
  80bbf7:	66 39 4a 12          	cmp    %cx,0x12(%edx)
  80bbfb:	75 05                	jne    80bc02 <udp_bind+0x7c>
  80bbfd:	41                   	inc    %ecx
  80bbfe:	89 c2                	mov    %eax,%edx
  80bc00:	eb 03                	jmp    80bc05 <udp_bind+0x7f>
  80bc02:	8b 52 0c             	mov    0xc(%edx),%edx
  80bc05:	85 d2                	test   %edx,%edx
  80bc07:	74 10                	je     80bc19 <udp_bind+0x93>
  80bc09:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  80bc0e:	75 e7                	jne    80bbf7 <udp_bind+0x71>
    }
    if (ipcb != NULL) {
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  80bc10:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80bc15:	85 d2                	test   %edx,%edx
  80bc17:	75 1d                	jne    80bc36 <udp_bind+0xb0>
    }
  }
  pcb->local_port = port;
  80bc19:	66 89 4b 12          	mov    %cx,0x12(%ebx)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  80bc1d:	89 f0                	mov    %esi,%eax
  80bc1f:	84 c0                	test   %al,%al
  80bc21:	75 0e                	jne    80bc31 <udp_bind+0xab>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  80bc23:	a1 80 e6 b3 00       	mov    0xb3e680,%eax
  80bc28:	89 43 0c             	mov    %eax,0xc(%ebx)
    udp_pcbs = pcb;
  80bc2b:	89 1d 80 e6 b3 00    	mov    %ebx,0xb3e680
  }
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  80bc31:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80bc36:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80bc39:	5b                   	pop    %ebx
  80bc3a:	5e                   	pop    %esi
  80bc3b:	5f                   	pop    %edi
  80bc3c:	c9                   	leave  
  80bc3d:	c3                   	ret    

0080bc3e <udp_connect>:
/**
 * Connect an UDP PCB.
 *
 * This will associate the UDP PCB with the remote address.
 *
 * @param pcb UDP PCB to be connected with remote address ipaddr and port.
 * @param ipaddr remote IP address to connect with.
 * @param port remote UDP port to connect with.
 *
 * @return lwIP error code
 *
 * ipaddr & port are expected to be in the same byte order as in the pcb.
 *
 * The udp pcb is bound to a random local port if not already bound.
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80bc3e:	55                   	push   %ebp
  80bc3f:	89 e5                	mov    %esp,%ebp
  80bc41:	57                   	push   %edi
  80bc42:	56                   	push   %esi
  80bc43:	53                   	push   %ebx
  80bc44:	83 ec 0c             	sub    $0xc,%esp
  80bc47:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bc4a:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80bc4d:	8b 75 10             	mov    0x10(%ebp),%esi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  80bc50:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80bc55:	75 16                	jne    80bc6d <udp_connect+0x2f>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80bc57:	83 ec 04             	sub    $0x4,%esp
  80bc5a:	6a 00                	push   $0x0
  80bc5c:	53                   	push   %ebx
  80bc5d:	53                   	push   %ebx
  80bc5e:	e8 23 ff ff ff       	call   80bb86 <udp_bind>
    if (err != ERR_OK)
  80bc63:	83 c4 10             	add    $0x10,%esp
      return err;
  80bc66:	0f be d0             	movsbl %al,%edx
  80bc69:	84 c0                	test   %al,%al
  80bc6b:	75 46                	jne    80bcb3 <udp_connect+0x75>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  80bc6d:	b8 00 00 00 00       	mov    $0x0,%eax
  80bc72:	85 ff                	test   %edi,%edi
  80bc74:	74 0b                	je     80bc81 <udp_connect+0x43>
  80bc76:	8b 07                	mov    (%edi),%eax
  80bc78:	eb 07                	jmp    80bc81 <udp_connect+0x43>
  pcb->remote_port = port;
  pcb->flags |= UDP_FLAGS_CONNECTED;
/** TODO: this functionality belongs in upper layers */
#ifdef LWIP_UDP_TODO
  /* Nail down local IP for netconn_addr()/getsockname() */
  if (ip_addr_isany(&pcb->local_ip) && !ip_addr_isany(&pcb->remote_ip)) {
    struct netif *netif;

    if ((netif = ip_route(&(pcb->remote_ip))) == NULL) {
      LWIP_DEBUGF(UDP_DEBUG, ("udp_connect: No route to 0x%lx\n", pcb->remote_ip.addr));
      UDP_STATS_INC(udp.rterr);
      return ERR_RTE;
    }
    /** TODO: this will bind the udp pcb locally, to the interface which
        is used to route output packets to the remote address. However, we
        might want to accept incoming packets on any interface! */
    pcb->local_ip = netif->ip_addr;
  } else if (ip_addr_isany(&pcb->remote_ip)) {
    pcb->local_ip.addr = 0;
  }
#endif
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_connect: connected to %"U16_F".%"U16_F".%"U16_F".%"U16_F",port %"U16_F"\n",
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    if (pcb == ipcb) {
      /* already on the list, just return */
      return ERR_OK;
  80bc7a:	ba 00 00 00 00       	mov    $0x0,%edx
  80bc7f:	eb 32                	jmp    80bcb3 <udp_connect+0x75>
  80bc81:	89 43 04             	mov    %eax,0x4(%ebx)
  80bc84:	66 89 73 14          	mov    %si,0x14(%ebx)
  80bc88:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
  80bc8c:	a1 80 e6 b3 00       	mov    0xb3e680,%eax
  80bc91:	85 c0                	test   %eax,%eax
  80bc93:	74 0b                	je     80bca0 <udp_connect+0x62>
  80bc95:	39 c3                	cmp    %eax,%ebx
  80bc97:	74 e1                	je     80bc7a <udp_connect+0x3c>
  80bc99:	8b 40 0c             	mov    0xc(%eax),%eax
  80bc9c:	85 c0                	test   %eax,%eax
  80bc9e:	75 f5                	jne    80bc95 <udp_connect+0x57>
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  80bca0:	a1 80 e6 b3 00       	mov    0xb3e680,%eax
  80bca5:	89 43 0c             	mov    %eax,0xc(%ebx)
  udp_pcbs = pcb;
  80bca8:	89 1d 80 e6 b3 00    	mov    %ebx,0xb3e680
  return ERR_OK;
  80bcae:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80bcb3:	89 d0                	mov    %edx,%eax
  80bcb5:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80bcb8:	5b                   	pop    %ebx
  80bcb9:	5e                   	pop    %esi
  80bcba:	5f                   	pop    %edi
  80bcbb:	c9                   	leave  
  80bcbc:	c3                   	ret    

0080bcbd <udp_disconnect>:

/**
 * Disconnect a UDP PCB
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  80bcbd:	55                   	push   %ebp
  80bcbe:	89 e5                	mov    %esp,%ebp
  80bcc0:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  80bcc3:	8b 15 b0 32 81 00    	mov    0x8132b0,%edx
  80bcc9:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  80bccc:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  80bcd2:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  80bcd6:	c9                   	leave  
  80bcd7:	c3                   	ret    

0080bcd8 <udp_recv>:

/**
 * Set a receive callback for a UDP PCB
 *
 * This callback will be called when receiving a datagram for the pcb.
 *
 * @param pcb the pcb for wich to set the recv callback
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  80bcd8:	55                   	push   %ebp
  80bcd9:	89 e5                	mov    %esp,%ebp
  80bcdb:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80bcde:	8b 55 0c             	mov    0xc(%ebp),%edx
  80bce1:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  80bce4:	8b 55 10             	mov    0x10(%ebp),%edx
  80bce7:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  80bcea:	c9                   	leave  
  80bceb:	c3                   	ret    

0080bcec <udp_remove>:

/**
 * Remove an UDP PCB.
 *
 * @param pcb UDP PCB to be removed. The PCB is removed from the list of
 * UDP PCB's and the data structure is freed from memory.
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  80bcec:	55                   	push   %ebp
  80bced:	89 e5                	mov    %esp,%ebp
  80bcef:	83 ec 08             	sub    $0x8,%esp
  80bcf2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  80bcf5:	39 0d 80 e6 b3 00    	cmp    %ecx,0xb3e680
  80bcfb:	75 0a                	jne    80bd07 <udp_remove+0x1b>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  80bcfd:	8b 41 0c             	mov    0xc(%ecx),%eax
  80bd00:	a3 80 e6 b3 00       	mov    %eax,0xb3e680
  80bd05:	eb 22                	jmp    80bd29 <udp_remove+0x3d>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80bd07:	8b 15 80 e6 b3 00    	mov    0xb3e680,%edx
  80bd0d:	85 d2                	test   %edx,%edx
  80bd0f:	74 18                	je     80bd29 <udp_remove+0x3d>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80bd11:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  80bd15:	74 0b                	je     80bd22 <udp_remove+0x36>
  80bd17:	39 4a 0c             	cmp    %ecx,0xc(%edx)
  80bd1a:	75 06                	jne    80bd22 <udp_remove+0x36>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80bd1c:	8b 41 0c             	mov    0xc(%ecx),%eax
  80bd1f:	89 42 0c             	mov    %eax,0xc(%edx)
  80bd22:	8b 52 0c             	mov    0xc(%edx),%edx
  80bd25:	85 d2                	test   %edx,%edx
  80bd27:	75 e8                	jne    80bd11 <udp_remove+0x25>
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  80bd29:	83 ec 08             	sub    $0x8,%esp
  80bd2c:	51                   	push   %ecx
  80bd2d:	6a 01                	push   $0x1
  80bd2f:	e8 bd b4 ff ff       	call   8071f1 <memp_free>
}
  80bd34:	c9                   	leave  
  80bd35:	c3                   	ret    

0080bd36 <udp_new>:

/**
 * Create a UDP PCB.
 *
 * @return The UDP PCB which was created. NULL if the PCB data structure
 * could not be allocated.
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  80bd36:	55                   	push   %ebp
  80bd37:	89 e5                	mov    %esp,%ebp
  80bd39:	53                   	push   %ebx
  80bd3a:	83 ec 10             	sub    $0x10,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  80bd3d:	6a 01                	push   $0x1
  80bd3f:	e8 53 b4 ff ff       	call   807197 <memp_malloc>
  80bd44:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  80bd46:	83 c4 10             	add    $0x10,%esp
  80bd49:	85 c0                	test   %eax,%eax
  80bd4b:	74 14                	je     80bd61 <udp_new+0x2b>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  80bd4d:	83 ec 04             	sub    $0x4,%esp
  80bd50:	6a 20                	push   $0x20
  80bd52:	6a 00                	push   $0x0
  80bd54:	50                   	push   %eax
  80bd55:	e8 8f 55 ff ff       	call   8012e9 <memset>
    pcb->ttl = UDP_TTL;
  80bd5a:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  80bd5e:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80bd61:	89 d8                	mov    %ebx,%eax
  80bd63:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80bd66:	c9                   	leave  
  80bd67:	c3                   	ret    

0080bd68 <free_etharp_q>:
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  80bd68:	55                   	push   %ebp
  80bd69:	89 e5                	mov    %esp,%ebp
  80bd6b:	56                   	push   %esi
  80bd6c:	53                   	push   %ebx
  80bd6d:	8b 75 08             	mov    0x8(%ebp),%esi
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  80bd70:	85 f6                	test   %esi,%esi
  80bd72:	75 17                	jne    80bd8b <free_etharp_q+0x23>
  80bd74:	83 ec 04             	sub    $0x4,%esp
  80bd77:	68 55 2d 81 00       	push   $0x812d55
  80bd7c:	68 93 00 00 00       	push   $0x93
  80bd81:	68 b2 36 81 00       	push   $0x8136b2
  80bd86:	e8 41 4d ff ff       	call   800acc <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80bd8b:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
  80bd8f:	75 17                	jne    80bda8 <free_etharp_q+0x40>
  80bd91:	83 ec 04             	sub    $0x4,%esp
  80bd94:	68 ca 36 81 00       	push   $0x8136ca
  80bd99:	68 94 00 00 00       	push   $0x94
  80bd9e:	68 b2 36 81 00       	push   $0x8136b2
  80bda3:	e8 24 4d ff ff       	call   800acc <_panic>
  while (q) {
    r = q;
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  80bda8:	85 f6                	test   %esi,%esi
  80bdaa:	74 3e                	je     80bdea <free_etharp_q+0x82>
  80bdac:	89 f3                	mov    %esi,%ebx
  80bdae:	8b 36                	mov    (%esi),%esi
  80bdb0:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  80bdb4:	75 17                	jne    80bdcd <free_etharp_q+0x65>
  80bdb6:	83 ec 04             	sub    $0x4,%esp
  80bdb9:	68 d7 36 81 00       	push   $0x8136d7
  80bdbe:	68 98 00 00 00       	push   $0x98
  80bdc3:	68 b2 36 81 00       	push   $0x8136b2
  80bdc8:	e8 ff 4c ff ff       	call   800acc <_panic>
  80bdcd:	83 ec 0c             	sub    $0xc,%esp
  80bdd0:	ff 73 04             	pushl  0x4(%ebx)
  80bdd3:	e8 41 bb ff ff       	call   807919 <pbuf_free>
  80bdd8:	83 c4 08             	add    $0x8,%esp
  80bddb:	53                   	push   %ebx
  80bddc:	6a 0a                	push   $0xa
  80bdde:	e8 0e b4 ff ff       	call   8071f1 <memp_free>
  80bde3:	83 c4 10             	add    $0x10,%esp
  80bde6:	85 f6                	test   %esi,%esi
  80bde8:	75 c2                	jne    80bdac <free_etharp_q+0x44>
  }
}
  80bdea:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80bded:	5b                   	pop    %ebx
  80bdee:	5e                   	pop    %esi
  80bdef:	c9                   	leave  
  80bdf0:	c3                   	ret    

0080bdf1 <etharp_tmr>:
#endif

/**
 * Clears expired entries in the ARP table.
 *
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  80bdf1:	55                   	push   %ebp
  80bdf2:	89 e5                	mov    %esp,%ebp
  80bdf4:	56                   	push   %esi
  80bdf5:	53                   	push   %ebx
  80bdf6:	83 ec 10             	sub    $0x10,%esp
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80bdf9:	c6 45 f7 00          	movb   $0x0,0xfffffff7(%ebp)
  80bdfd:	be 50 7e b3 00       	mov    $0xb37e50,%esi
    arp_table[i].ctime++;
  80be02:	0f b6 55 f7          	movzbl 0xfffffff7(%ebp),%edx
  80be06:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80be0d:	29 d0                	sub    %edx,%eax
  80be0f:	c1 e0 02             	shl    $0x2,%eax
  80be12:	fe 44 30 04          	incb   0x4(%eax,%esi,1)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80be16:	83 b8 50 7e b3 00 02 	cmpl   $0x2,0xb37e50(%eax)
  80be1d:	75 07                	jne    80be26 <etharp_tmr+0x35>
  80be1f:	80 7c 30 04 ef       	cmpb   $0xef,0x4(%eax,%esi,1)
  80be24:	77 20                	ja     80be46 <etharp_tmr+0x55>
  80be26:	0f b6 55 f7          	movzbl 0xfffffff7(%ebp),%edx
  80be2a:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80be31:	29 d0                	sub    %edx,%eax
  80be33:	c1 e0 02             	shl    $0x2,%eax
  80be36:	83 b8 50 7e b3 00 01 	cmpl   $0x1,0xb37e50(%eax)
  80be3d:	75 5d                	jne    80be9c <etharp_tmr+0xab>
  80be3f:	80 7c 30 04 01       	cmpb   $0x1,0x4(%eax,%esi,1)
  80be44:	76 56                	jbe    80be9c <etharp_tmr+0xab>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
         (arp_table[i].ctime >= ARP_MAXPENDING))) {
         /* pending or stable entry has become old! */
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
           arp_table[i].state == ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  80be46:	0f b6 55 f7          	movzbl 0xfffffff7(%ebp),%edx
  80be4a:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80be51:	29 d0                	sub    %edx,%eax
  80be53:	83 3c 85 40 7e b3 00 	cmpl   $0x0,0xb37e40(,%eax,4)
  80be5a:	00 
  80be5b:	74 27                	je     80be84 <etharp_tmr+0x93>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  80be5d:	83 ec 0c             	sub    $0xc,%esp
  80be60:	8d 1c d5 00 00 00 00 	lea    0x0(,%edx,8),%ebx
  80be67:	29 d3                	sub    %edx,%ebx
  80be69:	c1 e3 02             	shl    $0x2,%ebx
  80be6c:	ff b3 40 7e b3 00    	pushl  0xb37e40(%ebx)
  80be72:	e8 f1 fe ff ff       	call   80bd68 <free_etharp_q>
        arp_table[i].q = NULL;
  80be77:	c7 83 40 7e b3 00 00 	movl   $0x0,0xb37e40(%ebx)
  80be7e:	00 00 00 
  80be81:	83 c4 10             	add    $0x10,%esp
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  80be84:	0f b6 55 f7          	movzbl 0xfffffff7(%ebp),%edx
  80be88:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80be8f:	29 d0                	sub    %edx,%eax
  80be91:	c7 04 85 50 7e b3 00 	movl   $0x0,0xb37e50(,%eax,4)
  80be98:	00 00 00 00 
  80be9c:	fe 45 f7             	incb   0xfffffff7(%ebp)
  80be9f:	80 7d f7 09          	cmpb   $0x9,0xfffffff7(%ebp)
  80bea3:	0f 86 59 ff ff ff    	jbe    80be02 <etharp_tmr+0x11>
    }
#if ARP_QUEUEING
    /* still pending entry? (not expired) */
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  80bea9:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80beac:	5b                   	pop    %ebx
  80bead:	5e                   	pop    %esi
  80beae:	c9                   	leave  
  80beaf:	c3                   	ret    

0080beb0 <find_entry>:

/**
 * Search the ARP table for a matching or new entry.
 * 
 * If an IP address is given, return a pending or stable ARP entry that matches
 * the address. If no match is found, create a new entry with this address set,
 * but in state ETHARP_EMPTY. The caller must check and possibly change the
 * state of the returned entry.
 * 
 * If ipaddr is NULL, return a initialized new entry in state ETHARP_EMPTY.
 * 
 * In all cases, attempt to create new entries from an empty entry. If no
 * empty entries are available and ETHARP_TRY_HARD flag is set, recycle
 * old entries. Heuristic choose the least important entry for recycling.
 *
 * @param ipaddr IP address to find in ARP cache, or to add if not found.
 * @param flags
 * - ETHARP_TRY_HARD: Try hard to create a entry by allowing recycling of
 * active (stable or pending) entries.
 *  
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  80beb0:	55                   	push   %ebp
  80beb1:	89 e5                	mov    %esp,%ebp
  80beb3:	57                   	push   %edi
  80beb4:	56                   	push   %esi
  80beb5:	53                   	push   %ebx
  80beb6:	83 ec 0c             	sub    $0xc,%esp
  80beb9:	8b 75 08             	mov    0x8(%ebp),%esi
  80bebc:	0f b6 7d 0c          	movzbl 0xc(%ebp),%edi
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  80bec0:	c6 45 f3 0a          	movb   $0xa,0xfffffff3(%ebp)
  80bec4:	c6 45 f2 0a          	movb   $0xa,0xfffffff2(%ebp)
  s8_t empty = ARP_TABLE_SIZE;
  80bec8:	c6 45 f1 0a          	movb   $0xa,0xfffffff1(%ebp)
  u8_t i = 0, age_pending = 0, age_stable = 0;
  80becc:	c6 45 f0 00          	movb   $0x0,0xfffffff0(%ebp)
  80bed0:	c6 45 ef 00          	movb   $0x0,0xffffffef(%ebp)
#if ARP_QUEUEING
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  80bed4:	c6 45 ee 0a          	movb   $0xa,0xffffffee(%ebp)
  /* its age */
  u8_t age_queue = 0;
  80bed8:	c6 45 ed 00          	movb   $0x0,0xffffffed(%ebp)
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  80bedc:	85 f6                	test   %esi,%esi
  80bede:	74 36                	je     80bf16 <find_entry+0x66>
    /* ipaddr to search for was given */
#if LWIP_NETIF_HWADDRHINT
    if ((netif != NULL) && (netif->addr_hint != NULL)) {
      /* per-pcb cached entry was given */
      u8_t per_pcb_cache = *(netif->addr_hint);
      if ((per_pcb_cache < ARP_TABLE_SIZE) && arp_table[per_pcb_cache].state == ETHARP_STATE_STABLE) {
        /* the per-pcb-cached entry is stable */
        if (ip_addr_cmp(ipaddr, &arp_table[per_pcb_cache].ipaddr)) {
          /* per-pcb cached entry was the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  80bee0:	0f b6 15 58 7f b3 00 	movzbl 0xb37f58,%edx
  80bee7:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80beee:	29 d0                	sub    %edx,%eax
  80bef0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80bef7:	83 ba 50 7e b3 00 02 	cmpl   $0x2,0xb37e50(%edx)
  80befe:	75 16                	jne    80bf16 <find_entry+0x66>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  80bf00:	8b 06                	mov    (%esi),%eax
  80bf02:	3b 82 44 7e b3 00    	cmp    0xb37e44(%edx),%eax
  80bf08:	75 0c                	jne    80bf16 <find_entry+0x66>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  80bf0a:	0f be 05 58 7f b3 00 	movsbl 0xb37f58,%eax
  80bf11:	e9 31 02 00 00       	jmp    80c147 <find_entry+0x297>
      }
    }
#endif /* #if LWIP_NETIF_HWADDRHINT */
  }

  /**
   * a) do a search through the cache, remember candidates
   * b) select candidate entry
   * c) create new entry
   */

  /* a) in a single search sweep, do all of this
   * 1) remember the first empty entry (if any)
   * 2) remember the oldest stable entry (if any)
   * 3) remember the oldest pending entry without queued packets (if any)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80bf16:	b3 00                	mov    $0x0,%bl
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  80bf18:	80 7d f1 0a          	cmpb   $0xa,0xfffffff1(%ebp)
  80bf1c:	75 1e                	jne    80bf3c <find_entry+0x8c>
  80bf1e:	0f b6 d3             	movzbl %bl,%edx
  80bf21:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80bf28:	29 d0                	sub    %edx,%eax
  80bf2a:	83 3c 85 50 7e b3 00 	cmpl   $0x0,0xb37e50(,%eax,4)
  80bf31:	00 
  80bf32:	75 08                	jne    80bf3c <find_entry+0x8c>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  80bf34:	88 5d f1             	mov    %bl,0xfffffff1(%ebp)
  80bf37:	e9 f9 00 00 00       	jmp    80c035 <find_entry+0x185>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80bf3c:	0f b6 d3             	movzbl %bl,%edx
  80bf3f:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80bf46:	29 d0                	sub    %edx,%eax
  80bf48:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80bf4f:	83 ba 50 7e b3 00 01 	cmpl   $0x1,0xb37e50(%edx)
  80bf56:	75 7e                	jne    80bfd6 <find_entry+0x126>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80bf58:	85 f6                	test   %esi,%esi
  80bf5a:	74 18                	je     80bf74 <find_entry+0xc4>
  80bf5c:	8b 06                	mov    (%esi),%eax
  80bf5e:	3b 82 44 7e b3 00    	cmp    0xb37e44(%edx),%eax
  80bf64:	75 0e                	jne    80bf74 <find_entry+0xc4>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80bf66:	88 1d 58 7f b3 00    	mov    %bl,0xb37f58
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80bf6c:	0f be c3             	movsbl %bl,%eax
  80bf6f:	e9 d3 01 00 00       	jmp    80c147 <find_entry+0x297>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  80bf74:	0f b6 d3             	movzbl %bl,%edx
  80bf77:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80bf7e:	29 d0                	sub    %edx,%eax
  80bf80:	c1 e0 02             	shl    $0x2,%eax
  80bf83:	83 b8 40 7e b3 00 00 	cmpl   $0x0,0xb37e40(%eax)
  80bf8a:	74 21                	je     80bfad <find_entry+0xfd>
        if (arp_table[i].ctime >= age_queue) {
  80bf8c:	ba 50 7e b3 00       	mov    $0xb37e50,%edx
  80bf91:	8a 4d ed             	mov    0xffffffed(%ebp),%cl
  80bf94:	38 4c 10 04          	cmp    %cl,0x4(%eax,%edx,1)
  80bf98:	0f 82 97 00 00 00    	jb     80c035 <find_entry+0x185>
          old_queue = i;
  80bf9e:	88 5d ee             	mov    %bl,0xffffffee(%ebp)
          age_queue = arp_table[i].ctime;
  80bfa1:	8a 44 10 04          	mov    0x4(%eax,%edx,1),%al
  80bfa5:	88 45 ed             	mov    %al,0xffffffed(%ebp)
  80bfa8:	e9 88 00 00 00       	jmp    80c035 <find_entry+0x185>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  80bfad:	0f b6 d3             	movzbl %bl,%edx
  80bfb0:	b9 50 7e b3 00       	mov    $0xb37e50,%ecx
  80bfb5:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80bfbc:	29 d0                	sub    %edx,%eax
  80bfbe:	c1 e0 02             	shl    $0x2,%eax
  80bfc1:	8a 55 f0             	mov    0xfffffff0(%ebp),%dl
  80bfc4:	38 54 08 04          	cmp    %dl,0x4(%eax,%ecx,1)
  80bfc8:	72 6b                	jb     80c035 <find_entry+0x185>
          old_pending = i;
  80bfca:	88 5d f3             	mov    %bl,0xfffffff3(%ebp)
          age_pending = arp_table[i].ctime;
  80bfcd:	8a 44 08 04          	mov    0x4(%eax,%ecx,1),%al
  80bfd1:	88 45 f0             	mov    %al,0xfffffff0(%ebp)
  80bfd4:	eb 5f                	jmp    80c035 <find_entry+0x185>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80bfd6:	0f b6 d3             	movzbl %bl,%edx
  80bfd9:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80bfe0:	29 d0                	sub    %edx,%eax
  80bfe2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80bfe9:	83 ba 50 7e b3 00 02 	cmpl   $0x2,0xb37e50(%edx)
  80bff0:	75 43                	jne    80c035 <find_entry+0x185>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80bff2:	85 f6                	test   %esi,%esi
  80bff4:	74 18                	je     80c00e <find_entry+0x15e>
  80bff6:	8b 06                	mov    (%esi),%eax
  80bff8:	3b 82 44 7e b3 00    	cmp    0xb37e44(%edx),%eax
  80bffe:	75 0e                	jne    80c00e <find_entry+0x15e>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80c000:	88 1d 58 7f b3 00    	mov    %bl,0xb37f58
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80c006:	0f be c3             	movsbl %bl,%eax
  80c009:	e9 39 01 00 00       	jmp    80c147 <find_entry+0x297>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  80c00e:	0f b6 d3             	movzbl %bl,%edx
  80c011:	b9 50 7e b3 00       	mov    $0xb37e50,%ecx
  80c016:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80c01d:	29 d0                	sub    %edx,%eax
  80c01f:	c1 e0 02             	shl    $0x2,%eax
  80c022:	8a 55 ef             	mov    0xffffffef(%ebp),%dl
  80c025:	38 54 08 04          	cmp    %dl,0x4(%eax,%ecx,1)
  80c029:	72 0a                	jb     80c035 <find_entry+0x185>
        old_stable = i;
  80c02b:	88 5d f2             	mov    %bl,0xfffffff2(%ebp)
        age_stable = arp_table[i].ctime;
  80c02e:	8a 44 08 04          	mov    0x4(%eax,%ecx,1),%al
  80c032:	88 45 ef             	mov    %al,0xffffffef(%ebp)
  80c035:	43                   	inc    %ebx
  80c036:	80 fb 09             	cmp    $0x9,%bl
  80c039:	0f 86 d9 fe ff ff    	jbe    80bf18 <find_entry+0x68>
      }
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  80c03f:	80 7d f1 0a          	cmpb   $0xa,0xfffffff1(%ebp)
  80c043:	75 08                	jne    80c04d <find_entry+0x19d>
  80c045:	f7 c7 01 00 00 00    	test   $0x1,%edi
  80c04b:	74 08                	je     80c055 <find_entry+0x1a5>
  80c04d:	f7 c7 02 00 00 00    	test   $0x2,%edi
  80c053:	74 0a                	je     80c05f <find_entry+0x1af>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  80c055:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c05a:	e9 e8 00 00 00       	jmp    80c147 <find_entry+0x297>
  }
  
  /* b) choose the least destructive entry to recycle:
   * 1) empty entry
   * 2) oldest stable entry
   * 3) oldest pending entry without queued packets
   * 4) oldest pending entry with queued packets
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  80c05f:	8a 5d f1             	mov    0xfffffff1(%ebp),%bl
  80c062:	80 fb 09             	cmp    $0x9,%bl
  80c065:	7e 7e                	jle    80c0e5 <find_entry+0x235>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  80c067:	80 7d f2 09          	cmpb   $0x9,0xfffffff2(%ebp)
  80c06b:	7f 30                	jg     80c09d <find_entry+0x1ed>
    /* recycle oldest stable*/
    i = old_stable;
  80c06d:	8a 5d f2             	mov    0xfffffff2(%ebp),%bl
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  80c070:	0f b6 d3             	movzbl %bl,%edx
  80c073:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80c07a:	29 d0                	sub    %edx,%eax
  80c07c:	83 3c 85 40 7e b3 00 	cmpl   $0x0,0xb37e40(,%eax,4)
  80c083:	00 
  80c084:	74 5f                	je     80c0e5 <find_entry+0x235>
  80c086:	83 ec 04             	sub    $0x4,%esp
  80c089:	68 e4 36 81 00       	push   $0x8136e4
  80c08e:	68 75 01 00 00       	push   $0x175
  80c093:	68 b2 36 81 00       	push   $0x8136b2
  80c098:	e8 2f 4a ff ff       	call   800acc <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
    /* recycle oldest pending */
    i = old_pending;
  80c09d:	8a 5d f3             	mov    0xfffffff3(%ebp),%bl
  80c0a0:	80 fb 09             	cmp    $0x9,%bl
  80c0a3:	7e 40                	jle    80c0e5 <find_entry+0x235>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
    /* recycle oldest pending */
    i = old_queue;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  80c0a5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c0aa:	80 7d ee 09          	cmpb   $0x9,0xffffffee(%ebp)
  80c0ae:	0f 8f 93 00 00 00    	jg     80c147 <find_entry+0x297>
  80c0b4:	8a 5d ee             	mov    0xffffffee(%ebp),%bl
  80c0b7:	83 ec 0c             	sub    $0xc,%esp
  80c0ba:	0f b6 c3             	movzbl %bl,%eax
  80c0bd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  80c0c4:	29 c2                	sub    %eax,%edx
  80c0c6:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
  80c0cd:	ff b7 40 7e b3 00    	pushl  0xb37e40(%edi)
  80c0d3:	e8 90 fc ff ff       	call   80bd68 <free_etharp_q>
  80c0d8:	c7 87 40 7e b3 00 00 	movl   $0x0,0xb37e40(%edi)
  80c0df:	00 00 00 
  80c0e2:	83 c4 10             	add    $0x10,%esp
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  80c0e5:	80 fb 09             	cmp    $0x9,%bl
  80c0e8:	76 17                	jbe    80c101 <find_entry+0x251>
  80c0ea:	83 ec 04             	sub    $0x4,%esp
  80c0ed:	68 fb 36 81 00       	push   $0x8136fb
  80c0f2:	68 8b 01 00 00       	push   $0x18b
  80c0f7:	68 b2 36 81 00       	push   $0x8136b2
  80c0fc:	e8 cb 49 ff ff       	call   800acc <_panic>

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  80c101:	0f b6 d3             	movzbl %bl,%edx
  80c104:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80c10b:	29 d0                	sub    %edx,%eax
  80c10d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  80c114:	c7 82 50 7e b3 00 00 	movl   $0x0,0xb37e50(%edx)
  80c11b:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  80c11e:	85 f6                	test   %esi,%esi
  80c120:	74 08                	je     80c12a <find_entry+0x27a>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  80c122:	8b 06                	mov    (%esi),%eax
  80c124:	89 82 44 7e b3 00    	mov    %eax,0xb37e44(%edx)
  }
  arp_table[i].ctime = 0;
  80c12a:	0f b6 d3             	movzbl %bl,%edx
  80c12d:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80c134:	29 d0                	sub    %edx,%eax
  80c136:	c6 04 85 54 7e b3 00 	movb   $0x0,0xb37e54(,%eax,4)
  80c13d:	00 
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  80c13e:	88 1d 58 7f b3 00    	mov    %bl,0xb37f58
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  80c144:	0f be c3             	movsbl %bl,%eax
}
  80c147:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80c14a:	5b                   	pop    %ebx
  80c14b:	5e                   	pop    %esi
  80c14c:	5f                   	pop    %edi
  80c14d:	c9                   	leave  
  80c14e:	c3                   	ret    

0080c14f <etharp_send_ip>:

/**
 * Send an IP packet on the network using netif->linkoutput
 * The ethernet header is filled in before sending.
 *
 * @params netif the lwIP network interface on which to send the packet
 * @params p the packet to send, p->payload pointing to the (uninitialized) ethernet header
 * @params src the source MAC address to be copied into the ethernet header
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  80c14f:	55                   	push   %ebp
  80c150:	89 e5                	mov    %esp,%ebp
  80c152:	57                   	push   %edi
  80c153:	56                   	push   %esi
  80c154:	53                   	push   %ebx
  80c155:	83 ec 0c             	sub    $0xc,%esp
  80c158:	8b 7d 10             	mov    0x10(%ebp),%edi
  80c15b:	8b 75 14             	mov    0x14(%ebp),%esi
  struct eth_hdr *ethhdr = p->payload;
  80c15e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c161:	8b 58 04             	mov    0x4(%eax),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  80c164:	b1 06                	mov    $0x6,%cl
  80c166:	8b 55 08             	mov    0x8(%ebp),%edx
  80c169:	80 7a 24 06          	cmpb   $0x6,0x24(%edx)
  80c16d:	74 17                	je     80c186 <etharp_send_ip+0x37>
  80c16f:	83 ec 04             	sub    $0x4,%esp
  80c172:	68 28 37 81 00       	push   $0x813728
  80c177:	68 b3 01 00 00       	push   $0x1b3
  80c17c:	68 b2 36 81 00       	push   $0x8136b2
  80c181:	e8 46 49 ff ff       	call   800acc <_panic>
  while(k > 0) {
    k--;
  80c186:	49                   	dec    %ecx
    ethhdr->dest.addr[k] = dst->addr[k];
  80c187:	0f b6 c1             	movzbl %cl,%eax
  80c18a:	8a 14 06             	mov    (%esi,%eax,1),%dl
  80c18d:	88 14 03             	mov    %dl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  80c190:	8a 14 07             	mov    (%edi,%eax,1),%dl
  80c193:	88 54 03 06          	mov    %dl,0x6(%ebx,%eax,1)
  80c197:	84 c9                	test   %cl,%cl
  80c199:	75 eb                	jne    80c186 <etharp_send_ip+0x37>
  }
  ethhdr->type = htons(ETHTYPE_IP);
  80c19b:	83 ec 0c             	sub    $0xc,%esp
  80c19e:	68 00 08 00 00       	push   $0x800
  80c1a3:	e8 b7 e4 ff ff       	call   80a65f <htons>
  80c1a8:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  80c1ac:	83 c4 08             	add    $0x8,%esp
  /* send the packet */
  return netif->linkoutput(netif, p);
  80c1af:	ff 75 0c             	pushl  0xc(%ebp)
  80c1b2:	ff 75 08             	pushl  0x8(%ebp)
  80c1b5:	8b 55 08             	mov    0x8(%ebp),%edx
  80c1b8:	ff 52 18             	call   *0x18(%edx)
  80c1bb:	0f be c0             	movsbl %al,%eax
}
  80c1be:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80c1c1:	5b                   	pop    %ebx
  80c1c2:	5e                   	pop    %esi
  80c1c3:	5f                   	pop    %edi
  80c1c4:	c9                   	leave  
  80c1c5:	c3                   	ret    

0080c1c6 <update_arp_entry>:

/**
 * Update (or insert) a IP/MAC address pair in the ARP cache.
 *
 * If a pending entry is resolved, any queued packets will be sent
 * at this point.
 * 
 * @param ipaddr IP address of the inserted ARP entry.
 * @param ethaddr Ethernet address of the inserted ARP entry.
 * @param flags Defines behaviour:
 * - ETHARP_TRY_HARD Allows ARP to insert this as a new item. If not specified,
 * only existing ARP entries will be updated.
 *
 * @return
 * - ERR_OK Succesfully updated ARP cache.
 * - ERR_MEM If we could not add a new ARP entry when ETHARP_TRY_HARD was set.
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  80c1c6:	55                   	push   %ebp
  80c1c7:	89 e5                	mov    %esp,%ebp
  80c1c9:	57                   	push   %edi
  80c1ca:	56                   	push   %esi
  80c1cb:	53                   	push   %ebx
  80c1cc:	83 ec 0c             	sub    $0xc,%esp
  80c1cf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80c1d2:	0f b6 75 14          	movzbl 0x14(%ebp),%esi
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80c1d6:	8b 45 08             	mov    0x8(%ebp),%eax
  80c1d9:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80c1dd:	74 17                	je     80c1f6 <update_arp_entry+0x30>
  80c1df:	83 ec 04             	sub    $0x4,%esp
  80c1e2:	68 6c 37 81 00       	push   $0x81376c
  80c1e7:	68 d9 01 00 00       	push   $0x1d9
  80c1ec:	68 b2 36 81 00       	push   $0x8136b2
  80c1f1:	e8 d6 48 ff ff       	call   800acc <_panic>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80c1f6:	85 db                	test   %ebx,%ebx
  80c1f8:	74 3c                	je     80c236 <update_arp_entry+0x70>
  80c1fa:	83 3b 00             	cmpl   $0x0,(%ebx)
  80c1fd:	74 37                	je     80c236 <update_arp_entry+0x70>
  80c1ff:	83 ec 08             	sub    $0x8,%esp
  80c202:	ff 75 08             	pushl  0x8(%ebp)
  80c205:	53                   	push   %ebx
  80c206:	e8 8d cf ff ff       	call   809198 <ip_addr_isbroadcast>
  80c20b:	83 c4 10             	add    $0x10,%esp
  80c20e:	84 c0                	test   %al,%al
  80c210:	75 24                	jne    80c236 <update_arp_entry+0x70>
  80c212:	83 ec 0c             	sub    $0xc,%esp
  80c215:	68 00 00 00 f0       	push   $0xf0000000
  80c21a:	e8 97 e4 ff ff       	call   80a6b6 <ntohl>
  80c21f:	89 c7                	mov    %eax,%edi
  80c221:	23 3b                	and    (%ebx),%edi
  80c223:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80c22a:	e8 87 e4 ff ff       	call   80a6b6 <ntohl>
  80c22f:	83 c4 10             	add    $0x10,%esp
  80c232:	39 c7                	cmp    %eax,%edi
  80c234:	75 0a                	jne    80c240 <update_arp_entry+0x7a>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  80c236:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80c23b:	e9 e7 00 00 00       	jmp    80c327 <update_arp_entry+0x161>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  80c240:	83 ec 08             	sub    $0x8,%esp
  80c243:	89 f2                	mov    %esi,%edx
  80c245:	0f b6 c2             	movzbl %dl,%eax
  80c248:	50                   	push   %eax
  80c249:	53                   	push   %ebx
  80c24a:	e8 61 fc ff ff       	call   80beb0 <find_entry>
  80c24f:	88 45 f3             	mov    %al,0xfffffff3(%ebp)
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  80c252:	83 c4 10             	add    $0x10,%esp
    return (err_t)i;
  80c255:	0f be c0             	movsbl %al,%eax
  80c258:	80 7d f3 00          	cmpb   $0x0,0xfffffff3(%ebp)
  80c25c:	0f 88 c5 00 00 00    	js     80c327 <update_arp_entry+0x161>
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  80c262:	0f be 55 f3          	movsbl 0xfffffff3(%ebp),%edx
  80c266:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80c26d:	29 d0                	sub    %edx,%eax
  80c26f:	c1 e0 02             	shl    $0x2,%eax
  80c272:	c7 80 50 7e b3 00 02 	movl   $0x2,0xb37e50(%eax)
  80c279:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  80c27c:	8b 75 08             	mov    0x8(%ebp),%esi
  80c27f:	89 b0 58 7e b3 00    	mov    %esi,0xb37e58(%eax)

  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  80c285:	b1 06                	mov    $0x6,%cl
  80c287:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80c28e:	29 d0                	sub    %edx,%eax
  80c290:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
  while (k > 0) {
    k--;
  80c297:	49                   	dec    %ecx
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  80c298:	0f b6 d1             	movzbl %cl,%edx
  80c29b:	8b 75 10             	mov    0x10(%ebp),%esi
  80c29e:	8a 04 16             	mov    (%esi,%edx,1),%al
  80c2a1:	88 84 13 48 7e b3 00 	mov    %al,0xb37e48(%ebx,%edx,1)
  80c2a8:	84 c9                	test   %cl,%cl
  80c2aa:	75 eb                	jne    80c297 <update_arp_entry+0xd1>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  80c2ac:	0f be 55 f3          	movsbl 0xfffffff3(%ebp),%edx
  80c2b0:	89 d1                	mov    %edx,%ecx
  80c2b2:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80c2b9:	29 d0                	sub    %edx,%eax
  80c2bb:	c1 e0 02             	shl    $0x2,%eax
  80c2be:	c6 80 54 7e b3 00 00 	movb   $0x0,0xb37e54(%eax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  80c2c5:	83 b8 40 7e b3 00 00 	cmpl   $0x0,0xb37e40(%eax)
  80c2cc:	74 54                	je     80c322 <update_arp_entry+0x15c>
  80c2ce:	89 ce                	mov    %ecx,%esi
  80c2d0:	8d 1c cd 00 00 00 00 	lea    0x0(,%ecx,8),%ebx
  80c2d7:	29 cb                	sub    %ecx,%ebx
  80c2d9:	c1 e3 02             	shl    $0x2,%ebx
  80c2dc:	8b 93 40 7e b3 00    	mov    0xb37e40(%ebx),%edx
  80c2e2:	8b 02                	mov    (%edx),%eax
  80c2e4:	89 83 40 7e b3 00    	mov    %eax,0xb37e40(%ebx)
  80c2ea:	8b 7a 04             	mov    0x4(%edx),%edi
  80c2ed:	83 ec 08             	sub    $0x8,%esp
  80c2f0:	52                   	push   %edx
  80c2f1:	6a 0a                	push   $0xa
  80c2f3:	e8 f9 ae ff ff       	call   8071f1 <memp_free>
  80c2f8:	ff 75 10             	pushl  0x10(%ebp)
  80c2fb:	8b 45 08             	mov    0x8(%ebp),%eax
  80c2fe:	83 c0 25             	add    $0x25,%eax
  80c301:	50                   	push   %eax
  80c302:	57                   	push   %edi
  80c303:	ff 75 08             	pushl  0x8(%ebp)
  80c306:	e8 44 fe ff ff       	call   80c14f <etharp_send_ip>
  80c30b:	83 c4 14             	add    $0x14,%esp
  80c30e:	57                   	push   %edi
  80c30f:	e8 05 b6 ff ff       	call   807919 <pbuf_free>
  80c314:	83 c4 10             	add    $0x10,%esp
  80c317:	89 f1                	mov    %esi,%ecx
  80c319:	83 bb 40 7e b3 00 00 	cmpl   $0x0,0xb37e40(%ebx)
  80c320:	75 ac                	jne    80c2ce <update_arp_entry+0x108>
  }
#endif
  return ERR_OK;
  80c322:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80c327:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80c32a:	5b                   	pop    %ebx
  80c32b:	5e                   	pop    %esi
  80c32c:	5f                   	pop    %edi
  80c32d:	c9                   	leave  
  80c32e:	c3                   	ret    

0080c32f <etharp_find_addr>:

/**
 * Finds (stable) ethernet/IP address pair from ARP table
 * using interface and IP address index.
 * @note the addresses in the ARP table are in network order!
 *
 * @param netif points to interface index
 * @param ipaddr points to the (network order) IP address index
 * @param eth_ret points to return pointer
 * @param ip_ret points to return pointer
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  80c32f:	55                   	push   %ebp
  80c330:	89 e5                	mov    %esp,%ebp
  80c332:	53                   	push   %ebx
  80c333:	83 ec 0c             	sub    $0xc,%esp
  s8_t i;

  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  80c336:	6a 02                	push   $0x2
  80c338:	ff 75 0c             	pushl  0xc(%ebp)
  80c33b:	e8 70 fb ff ff       	call   80beb0 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  80c340:	83 c4 10             	add    $0x10,%esp
  80c343:	84 c0                	test   %al,%al
  80c345:	78 36                	js     80c37d <etharp_find_addr+0x4e>
  80c347:	0f be d8             	movsbl %al,%ebx
  80c34a:	8d 04 dd 00 00 00 00 	lea    0x0(,%ebx,8),%eax
  80c351:	29 d8                	sub    %ebx,%eax
  80c353:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  80c35a:	83 b9 50 7e b3 00 02 	cmpl   $0x2,0xb37e50(%ecx)
  80c361:	75 1a                	jne    80c37d <etharp_find_addr+0x4e>
      *eth_ret = &arp_table[i].ethaddr;
  80c363:	8d 91 48 7e b3 00    	lea    0xb37e48(%ecx),%edx
  80c369:	8b 45 10             	mov    0x10(%ebp),%eax
  80c36c:	89 10                	mov    %edx,(%eax)
      *ip_ret = &arp_table[i].ipaddr;
  80c36e:	8d 91 44 7e b3 00    	lea    0xb37e44(%ecx),%edx
  80c374:	8b 45 14             	mov    0x14(%ebp),%eax
  80c377:	89 10                	mov    %edx,(%eax)
      return i;
  80c379:	89 d8                	mov    %ebx,%eax
  80c37b:	eb 05                	jmp    80c382 <etharp_find_addr+0x53>
  }
  return -1;
  80c37d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80c382:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80c385:	c9                   	leave  
  80c386:	c3                   	ret    

0080c387 <etharp_ip_input>:

/**
 * Updates the ARP table using the given IP packet.
 *
 * Uses the incoming IP packet's source address to update the
 * ARP cache for the local network. The function does not alter
 * or free the packet. This function must be called before the
 * packet p is passed to the IP layer.
 *
 * @param netif The lwIP network interface on which the IP packet pbuf arrived.
 * @param p The IP packet that arrived on netif.
 *
 * @return NULL
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  80c387:	55                   	push   %ebp
  80c388:	89 e5                	mov    %esp,%ebp
  80c38a:	53                   	push   %ebx
  80c38b:	83 ec 04             	sub    $0x4,%esp
  80c38e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80c391:	85 db                	test   %ebx,%ebx
  80c393:	75 17                	jne    80c3ac <etharp_ip_input+0x25>
  80c395:	83 ec 04             	sub    $0x4,%esp
  80c398:	68 ec 25 81 00       	push   $0x8125ec
  80c39d:	68 48 02 00 00       	push   $0x248
  80c3a2:	68 b2 36 81 00       	push   $0x8136b2
  80c3a7:	e8 20 47 ff ff       	call   800acc <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  80c3ac:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c3af:	8b 48 04             	mov    0x4(%eax),%ecx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  80c3b2:	8b 43 08             	mov    0x8(%ebx),%eax
  80c3b5:	8b 51 1c             	mov    0x1c(%ecx),%edx
  80c3b8:	21 c2                	and    %eax,%edx
  80c3ba:	23 43 04             	and    0x4(%ebx),%eax
  80c3bd:	39 c2                	cmp    %eax,%edx
  80c3bf:	75 10                	jne    80c3d1 <etharp_ip_input+0x4a>
    /* do nothing */
    return;
  }

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  80c3c1:	6a 00                	push   $0x0
  80c3c3:	8d 41 06             	lea    0x6(%ecx),%eax
  80c3c6:	50                   	push   %eax
  80c3c7:	8d 41 1c             	lea    0x1c(%ecx),%eax
  80c3ca:	50                   	push   %eax
  80c3cb:	53                   	push   %ebx
  80c3cc:	e8 f5 fd ff ff       	call   80c1c6 <update_arp_entry>
}
  80c3d1:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80c3d4:	c9                   	leave  
  80c3d5:	c3                   	ret    

0080c3d6 <etharp_arp_input>:


/**
 * Responds to ARP requests to us. Upon ARP replies to us, add entry to cache  
 * send out queued IP packets. Updates cache with snooped address pairs.
 *
 * Should be called for incoming ARP packets. The pbuf in the argument
 * is freed by this function.
 *
 * @param netif The lwIP network interface on which the ARP packet pbuf arrived.
 * @param ethaddr Ethernet address of netif.
 * @param p The ARP packet that arrived on netif. Is freed by this function.
 *
 * @return NULL
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  80c3d6:	55                   	push   %ebp
  80c3d7:	89 e5                	mov    %esp,%ebp
  80c3d9:	57                   	push   %edi
  80c3da:	56                   	push   %esi
  80c3db:	53                   	push   %ebx
  80c3dc:	83 ec 1c             	sub    $0x1c,%esp
  80c3df:	8b 7d 08             	mov    0x8(%ebp),%edi
  80c3e2:	8b 75 10             	mov    0x10(%ebp),%esi
  struct etharp_hdr *hdr;
  /* these are aligned properly, whereas the ARP header fields might not be */
  struct ip_addr sipaddr, dipaddr;
  u8_t i;
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80c3e5:	85 ff                	test   %edi,%edi
  80c3e7:	75 17                	jne    80c400 <etharp_arp_input+0x2a>
  80c3e9:	83 ec 04             	sub    $0x4,%esp
  80c3ec:	68 ec 25 81 00       	push   $0x8125ec
  80c3f1:	68 75 02 00 00       	push   $0x275
  80c3f6:	68 b2 36 81 00       	push   $0x8136b2
  80c3fb:	e8 cc 46 ff ff       	call   800acc <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  80c400:	66 83 7e 0a 29       	cmpw   $0x29,0xa(%esi)
  80c405:	77 0e                	ja     80c415 <etharp_arp_input+0x3f>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80c407:	83 ec 0c             	sub    $0xc,%esp
  80c40a:	56                   	push   %esi
  80c40b:	e8 09 b5 ff ff       	call   807919 <pbuf_free>
    return;
  80c410:	e9 84 01 00 00       	jmp    80c599 <etharp_arp_input+0x1c3>
  }

  hdr = p->payload;
  80c415:	8b 5e 04             	mov    0x4(%esi),%ebx

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80c418:	83 ec 0c             	sub    $0xc,%esp
  80c41b:	6a 01                	push   $0x1
  80c41d:	e8 3d e2 ff ff       	call   80a65f <htons>
  80c422:	83 c4 10             	add    $0x10,%esp
  80c425:	66 39 43 0e          	cmp    %ax,0xe(%ebx)
  80c429:	75 42                	jne    80c46d <etharp_arp_input+0x97>
  80c42b:	83 ec 0c             	sub    $0xc,%esp
  80c42e:	68 04 06 00 00       	push   $0x604
  80c433:	e8 27 e2 ff ff       	call   80a65f <htons>
  80c438:	83 c4 10             	add    $0x10,%esp
  80c43b:	66 39 43 12          	cmp    %ax,0x12(%ebx)
  80c43f:	75 2c                	jne    80c46d <etharp_arp_input+0x97>
  80c441:	83 ec 0c             	sub    $0xc,%esp
  80c444:	68 00 08 00 00       	push   $0x800
  80c449:	e8 11 e2 ff ff       	call   80a65f <htons>
  80c44e:	83 c4 10             	add    $0x10,%esp
  80c451:	66 39 43 10          	cmp    %ax,0x10(%ebx)
  80c455:	75 16                	jne    80c46d <etharp_arp_input+0x97>
  80c457:	83 ec 0c             	sub    $0xc,%esp
  80c45a:	68 06 08 00 00       	push   $0x806
  80c45f:	e8 fb e1 ff ff       	call   80a65f <htons>
  80c464:	83 c4 10             	add    $0x10,%esp
  80c467:	66 39 43 0c          	cmp    %ax,0xc(%ebx)
  80c46b:	74 0e                	je     80c47b <etharp_arp_input+0xa5>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80c46d:	83 ec 0c             	sub    $0xc,%esp
  80c470:	56                   	push   %esi
  80c471:	e8 a3 b4 ff ff       	call   807919 <pbuf_free>
    return;
  80c476:	e9 1e 01 00 00       	jmp    80c599 <etharp_arp_input+0x1c3>
  }
  ETHARP_STATS_INC(etharp.recv);

#if LWIP_AUTOIP
  /* We have to check if a host already has configured our random
   * created link local address and continously check if there is
   * a host with this IP-address so we can detect collisions */
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  80c47b:	83 ec 04             	sub    $0x4,%esp
  80c47e:	6a 04                	push   $0x4
  80c480:	8d 43 1c             	lea    0x1c(%ebx),%eax
  80c483:	50                   	push   %eax
  80c484:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  80c487:	50                   	push   %eax
  80c488:	e8 1a 4f ff ff       	call   8013a7 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  80c48d:	83 c4 0c             	add    $0xc,%esp
  80c490:	6a 04                	push   $0x4
  80c492:	8d 43 26             	lea    0x26(%ebx),%eax
  80c495:	50                   	push   %eax
  80c496:	8d 45 ec             	lea    0xffffffec(%ebp),%eax
  80c499:	50                   	push   %eax
  80c49a:	e8 08 4f ff ff       	call   8013a7 <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80c49f:	83 c4 10             	add    $0x10,%esp
    for_us = 0;
  80c4a2:	c6 45 eb 00          	movb   $0x0,0xffffffeb(%ebp)
  80c4a6:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
  80c4aa:	74 0a                	je     80c4b6 <etharp_arp_input+0xe0>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  80c4ac:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  80c4af:	3b 47 04             	cmp    0x4(%edi),%eax
  80c4b2:	0f 94 45 eb          	sete   0xffffffeb(%ebp)
  }

  /* ARP message directed to us? */
  if (for_us) {
  80c4b6:	80 7d eb 00          	cmpb   $0x0,0xffffffeb(%ebp)
  80c4ba:	74 15                	je     80c4d1 <etharp_arp_input+0xfb>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80c4bc:	6a 01                	push   $0x1
  80c4be:	8d 43 16             	lea    0x16(%ebx),%eax
  80c4c1:	50                   	push   %eax
  80c4c2:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  80c4c5:	50                   	push   %eax
  80c4c6:	57                   	push   %edi
  80c4c7:	e8 fa fc ff ff       	call   80c1c6 <update_arp_entry>
  80c4cc:	83 c4 10             	add    $0x10,%esp
  80c4cf:	eb 13                	jmp    80c4e4 <etharp_arp_input+0x10e>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  80c4d1:	6a 00                	push   $0x0
  80c4d3:	8d 43 16             	lea    0x16(%ebx),%eax
  80c4d6:	50                   	push   %eax
  80c4d7:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  80c4da:	50                   	push   %eax
  80c4db:	57                   	push   %edi
  80c4dc:	e8 e5 fc ff ff       	call   80c1c6 <update_arp_entry>
  80c4e1:	83 c4 10             	add    $0x10,%esp
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  80c4e4:	83 ec 0c             	sub    $0xc,%esp
  80c4e7:	0f b7 43 14          	movzwl 0x14(%ebx),%eax
  80c4eb:	50                   	push   %eax
  80c4ec:	e8 6e e1 ff ff       	call   80a65f <htons>
  80c4f1:	0f b7 c0             	movzwl %ax,%eax
  80c4f4:	83 c4 10             	add    $0x10,%esp
  80c4f7:	83 f8 01             	cmp    $0x1,%eax
  80c4fa:	74 0a                	je     80c506 <etharp_arp_input+0x130>
  80c4fc:	83 f8 02             	cmp    $0x2,%eax
  80c4ff:	74 7f                	je     80c580 <etharp_arp_input+0x1aa>
  80c501:	e9 8a 00 00 00       	jmp    80c590 <etharp_arp_input+0x1ba>
  /* ARP request? */
  case ARP_REQUEST:
    /* ARP request. If it asked for our address, we send out a
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  80c506:	80 7d eb 00          	cmpb   $0x0,0xffffffeb(%ebp)
  80c50a:	0f 84 80 00 00 00    	je     80c590 <etharp_arp_input+0x1ba>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  80c510:	83 ec 0c             	sub    $0xc,%esp
  80c513:	6a 02                	push   $0x2
  80c515:	e8 45 e1 ff ff       	call   80a65f <htons>
  80c51a:	66 89 43 14          	mov    %ax,0x14(%ebx)

      hdr->dipaddr = hdr->sipaddr;
  80c51e:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80c521:	89 43 26             	mov    %eax,0x26(%ebx)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  80c524:	8b 47 04             	mov    0x4(%edi),%eax
  80c527:	89 43 1c             	mov    %eax,0x1c(%ebx)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80c52a:	83 c4 10             	add    $0x10,%esp
                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
      i = ETHARP_HWADDR_LEN;
  80c52d:	b1 06                	mov    $0x6,%cl
  80c52f:	80 7f 24 06          	cmpb   $0x6,0x24(%edi)
  80c533:	74 17                	je     80c54c <etharp_arp_input+0x176>
  80c535:	83 ec 04             	sub    $0x4,%esp
  80c538:	68 28 37 81 00       	push   $0x813728
  80c53d:	68 c7 02 00 00       	push   $0x2c7
  80c542:	68 b2 36 81 00       	push   $0x8136b2
  80c547:	e8 80 45 ff ff       	call   800acc <_panic>
#if LWIP_AUTOIP
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  80c54c:	49                   	dec    %ecx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  80c54d:	0f b6 c1             	movzbl %cl,%eax
  80c550:	8a 54 18 16          	mov    0x16(%eax,%ebx,1),%dl
  80c554:	88 54 18 20          	mov    %dl,0x20(%eax,%ebx,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  80c558:	88 14 03             	mov    %dl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  80c55b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c55e:	8a 14 02             	mov    (%edx,%eax,1),%dl
  80c561:	88 54 18 16          	mov    %dl,0x16(%eax,%ebx,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  80c565:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c568:	8a 14 02             	mov    (%edx,%eax,1),%dl
  80c56b:	88 54 03 06          	mov    %dl,0x6(%ebx,%eax,1)
  80c56f:	84 c9                	test   %cl,%cl
  80c571:	75 d9                	jne    80c54c <etharp_arp_input+0x176>
      }

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  80c573:	83 ec 08             	sub    $0x8,%esp
  80c576:	56                   	push   %esi
  80c577:	57                   	push   %edi
  80c578:	ff 57 18             	call   *0x18(%edi)
  80c57b:	83 c4 10             	add    $0x10,%esp
  80c57e:	eb 10                	jmp    80c590 <etharp_arp_input+0x1ba>
    /* we are not configured? */
    } else if (netif->ip_addr.addr == 0) {
      /* { for_us == 0 and netif->ip_addr.addr == 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: we are unconfigured, ARP request ignored.\n"));
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
  case ARP_REPLY:
    /* ARP reply. We already updated the ARP cache earlier. */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP reply\n"));
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  80c580:	83 ec 08             	sub    $0x8,%esp
  80c583:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  80c586:	50                   	push   %eax
  80c587:	57                   	push   %edi
  80c588:	e8 46 95 ff ff       	call   805ad3 <dhcp_arp_reply>
#endif
    break;
  80c58d:	83 c4 10             	add    $0x10,%esp
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  80c590:	83 ec 0c             	sub    $0xc,%esp
  80c593:	56                   	push   %esi
  80c594:	e8 80 b3 ff ff       	call   807919 <pbuf_free>
}
  80c599:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80c59c:	5b                   	pop    %ebx
  80c59d:	5e                   	pop    %esi
  80c59e:	5f                   	pop    %edi
  80c59f:	c9                   	leave  
  80c5a0:	c3                   	ret    

0080c5a1 <etharp_output>:

/**
 * Resolve and fill-in Ethernet address header for outgoing IP packet.
 *
 * For IP multicast and broadcast, corresponding Ethernet addresses
 * are selected and the packet is transmitted on the link.
 *
 * For unicast addresses, the packet is submitted to etharp_query(). In
 * case the IP address is outside the local network, the IP address of
 * the gateway is used.
 *
 * @param netif The lwIP network interface which the IP packet will be sent on.
 * @param q The pbuf(s) containing the IP packet to be sent.
 * @param ipaddr The IP address of the packet destination.
 *
 * @return
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  80c5a1:	55                   	push   %ebp
  80c5a2:	89 e5                	mov    %esp,%ebp
  80c5a4:	57                   	push   %edi
  80c5a5:	56                   	push   %esi
  80c5a6:	53                   	push   %ebx
  80c5a7:	83 ec 24             	sub    $0x24,%esp
  80c5aa:	8b 75 08             	mov    0x8(%ebp),%esi
  80c5ad:	8b 5d 10             	mov    0x10(%ebp),%ebx
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  80c5b0:	6a 0e                	push   $0xe
  80c5b2:	ff 75 0c             	pushl  0xc(%ebp)
  80c5b5:	e8 89 b2 ff ff       	call   807843 <pbuf_header>
  80c5ba:	83 c4 10             	add    $0x10,%esp
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  80c5bd:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
  80c5c2:	84 c0                	test   %al,%al
  80c5c4:	0f 85 c1 00 00 00    	jne    80c68b <etharp_output+0xea>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80c5ca:	83 ec 08             	sub    $0x8,%esp
  80c5cd:	56                   	push   %esi
  80c5ce:	53                   	push   %ebx
  80c5cf:	e8 c4 cb ff ff       	call   809198 <ip_addr_isbroadcast>
  80c5d4:	83 c4 10             	add    $0x10,%esp
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  80c5d7:	ba a6 36 81 00       	mov    $0x8136a6,%edx
  80c5dc:	84 c0                	test   %al,%al
  80c5de:	0f 85 96 00 00 00    	jne    80c67a <etharp_output+0xd9>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  80c5e4:	83 ec 0c             	sub    $0xc,%esp
  80c5e7:	68 00 00 00 f0       	push   $0xf0000000
  80c5ec:	e8 c5 e0 ff ff       	call   80a6b6 <ntohl>
  80c5f1:	89 c7                	mov    %eax,%edi
  80c5f3:	23 3b                	and    (%ebx),%edi
  80c5f5:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80c5fc:	e8 b5 e0 ff ff       	call   80a6b6 <ntohl>
  80c601:	83 c4 10             	add    $0x10,%esp
  80c604:	39 c7                	cmp    %eax,%edi
  80c606:	75 44                	jne    80c64c <etharp_output+0xab>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  80c608:	c6 45 d8 01          	movb   $0x1,0xffffffd8(%ebp)
    mcastaddr.addr[1] = 0x00;
  80c60c:	c6 45 d9 00          	movb   $0x0,0xffffffd9(%ebp)
    mcastaddr.addr[2] = 0x5e;
  80c610:	c6 45 da 5e          	movb   $0x5e,0xffffffda(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  80c614:	83 ec 0c             	sub    $0xc,%esp
  80c617:	ff 33                	pushl  (%ebx)
  80c619:	e8 98 e0 ff ff       	call   80a6b6 <ntohl>
  80c61e:	c1 e8 10             	shr    $0x10,%eax
  80c621:	83 e0 7f             	and    $0x7f,%eax
  80c624:	88 45 db             	mov    %al,0xffffffdb(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  80c627:	83 c4 04             	add    $0x4,%esp
  80c62a:	ff 33                	pushl  (%ebx)
  80c62c:	e8 85 e0 ff ff       	call   80a6b6 <ntohl>
  80c631:	c1 e8 08             	shr    $0x8,%eax
  80c634:	88 45 dc             	mov    %al,0xffffffdc(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  80c637:	83 c4 04             	add    $0x4,%esp
  80c63a:	ff 33                	pushl  (%ebx)
  80c63c:	e8 75 e0 ff ff       	call   80a6b6 <ntohl>
  80c641:	88 45 dd             	mov    %al,0xffffffdd(%ebp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  80c644:	8d 55 d8             	lea    0xffffffd8(%ebp),%edx
  80c647:	83 c4 10             	add    $0x10,%esp
  80c64a:	eb 2e                	jmp    80c67a <etharp_output+0xd9>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  80c64c:	8b 46 08             	mov    0x8(%esi),%eax
  80c64f:	8b 13                	mov    (%ebx),%edx
  80c651:	21 c2                	and    %eax,%edx
  80c653:	23 46 04             	and    0x4(%esi),%eax
  80c656:	39 c2                	cmp    %eax,%edx
  80c658:	74 0e                	je     80c668 <etharp_output+0xc7>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  80c65a:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
  80c65f:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
  80c663:	74 26                	je     80c68b <etharp_output+0xea>
  80c665:	8d 5e 0c             	lea    0xc(%esi),%ebx
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80c668:	83 ec 04             	sub    $0x4,%esp
  80c66b:	ff 75 0c             	pushl  0xc(%ebp)
  80c66e:	53                   	push   %ebx
  80c66f:	56                   	push   %esi
  80c670:	e8 20 00 00 00       	call   80c695 <etharp_query>
  80c675:	0f be d0             	movsbl %al,%edx
  80c678:	eb 11                	jmp    80c68b <etharp_output+0xea>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  80c67a:	52                   	push   %edx
  80c67b:	8d 46 25             	lea    0x25(%esi),%eax
  80c67e:	50                   	push   %eax
  80c67f:	ff 75 0c             	pushl  0xc(%ebp)
  80c682:	56                   	push   %esi
  80c683:	e8 c7 fa ff ff       	call   80c14f <etharp_send_ip>
  80c688:	0f be d0             	movsbl %al,%edx
}
  80c68b:	89 d0                	mov    %edx,%eax
  80c68d:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80c690:	5b                   	pop    %ebx
  80c691:	5e                   	pop    %esi
  80c692:	5f                   	pop    %edi
  80c693:	c9                   	leave  
  80c694:	c3                   	ret    

0080c695 <etharp_query>:

/**
 * Send an ARP request for the given IP address and/or queue a packet.
 *
 * If the IP address was not yet in the cache, a pending ARP cache entry
 * is added and an ARP request is sent for the given address. The packet
 * is queued on this entry.
 *
 * If the IP address was already pending in the cache, a new ARP request
 * is sent for the given address. The packet is queued on this entry.
 *
 * If the IP address was already stable in the cache, and a packet is
 * given, it is directly sent and no ARP request is sent out. 
 * 
 * If the IP address was already stable in the cache, and no packet is
 * given, an ARP request is sent out.
 * 
 * @param netif The lwIP network interface on which ipaddr
 * must be queried for.
 * @param ipaddr The IP address to be resolved.
 * @param q If non-NULL, a pbuf that must be delivered to the IP address.
 * q is not freed by this function.
 *
 * @note q must only be ONE packet, not a packet queue!
 *
 * @return
 * - ERR_BUF Could not make room for Ethernet header.
 * - ERR_MEM Hardware address unknown, and no more ARP entries available
 *   to query for address or queue the packet.
 * - ERR_MEM Could not queue packet due to memory shortage.
 * - ERR_RTE No route to destination (no gateway to external networks).
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  80c695:	55                   	push   %ebp
  80c696:	89 e5                	mov    %esp,%ebp
  80c698:	57                   	push   %edi
  80c699:	56                   	push   %esi
  80c69a:	53                   	push   %ebx
  80c69b:	83 ec 14             	sub    $0x14,%esp
  80c69e:	8b 7d 08             	mov    0x8(%ebp),%edi
  80c6a1:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  80c6a4:	8d 47 25             	lea    0x25(%edi),%eax
  80c6a7:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  err_t result = ERR_MEM;
  80c6aa:	c6 45 ef ff          	movb   $0xff,0xffffffef(%ebp)
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80c6ae:	57                   	push   %edi
  80c6af:	56                   	push   %esi
  80c6b0:	e8 e3 ca ff ff       	call   809198 <ip_addr_isbroadcast>
  80c6b5:	83 c4 10             	add    $0x10,%esp
  80c6b8:	84 c0                	test   %al,%al
  80c6ba:	75 2d                	jne    80c6e9 <etharp_query+0x54>
  80c6bc:	83 ec 0c             	sub    $0xc,%esp
  80c6bf:	68 00 00 00 f0       	push   $0xf0000000
  80c6c4:	e8 ed df ff ff       	call   80a6b6 <ntohl>
  80c6c9:	89 c3                	mov    %eax,%ebx
  80c6cb:	23 1e                	and    (%esi),%ebx
  80c6cd:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80c6d4:	e8 dd df ff ff       	call   80a6b6 <ntohl>
  80c6d9:	83 c4 10             	add    $0x10,%esp
  80c6dc:	39 c3                	cmp    %eax,%ebx
  80c6de:	74 09                	je     80c6e9 <etharp_query+0x54>
  80c6e0:	85 f6                	test   %esi,%esi
  80c6e2:	74 05                	je     80c6e9 <etharp_query+0x54>
  80c6e4:	83 3e 00             	cmpl   $0x0,(%esi)
  80c6e7:	75 0a                	jne    80c6f3 <etharp_query+0x5e>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  80c6e9:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80c6ee:	e9 0d 02 00 00       	jmp    80c900 <etharp_query+0x26b>
  }

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  80c6f3:	83 ec 08             	sub    $0x8,%esp
  80c6f6:	6a 01                	push   $0x1
  80c6f8:	56                   	push   %esi
  80c6f9:	e8 b2 f7 ff ff       	call   80beb0 <find_entry>
  80c6fe:	88 45 ee             	mov    %al,0xffffffee(%ebp)
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  80c701:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    }
    return (err_t)i;
  80c704:	0f be c0             	movsbl %al,%eax
  80c707:	80 7d ee 00          	cmpb   $0x0,0xffffffee(%ebp)
  80c70b:	0f 88 ef 01 00 00    	js     80c900 <etharp_query+0x26b>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  80c711:	0f be 55 ee          	movsbl 0xffffffee(%ebp),%edx
  80c715:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80c71c:	29 d0                	sub    %edx,%eax
  80c71e:	8d 04 85 40 7e b3 00 	lea    0xb37e40(,%eax,4),%eax
  80c725:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  80c729:	75 07                	jne    80c732 <etharp_query+0x9d>
    arp_table[i].state = ETHARP_STATE_PENDING;
  80c72b:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  80c732:	0f be 45 ee          	movsbl 0xffffffee(%ebp),%eax
  80c736:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  80c73d:	29 c2                	sub    %eax,%edx
  80c73f:	8b 04 95 50 7e b3 00 	mov    0xb37e50(,%edx,4),%eax
  80c746:	48                   	dec    %eax
  80c747:	83 f8 01             	cmp    $0x1,%eax
  80c74a:	76 17                	jbe    80c763 <etharp_query+0xce>
  80c74c:	83 ec 04             	sub    $0x4,%esp
  80c74f:	68 94 37 81 00       	push   $0x813794
  80c754:	68 92 03 00 00       	push   $0x392
  80c759:	68 b2 36 81 00       	push   $0x8136b2
  80c75e:	e8 69 43 ff ff       	call   800acc <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  80c763:	0f be 55 ee          	movsbl 0xffffffee(%ebp),%edx
  80c767:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80c76e:	29 d0                	sub    %edx,%eax
  80c770:	83 3c 85 50 7e b3 00 	cmpl   $0x1,0xb37e50(,%eax,4)
  80c777:	01 
  80c778:	74 06                	je     80c780 <etharp_query+0xeb>
  80c77a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80c77e:	75 1a                	jne    80c79a <etharp_query+0x105>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80c780:	83 ec 08             	sub    $0x8,%esp
  80c783:	56                   	push   %esi
  80c784:	57                   	push   %edi
  80c785:	e8 a8 02 00 00       	call   80ca32 <etharp_request>
  80c78a:	88 45 ef             	mov    %al,0xffffffef(%ebp)
    if (result != ERR_OK) {
  80c78d:	83 c4 10             	add    $0x10,%esp
      /* ARP request couldn't be sent */
      /* We don't re-send arp request in etharp_tmr, but we still queue packets,
         since this failure could be temporary, and the next packet calling
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  80c790:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80c794:	0f 84 62 01 00 00    	je     80c8fc <etharp_query+0x267>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80c79a:	0f be 55 ee          	movsbl 0xffffffee(%ebp),%edx
  80c79e:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80c7a5:	29 d0                	sub    %edx,%eax
  80c7a7:	c1 e0 02             	shl    $0x2,%eax
  80c7aa:	83 b8 50 7e b3 00 02 	cmpl   $0x2,0xb37e50(%eax)
  80c7b1:	75 24                	jne    80c7d7 <etharp_query+0x142>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  80c7b3:	05 48 7e b3 00       	add    $0xb37e48,%eax
  80c7b8:	50                   	push   %eax
  80c7b9:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  80c7bc:	ff 75 10             	pushl  0x10(%ebp)
  80c7bf:	57                   	push   %edi
  80c7c0:	e8 8a f9 ff ff       	call   80c14f <etharp_send_ip>
  80c7c5:	88 45 ef             	mov    %al,0xffffffef(%ebp)
  80c7c8:	83 c4 10             	add    $0x10,%esp
  80c7cb:	e9 2c 01 00 00       	jmp    80c8fc <etharp_query+0x267>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
#if ARP_QUEUEING /* queue the given q packet */
      struct pbuf *p;
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
        if(p->type != PBUF_ROM) {
          copy_needed = 1;
  80c7d0:	ba 01 00 00 00       	mov    $0x1,%edx
          break;
  80c7d5:	eb 59                	jmp    80c830 <etharp_query+0x19b>
  80c7d7:	0f be 55 ee          	movsbl 0xffffffee(%ebp),%edx
  80c7db:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80c7e2:	29 d0                	sub    %edx,%eax
  80c7e4:	83 3c 85 50 7e b3 00 	cmpl   $0x1,0xb37e50(,%eax,4)
  80c7eb:	01 
  80c7ec:	0f 85 0a 01 00 00    	jne    80c8fc <etharp_query+0x267>
  80c7f2:	ba 00 00 00 00       	mov    $0x0,%edx
  80c7f7:	8b 5d 10             	mov    0x10(%ebp),%ebx
        }
        p = p->next;
  80c7fa:	85 db                	test   %ebx,%ebx
  80c7fc:	74 32                	je     80c830 <etharp_query+0x19b>
  80c7fe:	66 8b 43 0a          	mov    0xa(%ebx),%ax
  80c802:	66 3b 43 08          	cmp    0x8(%ebx),%ax
  80c806:	75 1c                	jne    80c824 <etharp_query+0x18f>
  80c808:	83 3b 00             	cmpl   $0x0,(%ebx)
  80c80b:	74 17                	je     80c824 <etharp_query+0x18f>
  80c80d:	83 ec 04             	sub    $0x4,%esp
  80c810:	68 0e 37 81 00       	push   $0x81370e
  80c815:	68 b1 03 00 00       	push   $0x3b1
  80c81a:	68 b2 36 81 00       	push   $0x8136b2
  80c81f:	e8 a8 42 ff ff       	call   800acc <_panic>
  80c824:	80 7b 0c 01          	cmpb   $0x1,0xc(%ebx)
  80c828:	75 a6                	jne    80c7d0 <etharp_query+0x13b>
  80c82a:	8b 1b                	mov    (%ebx),%ebx
  80c82c:	85 db                	test   %ebx,%ebx
  80c82e:	75 ce                	jne    80c7fe <etharp_query+0x169>
      }
      if(copy_needed) {
  80c830:	85 d2                	test   %edx,%edx
  80c832:	74 44                	je     80c878 <etharp_query+0x1e3>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80c834:	83 ec 04             	sub    $0x4,%esp
  80c837:	6a 00                	push   $0x0
  80c839:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c83d:	50                   	push   %eax
  80c83e:	6a 03                	push   $0x3
  80c840:	e8 43 ac ff ff       	call   807488 <pbuf_alloc>
  80c845:	89 c3                	mov    %eax,%ebx
        if(p != NULL) {
  80c847:	83 c4 10             	add    $0x10,%esp
  80c84a:	85 c0                	test   %eax,%eax
  80c84c:	0f 84 aa 00 00 00    	je     80c8fc <etharp_query+0x267>
          if (pbuf_copy(p, q) != ERR_OK) {
  80c852:	83 ec 08             	sub    $0x8,%esp
  80c855:	ff 75 10             	pushl  0x10(%ebp)
  80c858:	50                   	push   %eax
  80c859:	e8 f8 b2 ff ff       	call   807b56 <pbuf_copy>
  80c85e:	83 c4 10             	add    $0x10,%esp
  80c861:	84 c0                	test   %al,%al
  80c863:	74 22                	je     80c887 <etharp_query+0x1f2>
            pbuf_free(p);
  80c865:	83 ec 0c             	sub    $0xc,%esp
  80c868:	53                   	push   %ebx
  80c869:	e8 ab b0 ff ff       	call   807919 <pbuf_free>
            p = NULL;
  80c86e:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c873:	83 c4 10             	add    $0x10,%esp
  80c876:	eb 0f                	jmp    80c887 <etharp_query+0x1f2>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
  80c878:	8b 5d 10             	mov    0x10(%ebp),%ebx
        pbuf_ref(p);
  80c87b:	83 ec 0c             	sub    $0xc,%esp
  80c87e:	53                   	push   %ebx
  80c87f:	e8 7c b1 ff ff       	call   807a00 <pbuf_ref>
  80c884:	83 c4 10             	add    $0x10,%esp
      }
      /* packet could be taken over? */
      if (p != NULL) {
  80c887:	85 db                	test   %ebx,%ebx
  80c889:	74 71                	je     80c8fc <etharp_query+0x267>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  80c88b:	83 ec 0c             	sub    $0xc,%esp
  80c88e:	6a 0a                	push   $0xa
  80c890:	e8 02 a9 ff ff       	call   807197 <memp_malloc>
  80c895:	89 c1                	mov    %eax,%ecx
        if (new_entry != NULL) {
  80c897:	83 c4 10             	add    $0x10,%esp
  80c89a:	85 c0                	test   %eax,%eax
  80c89c:	74 52                	je     80c8f0 <etharp_query+0x25b>
          new_entry->next = 0;
  80c89e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  80c8a4:	89 58 04             	mov    %ebx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  80c8a7:	0f be 55 ee          	movsbl 0xffffffee(%ebp),%edx
  80c8ab:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80c8b2:	29 d0                	sub    %edx,%eax
  80c8b4:	c1 e0 02             	shl    $0x2,%eax
  80c8b7:	83 b8 40 7e b3 00 00 	cmpl   $0x0,0xb37e40(%eax)
  80c8be:	74 16                	je     80c8d6 <etharp_query+0x241>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
  80c8c0:	8b 80 40 7e b3 00    	mov    0xb37e40(%eax),%eax
            while (r->next != NULL) {
              r = r->next;
  80c8c6:	83 38 00             	cmpl   $0x0,(%eax)
  80c8c9:	74 07                	je     80c8d2 <etharp_query+0x23d>
  80c8cb:	8b 00                	mov    (%eax),%eax
  80c8cd:	83 38 00             	cmpl   $0x0,(%eax)
  80c8d0:	75 f9                	jne    80c8cb <etharp_query+0x236>
            }
            r->next = new_entry;
  80c8d2:	89 08                	mov    %ecx,(%eax)
  80c8d4:	eb 14                	jmp    80c8ea <etharp_query+0x255>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  80c8d6:	0f be 55 ee          	movsbl 0xffffffee(%ebp),%edx
  80c8da:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  80c8e1:	29 d0                	sub    %edx,%eax
  80c8e3:	89 0c 85 40 7e b3 00 	mov    %ecx,0xb37e40(,%eax,4)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  80c8ea:	c6 45 ef 00          	movb   $0x0,0xffffffef(%ebp)
  80c8ee:	eb 0c                	jmp    80c8fc <etharp_query+0x267>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  80c8f0:	83 ec 0c             	sub    $0xc,%esp
  80c8f3:	53                   	push   %ebx
  80c8f4:	e8 20 b0 ff ff       	call   807919 <pbuf_free>
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
  80c8f9:	83 c4 10             	add    $0x10,%esp
          /* { result == ERR_MEM } through initialization */
        }
      } else {
        ETHARP_STATS_INC(etharp.memerr);
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
        /* { result == ERR_MEM } through initialization */
      }
#else /* ARP_QUEUEING == 0 */
      /* q && state == PENDING && ARP_QUEUEING == 0 => result = ERR_MEM */
      /* { result == ERR_MEM } through initialization */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
  80c8fc:	0f be 45 ef          	movsbl 0xffffffef(%ebp),%eax
}
  80c900:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80c903:	5b                   	pop    %ebx
  80c904:	5e                   	pop    %esi
  80c905:	5f                   	pop    %edi
  80c906:	c9                   	leave  
  80c907:	c3                   	ret    

0080c908 <etharp_raw>:

/**
 * Send a raw ARP packet (opcode and all addresses can be modified)
 *
 * @param netif the lwip network interface on which to send the ARP packet
 * @param ethsrc_addr the source MAC address for the ethernet header
 * @param ethdst_addr the destination MAC address for the ethernet header
 * @param hwsrc_addr the source MAC address for the ARP protocol header
 * @param ipsrc_addr the source IP address for the ARP protocol header
 * @param hwdst_addr the destination MAC address for the ARP protocol header
 * @param ipdst_addr the destination IP address for the ARP protocol header
 * @param opcode the type of the ARP packet
 * @return ERR_OK if the ARP packet has been sent
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
#if !LWIP_AUTOIP
static
#endif /* LWIP_AUTOIP */
err_t
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const struct ip_addr *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const struct ip_addr *ipdst_addr,
           const u16_t opcode)
{
  80c908:	55                   	push   %ebp
  80c909:	89 e5                	mov    %esp,%ebp
  80c90b:	57                   	push   %edi
  80c90c:	56                   	push   %esi
  80c90d:	53                   	push   %ebx
  80c90e:	83 ec 10             	sub    $0x10,%esp
  80c911:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct pbuf *p;
  err_t result = ERR_OK;
  u8_t k; /* ARP entry index */
  struct etharp_hdr *hdr;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  80c914:	6a 00                	push   $0x0
  80c916:	6a 2a                	push   $0x2a
  80c918:	6a 02                	push   $0x2
  80c91a:	e8 69 ab ff ff       	call   807488 <pbuf_alloc>
  80c91f:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  80c922:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  80c925:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c92a:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  80c92e:	0f 84 f6 00 00 00    	je     80ca2a <etharp_raw+0x122>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80c934:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  80c937:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  80c93c:	77 17                	ja     80c955 <etharp_raw+0x4d>
  80c93e:	83 ec 04             	sub    $0x4,%esp
  80c941:	68 bc 37 81 00       	push   $0x8137bc
  80c946:	68 1c 04 00 00       	push   $0x41c
  80c94b:	68 b2 36 81 00       	push   $0x8136b2
  80c950:	e8 77 41 ff ff       	call   800acc <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  80c955:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  80c958:	8b 5a 04             	mov    0x4(%edx),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  80c95b:	83 ec 0c             	sub    $0xc,%esp
  80c95e:	0f b7 45 24          	movzwl 0x24(%ebp),%eax
  80c962:	50                   	push   %eax
  80c963:	e8 f7 dc ff ff       	call   80a65f <htons>
  80c968:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80c96c:	83 c4 10             	add    $0x10,%esp
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  80c96f:	b1 06                	mov    $0x6,%cl
  80c971:	8b 75 08             	mov    0x8(%ebp),%esi
  80c974:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  80c978:	74 17                	je     80c991 <etharp_raw+0x89>
  80c97a:	83 ec 04             	sub    $0x4,%esp
  80c97d:	68 28 37 81 00       	push   $0x813728
  80c982:	68 23 04 00 00       	push   $0x423
  80c987:	68 b2 36 81 00       	push   $0x8136b2
  80c98c:	e8 3b 41 ff ff       	call   800acc <_panic>
#if LWIP_AUTOIP
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  80c991:	49                   	dec    %ecx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  80c992:	0f b6 c1             	movzbl %cl,%eax
  80c995:	8b 75 14             	mov    0x14(%ebp),%esi
  80c998:	8a 14 06             	mov    (%esi,%eax,1),%dl
  80c99b:	88 54 18 16          	mov    %dl,0x16(%eax,%ebx,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80c99f:	8a 14 07             	mov    (%edi,%eax,1),%dl
  80c9a2:	88 54 18 20          	mov    %dl,0x20(%eax,%ebx,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  80c9a6:	8b 75 10             	mov    0x10(%ebp),%esi
  80c9a9:	8a 14 06             	mov    (%esi,%eax,1),%dl
  80c9ac:	88 14 03             	mov    %dl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  80c9af:	8b 75 0c             	mov    0xc(%ebp),%esi
  80c9b2:	8a 14 06             	mov    (%esi,%eax,1),%dl
  80c9b5:	88 54 03 06          	mov    %dl,0x6(%ebx,%eax,1)
  80c9b9:	84 c9                	test   %cl,%cl
  80c9bb:	75 d4                	jne    80c991 <etharp_raw+0x89>
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  80c9bd:	8b 45 18             	mov    0x18(%ebp),%eax
  80c9c0:	8b 00                	mov    (%eax),%eax
  80c9c2:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  80c9c5:	8b 45 20             	mov    0x20(%ebp),%eax
  80c9c8:	8b 00                	mov    (%eax),%eax
  80c9ca:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  80c9cd:	83 ec 0c             	sub    $0xc,%esp
  80c9d0:	6a 01                	push   $0x1
  80c9d2:	e8 88 dc ff ff       	call   80a65f <htons>
  80c9d7:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  80c9db:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80c9e2:	e8 78 dc ff ff       	call   80a65f <htons>
  80c9e7:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  80c9eb:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80c9f2:	e8 68 dc ff ff       	call   80a65f <htons>
  80c9f7:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  80c9fb:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80ca02:	e8 58 dc ff ff       	call   80a65f <htons>
  80ca07:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  80ca0b:	83 c4 08             	add    $0x8,%esp
  80ca0e:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  80ca11:	ff 75 08             	pushl  0x8(%ebp)
  80ca14:	8b 55 08             	mov    0x8(%ebp),%edx
  80ca17:	ff 52 18             	call   *0x18(%edx)
  80ca1a:	88 c3                	mov    %al,%bl
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  80ca1c:	83 c4 04             	add    $0x4,%esp
  80ca1f:	ff 75 f0             	pushl  0xfffffff0(%ebp)
  80ca22:	e8 f2 ae ff ff       	call   807919 <pbuf_free>
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
  80ca27:	0f be c3             	movsbl %bl,%eax
}
  80ca2a:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80ca2d:	5b                   	pop    %ebx
  80ca2e:	5e                   	pop    %esi
  80ca2f:	5f                   	pop    %edi
  80ca30:	c9                   	leave  
  80ca31:	c3                   	ret    

0080ca32 <etharp_request>:

/**
 * Send an ARP request packet asking for ipaddr.
 *
 * @param netif the lwip network interface on which to send the request
 * @param ipaddr the IP address for which to ask
 * @return ERR_OK if the request has been sent
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  80ca32:	55                   	push   %ebp
  80ca33:	89 e5                	mov    %esp,%ebp
  80ca35:	83 ec 08             	sub    $0x8,%esp
  80ca38:	8b 55 08             	mov    0x8(%ebp),%edx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  80ca3b:	6a 01                	push   $0x1
  80ca3d:	ff 75 0c             	pushl  0xc(%ebp)
  80ca40:	68 ac 36 81 00       	push   $0x8136ac
  80ca45:	8d 42 04             	lea    0x4(%edx),%eax
  80ca48:	50                   	push   %eax
  80ca49:	8d 42 25             	lea    0x25(%edx),%eax
  80ca4c:	50                   	push   %eax
  80ca4d:	68 a6 36 81 00       	push   $0x8136a6
  80ca52:	50                   	push   %eax
  80ca53:	52                   	push   %edx
  80ca54:	e8 af fe ff ff       	call   80c908 <etharp_raw>
  80ca59:	0f be c0             	movsbl %al,%eax
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  80ca5c:	c9                   	leave  
  80ca5d:	c3                   	ret    

0080ca5e <ethernet_input>:

/**
 * Process received ethernet frames. Using this function instead of directly
 * calling ip_input and passing ARP frames through etharp in ethernetif_input,
 * the ARP cache is protected from concurrent access.
 *
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  80ca5e:	55                   	push   %ebp
  80ca5f:	89 e5                	mov    %esp,%ebp
  80ca61:	56                   	push   %esi
  80ca62:	53                   	push   %ebx
  80ca63:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ca66:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct eth_hdr* ethhdr;

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
  80ca69:	8b 43 04             	mov    0x4(%ebx),%eax
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
    ("ethernet_input: dest:%02x:%02x:%02x:%02x:%02x:%02x, src:%02x:%02x:%02x:%02x:%02x:%02x, type:%2hx\n",
     (unsigned)ethhdr->dest.addr[0], (unsigned)ethhdr->dest.addr[1], (unsigned)ethhdr->dest.addr[2],
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  80ca6c:	83 ec 0c             	sub    $0xc,%esp
  80ca6f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca73:	50                   	push   %eax
  80ca74:	e8 e6 db ff ff       	call   80a65f <htons>
  80ca79:	0f b7 c0             	movzwl %ax,%eax
  80ca7c:	83 c4 10             	add    $0x10,%esp
  80ca7f:	3d 00 08 00 00       	cmp    $0x800,%eax
  80ca84:	74 09                	je     80ca8f <ethernet_input+0x31>
  80ca86:	3d 06 08 00 00       	cmp    $0x806,%eax
  80ca8b:	74 44                	je     80cad1 <ethernet_input+0x73>
  80ca8d:	eb 55                	jmp    80cae4 <ethernet_input+0x86>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  80ca8f:	83 ec 08             	sub    $0x8,%esp
  80ca92:	53                   	push   %ebx
  80ca93:	56                   	push   %esi
  80ca94:	e8 ee f8 ff ff       	call   80c387 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  80ca99:	83 c4 08             	add    $0x8,%esp
  80ca9c:	6a f2                	push   $0xfffffff2
  80ca9e:	53                   	push   %ebx
  80ca9f:	e8 9f ad ff ff       	call   807843 <pbuf_header>
  80caa4:	83 c4 10             	add    $0x10,%esp
  80caa7:	84 c0                	test   %al,%al
  80caa9:	74 17                	je     80cac2 <ethernet_input+0x64>
        LWIP_ASSERT("Can't move over header in packet", 0);
  80caab:	83 ec 04             	sub    $0x4,%esp
  80caae:	68 f0 37 81 00       	push   $0x8137f0
  80cab3:	68 7e 04 00 00       	push   $0x47e
  80cab8:	68 b2 36 81 00       	push   $0x8136b2
  80cabd:	e8 0a 40 ff ff       	call   800acc <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  80cac2:	83 ec 08             	sub    $0x8,%esp
  80cac5:	56                   	push   %esi
  80cac6:	53                   	push   %ebx
  80cac7:	e8 93 c7 ff ff       	call   80925f <ip_input>
  80cacc:	83 c4 10             	add    $0x10,%esp
      }
      break;
  80cacf:	eb 1f                	jmp    80caf0 <ethernet_input+0x92>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  80cad1:	83 ec 04             	sub    $0x4,%esp
  80cad4:	53                   	push   %ebx
  80cad5:	8d 46 25             	lea    0x25(%esi),%eax
  80cad8:	50                   	push   %eax
  80cad9:	56                   	push   %esi
  80cada:	e8 f7 f8 ff ff       	call   80c3d6 <etharp_arp_input>
      break;
  80cadf:	83 c4 10             	add    $0x10,%esp
  80cae2:	eb 0c                	jmp    80caf0 <ethernet_input+0x92>

#if PPPOE_SUPPORT
    case ETHTYPE_PPPOEDISC: /* PPP Over Ethernet Discovery Stage */
      pppoe_disc_input(netif, p);
      break;

    case ETHTYPE_PPPOE: /* PPP Over Ethernet Session Stage */
      pppoe_data_input(netif, p);
      break;
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  80cae4:	83 ec 0c             	sub    $0xc,%esp
  80cae7:	53                   	push   %ebx
  80cae8:	e8 2c ae ff ff       	call   807919 <pbuf_free>
      p = NULL;
      break;
  80caed:	83 c4 10             	add    $0x10,%esp
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  80caf0:	b8 00 00 00 00       	mov    $0x0,%eax
  80caf5:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80caf8:	5b                   	pop    %ebx
  80caf9:	5e                   	pop    %esi
  80cafa:	c9                   	leave  
  80cafb:	c3                   	ret    

0080cafc <sys_init>:
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  80cafc:	55                   	push   %ebp
  80cafd:	89 e5                	mov    %esp,%ebp
    int i = 0;
  80caff:	b9 00 00 00 00       	mov    $0x0,%ecx
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  80cb04:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80cb07:	c1 e0 02             	shl    $0x2,%eax
  80cb0a:	c7 80 60 7f b3 00 01 	movl   $0x1,0xb37f60(%eax)
  80cb11:	00 00 00 
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80cb14:	8b 15 60 93 b3 00    	mov    0xb39360,%edx
  80cb1a:	89 90 6c 7f b3 00    	mov    %edx,0xb37f6c(%eax)
  80cb20:	85 d2                	test   %edx,%edx
  80cb22:	74 08                	je     80cb2c <sys_init+0x30>
  80cb24:	05 6c 7f b3 00       	add    $0xb37f6c,%eax
  80cb29:	89 42 10             	mov    %eax,0x10(%edx)
  80cb2c:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80cb2f:	c1 e0 02             	shl    $0x2,%eax
  80cb32:	8d 90 60 7f b3 00    	lea    0xb37f60(%eax),%edx
  80cb38:	89 15 60 93 b3 00    	mov    %edx,0xb39360
  80cb3e:	c7 80 70 7f b3 00 60 	movl   $0xb39360,0xb37f70(%eax)
  80cb45:	93 b3 00 
  80cb48:	41                   	inc    %ecx
  80cb49:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
  80cb4f:	7e b3                	jle    80cb04 <sys_init+0x8>
    }

    for (i = 0; i < NMBOX; i++) {
  80cb51:	b9 00 00 00 00       	mov    $0x0,%ecx
	mboxes[i].freed = 1;
  80cb56:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80cb59:	c1 e0 03             	shl    $0x3,%eax
  80cb5c:	29 c8                	sub    %ecx,%eax
  80cb5e:	c1 e0 02             	shl    $0x2,%eax
  80cb61:	c7 80 80 93 b3 00 01 	movl   $0x1,0xb39380(%eax)
  80cb68:	00 00 00 
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80cb6b:	8b 15 80 e1 b3 00    	mov    0xb3e180,%edx
  80cb71:	89 90 14 94 b3 00    	mov    %edx,0xb39414(%eax)
  80cb77:	85 d2                	test   %edx,%edx
  80cb79:	74 0b                	je     80cb86 <sys_init+0x8a>
  80cb7b:	05 14 94 b3 00       	add    $0xb39414,%eax
  80cb80:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
  80cb86:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80cb89:	c1 e0 03             	shl    $0x3,%eax
  80cb8c:	29 c8                	sub    %ecx,%eax
  80cb8e:	c1 e0 02             	shl    $0x2,%eax
  80cb91:	8d 90 80 93 b3 00    	lea    0xb39380(%eax),%edx
  80cb97:	89 15 80 e1 b3 00    	mov    %edx,0xb3e180
  80cb9d:	c7 80 18 94 b3 00 80 	movl   $0xb3e180,0xb39418(%eax)
  80cba4:	e1 b3 00 
  80cba7:	41                   	inc    %ecx
  80cba8:	83 f9 7f             	cmp    $0x7f,%ecx
  80cbab:	7e a9                	jle    80cb56 <sys_init+0x5a>
    }
}
  80cbad:	c9                   	leave  
  80cbae:	c3                   	ret    

0080cbaf <sys_mbox_new>:

sys_mbox_t
sys_mbox_new(int size)
{
  80cbaf:	55                   	push   %ebp
  80cbb0:	89 e5                	mov    %esp,%ebp
  80cbb2:	56                   	push   %esi
  80cbb3:	53                   	push   %ebx
    assert(size < MBOXSLOTS);
  80cbb4:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80cbb8:	7e 16                	jle    80cbd0 <sys_mbox_new+0x21>
  80cbba:	68 11 38 81 00       	push   $0x813811
  80cbbf:	68 57 22 81 00       	push   $0x812257
  80cbc4:	6a 45                	push   $0x45
  80cbc6:	68 22 38 81 00       	push   $0x813822
  80cbcb:	e8 fc 3e ff ff       	call   800acc <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80cbd0:	8b 1d 80 e1 b3 00    	mov    0xb3e180,%ebx
    if (!mbe) {
  80cbd6:	85 db                	test   %ebx,%ebx
  80cbd8:	75 17                	jne    80cbf1 <sys_mbox_new+0x42>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80cbda:	83 ec 0c             	sub    $0xc,%esp
  80cbdd:	68 a4 38 81 00       	push   $0x8138a4
  80cbe2:	e8 d5 3f ff ff       	call   800bbc <cprintf>
	return SYS_MBOX_NULL;
  80cbe7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80cbec:	e9 be 00 00 00       	jmp    80ccaf <sys_mbox_new+0x100>
    }
    LIST_REMOVE(mbe, link);
  80cbf1:	83 bb 94 00 00 00 00 	cmpl   $0x0,0x94(%ebx)
  80cbf8:	74 12                	je     80cc0c <sys_mbox_new+0x5d>
  80cbfa:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80cc00:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80cc06:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
  80cc0c:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80cc12:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80cc18:	89 02                	mov    %eax,(%edx)
    assert(mbe->freed);
  80cc1a:	83 3b 00             	cmpl   $0x0,(%ebx)
  80cc1d:	75 16                	jne    80cc35 <sys_mbox_new+0x86>
  80cc1f:	68 3f 38 81 00       	push   $0x81383f
  80cc24:	68 57 22 81 00       	push   $0x812257
  80cc29:	6a 4c                	push   $0x4c
  80cc2b:	68 22 38 81 00       	push   $0x813822
  80cc30:	e8 97 3e ff ff       	call   800acc <_panic>
    mbe->freed = 0;
  80cc35:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  80cc3b:	89 de                	mov    %ebx,%esi
  80cc3d:	81 ee 80 93 b3 00    	sub    $0xb39380,%esi
  80cc43:	89 f0                	mov    %esi,%eax
  80cc45:	c1 f8 02             	sar    $0x2,%eax
  80cc48:	69 f0 97 6f f9 96    	imul   $0x96f96f97,%eax,%esi
    mbe->head = -1;
  80cc4e:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80cc55:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80cc5c:	83 ec 0c             	sub    $0xc,%esp
  80cc5f:	6a 00                	push   $0x0
  80cc61:	e8 03 02 00 00       	call   80ce69 <sys_sem_new>
  80cc66:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80cc6c:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80cc73:	e8 f1 01 00 00       	call   80ce69 <sys_sem_new>
  80cc78:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  80cc7e:	83 c4 10             	add    $0x10,%esp
  80cc81:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80cc88:	74 0b                	je     80cc95 <sys_mbox_new+0xe6>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
	return SYS_MBOX_NULL;
    }
    return i;
  80cc8a:	89 f0                	mov    %esi,%eax
  80cc8c:	83 bb 90 00 00 00 ff 	cmpl   $0xffffffff,0x90(%ebx)
  80cc93:	75 1a                	jne    80ccaf <sys_mbox_new+0x100>
  80cc95:	83 ec 0c             	sub    $0xc,%esp
  80cc98:	56                   	push   %esi
  80cc99:	e8 18 00 00 00       	call   80ccb6 <sys_mbox_free>
  80cc9e:	c7 04 24 cc 38 81 00 	movl   $0x8138cc,(%esp)
  80cca5:	e8 12 3f ff ff       	call   800bbc <cprintf>
  80ccaa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80ccaf:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80ccb2:	5b                   	pop    %ebx
  80ccb3:	5e                   	pop    %esi
  80ccb4:	c9                   	leave  
  80ccb5:	c3                   	ret    

0080ccb6 <sys_mbox_free>:

void
sys_mbox_free(sys_mbox_t mbox)
{
  80ccb6:	55                   	push   %ebp
  80ccb7:	89 e5                	mov    %esp,%ebp
  80ccb9:	56                   	push   %esi
  80ccba:	53                   	push   %ebx
  80ccbb:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80ccbe:	8d 04 b6             	lea    (%esi,%esi,4),%eax
  80ccc1:	c1 e0 03             	shl    $0x3,%eax
  80ccc4:	29 f0                	sub    %esi,%eax
  80ccc6:	83 3c 85 80 93 b3 00 	cmpl   $0x0,0xb39380(,%eax,4)
  80cccd:	00 
  80ccce:	74 16                	je     80cce6 <sys_mbox_free+0x30>
  80ccd0:	68 4a 38 81 00       	push   $0x81384a
  80ccd5:	68 57 22 81 00       	push   $0x812257
  80ccda:	6a 62                	push   $0x62
  80ccdc:	68 22 38 81 00       	push   $0x813822
  80cce1:	e8 e6 3d ff ff       	call   800acc <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  80cce6:	83 ec 0c             	sub    $0xc,%esp
  80cce9:	8d 04 b6             	lea    (%esi,%esi,4),%eax
  80ccec:	c1 e0 03             	shl    $0x3,%eax
  80ccef:	29 f0                	sub    %esi,%eax
  80ccf1:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
  80ccf8:	ff b3 0c 94 b3 00    	pushl  0xb3940c(%ebx)
  80ccfe:	e8 fc 01 00 00       	call   80ceff <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80cd03:	83 c4 04             	add    $0x4,%esp
  80cd06:	ff b3 10 94 b3 00    	pushl  0xb39410(%ebx)
  80cd0c:	e8 ee 01 00 00       	call   80ceff <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80cd11:	8b 15 80 e1 b3 00    	mov    0xb3e180,%edx
  80cd17:	89 93 14 94 b3 00    	mov    %edx,0xb39414(%ebx)
  80cd1d:	83 c4 10             	add    $0x10,%esp
  80cd20:	85 d2                	test   %edx,%edx
  80cd22:	74 0c                	je     80cd30 <sys_mbox_free+0x7a>
  80cd24:	8d 83 14 94 b3 00    	lea    0xb39414(%ebx),%eax
  80cd2a:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
  80cd30:	8d 04 b6             	lea    (%esi,%esi,4),%eax
  80cd33:	c1 e0 03             	shl    $0x3,%eax
  80cd36:	29 f0                	sub    %esi,%eax
  80cd38:	c1 e0 02             	shl    $0x2,%eax
  80cd3b:	8d 90 80 93 b3 00    	lea    0xb39380(%eax),%edx
  80cd41:	89 15 80 e1 b3 00    	mov    %edx,0xb3e180
  80cd47:	c7 80 18 94 b3 00 80 	movl   $0xb3e180,0xb39418(%eax)
  80cd4e:	e1 b3 00 
    mboxes[mbox].freed = 1;
  80cd51:	c7 80 80 93 b3 00 01 	movl   $0x1,0xb39380(%eax)
  80cd58:	00 00 00 
}
  80cd5b:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80cd5e:	5b                   	pop    %ebx
  80cd5f:	5e                   	pop    %esi
  80cd60:	c9                   	leave  
  80cd61:	c3                   	ret    

0080cd62 <sys_mbox_post>:

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80cd62:	55                   	push   %ebp
  80cd63:	89 e5                	mov    %esp,%ebp
  80cd65:	83 ec 10             	sub    $0x10,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80cd68:	ff 75 0c             	pushl  0xc(%ebp)
  80cd6b:	ff 75 08             	pushl  0x8(%ebp)
  80cd6e:	e8 1f 00 00 00       	call   80cd92 <sys_mbox_trypost>
  80cd73:	83 c4 10             	add    $0x10,%esp
  80cd76:	84 c0                	test   %al,%al
  80cd78:	74 16                	je     80cd90 <sys_mbox_post+0x2e>
  80cd7a:	68 f8 38 81 00       	push   $0x8138f8
  80cd7f:	68 57 22 81 00       	push   $0x812257
  80cd84:	6a 6c                	push   $0x6c
  80cd86:	68 22 38 81 00       	push   $0x813822
  80cd8b:	e8 3c 3d ff ff       	call   800acc <_panic>
}
  80cd90:	c9                   	leave  
  80cd91:	c3                   	ret    

0080cd92 <sys_mbox_trypost>:

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80cd92:	55                   	push   %ebp
  80cd93:	89 e5                	mov    %esp,%ebp
  80cd95:	56                   	push   %esi
  80cd96:	53                   	push   %ebx
  80cd97:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80cd9a:	8d 04 b6             	lea    (%esi,%esi,4),%eax
  80cd9d:	c1 e0 03             	shl    $0x3,%eax
  80cda0:	29 f0                	sub    %esi,%eax
  80cda2:	83 3c 85 80 93 b3 00 	cmpl   $0x0,0xb39380(,%eax,4)
  80cda9:	00 
  80cdaa:	74 16                	je     80cdc2 <sys_mbox_trypost+0x30>
  80cdac:	68 4a 38 81 00       	push   $0x81384a
  80cdb1:	68 57 22 81 00       	push   $0x812257
  80cdb6:	6a 72                	push   $0x72
  80cdb8:	68 22 38 81 00       	push   $0x813822
  80cdbd:	e8 0a 3d ff ff       	call   800acc <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80cdc2:	83 ec 08             	sub    $0x8,%esp
  80cdc5:	6a 00                	push   $0x0
  80cdc7:	8d 1c b6             	lea    (%esi,%esi,4),%ebx
  80cdca:	c1 e3 03             	shl    $0x3,%ebx
  80cdcd:	29 f3                	sub    %esi,%ebx
  80cdcf:	c1 e3 02             	shl    $0x2,%ebx
  80cdd2:	ff b3 10 94 b3 00    	pushl  0xb39410(%ebx)
  80cdd8:	e8 ff 01 00 00       	call   80cfdc <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80cddd:	83 c4 10             	add    $0x10,%esp
  80cde0:	8b 83 88 93 b3 00    	mov    0xb39388(%ebx),%eax
	return ERR_MEM;
  80cde6:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80cdeb:	3b 83 84 93 b3 00    	cmp    0xb39384(%ebx),%eax
  80cdf1:	74 6d                	je     80ce60 <sys_mbox_trypost+0xce>

    int slot = mboxes[mbox].nextq;
  80cdf3:	8d 04 b6             	lea    (%esi,%esi,4),%eax
  80cdf6:	c1 e0 03             	shl    $0x3,%eax
  80cdf9:	29 f0                	sub    %esi,%eax
  80cdfb:	c1 e0 02             	shl    $0x2,%eax
  80cdfe:	8b 98 88 93 b3 00    	mov    0xb39388(%eax),%ebx
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80ce04:	89 c1                	mov    %eax,%ecx
  80ce06:	8d 53 01             	lea    0x1(%ebx),%edx
  80ce09:	89 d0                	mov    %edx,%eax
  80ce0b:	85 d2                	test   %edx,%edx
  80ce0d:	79 03                	jns    80ce12 <sys_mbox_trypost+0x80>
  80ce0f:	8d 43 20             	lea    0x20(%ebx),%eax
  80ce12:	83 e0 e0             	and    $0xffffffe0,%eax
  80ce15:	29 c2                	sub    %eax,%edx
  80ce17:	89 91 88 93 b3 00    	mov    %edx,0xb39388(%ecx)
    mboxes[mbox].msg[slot] = msg;
  80ce1d:	8d 04 b6             	lea    (%esi,%esi,4),%eax
  80ce20:	c1 e0 03             	shl    $0x3,%eax
  80ce23:	29 f0                	sub    %esi,%eax
  80ce25:	8d 0c 18             	lea    (%eax,%ebx,1),%ecx
  80ce28:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ce2b:	89 14 8d 8c 93 b3 00 	mov    %edx,0xb3938c(,%ecx,4)

    if (mboxes[mbox].head == -1)
  80ce32:	c1 e0 02             	shl    $0x2,%eax
  80ce35:	83 b8 84 93 b3 00 ff 	cmpl   $0xffffffff,0xb39384(%eax)
  80ce3c:	75 06                	jne    80ce44 <sys_mbox_trypost+0xb2>
	mboxes[mbox].head = slot;
  80ce3e:	89 98 84 93 b3 00    	mov    %ebx,0xb39384(%eax)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80ce44:	83 ec 0c             	sub    $0xc,%esp
  80ce47:	8d 04 b6             	lea    (%esi,%esi,4),%eax
  80ce4a:	c1 e0 03             	shl    $0x3,%eax
  80ce4d:	29 f0                	sub    %esi,%eax
  80ce4f:	ff 34 85 0c 94 b3 00 	pushl  0xb3940c(,%eax,4)
  80ce56:	e8 1f 01 00 00       	call   80cf7a <sys_sem_signal>

    return ERR_OK;
  80ce5b:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80ce60:	89 d0                	mov    %edx,%eax
  80ce62:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80ce65:	5b                   	pop    %ebx
  80ce66:	5e                   	pop    %esi
  80ce67:	c9                   	leave  
  80ce68:	c3                   	ret    

0080ce69 <sys_sem_new>:

sys_sem_t
sys_sem_new(u8_t count)
{
  80ce69:	55                   	push   %ebp
  80ce6a:	89 e5                	mov    %esp,%ebp
  80ce6c:	53                   	push   %ebx
  80ce6d:	83 ec 04             	sub    $0x4,%esp
  80ce70:	8a 5d 08             	mov    0x8(%ebp),%bl
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  80ce73:	8b 0d 60 93 b3 00    	mov    0xb39360,%ecx
    if (!se) {
  80ce79:	85 c9                	test   %ecx,%ecx
  80ce7b:	75 14                	jne    80ce91 <sys_sem_new+0x28>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80ce7d:	83 ec 0c             	sub    $0xc,%esp
  80ce80:	68 20 39 81 00       	push   $0x813920
  80ce85:	e8 32 3d ff ff       	call   800bbc <cprintf>
	return SYS_SEM_NULL;
  80ce8a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80ce8f:	eb 69                	jmp    80cefa <sys_sem_new+0x91>
    }
    LIST_REMOVE(se, link);
  80ce91:	83 79 0c 00          	cmpl   $0x0,0xc(%ecx)
  80ce95:	74 09                	je     80cea0 <sys_sem_new+0x37>
  80ce97:	8b 51 0c             	mov    0xc(%ecx),%edx
  80ce9a:	8b 41 10             	mov    0x10(%ecx),%eax
  80ce9d:	89 42 10             	mov    %eax,0x10(%edx)
  80cea0:	8b 51 10             	mov    0x10(%ecx),%edx
  80cea3:	8b 41 0c             	mov    0xc(%ecx),%eax
  80cea6:	89 02                	mov    %eax,(%edx)
    assert(se->freed);
  80cea8:	83 39 00             	cmpl   $0x0,(%ecx)
  80ceab:	75 19                	jne    80cec6 <sys_sem_new+0x5d>
  80cead:	68 5e 38 81 00       	push   $0x81385e
  80ceb2:	68 57 22 81 00       	push   $0x812257
  80ceb7:	68 8d 00 00 00       	push   $0x8d
  80cebc:	68 22 38 81 00       	push   $0x813822
  80cec1:	e8 06 3c ff ff       	call   800acc <_panic>
    se->freed = 0;
  80cec6:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)

    se->counter = count;
  80cecc:	66 0f b6 c3          	movzbw %bl,%ax
  80ced0:	66 89 41 08          	mov    %ax,0x8(%ecx)
    se->gen++;
  80ced4:	ff 41 04             	incl   0x4(%ecx)
    return se - &sems[0];
  80ced7:	81 e9 60 7f b3 00    	sub    $0xb37f60,%ecx
  80cedd:	c1 f9 02             	sar    $0x2,%ecx
  80cee0:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80cee3:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80cee6:	8d 04 41             	lea    (%ecx,%eax,2),%eax
  80cee9:	89 c2                	mov    %eax,%edx
  80ceeb:	c1 e2 08             	shl    $0x8,%edx
  80ceee:	01 d0                	add    %edx,%eax
  80cef0:	89 c2                	mov    %eax,%edx
  80cef2:	c1 e2 10             	shl    $0x10,%edx
  80cef5:	01 d0                	add    %edx,%eax
  80cef7:	8d 04 81             	lea    (%ecx,%eax,4),%eax
}
  80cefa:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80cefd:	c9                   	leave  
  80cefe:	c3                   	ret    

0080ceff <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  80ceff:	55                   	push   %ebp
  80cf00:	89 e5                	mov    %esp,%ebp
  80cf02:	83 ec 08             	sub    $0x8,%esp
  80cf05:	8b 4d 08             	mov    0x8(%ebp),%ecx
    assert(!sems[sem].freed);
  80cf08:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80cf0b:	83 3c 85 60 7f b3 00 	cmpl   $0x0,0xb37f60(,%eax,4)
  80cf12:	00 
  80cf13:	74 19                	je     80cf2e <sys_sem_free+0x2f>
  80cf15:	68 68 38 81 00       	push   $0x813868
  80cf1a:	68 57 22 81 00       	push   $0x812257
  80cf1f:	68 98 00 00 00       	push   $0x98
  80cf24:	68 22 38 81 00       	push   $0x813822
  80cf29:	e8 9e 3b ff ff       	call   800acc <_panic>
    sems[sem].freed = 1;
  80cf2e:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80cf31:	c1 e0 02             	shl    $0x2,%eax
  80cf34:	c7 80 60 7f b3 00 01 	movl   $0x1,0xb37f60(%eax)
  80cf3b:	00 00 00 
    sems[sem].gen++;
  80cf3e:	ff 80 64 7f b3 00    	incl   0xb37f64(%eax)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80cf44:	8b 15 60 93 b3 00    	mov    0xb39360,%edx
  80cf4a:	89 90 6c 7f b3 00    	mov    %edx,0xb37f6c(%eax)
  80cf50:	85 d2                	test   %edx,%edx
  80cf52:	74 08                	je     80cf5c <sys_sem_free+0x5d>
  80cf54:	05 6c 7f b3 00       	add    $0xb37f6c,%eax
  80cf59:	89 42 10             	mov    %eax,0x10(%edx)
  80cf5c:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80cf5f:	c1 e0 02             	shl    $0x2,%eax
  80cf62:	8d 90 60 7f b3 00    	lea    0xb37f60(%eax),%edx
  80cf68:	89 15 60 93 b3 00    	mov    %edx,0xb39360
  80cf6e:	c7 80 70 7f b3 00 60 	movl   $0xb39360,0xb37f70(%eax)
  80cf75:	93 b3 00 
}
  80cf78:	c9                   	leave  
  80cf79:	c3                   	ret    

0080cf7a <sys_sem_signal>:

void
sys_sem_signal(sys_sem_t sem)
{
  80cf7a:	55                   	push   %ebp
  80cf7b:	89 e5                	mov    %esp,%ebp
  80cf7d:	83 ec 08             	sub    $0x8,%esp
  80cf80:	8b 55 08             	mov    0x8(%ebp),%edx
    assert(!sems[sem].freed);
  80cf83:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80cf86:	83 3c 85 60 7f b3 00 	cmpl   $0x0,0xb37f60(,%eax,4)
  80cf8d:	00 
  80cf8e:	74 19                	je     80cfa9 <sys_sem_signal+0x2f>
  80cf90:	68 68 38 81 00       	push   $0x813868
  80cf95:	68 57 22 81 00       	push   $0x812257
  80cf9a:	68 a1 00 00 00       	push   $0xa1
  80cf9f:	68 22 38 81 00       	push   $0x813822
  80cfa4:	e8 23 3b ff ff       	call   800acc <_panic>
    sems[sem].counter++;
  80cfa9:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80cfac:	c1 e0 02             	shl    $0x2,%eax
  80cfaf:	66 ff 80 68 7f b3 00 	incw   0xb37f68(%eax)
    if (sems[sem].waiters) {
  80cfb6:	66 83 b8 6a 7f b3 00 	cmpw   $0x0,0xb37f6a(%eax)
  80cfbd:	00 
  80cfbe:	74 1a                	je     80cfda <sys_sem_signal+0x60>
	sems[sem].waiters = 0;
  80cfc0:	66 c7 80 6a 7f b3 00 	movw   $0x0,0xb37f6a(%eax)
  80cfc7:	00 00 
	thread_wakeup(&sems[sem].v);
  80cfc9:	83 ec 0c             	sub    $0xc,%esp
  80cfcc:	05 68 7f b3 00       	add    $0xb37f68,%eax
  80cfd1:	50                   	push   %eax
  80cfd2:	e8 c4 04 00 00       	call   80d49b <thread_wakeup>
  80cfd7:	83 c4 10             	add    $0x10,%esp
    }
}
  80cfda:	c9                   	leave  
  80cfdb:	c3                   	ret    

0080cfdc <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80cfdc:	55                   	push   %ebp
  80cfdd:	89 e5                	mov    %esp,%ebp
  80cfdf:	57                   	push   %edi
  80cfe0:	56                   	push   %esi
  80cfe1:	53                   	push   %ebx
  80cfe2:	83 ec 1c             	sub    $0x1c,%esp
  80cfe5:	8b 55 08             	mov    0x8(%ebp),%edx
    assert(!sems[sem].freed);
  80cfe8:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80cfeb:	83 3c 85 60 7f b3 00 	cmpl   $0x0,0xb37f60(,%eax,4)
  80cff2:	00 
  80cff3:	74 4c                	je     80d041 <sys_arch_sem_wait+0x65>
  80cff5:	68 68 38 81 00       	push   $0x813868
  80cffa:	68 57 22 81 00       	push   $0x812257
  80cfff:	68 ac 00 00 00       	push   $0xac
  80d004:	68 22 38 81 00       	push   $0x813822
  80d009:	e8 be 3a ff ff       	call   800acc <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
	    sems[sem].counter--;
  80d00e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  80d011:	66 ff 88 68 7f b3 00 	decw   0xb37f68(%eax)
	    return waited;
  80d018:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  80d01b:	e9 e6 00 00 00       	jmp    80d106 <sys_arch_sem_wait+0x12a>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
  80d020:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80d025:	e9 dc 00 00 00       	jmp    80d106 <sys_arch_sem_wait+0x12a>
	} else {
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80d02a:	83 ec 0c             	sub    $0xc,%esp
  80d02d:	68 48 39 81 00       	push   $0x813948
  80d032:	e8 85 3b ff ff       	call   800bbc <cprintf>
		return SYS_ARCH_TIMEOUT;
  80d037:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80d03c:	e9 c5 00 00 00       	jmp    80d106 <sys_arch_sem_wait+0x12a>
  80d041:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  80d048:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d04b:	8b 04 85 64 7f b3 00 	mov    0xb37f64(,%eax,4),%eax
  80d052:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	    }
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
  80d055:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80d059:	74 0c                	je     80d067 <sys_arch_sem_wait+0x8b>
  80d05b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80d05e:	39 45 f0             	cmp    %eax,0xfffffff0(%ebp)
  80d061:	0f 83 9a 00 00 00    	jae    80d101 <sys_arch_sem_wait+0x125>
  80d067:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d06a:	c1 e0 02             	shl    $0x2,%eax
  80d06d:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  80d070:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d073:	8d 3c 85 00 00 00 00 	lea    0x0(,%eax,4),%edi
  80d07a:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  80d07d:	66 83 b8 68 7f b3 00 	cmpw   $0x0,0xb37f68(%eax)
  80d084:	00 
  80d085:	75 87                	jne    80d00e <sys_arch_sem_wait+0x32>
  80d087:	83 7d 0c fe          	cmpl   $0xfffffffe,0xc(%ebp)
  80d08b:	74 93                	je     80d020 <sys_arch_sem_wait+0x44>
  80d08d:	e8 75 47 ff ff       	call   801807 <sys_time_msec>
  80d092:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  80d095:	be ff ff ff ff       	mov    $0xffffffff,%esi
  80d09a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80d09e:	74 08                	je     80d0a8 <sys_arch_sem_wait+0xcc>
  80d0a0:	8b 75 0c             	mov    0xc(%ebp),%esi
  80d0a3:	2b 75 f0             	sub    0xfffffff0(%ebp),%esi
  80d0a6:	01 c6                	add    %eax,%esi
  80d0a8:	66 c7 87 6a 7f b3 00 	movw   $0x1,0xb37f6a(%edi)
  80d0af:	01 00 
  80d0b1:	8b 9f 68 7f b3 00    	mov    0xb37f68(%edi),%ebx
  80d0b7:	e8 a9 03 00 00       	call   80d465 <lwip_core_unlock>
  80d0bc:	83 ec 04             	sub    $0x4,%esp
  80d0bf:	56                   	push   %esi
  80d0c0:	53                   	push   %ebx
  80d0c1:	8d 87 68 7f b3 00    	lea    0xb37f68(%edi),%eax
  80d0c7:	50                   	push   %eax
  80d0c8:	e8 ef 03 00 00       	call   80d4bc <thread_wait>
  80d0cd:	e8 8e 03 00 00       	call   80d460 <lwip_core_lock>
  80d0d2:	83 c4 10             	add    $0x10,%esp
  80d0d5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  80d0d8:	39 87 64 7f b3 00    	cmp    %eax,0xb37f64(%edi)
  80d0de:	0f 85 46 ff ff ff    	jne    80d02a <sys_arch_sem_wait+0x4e>
  80d0e4:	e8 1e 47 ff ff       	call   801807 <sys_time_msec>
  80d0e9:	2b 45 e4             	sub    0xffffffe4(%ebp),%eax
  80d0ec:	01 45 f0             	add    %eax,0xfffffff0(%ebp)
  80d0ef:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80d0f3:	74 85                	je     80d07a <sys_arch_sem_wait+0x9e>
  80d0f5:	8b 45 0c             	mov    0xc(%ebp),%eax
  80d0f8:	39 45 f0             	cmp    %eax,0xfffffff0(%ebp)
  80d0fb:	0f 82 79 ff ff ff    	jb     80d07a <sys_arch_sem_wait+0x9e>
	}
    }

    return SYS_ARCH_TIMEOUT;
  80d101:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80d106:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80d109:	5b                   	pop    %ebx
  80d10a:	5e                   	pop    %esi
  80d10b:	5f                   	pop    %edi
  80d10c:	c9                   	leave  
  80d10d:	c3                   	ret    

0080d10e <sys_arch_mbox_fetch>:

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80d10e:	55                   	push   %ebp
  80d10f:	89 e5                	mov    %esp,%ebp
  80d111:	57                   	push   %edi
  80d112:	56                   	push   %esi
  80d113:	53                   	push   %ebx
  80d114:	83 ec 0c             	sub    $0xc,%esp
  80d117:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80d11a:	8b 75 0c             	mov    0xc(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80d11d:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80d120:	c1 e0 03             	shl    $0x3,%eax
  80d123:	29 d8                	sub    %ebx,%eax
  80d125:	83 3c 85 80 93 b3 00 	cmpl   $0x0,0xb39380(,%eax,4)
  80d12c:	00 
  80d12d:	74 19                	je     80d148 <sys_arch_mbox_fetch+0x3a>
  80d12f:	68 4a 38 81 00       	push   $0x81384a
  80d134:	68 57 22 81 00       	push   $0x812257
  80d139:	68 ce 00 00 00       	push   $0xce
  80d13e:	68 22 38 81 00       	push   $0x813822
  80d143:	e8 84 39 ff ff       	call   800acc <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80d148:	83 ec 08             	sub    $0x8,%esp
  80d14b:	ff 75 10             	pushl  0x10(%ebp)
  80d14e:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80d151:	c1 e0 03             	shl    $0x3,%eax
  80d154:	29 d8                	sub    %ebx,%eax
  80d156:	ff 34 85 0c 94 b3 00 	pushl  0xb3940c(,%eax,4)
  80d15d:	e8 7a fe ff ff       	call   80cfdc <sys_arch_sem_wait>
  80d162:	89 c7                	mov    %eax,%edi
    if (waited == SYS_ARCH_TIMEOUT)
  80d164:	83 c4 10             	add    $0x10,%esp
	return waited;
  80d167:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80d16c:	83 ff ff             	cmp    $0xffffffff,%edi
  80d16f:	0f 84 a8 00 00 00    	je     80d21d <sys_arch_mbox_fetch+0x10f>

    int slot = mboxes[mbox].head;
  80d175:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80d178:	c1 e0 03             	shl    $0x3,%eax
  80d17b:	29 d8                	sub    %ebx,%eax
  80d17d:	8b 0c 85 84 93 b3 00 	mov    0xb39384(,%eax,4),%ecx
    if (slot == -1)
  80d184:	83 f9 ff             	cmp    $0xffffffff,%ecx
  80d187:	75 17                	jne    80d1a0 <sys_arch_mbox_fetch+0x92>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80d189:	83 ec 04             	sub    $0x4,%esp
  80d18c:	68 74 39 81 00       	push   $0x813974
  80d191:	68 d6 00 00 00       	push   $0xd6
  80d196:	68 22 38 81 00       	push   $0x813822
  80d19b:	e8 2c 39 ff ff       	call   800acc <_panic>
    if (msg)
  80d1a0:	85 f6                	test   %esi,%esi
  80d1a2:	74 13                	je     80d1b7 <sys_arch_mbox_fetch+0xa9>
	*msg = mboxes[mbox].msg[slot];
  80d1a4:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80d1a7:	c1 e0 03             	shl    $0x3,%eax
  80d1aa:	29 d8                	sub    %ebx,%eax
  80d1ac:	01 c8                	add    %ecx,%eax
  80d1ae:	8b 04 85 8c 93 b3 00 	mov    0xb3938c(,%eax,4),%eax
  80d1b5:	89 06                	mov    %eax,(%esi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80d1b7:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80d1ba:	c1 e0 03             	shl    $0x3,%eax
  80d1bd:	29 d8                	sub    %ebx,%eax
  80d1bf:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
  80d1c6:	8d 51 01             	lea    0x1(%ecx),%edx
  80d1c9:	89 d0                	mov    %edx,%eax
  80d1cb:	85 d2                	test   %edx,%edx
  80d1cd:	79 03                	jns    80d1d2 <sys_arch_mbox_fetch+0xc4>
  80d1cf:	8d 41 20             	lea    0x20(%ecx),%eax
  80d1d2:	83 e0 e0             	and    $0xffffffe0,%eax
  80d1d5:	29 c2                	sub    %eax,%edx
  80d1d7:	89 96 84 93 b3 00    	mov    %edx,0xb39384(%esi)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80d1dd:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80d1e0:	c1 e0 03             	shl    $0x3,%eax
  80d1e3:	29 d8                	sub    %ebx,%eax
  80d1e5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80d1ec:	8b 82 84 93 b3 00    	mov    0xb39384(%edx),%eax
  80d1f2:	3b 82 88 93 b3 00    	cmp    0xb39388(%edx),%eax
  80d1f8:	75 0a                	jne    80d204 <sys_arch_mbox_fetch+0xf6>
	mboxes[mbox].head = -1;
  80d1fa:	c7 82 84 93 b3 00 ff 	movl   $0xffffffff,0xb39384(%edx)
  80d201:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80d204:	83 ec 0c             	sub    $0xc,%esp
  80d207:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80d20a:	c1 e0 03             	shl    $0x3,%eax
  80d20d:	29 d8                	sub    %ebx,%eax
  80d20f:	ff 34 85 10 94 b3 00 	pushl  0xb39410(,%eax,4)
  80d216:	e8 5f fd ff ff       	call   80cf7a <sys_sem_signal>
    return waited;
  80d21b:	89 f8                	mov    %edi,%eax
}
  80d21d:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80d220:	5b                   	pop    %ebx
  80d221:	5e                   	pop    %esi
  80d222:	5f                   	pop    %edi
  80d223:	c9                   	leave  
  80d224:	c3                   	ret    

0080d225 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80d225:	55                   	push   %ebp
  80d226:	89 e5                	mov    %esp,%ebp
  80d228:	83 ec 0c             	sub    $0xc,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80d22b:	6a fe                	push   $0xfffffffe
  80d22d:	ff 75 0c             	pushl  0xc(%ebp)
  80d230:	ff 75 08             	pushl  0x8(%ebp)
  80d233:	e8 d6 fe ff ff       	call   80d10e <sys_arch_mbox_fetch>
}
  80d238:	c9                   	leave  
  80d239:	c3                   	ret    

0080d23a <lwip_thread_entry>:

struct lwip_thread {
    void (*func)(void *arg);
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  80d23a:	55                   	push   %ebp
  80d23b:	89 e5                	mov    %esp,%ebp
  80d23d:	53                   	push   %ebx
  80d23e:	83 ec 04             	sub    $0x4,%esp
  80d241:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
  80d244:	e8 17 02 00 00       	call   80d460 <lwip_core_lock>
    lt->func(lt->arg);
  80d249:	83 ec 0c             	sub    $0xc,%esp
  80d24c:	ff 73 04             	pushl  0x4(%ebx)
  80d24f:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
  80d251:	e8 0f 02 00 00       	call   80d465 <lwip_core_unlock>
    free(lt);
  80d256:	89 1c 24             	mov    %ebx,(%esp)
  80d259:	e8 07 59 ff ff       	call   802b65 <free>
}
  80d25e:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80d261:	c9                   	leave  
  80d262:	c3                   	ret    

0080d263 <sys_thread_new>:

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80d263:	55                   	push   %ebp
  80d264:	89 e5                	mov    %esp,%ebp
  80d266:	53                   	push   %ebx
  80d267:	83 ec 10             	sub    $0x10,%esp
  80d26a:	8b 5d 14             	mov    0x14(%ebp),%ebx
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80d26d:	6a 08                	push   $0x8
  80d26f:	e8 6b 57 ff ff       	call   8029df <malloc>
  80d274:	89 c2                	mov    %eax,%edx
    if (lt == 0)
  80d276:	83 c4 10             	add    $0x10,%esp
  80d279:	85 c0                	test   %eax,%eax
  80d27b:	75 17                	jne    80d294 <sys_thread_new+0x31>
	panic("sys_thread_new: cannot allocate thread struct");
  80d27d:	83 ec 04             	sub    $0x4,%esp
  80d280:	68 9c 39 81 00       	push   $0x81399c
  80d285:	68 fd 00 00 00       	push   $0xfd
  80d28a:	68 22 38 81 00       	push   $0x813822
  80d28f:	e8 38 38 ff ff       	call   800acc <_panic>

    if (stacksize > PGSIZE)
  80d294:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
  80d29a:	7e 15                	jle    80d2b1 <sys_thread_new+0x4e>
	panic("large stack %d", stacksize);
  80d29c:	53                   	push   %ebx
  80d29d:	68 79 38 81 00       	push   $0x813879
  80d2a2:	68 00 01 00 00       	push   $0x100
  80d2a7:	68 22 38 81 00       	push   $0x813822
  80d2ac:	e8 1b 38 ff ff       	call   800acc <_panic>

    lt->func = thread;
  80d2b1:	8b 45 0c             	mov    0xc(%ebp),%eax
  80d2b4:	89 02                	mov    %eax,(%edx)
    lt->arg = arg;
  80d2b6:	8b 45 10             	mov    0x10(%ebp),%eax
  80d2b9:	89 42 04             	mov    %eax,0x4(%edx)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80d2bc:	52                   	push   %edx
  80d2bd:	68 3a d2 80 00       	push   $0x80d23a
  80d2c2:	ff 75 08             	pushl  0x8(%ebp)
  80d2c5:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  80d2c8:	50                   	push   %eax
  80d2c9:	e8 00 03 00 00       	call   80d5ce <thread_create>

    if (r < 0)
  80d2ce:	83 c4 10             	add    $0x10,%esp
  80d2d1:	85 c0                	test   %eax,%eax
  80d2d3:	79 21                	jns    80d2f6 <sys_thread_new+0x93>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80d2d5:	83 ec 0c             	sub    $0xc,%esp
  80d2d8:	50                   	push   %eax
  80d2d9:	e8 1e 06 00 00       	call   80d8fc <e2s>
  80d2de:	83 c4 10             	add    $0x10,%esp
  80d2e1:	50                   	push   %eax
  80d2e2:	68 cc 39 81 00       	push   $0x8139cc
  80d2e7:	68 09 01 00 00       	push   $0x109
  80d2ec:	68 22 38 81 00       	push   $0x813822
  80d2f1:	e8 d6 37 ff ff       	call   800acc <_panic>

    return tid;
  80d2f6:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
}
  80d2f9:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80d2fc:	c9                   	leave  
  80d2fd:	c3                   	ret    

0080d2fe <timeout_cleanup>:

static void
timeout_cleanup(thread_id_t tid)
{
  80d2fe:	55                   	push   %ebp
  80d2ff:	89 e5                	mov    %esp,%ebp
  80d301:	53                   	push   %ebx
  80d302:	83 ec 04             	sub    $0x4,%esp
  80d305:	8b 5d 08             	mov    0x8(%ebp),%ebx
    lwip_core_lock();
  80d308:	e8 53 01 00 00       	call   80d460 <lwip_core_lock>

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d30d:	ba 01 01 00 00       	mov    $0x101,%edx
  80d312:	89 d8                	mov    %ebx,%eax
  80d314:	89 d1                	mov    %edx,%ecx
  80d316:	ba 00 00 00 00       	mov    $0x0,%edx
  80d31b:	f7 f1                	div    %ecx
  80d31d:	8b 0c 95 a0 e1 b3 00 	mov    0xb3e1a0(,%edx,4),%ecx
  80d324:	85 c9                	test   %ecx,%ecx
  80d326:	74 30                	je     80d358 <timeout_cleanup+0x5a>
	if (t->tid == tid) {
  80d328:	39 19                	cmp    %ebx,(%ecx)
  80d32a:	75 25                	jne    80d351 <timeout_cleanup+0x53>
	    LIST_REMOVE(t, link);
  80d32c:	83 79 08 00          	cmpl   $0x0,0x8(%ecx)
  80d330:	74 09                	je     80d33b <timeout_cleanup+0x3d>
  80d332:	8b 51 08             	mov    0x8(%ecx),%edx
  80d335:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d338:	89 42 0c             	mov    %eax,0xc(%edx)
  80d33b:	8b 51 0c             	mov    0xc(%ecx),%edx
  80d33e:	8b 41 08             	mov    0x8(%ecx),%eax
  80d341:	89 02                	mov    %eax,(%edx)
	    free(t);
  80d343:	83 ec 0c             	sub    $0xc,%esp
  80d346:	51                   	push   %ecx
  80d347:	e8 19 58 ff ff       	call   802b65 <free>
	    goto done;
  80d34c:	83 c4 10             	add    $0x10,%esp
  80d34f:	eb 07                	jmp    80d358 <timeout_cleanup+0x5a>
  80d351:	8b 49 08             	mov    0x8(%ecx),%ecx
  80d354:	85 c9                	test   %ecx,%ecx
  80d356:	75 d0                	jne    80d328 <timeout_cleanup+0x2a>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
  80d358:	e8 08 01 00 00       	call   80d465 <lwip_core_unlock>
}
  80d35d:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80d360:	c9                   	leave  
  80d361:	c3                   	ret    

0080d362 <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80d362:	55                   	push   %ebp
  80d363:	89 e5                	mov    %esp,%ebp
  80d365:	56                   	push   %esi
  80d366:	53                   	push   %ebx
  80d367:	83 ec 10             	sub    $0x10,%esp
    thread_id_t tid = thread_id();
  80d36a:	e8 20 01 00 00       	call   80d48f <thread_id>
  80d36f:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d371:	ba 01 01 00 00       	mov    $0x101,%edx
  80d376:	89 d1                	mov    %edx,%ecx
  80d378:	ba 00 00 00 00       	mov    $0x0,%edx
  80d37d:	f7 f1                	div    %ecx
  80d37f:	8b 1c 95 a0 e1 b3 00 	mov    0xb3e1a0(,%edx,4),%ebx
  80d386:	85 db                	test   %ebx,%ebx
  80d388:	74 0f                	je     80d399 <sys_arch_timeouts+0x37>
	if (t->tid == tid)
  80d38a:	39 33                	cmp    %esi,(%ebx)
  80d38c:	0f 84 c4 00 00 00    	je     80d456 <sys_arch_timeouts+0xf4>
  80d392:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80d395:	85 db                	test   %ebx,%ebx
  80d397:	75 f1                	jne    80d38a <sys_arch_timeouts+0x28>
	    goto out;

    t = malloc(sizeof(*t));
  80d399:	83 ec 0c             	sub    $0xc,%esp
  80d39c:	6a 10                	push   $0x10
  80d39e:	e8 3c 56 ff ff       	call   8029df <malloc>
  80d3a3:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80d3a5:	83 c4 10             	add    $0x10,%esp
  80d3a8:	85 c0                	test   %eax,%eax
  80d3aa:	75 17                	jne    80d3c3 <sys_arch_timeouts+0x61>
	panic("sys_arch_timeouts: cannot malloc");
  80d3ac:	83 ec 04             	sub    $0x4,%esp
  80d3af:	68 f8 39 81 00       	push   $0x8139f8
  80d3b4:	68 2c 01 00 00       	push   $0x12c
  80d3b9:	68 22 38 81 00       	push   $0x813822
  80d3be:	e8 09 37 ff ff       	call   800acc <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80d3c3:	83 ec 0c             	sub    $0xc,%esp
  80d3c6:	68 fe d2 80 00       	push   $0x80d2fe
  80d3cb:	e8 61 01 00 00       	call   80d531 <thread_onhalt>
    if (r < 0)
  80d3d0:	83 c4 10             	add    $0x10,%esp
  80d3d3:	85 c0                	test   %eax,%eax
  80d3d5:	79 21                	jns    80d3f8 <sys_arch_timeouts+0x96>
	panic("thread_onhalt failed: %s", e2s(r));
  80d3d7:	83 ec 0c             	sub    $0xc,%esp
  80d3da:	50                   	push   %eax
  80d3db:	e8 1c 05 00 00       	call   80d8fc <e2s>
  80d3e0:	83 c4 10             	add    $0x10,%esp
  80d3e3:	50                   	push   %eax
  80d3e4:	68 88 38 81 00       	push   $0x813888
  80d3e9:	68 30 01 00 00       	push   $0x130
  80d3ee:	68 22 38 81 00       	push   $0x813822
  80d3f3:	e8 d4 36 ff ff       	call   800acc <_panic>

    t->tid = tid;
  80d3f8:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80d3fa:	83 ec 04             	sub    $0x4,%esp
  80d3fd:	6a 04                	push   $0x4
  80d3ff:	6a 00                	push   $0x0
  80d401:	8d 43 04             	lea    0x4(%ebx),%eax
  80d404:	50                   	push   %eax
  80d405:	e8 df 3e ff ff       	call   8012e9 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80d40a:	ba 01 01 00 00       	mov    $0x101,%edx
  80d40f:	89 f0                	mov    %esi,%eax
  80d411:	89 d1                	mov    %edx,%ecx
  80d413:	ba 00 00 00 00       	mov    $0x0,%edx
  80d418:	f7 f1                	div    %ecx
  80d41a:	b9 a0 e1 b3 00       	mov    $0xb3e1a0,%ecx
  80d41f:	8b 04 91             	mov    (%ecx,%edx,4),%eax
  80d422:	89 43 08             	mov    %eax,0x8(%ebx)
  80d425:	83 c4 10             	add    $0x10,%esp
  80d428:	85 c0                	test   %eax,%eax
  80d42a:	74 09                	je     80d435 <sys_arch_timeouts+0xd3>
  80d42c:	8b 14 91             	mov    (%ecx,%edx,4),%edx
  80d42f:	8d 43 08             	lea    0x8(%ebx),%eax
  80d432:	89 42 0c             	mov    %eax,0xc(%edx)
  80d435:	ba 01 01 00 00       	mov    $0x101,%edx
  80d43a:	89 f0                	mov    %esi,%eax
  80d43c:	89 d1                	mov    %edx,%ecx
  80d43e:	ba 00 00 00 00       	mov    $0x0,%edx
  80d443:	f7 f1                	div    %ecx
  80d445:	89 1c 95 a0 e1 b3 00 	mov    %ebx,0xb3e1a0(,%edx,4)
  80d44c:	8d 14 95 a0 e1 b3 00 	lea    0xb3e1a0(,%edx,4),%edx
  80d453:	89 53 0c             	mov    %edx,0xc(%ebx)

out:
    return &t->tmo;
  80d456:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80d459:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80d45c:	5b                   	pop    %ebx
  80d45d:	5e                   	pop    %esi
  80d45e:	c9                   	leave  
  80d45f:	c3                   	ret    

0080d460 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  80d460:	55                   	push   %ebp
  80d461:	89 e5                	mov    %esp,%ebp
  80d463:	c9                   	leave  
  80d464:	c3                   	ret    

0080d465 <lwip_core_unlock>:
}

void
lwip_core_unlock(void)
{
  80d465:	55                   	push   %ebp
  80d466:	89 e5                	mov    %esp,%ebp
  80d468:	c9                   	leave  
  80d469:	c3                   	ret    
	...

0080d46c <thread_init>:
static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80d46c:	55                   	push   %ebp
  80d46d:	89 e5                	mov    %esp,%ebp

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80d46f:	c7 05 ac e5 b3 00 00 	movl   $0x0,0xb3e5ac
  80d476:	00 00 00 
    tq->tq_last = 0;
  80d479:	c7 05 b0 e5 b3 00 00 	movl   $0x0,0xb3e5b0
  80d480:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80d483:	c7 05 a4 e5 b3 00 00 	movl   $0x0,0xb3e5a4
  80d48a:	00 00 00 
}
  80d48d:	c9                   	leave  
  80d48e:	c3                   	ret    

0080d48f <thread_id>:

uint32_t
thread_id(void) {
  80d48f:	55                   	push   %ebp
  80d490:	89 e5                	mov    %esp,%ebp
    return cur_tc->tc_tid;
  80d492:	a1 a8 e5 b3 00       	mov    0xb3e5a8,%eax
  80d497:	8b 00                	mov    (%eax),%eax
}
  80d499:	c9                   	leave  
  80d49a:	c3                   	ret    

0080d49b <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80d49b:	55                   	push   %ebp
  80d49c:	89 e5                	mov    %esp,%ebp
  80d49e:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80d4a1:	a1 ac e5 b3 00       	mov    0xb3e5ac,%eax
    while (tc) {
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
  80d4a6:	85 c0                	test   %eax,%eax
  80d4a8:	74 10                	je     80d4ba <thread_wakeup+0x1f>
  80d4aa:	39 50 48             	cmp    %edx,0x48(%eax)
  80d4ad:	75 04                	jne    80d4b3 <thread_wakeup+0x18>
  80d4af:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
  80d4b3:	8b 40 64             	mov    0x64(%eax),%eax
  80d4b6:	85 c0                	test   %eax,%eax
  80d4b8:	75 f0                	jne    80d4aa <thread_wakeup+0xf>
    }
}
  80d4ba:	c9                   	leave  
  80d4bb:	c3                   	ret    

0080d4bc <thread_wait>:

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80d4bc:	55                   	push   %ebp
  80d4bd:	89 e5                	mov    %esp,%ebp
  80d4bf:	57                   	push   %edi
  80d4c0:	56                   	push   %esi
  80d4c1:	53                   	push   %ebx
  80d4c2:	83 ec 0c             	sub    $0xc,%esp
  80d4c5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80d4c8:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80d4cb:	e8 37 43 ff ff       	call   801807 <sys_time_msec>
  80d4d0:	89 c2                	mov    %eax,%edx
    uint32_t p = s;
  80d4d2:	89 c6                	mov    %eax,%esi

    cur_tc->tc_wait_addr = addr;
  80d4d4:	a1 a8 e5 b3 00       	mov    0xb3e5a8,%eax
  80d4d9:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80d4dc:	a1 a8 e5 b3 00       	mov    0xb3e5a8,%eax
  80d4e1:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)

    while (p < msec) {
	if (p < s)
	    break;
	if (addr && *addr != val)
	    break;
	if (cur_tc->tc_wakeup)
	    break;

	thread_yield();
	p = sys_time_msec();
  80d4e5:	39 fa                	cmp    %edi,%edx
  80d4e7:	73 2b                	jae    80d514 <thread_wait+0x58>
  80d4e9:	39 f2                	cmp    %esi,%edx
  80d4eb:	72 27                	jb     80d514 <thread_wait+0x58>
  80d4ed:	85 db                	test   %ebx,%ebx
  80d4ef:	74 07                	je     80d4f8 <thread_wait+0x3c>
  80d4f1:	8b 03                	mov    (%ebx),%eax
  80d4f3:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80d4f6:	75 1c                	jne    80d514 <thread_wait+0x58>
  80d4f8:	a1 a8 e5 b3 00       	mov    0xb3e5a8,%eax
  80d4fd:	8a 40 4c             	mov    0x4c(%eax),%al
  80d500:	84 c0                	test   %al,%al
  80d502:	75 10                	jne    80d514 <thread_wait+0x58>
  80d504:	e8 6e 02 00 00       	call   80d777 <thread_yield>
  80d509:	e8 f9 42 ff ff       	call   801807 <sys_time_msec>
  80d50e:	89 c2                	mov    %eax,%edx
  80d510:	39 f8                	cmp    %edi,%eax
  80d512:	72 d5                	jb     80d4e9 <thread_wait+0x2d>
    }

    cur_tc->tc_wait_addr = 0;
  80d514:	a1 a8 e5 b3 00       	mov    0xb3e5a8,%eax
  80d519:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80d520:	a1 a8 e5 b3 00       	mov    0xb3e5a8,%eax
  80d525:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80d529:	83 c4 0c             	add    $0xc,%esp
  80d52c:	5b                   	pop    %ebx
  80d52d:	5e                   	pop    %esi
  80d52e:	5f                   	pop    %edi
  80d52f:	c9                   	leave  
  80d530:	c3                   	ret    

0080d531 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80d531:	55                   	push   %ebp
  80d532:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;
  80d534:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
  80d539:	a1 a8 e5 b3 00       	mov    0xb3e5a8,%eax
  80d53e:	83 78 60 03          	cmpl   $0x3,0x60(%eax)
  80d542:	7f 18                	jg     80d55c <thread_onhalt+0x2b>

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80d544:	a1 a8 e5 b3 00       	mov    0xb3e5a8,%eax
  80d549:	8b 50 60             	mov    0x60(%eax),%edx
  80d54c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80d54f:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
  80d553:	42                   	inc    %edx
  80d554:	89 50 60             	mov    %edx,0x60(%eax)
    return 0;
  80d557:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80d55c:	89 d0                	mov    %edx,%eax
  80d55e:	c9                   	leave  
  80d55f:	c3                   	ret    

0080d560 <alloc_tid>:

static thread_id_t
alloc_tid(void) {
  80d560:	55                   	push   %ebp
  80d561:	89 e5                	mov    %esp,%ebp
  80d563:	83 ec 08             	sub    $0x8,%esp
    int tid = max_tid++;
  80d566:	8b 15 a4 e5 b3 00    	mov    0xb3e5a4,%edx
  80d56c:	8d 42 01             	lea    0x1(%edx),%eax
  80d56f:	a3 a4 e5 b3 00       	mov    %eax,0xb3e5a4
  80d574:	89 d0                	mov    %edx,%eax
    if (max_tid == (uint32_t)~0)
  80d576:	83 3d a4 e5 b3 00 ff 	cmpl   $0xffffffff,0xb3e5a4
  80d57d:	75 14                	jne    80d593 <alloc_tid+0x33>
	panic("alloc_tid: no more thread ids");
  80d57f:	83 ec 04             	sub    $0x4,%esp
  80d582:	68 19 3a 81 00       	push   $0x813a19
  80d587:	6a 47                	push   $0x47
  80d589:	68 37 3a 81 00       	push   $0x813a37
  80d58e:	e8 39 35 ff ff       	call   800acc <_panic>
    return tid;
}
  80d593:	c9                   	leave  
  80d594:	c3                   	ret    

0080d595 <thread_set_name>:

static void
thread_set_name(struct thread_context *tc, const char *name)
{
  80d595:	55                   	push   %ebp
  80d596:	89 e5                	mov    %esp,%ebp
  80d598:	53                   	push   %ebx
  80d599:	83 ec 08             	sub    $0x8,%esp
  80d59c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    strncpy(tc->tc_name, name, name_size - 1);
  80d59f:	6a 1f                	push   $0x1f
  80d5a1:	ff 75 0c             	pushl  0xc(%ebp)
  80d5a4:	8d 43 08             	lea    0x8(%ebx),%eax
  80d5a7:	50                   	push   %eax
  80d5a8:	e8 2e 3c ff ff       	call   8011db <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80d5ad:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
}
  80d5b1:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80d5b4:	c9                   	leave  
  80d5b5:	c3                   	ret    

0080d5b6 <thread_entry>:

static void
thread_entry(void) {
  80d5b6:	55                   	push   %ebp
  80d5b7:	89 e5                	mov    %esp,%ebp
  80d5b9:	83 ec 14             	sub    $0x14,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80d5bc:	a1 a8 e5 b3 00       	mov    0xb3e5a8,%eax
  80d5c1:	ff 70 2c             	pushl  0x2c(%eax)
  80d5c4:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80d5c7:	e8 30 01 00 00       	call   80d6fc <thread_halt>
}
  80d5cc:	c9                   	leave  
  80d5cd:	c3                   	ret    

0080d5ce <thread_create>:

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80d5ce:	55                   	push   %ebp
  80d5cf:	89 e5                	mov    %esp,%ebp
  80d5d1:	57                   	push   %edi
  80d5d2:	56                   	push   %esi
  80d5d3:	53                   	push   %ebx
  80d5d4:	83 ec 18             	sub    $0x18,%esp
  80d5d7:	8b 7d 08             	mov    0x8(%ebp),%edi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80d5da:	6a 68                	push   $0x68
  80d5dc:	e8 fe 53 ff ff       	call   8029df <malloc>
  80d5e1:	89 c6                	mov    %eax,%esi
    if (!tc)
  80d5e3:	83 c4 10             	add    $0x10,%esp
	return -E_NO_MEM;
  80d5e6:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80d5eb:	85 f6                	test   %esi,%esi
  80d5ed:	0f 84 be 00 00 00    	je     80d6b1 <thread_create+0xe3>

    memset(tc, 0, sizeof(struct thread_context));
  80d5f3:	83 ec 04             	sub    $0x4,%esp
  80d5f6:	6a 68                	push   $0x68
  80d5f8:	6a 00                	push   $0x0
  80d5fa:	56                   	push   %esi
  80d5fb:	e8 e9 3c ff ff       	call   8012e9 <memset>
    
    thread_set_name(tc, name);
  80d600:	83 c4 08             	add    $0x8,%esp
  80d603:	ff 75 0c             	pushl  0xc(%ebp)
  80d606:	56                   	push   %esi
  80d607:	e8 89 ff ff ff       	call   80d595 <thread_set_name>
    tc->tc_tid = alloc_tid();
  80d60c:	e8 4f ff ff ff       	call   80d560 <alloc_tid>
  80d611:	89 06                	mov    %eax,(%esi)

    tc->tc_stack_bottom = malloc(stack_size);
  80d613:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  80d61a:	e8 c0 53 ff ff       	call   8029df <malloc>
  80d61f:	89 46 04             	mov    %eax,0x4(%esi)
    if (!tc->tc_stack_bottom) {
  80d622:	83 c4 10             	add    $0x10,%esp
  80d625:	85 c0                	test   %eax,%eax
  80d627:	75 10                	jne    80d639 <thread_create+0x6b>
	free(tc);
  80d629:	83 ec 0c             	sub    $0xc,%esp
  80d62c:	56                   	push   %esi
  80d62d:	e8 33 55 ff ff       	call   802b65 <free>
	return -E_NO_MEM;
  80d632:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80d637:	eb 78                	jmp    80d6b1 <thread_create+0xe3>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80d639:	8b 5e 04             	mov    0x4(%esi),%ebx
  80d63c:	81 c3 fc 0f 00 00    	add    $0xffc,%ebx
    memset(stacktop, 0, 4);
  80d642:	83 ec 04             	sub    $0x4,%esp
  80d645:	6a 04                	push   $0x4
  80d647:	6a 00                	push   $0x0
  80d649:	53                   	push   %ebx
  80d64a:	e8 9a 3c ff ff       	call   8012e9 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80d64f:	83 c4 0c             	add    $0xc,%esp
  80d652:	6a 18                	push   $0x18
  80d654:	6a 00                	push   $0x0
  80d656:	8d 46 30             	lea    0x30(%esi),%eax
  80d659:	50                   	push   %eax
  80d65a:	e8 8a 3c ff ff       	call   8012e9 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80d65f:	89 5e 34             	mov    %ebx,0x34(%esi)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80d662:	c7 46 30 b6 d5 80 00 	movl   $0x80d5b6,0x30(%esi)
    tc->tc_entry = entry;
  80d669:	8b 45 10             	mov    0x10(%ebp),%eax
  80d66c:	89 46 28             	mov    %eax,0x28(%esi)
    tc->tc_arg = arg;
  80d66f:	8b 45 14             	mov    0x14(%ebp),%eax
  80d672:	89 46 2c             	mov    %eax,0x2c(%esi)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
  80d675:	83 c4 10             	add    $0x10,%esp
  80d678:	b9 ac e5 b3 00       	mov    $0xb3e5ac,%ecx
    tc->tc_queue_link = 0;
  80d67d:	c7 46 64 00 00 00 00 	movl   $0x0,0x64(%esi)
    if (!tq->tq_first) {
  80d684:	83 3d ac e5 b3 00 00 	cmpl   $0x0,0xb3e5ac
  80d68b:	75 0e                	jne    80d69b <thread_create+0xcd>
	tq->tq_first = tc;
  80d68d:	89 35 ac e5 b3 00    	mov    %esi,0xb3e5ac
	tq->tq_last = tc;
  80d693:	89 35 b0 e5 b3 00    	mov    %esi,0xb3e5b0
  80d699:	eb 09                	jmp    80d6a4 <thread_create+0xd6>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80d69b:	8b 41 04             	mov    0x4(%ecx),%eax
  80d69e:	89 70 64             	mov    %esi,0x64(%eax)
	tq->tq_last = tc;
  80d6a1:	89 71 04             	mov    %esi,0x4(%ecx)

    threadq_push(&thread_queue, tc);

    if (tid)
  80d6a4:	85 ff                	test   %edi,%edi
  80d6a6:	74 04                	je     80d6ac <thread_create+0xde>
	*tid = tc->tc_tid;
  80d6a8:	8b 06                	mov    (%esi),%eax
  80d6aa:	89 07                	mov    %eax,(%edi)
    return 0;
  80d6ac:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80d6b1:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80d6b4:	5b                   	pop    %ebx
  80d6b5:	5e                   	pop    %esi
  80d6b6:	5f                   	pop    %edi
  80d6b7:	c9                   	leave  
  80d6b8:	c3                   	ret    

0080d6b9 <thread_clean>:

static void
thread_clean(struct thread_context *tc) {
  80d6b9:	55                   	push   %ebp
  80d6ba:	89 e5                	mov    %esp,%ebp
  80d6bc:	56                   	push   %esi
  80d6bd:	53                   	push   %ebx
  80d6be:	8b 75 08             	mov    0x8(%ebp),%esi
    if (!tc) return;
  80d6c1:	85 f6                	test   %esi,%esi
  80d6c3:	74 30                	je     80d6f5 <thread_clean+0x3c>

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80d6c5:	bb 00 00 00 00       	mov    $0x0,%ebx
  80d6ca:	83 7e 60 00          	cmpl   $0x0,0x60(%esi)
  80d6ce:	7e 12                	jle    80d6e2 <thread_clean+0x29>
	tc->tc_onhalt[i](tc->tc_tid);
  80d6d0:	83 ec 0c             	sub    $0xc,%esp
  80d6d3:	ff 36                	pushl  (%esi)
  80d6d5:	ff 54 9e 50          	call   *0x50(%esi,%ebx,4)
  80d6d9:	83 c4 10             	add    $0x10,%esp
  80d6dc:	43                   	inc    %ebx
  80d6dd:	39 5e 60             	cmp    %ebx,0x60(%esi)
  80d6e0:	7f ee                	jg     80d6d0 <thread_clean+0x17>
    free(tc->tc_stack_bottom);
  80d6e2:	83 ec 0c             	sub    $0xc,%esp
  80d6e5:	ff 76 04             	pushl  0x4(%esi)
  80d6e8:	e8 78 54 ff ff       	call   802b65 <free>
    free(tc);
  80d6ed:	89 34 24             	mov    %esi,(%esp)
  80d6f0:	e8 70 54 ff ff       	call   802b65 <free>
}
  80d6f5:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80d6f8:	5b                   	pop    %ebx
  80d6f9:	5e                   	pop    %esi
  80d6fa:	c9                   	leave  
  80d6fb:	c3                   	ret    

0080d6fc <thread_halt>:

void
thread_halt() {
  80d6fc:	55                   	push   %ebp
  80d6fd:	89 e5                	mov    %esp,%ebp
  80d6ff:	83 ec 08             	sub    $0x8,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
  80d702:	b9 b4 e5 b3 00       	mov    $0xb3e5b4,%ecx
    if (!tq->tq_first)
  80d707:	b8 00 00 00 00       	mov    $0x0,%eax
  80d70c:	83 3d b4 e5 b3 00 00 	cmpl   $0x0,0xb3e5b4
  80d713:	74 0e                	je     80d723 <thread_halt+0x27>
	return 0;

    struct thread_context *tc = tq->tq_first;
  80d715:	8b 01                	mov    (%ecx),%eax
    tq->tq_first = tc->tc_queue_link;
  80d717:	8b 50 64             	mov    0x64(%eax),%edx
  80d71a:	89 11                	mov    %edx,(%ecx)
    tc->tc_queue_link = 0;
  80d71c:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
  80d723:	83 ec 0c             	sub    $0xc,%esp
  80d726:	50                   	push   %eax
  80d727:	e8 8d ff ff ff       	call   80d6b9 <thread_clean>
  80d72c:	83 c4 10             	add    $0x10,%esp
  80d72f:	b9 b4 e5 b3 00       	mov    $0xb3e5b4,%ecx
  80d734:	8b 15 a8 e5 b3 00    	mov    0xb3e5a8,%edx
  80d73a:	c7 42 64 00 00 00 00 	movl   $0x0,0x64(%edx)
  80d741:	83 3d b4 e5 b3 00 00 	cmpl   $0x0,0xb3e5b4
  80d748:	75 0e                	jne    80d758 <thread_halt+0x5c>
  80d74a:	89 15 b4 e5 b3 00    	mov    %edx,0xb3e5b4
  80d750:	89 15 b8 e5 b3 00    	mov    %edx,0xb3e5b8
  80d756:	eb 09                	jmp    80d761 <thread_halt+0x65>
  80d758:	8b 41 04             	mov    0x4(%ecx),%eax
  80d75b:	89 50 64             	mov    %edx,0x64(%eax)
  80d75e:	89 51 04             	mov    %edx,0x4(%ecx)
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
    cur_tc = NULL;
  80d761:	c7 05 a8 e5 b3 00 00 	movl   $0x0,0xb3e5a8
  80d768:	00 00 00 
    thread_yield();
  80d76b:	e8 07 00 00 00       	call   80d777 <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80d770:	e8 3f 33 ff ff       	call   800ab4 <exit>
}
  80d775:	c9                   	leave  
  80d776:	c3                   	ret    

0080d777 <thread_yield>:

void
thread_yield(void) {
  80d777:	55                   	push   %ebp
  80d778:	89 e5                	mov    %esp,%ebp
  80d77a:	53                   	push   %ebx
  80d77b:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
  80d77e:	b9 ac e5 b3 00       	mov    $0xb3e5ac,%ecx
    if (!tq->tq_first)
  80d783:	b8 00 00 00 00       	mov    $0x0,%eax
  80d788:	83 3d ac e5 b3 00 00 	cmpl   $0x0,0xb3e5ac
  80d78f:	74 0e                	je     80d79f <thread_yield+0x28>
	return 0;

    struct thread_context *tc = tq->tq_first;
  80d791:	8b 01                	mov    (%ecx),%eax
    tq->tq_first = tc->tc_queue_link;
  80d793:	8b 50 64             	mov    0x64(%eax),%edx
  80d796:	89 11                	mov    %edx,(%ecx)
    tc->tc_queue_link = 0;
  80d798:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
  80d79f:	89 c3                	mov    %eax,%ebx
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
  80d7a1:	85 c0                	test   %eax,%eax
  80d7a3:	74 66                	je     80d80b <thread_yield+0x94>
	return;

    if (cur_tc) {
  80d7a5:	83 3d a8 e5 b3 00 00 	cmpl   $0x0,0xb3e5a8
  80d7ac:	74 4a                	je     80d7f8 <thread_yield+0x81>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80d7ae:	83 ec 0c             	sub    $0xc,%esp
  80d7b1:	a1 a8 e5 b3 00       	mov    0xb3e5a8,%eax
  80d7b6:	83 c0 30             	add    $0x30,%eax
  80d7b9:	50                   	push   %eax
  80d7ba:	e8 d1 00 00 00       	call   80d890 <jos_setjmp>
  80d7bf:	83 c4 10             	add    $0x10,%esp
  80d7c2:	85 c0                	test   %eax,%eax
  80d7c4:	75 45                	jne    80d80b <thread_yield+0x94>
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
  80d7c6:	b9 ac e5 b3 00       	mov    $0xb3e5ac,%ecx
  80d7cb:	8b 15 a8 e5 b3 00    	mov    0xb3e5a8,%edx
    tc->tc_queue_link = 0;
  80d7d1:	c7 42 64 00 00 00 00 	movl   $0x0,0x64(%edx)
    if (!tq->tq_first) {
  80d7d8:	83 3d ac e5 b3 00 00 	cmpl   $0x0,0xb3e5ac
  80d7df:	75 0e                	jne    80d7ef <thread_yield+0x78>
	tq->tq_first = tc;
  80d7e1:	89 15 ac e5 b3 00    	mov    %edx,0xb3e5ac
	tq->tq_last = tc;
  80d7e7:	89 15 b0 e5 b3 00    	mov    %edx,0xb3e5b0
  80d7ed:	eb 09                	jmp    80d7f8 <thread_yield+0x81>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80d7ef:	8b 41 04             	mov    0x4(%ecx),%eax
  80d7f2:	89 50 64             	mov    %edx,0x64(%eax)
	tq->tq_last = tc;
  80d7f5:	89 51 04             	mov    %edx,0x4(%ecx)
	    return;
	threadq_push(&thread_queue, cur_tc);
    }

    cur_tc = next_tc;
  80d7f8:	89 1d a8 e5 b3 00    	mov    %ebx,0xb3e5a8
    jos_longjmp(&cur_tc->tc_jb, 1);
  80d7fe:	8d 43 30             	lea    0x30(%ebx),%eax
  80d801:	ba 01 00 00 00       	mov    $0x1,%edx
  80d806:	e8 b5 00 00 00       	call   80d8c0 <jos_longjmp>
}
  80d80b:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80d80e:	c9                   	leave  
  80d80f:	c3                   	ret    

0080d810 <print_jb>:

static void
print_jb(struct thread_context *tc) {
  80d810:	55                   	push   %ebp
  80d811:	89 e5                	mov    %esp,%ebp
  80d813:	53                   	push   %ebx
  80d814:	83 ec 0c             	sub    $0xc,%esp
  80d817:	8b 5d 08             	mov    0x8(%ebp),%ebx
    cprintf("jump buffer for thread %s:\n", tc->tc_name);
  80d81a:	8d 43 08             	lea    0x8(%ebx),%eax
  80d81d:	50                   	push   %eax
  80d81e:	68 52 3a 81 00       	push   $0x813a52
  80d823:	e8 94 33 ff ff       	call   800bbc <cprintf>
    cprintf("\teip: %x\n", tc->tc_jb.jb_eip);
  80d828:	83 c4 08             	add    $0x8,%esp
  80d82b:	ff 73 30             	pushl  0x30(%ebx)
  80d82e:	68 6e 3a 81 00       	push   $0x813a6e
  80d833:	e8 84 33 ff ff       	call   800bbc <cprintf>
    cprintf("\tesp: %x\n", tc->tc_jb.jb_esp);
  80d838:	83 c4 08             	add    $0x8,%esp
  80d83b:	ff 73 34             	pushl  0x34(%ebx)
  80d83e:	68 78 3a 81 00       	push   $0x813a78
  80d843:	e8 74 33 ff ff       	call   800bbc <cprintf>
    cprintf("\tebp: %x\n", tc->tc_jb.jb_ebp);
  80d848:	83 c4 08             	add    $0x8,%esp
  80d84b:	ff 73 38             	pushl  0x38(%ebx)
  80d84e:	68 82 3a 81 00       	push   $0x813a82
  80d853:	e8 64 33 ff ff       	call   800bbc <cprintf>
    cprintf("\tebx: %x\n", tc->tc_jb.jb_ebx);
  80d858:	83 c4 08             	add    $0x8,%esp
  80d85b:	ff 73 3c             	pushl  0x3c(%ebx)
  80d85e:	68 8c 3a 81 00       	push   $0x813a8c
  80d863:	e8 54 33 ff ff       	call   800bbc <cprintf>
    cprintf("\tesi: %x\n", tc->tc_jb.jb_esi);
  80d868:	83 c4 08             	add    $0x8,%esp
  80d86b:	ff 73 40             	pushl  0x40(%ebx)
  80d86e:	68 96 3a 81 00       	push   $0x813a96
  80d873:	e8 44 33 ff ff       	call   800bbc <cprintf>
    cprintf("\tedi: %x\n", tc->tc_jb.jb_edi);
  80d878:	83 c4 08             	add    $0x8,%esp
  80d87b:	ff 73 44             	pushl  0x44(%ebx)
  80d87e:	68 a0 3a 81 00       	push   $0x813aa0
  80d883:	e8 34 33 ff ff       	call   800bbc <cprintf>
}
  80d888:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80d88b:	c9                   	leave  
  80d88c:	c3                   	ret    
  80d88d:	00 00                	add    %al,(%eax)
	...

0080d890 <jos_setjmp>:
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80d890:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80d894:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80d897:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80d899:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80d89d:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80d8a0:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80d8a3:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80d8a6:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80d8a9:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80d8ac:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80d8b1:	c3                   	ret    
  80d8b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  80d8b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

0080d8c0 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80d8c0:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80d8c2:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80d8c5:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80d8c8:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80d8cb:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80d8ce:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80d8d1:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80d8d3:	ff e1                	jmp    *%ecx
  80d8d5:	00 00                	add    %al,(%eax)
	...

0080d8d8 <perror>:
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80d8d8:	55                   	push   %ebp
  80d8d9:	89 e5                	mov    %esp,%ebp
  80d8db:	83 ec 14             	sub    $0x14,%esp
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80d8de:	ff 35 00 e6 b3 00    	pushl  0xb3e600
  80d8e4:	e8 13 00 00 00       	call   80d8fc <e2s>
  80d8e9:	83 c4 0c             	add    $0xc,%esp
  80d8ec:	50                   	push   %eax
  80d8ed:	ff 75 08             	pushl  0x8(%ebp)
  80d8f0:	68 84 3f 81 00       	push   $0x813f84
  80d8f5:	e8 c2 32 ff ff       	call   800bbc <cprintf>
}
  80d8fa:	c9                   	leave  
  80d8fb:	c3                   	ret    

0080d8fc <e2s>:

const char *
e2s(int err) {
  80d8fc:	55                   	push   %ebp
  80d8fd:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80d8ff:	8b 45 08             	mov    0x8(%ebp),%eax
  80d902:	8b 04 85 00 81 81 00 	mov    0x818100(,%eax,4),%eax
}
  80d909:	c9                   	leave  
  80d90a:	c3                   	ret    
	...

0080d90c <low_level_init>:
};

static void
low_level_init(struct netif *netif)
{
  80d90c:	55                   	push   %ebp
  80d90d:	89 e5                	mov    %esp,%ebp
  80d90f:	8b 45 08             	mov    0x8(%ebp),%eax
    int r;

    netif->hwaddr_len = 6;
  80d912:	c6 40 24 06          	movb   $0x6,0x24(%eax)
    netif->mtu = 1500;
  80d916:	66 c7 40 2c dc 05    	movw   $0x5dc,0x2c(%eax)
    netif->flags = NETIF_FLAG_BROADCAST;
  80d91c:	c6 40 2e 02          	movb   $0x2,0x2e(%eax)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  80d920:	c6 40 25 52          	movb   $0x52,0x25(%eax)
    netif->hwaddr[1] = 0x54;
  80d924:	c6 40 26 54          	movb   $0x54,0x26(%eax)
    netif->hwaddr[2] = 0x00;
  80d928:	c6 40 27 00          	movb   $0x0,0x27(%eax)
    netif->hwaddr[3] = 0x12;
  80d92c:	c6 40 28 12          	movb   $0x12,0x28(%eax)
    netif->hwaddr[4] = 0x34;
  80d930:	c6 40 29 34          	movb   $0x34,0x29(%eax)
    netif->hwaddr[5] = 0x56;
  80d934:	c6 40 2a 56          	movb   $0x56,0x2a(%eax)
}
  80d938:	c9                   	leave  
  80d939:	c3                   	ret    

0080d93a <low_level_output>:

/*
 * low_level_output():
 *
 * Should do the actual transmission of the packet. The packet is
 * contained in the pbuf that is passed to the function. This pbuf
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80d93a:	55                   	push   %ebp
  80d93b:	89 e5                	mov    %esp,%ebp
  80d93d:	57                   	push   %edi
  80d93e:	56                   	push   %esi
  80d93f:	53                   	push   %ebx
  80d940:	83 ec 10             	sub    $0x10,%esp
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80d943:	6a 07                	push   $0x7
  80d945:	68 00 00 00 10       	push   $0x10000000
  80d94a:	6a 00                	push   $0x0
  80d94c:	e8 41 3c ff ff       	call   801592 <sys_page_alloc>
    if (r < 0)
  80d951:	83 c4 10             	add    $0x10,%esp
  80d954:	85 c0                	test   %eax,%eax
  80d956:	79 14                	jns    80d96c <low_level_output+0x32>
	panic("jif: could not allocate page of memory");
  80d958:	83 ec 04             	sub    $0x4,%esp
  80d95b:	68 8c 3f 81 00       	push   $0x813f8c
  80d960:	6a 55                	push   $0x55
  80d962:	68 dd 3f 81 00       	push   $0x813fdd
  80d967:	e8 60 31 ff ff       	call   800acc <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80d96c:	8b 45 08             	mov    0x8(%ebp),%eax
  80d96f:	8b 40 1c             	mov    0x1c(%eax),%eax
  80d972:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)

    char *txbuf = pkt->jp_data;
  80d975:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80d97a:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80d97f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80d982:	85 db                	test   %ebx,%ebx
  80d984:	74 4a                	je     80d9d0 <low_level_output+0x96>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80d986:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80d98a:	01 f0                	add    %esi,%eax
  80d98c:	3d d0 07 00 00       	cmp    $0x7d0,%eax
  80d991:	7e 1a                	jle    80d9ad <low_level_output+0x73>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80d993:	83 ec 0c             	sub    $0xc,%esp
  80d996:	56                   	push   %esi
  80d997:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80d99b:	50                   	push   %eax
  80d99c:	68 b4 3f 81 00       	push   $0x813fb4
  80d9a1:	6a 64                	push   $0x64
  80d9a3:	68 dd 3f 81 00       	push   $0x813fdd
  80d9a8:	e8 1f 31 ff ff       	call   800acc <_panic>
	memcpy(&txbuf[txsize], q->payload, q->len);
  80d9ad:	83 ec 04             	sub    $0x4,%esp
  80d9b0:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80d9b4:	50                   	push   %eax
  80d9b5:	ff 73 04             	pushl  0x4(%ebx)
  80d9b8:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80d9bb:	50                   	push   %eax
  80d9bc:	e8 e6 39 ff ff       	call   8013a7 <memcpy>
	txsize += q->len;
  80d9c1:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80d9c5:	01 c6                	add    %eax,%esi
  80d9c7:	83 c4 10             	add    $0x10,%esp
  80d9ca:	8b 1b                	mov    (%ebx),%ebx
  80d9cc:	85 db                	test   %ebx,%ebx
  80d9ce:	75 b6                	jne    80d986 <low_level_output+0x4c>
    }

    pkt->jp_len = txsize;
  80d9d0:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80d9d6:	6a 07                	push   $0x7
  80d9d8:	68 00 00 00 10       	push   $0x10000000
  80d9dd:	6a 0b                	push   $0xb
  80d9df:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  80d9e2:	ff 70 04             	pushl  0x4(%eax)
  80d9e5:	e8 05 43 ff ff       	call   801cef <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80d9ea:	83 c4 08             	add    $0x8,%esp
  80d9ed:	68 00 00 00 10       	push   $0x10000000
  80d9f2:	6a 00                	push   $0x0
  80d9f4:	e8 1e 3c ff ff       	call   801617 <sys_page_unmap>

    return ERR_OK;
}
  80d9f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80d9fe:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80da01:	5b                   	pop    %ebx
  80da02:	5e                   	pop    %esi
  80da03:	5f                   	pop    %edi
  80da04:	c9                   	leave  
  80da05:	c3                   	ret    

0080da06 <low_level_input>:

/*
 * low_level_input():
 *
 * Should allocate a pbuf and transfer the bytes of the incoming
 * packet from the interface into the pbuf.
 *
 */
static struct pbuf *
low_level_input(void *va)
{
  80da06:	55                   	push   %ebp
  80da07:	89 e5                	mov    %esp,%ebp
  80da09:	57                   	push   %edi
  80da0a:	56                   	push   %esi
  80da0b:	53                   	push   %ebx
  80da0c:	83 ec 10             	sub    $0x10,%esp
    struct jif_pkt *pkt = (struct jif_pkt *)va;
  80da0f:	8b 5d 08             	mov    0x8(%ebp),%ebx
    s16_t len = pkt->jp_len;
  80da12:	66 8b 03             	mov    (%ebx),%ax
  80da15:	66 89 45 f2          	mov    %ax,0xfffffff2(%ebp)

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80da19:	6a 03                	push   $0x3
  80da1b:	0f b7 c0             	movzwl %ax,%eax
  80da1e:	50                   	push   %eax
  80da1f:	6a 03                	push   $0x3
  80da21:	e8 62 9a ff ff       	call   807488 <pbuf_alloc>
  80da26:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
    if (p == 0)
  80da29:	83 c4 10             	add    $0x10,%esp
	return 0;
  80da2c:	b8 00 00 00 00       	mov    $0x0,%eax
  80da31:	83 7d ec 00          	cmpl   $0x0,0xffffffec(%ebp)
  80da35:	74 42                	je     80da79 <low_level_input+0x73>

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  80da37:	83 c3 04             	add    $0x4,%ebx
  80da3a:	89 5d e8             	mov    %ebx,0xffffffe8(%ebp)
    int copied = 0;
  80da3d:	bf 00 00 00 00       	mov    $0x0,%edi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80da42:	8b 75 ec             	mov    0xffffffec(%ebp),%esi
  80da45:	85 f6                	test   %esi,%esi
  80da47:	74 2d                	je     80da76 <low_level_input+0x70>
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80da49:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
	if (bytes > (len - copied))
  80da4d:	0f bf 45 f2          	movswl 0xfffffff2(%ebp),%eax
  80da51:	29 f8                	sub    %edi,%eax
  80da53:	39 d8                	cmp    %ebx,%eax
  80da55:	7d 02                	jge    80da59 <low_level_input+0x53>
	    bytes = len - copied;
  80da57:	89 c3                	mov    %eax,%ebx
	memcpy(q->payload, rxbuf + copied, bytes);
  80da59:	83 ec 04             	sub    $0x4,%esp
  80da5c:	53                   	push   %ebx
  80da5d:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  80da60:	01 f8                	add    %edi,%eax
  80da62:	50                   	push   %eax
  80da63:	ff 76 04             	pushl  0x4(%esi)
  80da66:	e8 3c 39 ff ff       	call   8013a7 <memcpy>
	copied += bytes;
  80da6b:	01 df                	add    %ebx,%edi
  80da6d:	83 c4 10             	add    $0x10,%esp
  80da70:	8b 36                	mov    (%esi),%esi
  80da72:	85 f6                	test   %esi,%esi
  80da74:	75 d3                	jne    80da49 <low_level_input+0x43>
    }

    return p;
  80da76:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  80da79:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80da7c:	5b                   	pop    %ebx
  80da7d:	5e                   	pop    %esi
  80da7e:	5f                   	pop    %edi
  80da7f:	c9                   	leave  
  80da80:	c3                   	ret    

0080da81 <jif_output>:
/*
 * jif_output():
 *
 * This function is called by the TCP/IP stack when an IP packet
 * should be sent. It calls the function called low_level_output() to
 * do the actual transmission of the packet.
 *
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80da81:	55                   	push   %ebp
  80da82:	89 e5                	mov    %esp,%ebp
  80da84:	83 ec 0c             	sub    $0xc,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80da87:	ff 75 10             	pushl  0x10(%ebp)
  80da8a:	ff 75 0c             	pushl  0xc(%ebp)
  80da8d:	ff 75 08             	pushl  0x8(%ebp)
  80da90:	e8 0c eb ff ff       	call   80c5a1 <etharp_output>
  80da95:	0f be c0             	movsbl %al,%eax
}
  80da98:	c9                   	leave  
  80da99:	c3                   	ret    

0080da9a <jif_input>:

/*
 * jif_input():
 *
 * This function should be called when a packet is ready to be read
 * from the interface. It uses the function low_level_input() that
 * should handle the actual reception of bytes from the network
 * interface.
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80da9a:	55                   	push   %ebp
  80da9b:	89 e5                	mov    %esp,%ebp
  80da9d:	57                   	push   %edi
  80da9e:	56                   	push   %esi
  80da9f:	53                   	push   %ebx
  80daa0:	83 ec 18             	sub    $0x18,%esp
  80daa3:	8b 75 08             	mov    0x8(%ebp),%esi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80daa6:	8b 7e 1c             	mov    0x1c(%esi),%edi
  
    /* move received packet into a new pbuf */
    p = low_level_input(va);
  80daa9:	ff 75 0c             	pushl  0xc(%ebp)
  80daac:	e8 55 ff ff ff       	call   80da06 <low_level_input>
  80dab1:	89 c3                	mov    %eax,%ebx

    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
  80dab3:	83 c4 10             	add    $0x10,%esp
  80dab6:	85 c0                	test   %eax,%eax
  80dab8:	74 65                	je     80db1f <jif_input+0x85>
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;
  80daba:	8b 40 04             	mov    0x4(%eax),%eax

    switch (htons(ethhdr->type)) {
  80dabd:	83 ec 0c             	sub    $0xc,%esp
  80dac0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80dac4:	50                   	push   %eax
  80dac5:	e8 95 cb ff ff       	call   80a65f <htons>
  80daca:	0f b7 c0             	movzwl %ax,%eax
  80dacd:	83 c4 10             	add    $0x10,%esp
  80dad0:	3d 00 08 00 00       	cmp    $0x800,%eax
  80dad5:	74 09                	je     80dae0 <jif_input+0x46>
  80dad7:	3d 06 08 00 00       	cmp    $0x806,%eax
  80dadc:	74 24                	je     80db02 <jif_input+0x68>
  80dade:	eb 33                	jmp    80db13 <jif_input+0x79>
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80dae0:	83 ec 08             	sub    $0x8,%esp
  80dae3:	53                   	push   %ebx
  80dae4:	56                   	push   %esi
  80dae5:	e8 9d e8 ff ff       	call   80c387 <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80daea:	83 c4 08             	add    $0x8,%esp
  80daed:	6a f2                	push   $0xfffffff2
  80daef:	53                   	push   %ebx
  80daf0:	e8 4e 9d ff ff       	call   807843 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80daf5:	83 c4 08             	add    $0x8,%esp
  80daf8:	56                   	push   %esi
  80daf9:	53                   	push   %ebx
  80dafa:	ff 56 10             	call   *0x10(%esi)
	break;
  80dafd:	83 c4 10             	add    $0x10,%esp
  80db00:	eb 1d                	jmp    80db1f <jif_input+0x85>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80db02:	83 ec 04             	sub    $0x4,%esp
  80db05:	53                   	push   %ebx
  80db06:	ff 37                	pushl  (%edi)
  80db08:	56                   	push   %esi
  80db09:	e8 c8 e8 ff ff       	call   80c3d6 <etharp_arp_input>
	break;
  80db0e:	83 c4 10             	add    $0x10,%esp
  80db11:	eb 0c                	jmp    80db1f <jif_input+0x85>

    default:
	pbuf_free(p);
  80db13:	83 ec 0c             	sub    $0xc,%esp
  80db16:	53                   	push   %ebx
  80db17:	e8 fd 9d ff ff       	call   807919 <pbuf_free>
  80db1c:	83 c4 10             	add    $0x10,%esp
    }
}
  80db1f:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80db22:	5b                   	pop    %ebx
  80db23:	5e                   	pop    %esi
  80db24:	5f                   	pop    %edi
  80db25:	c9                   	leave  
  80db26:	c3                   	ret    

0080db27 <jif_init>:

/*
 * jif_init():
 *
 * Should be called at the beginning of the program to set up the
 * network interface. It calls the function low_level_init() to do the
 * actual setup of the hardware.
 *
 */

err_t
jif_init(struct netif *netif)
{
  80db27:	55                   	push   %ebp
  80db28:	89 e5                	mov    %esp,%ebp
  80db2a:	57                   	push   %edi
  80db2b:	56                   	push   %esi
  80db2c:	53                   	push   %ebx
  80db2d:	83 ec 18             	sub    $0x18,%esp
  80db30:	8b 7d 08             	mov    0x8(%ebp),%edi
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80db33:	6a 08                	push   $0x8
  80db35:	e8 d7 93 ff ff       	call   806f11 <mem_malloc>
  80db3a:	89 c6                	mov    %eax,%esi

    if (jif == NULL) {
  80db3c:	83 c4 10             	add    $0x10,%esp
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  80db3f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80db44:	85 f6                	test   %esi,%esi
  80db46:	74 5b                	je     80dba3 <jif_init+0x7c>
    }

    output_envid = (envid_t *)netif->state;
  80db48:	8b 5f 1c             	mov    0x1c(%edi),%ebx

    netif->state = jif;
  80db4b:	89 77 1c             	mov    %esi,0x1c(%edi)
    netif->output = jif_output;
  80db4e:	c7 47 14 81 da 80 00 	movl   $0x80da81,0x14(%edi)
    netif->linkoutput = low_level_output;
  80db55:	c7 47 18 3a d9 80 00 	movl   $0x80d93a,0x18(%edi)
    memcpy(&netif->name[0], "en", 2);
  80db5c:	83 ec 04             	sub    $0x4,%esp
  80db5f:	6a 02                	push   $0x2
  80db61:	68 a2 25 81 00       	push   $0x8125a2
  80db66:	8d 47 2f             	lea    0x2f(%edi),%eax
  80db69:	50                   	push   %eax
  80db6a:	e8 38 38 ff ff       	call   8013a7 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80db6f:	8d 47 25             	lea    0x25(%edi),%eax
  80db72:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80db74:	8b 03                	mov    (%ebx),%eax
  80db76:	89 46 04             	mov    %eax,0x4(%esi)

    low_level_init(netif);
  80db79:	57                   	push   %edi
  80db7a:	e8 8d fd ff ff       	call   80d90c <low_level_init>

    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80db7f:	83 c4 08             	add    $0x8,%esp
  80db82:	68 f8 19 81 00       	push   $0x8119f8
  80db87:	e8 64 c8 ff ff       	call   80a3f0 <inet_addr>
  80db8c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80db8f:	83 c4 0c             	add    $0xc,%esp
  80db92:	6a 00                	push   $0x0
  80db94:	8d 45 f0             	lea    0xfffffff0(%ebp),%eax
  80db97:	50                   	push   %eax
  80db98:	57                   	push   %edi
  80db99:	e8 f7 ea ff ff       	call   80c695 <etharp_query>

    return ERR_OK;
  80db9e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80dba3:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80dba6:	5b                   	pop    %ebx
  80dba7:	5e                   	pop    %esi
  80dba8:	5f                   	pop    %edi
  80dba9:	c9                   	leave  
  80dbaa:	c3                   	ret    
	...

0080dbac <netconn_new_with_proto_and_callback>:
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80dbac:	55                   	push   %ebp
  80dbad:	89 e5                	mov    %esp,%ebp
  80dbaf:	56                   	push   %esi
  80dbb0:	53                   	push   %ebx
  80dbb1:	83 ec 28             	sub    $0x28,%esp
  80dbb4:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80dbb7:	ff 75 10             	pushl  0x10(%ebp)
  80dbba:	ff 75 08             	pushl  0x8(%ebp)
  80dbbd:	e8 cc 0c 00 00       	call   80e88e <netconn_alloc>
  80dbc2:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80dbc4:	83 c4 10             	add    $0x10,%esp
  80dbc7:	85 c0                	test   %eax,%eax
  80dbc9:	0f 84 b8 00 00 00    	je     80dc87 <netconn_new_with_proto_and_callback+0xdb>
    msg.function = do_newconn;
  80dbcf:	c7 45 d8 5e e8 80 00 	movl   $0x80e85e,0xffffffd8(%ebp)
    msg.msg.msg.n.proto = proto;
  80dbd6:	89 f0                	mov    %esi,%eax
  80dbd8:	88 45 e0             	mov    %al,0xffffffe0(%ebp)
    msg.msg.conn = conn;
  80dbdb:	89 5d dc             	mov    %ebx,0xffffffdc(%ebp)
    TCPIP_APIMSG(&msg);
  80dbde:	83 ec 0c             	sub    $0xc,%esp
  80dbe1:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  80dbe4:	50                   	push   %eax
  80dbe5:	e8 ec 72 ff ff       	call   804ed6 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80dbea:	83 c4 10             	add    $0x10,%esp
  80dbed:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80dbf1:	0f 84 90 00 00 00    	je     80dc87 <netconn_new_with_proto_and_callback+0xdb>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80dbf7:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80dbfb:	74 14                	je     80dc11 <netconn_new_with_proto_and_callback+0x65>
  80dbfd:	83 ec 04             	sub    $0x4,%esp
  80dc00:	68 f4 3f 81 00       	push   $0x813ff4
  80dc05:	6a 52                	push   $0x52
  80dc07:	68 a6 40 81 00       	push   $0x8140a6
  80dc0c:	e8 bb 2e ff ff       	call   800acc <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80dc11:	83 7b 10 ff          	cmpl   $0xffffffff,0x10(%ebx)
  80dc15:	75 14                	jne    80dc2b <netconn_new_with_proto_and_callback+0x7f>
  80dc17:	83 ec 04             	sub    $0x4,%esp
  80dc1a:	68 bd 40 81 00       	push   $0x8140bd
  80dc1f:	6a 53                	push   $0x53
  80dc21:	68 a6 40 81 00       	push   $0x8140a6
  80dc26:	e8 a1 2e ff ff       	call   800acc <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80dc2b:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80dc2f:	75 14                	jne    80dc45 <netconn_new_with_proto_and_callback+0x99>
  80dc31:	83 ec 04             	sub    $0x4,%esp
  80dc34:	68 d6 40 81 00       	push   $0x8140d6
  80dc39:	6a 54                	push   $0x54
  80dc3b:	68 a6 40 81 00       	push   $0x8140a6
  80dc40:	e8 87 2e ff ff       	call   800acc <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80dc45:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80dc49:	74 14                	je     80dc5f <netconn_new_with_proto_and_callback+0xb3>
  80dc4b:	83 ec 04             	sub    $0x4,%esp
  80dc4e:	68 18 40 81 00       	push   $0x814018
  80dc53:	6a 55                	push   $0x55
  80dc55:	68 a6 40 81 00       	push   $0x8140a6
  80dc5a:	e8 6d 2e ff ff       	call   800acc <_panic>
      sys_sem_free(conn->op_completed);
  80dc5f:	83 ec 0c             	sub    $0xc,%esp
  80dc62:	ff 73 10             	pushl  0x10(%ebx)
  80dc65:	e8 95 f2 ff ff       	call   80ceff <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80dc6a:	83 c4 04             	add    $0x4,%esp
  80dc6d:	ff 73 14             	pushl  0x14(%ebx)
  80dc70:	e8 41 f0 ff ff       	call   80ccb6 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80dc75:	83 c4 08             	add    $0x8,%esp
  80dc78:	53                   	push   %ebx
  80dc79:	6a 07                	push   $0x7
  80dc7b:	e8 71 95 ff ff       	call   8071f1 <memp_free>
      return NULL;
  80dc80:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc85:	eb 02                	jmp    80dc89 <netconn_new_with_proto_and_callback+0xdd>
    }
  }
  return conn;
  80dc87:	89 d8                	mov    %ebx,%eax
}
  80dc89:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80dc8c:	5b                   	pop    %ebx
  80dc8d:	5e                   	pop    %esi
  80dc8e:	c9                   	leave  
  80dc8f:	c3                   	ret    

0080dc90 <netconn_delete>:

/**
 * Close a netconn 'connection' and free its resources.
 * UDP and RAW connection are completely closed, TCP pcbs might still be in a waitstate
 * after this returns.
 *
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80dc90:	55                   	push   %ebp
  80dc91:	89 e5                	mov    %esp,%ebp
  80dc93:	53                   	push   %ebx
  80dc94:	83 ec 24             	sub    $0x24,%esp
  80dc97:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
    return ERR_OK;
  80dc9a:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc9f:	85 db                	test   %ebx,%ebx
  80dca1:	74 2a                	je     80dccd <netconn_delete+0x3d>
  }

  msg.function = do_delconn;
  80dca3:	c7 45 d8 d6 eb 80 00 	movl   $0x80ebd6,0xffffffd8(%ebp)
  msg.msg.conn = conn;
  80dcaa:	89 5d dc             	mov    %ebx,0xffffffdc(%ebp)
  tcpip_apimsg(&msg);
  80dcad:	83 ec 0c             	sub    $0xc,%esp
  80dcb0:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  80dcb3:	50                   	push   %eax
  80dcb4:	e8 1d 72 ff ff       	call   804ed6 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80dcb9:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80dcc0:	89 1c 24             	mov    %ebx,(%esp)
  80dcc3:	e8 77 0c 00 00       	call   80e93f <netconn_free>

  return ERR_OK;
  80dcc8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80dccd:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80dcd0:	c9                   	leave  
  80dcd1:	c3                   	ret    

0080dcd2 <netconn_type>:

/**
 * Get the type of a netconn (as enum netconn_type).
 *
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80dcd2:	55                   	push   %ebp
  80dcd3:	89 e5                	mov    %esp,%ebp
  80dcd5:	83 ec 08             	sub    $0x8,%esp
  80dcd8:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80dcdb:	85 c0                	test   %eax,%eax
  80dcdd:	75 17                	jne    80dcf6 <netconn_type+0x24>
  80dcdf:	83 ec 04             	sub    $0x4,%esp
  80dce2:	68 eb 40 81 00       	push   $0x8140eb
  80dce7:	68 84 00 00 00       	push   $0x84
  80dcec:	68 a6 40 81 00       	push   $0x8140a6
  80dcf1:	e8 d6 2d ff ff       	call   800acc <_panic>
  return conn->type;
  80dcf6:	8b 00                	mov    (%eax),%eax
}
  80dcf8:	c9                   	leave  
  80dcf9:	c3                   	ret    

0080dcfa <netconn_getaddr>:

/**
 * Get the local or remote IP address and port of a netconn.
 * For RAW netconns, this returns the protocol instead of a port!
 *
 * @param conn the netconn to query
 * @param addr a pointer to which to save the IP address
 * @param port a pointer to which to save the port (or protocol for RAW)
 * @param local 1 to get the local IP address, 0 to get the remote one
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80dcfa:	55                   	push   %ebp
  80dcfb:	89 e5                	mov    %esp,%ebp
  80dcfd:	53                   	push   %ebx
  80dcfe:	83 ec 24             	sub    $0x24,%esp
  80dd01:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80dd04:	8b 55 0c             	mov    0xc(%ebp),%edx
  80dd07:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80dd0a:	8a 45 14             	mov    0x14(%ebp),%al
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80dd0d:	85 db                	test   %ebx,%ebx
  80dd0f:	75 17                	jne    80dd28 <netconn_getaddr+0x2e>
  80dd11:	83 ec 04             	sub    $0x4,%esp
  80dd14:	68 06 41 81 00       	push   $0x814106
  80dd19:	68 98 00 00 00       	push   $0x98
  80dd1e:	68 a6 40 81 00       	push   $0x8140a6
  80dd23:	e8 a4 2d ff ff       	call   800acc <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80dd28:	85 d2                	test   %edx,%edx
  80dd2a:	75 17                	jne    80dd43 <netconn_getaddr+0x49>
  80dd2c:	83 ec 04             	sub    $0x4,%esp
  80dd2f:	68 24 41 81 00       	push   $0x814124
  80dd34:	68 99 00 00 00       	push   $0x99
  80dd39:	68 a6 40 81 00       	push   $0x8140a6
  80dd3e:	e8 89 2d ff ff       	call   800acc <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80dd43:	85 c9                	test   %ecx,%ecx
  80dd45:	75 17                	jne    80dd5e <netconn_getaddr+0x64>
  80dd47:	83 ec 04             	sub    $0x4,%esp
  80dd4a:	68 42 41 81 00       	push   $0x814142
  80dd4f:	68 9a 00 00 00       	push   $0x9a
  80dd54:	68 a6 40 81 00       	push   $0x8140a6
  80dd59:	e8 6e 2d ff ff       	call   800acc <_panic>

  msg.function = do_getaddr;
  80dd5e:	c7 45 d8 20 f2 80 00 	movl   $0x80f220,0xffffffd8(%ebp)
  msg.msg.conn = conn;
  80dd65:	89 5d dc             	mov    %ebx,0xffffffdc(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80dd68:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
  msg.msg.msg.ad.port = port;
  80dd6b:	89 4d e4             	mov    %ecx,0xffffffe4(%ebp)
  msg.msg.msg.ad.local = local;
  80dd6e:	88 45 e8             	mov    %al,0xffffffe8(%ebp)
  TCPIP_APIMSG(&msg);
  80dd71:	83 ec 0c             	sub    $0xc,%esp
  80dd74:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  80dd77:	50                   	push   %eax
  80dd78:	e8 59 71 ff ff       	call   804ed6 <tcpip_apimsg>

  return conn->err;
  80dd7d:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
}
  80dd81:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80dd84:	c9                   	leave  
  80dd85:	c3                   	ret    

0080dd86 <netconn_bind>:

/**
 * Bind a netconn to a specific local IP address and port.
 * Binding one netconn twice might not always be checked correctly!
 *
 * @param conn the netconn to bind
 * @param addr the local IP address to bind the netconn to (use IP_ADDR_ANY
 *             to bind to all addresses)
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80dd86:	55                   	push   %ebp
  80dd87:	89 e5                	mov    %esp,%ebp
  80dd89:	53                   	push   %ebx
  80dd8a:	83 ec 24             	sub    $0x24,%esp
  80dd8d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80dd90:	8b 55 10             	mov    0x10(%ebp),%edx
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80dd93:	85 db                	test   %ebx,%ebx
  80dd95:	75 17                	jne    80ddae <netconn_bind+0x28>
  80dd97:	83 ec 04             	sub    $0x4,%esp
  80dd9a:	68 60 41 81 00       	push   $0x814160
  80dd9f:	68 b5 00 00 00       	push   $0xb5
  80dda4:	68 a6 40 81 00       	push   $0x8140a6
  80dda9:	e8 1e 2d ff ff       	call   800acc <_panic>

  msg.function = do_bind;
  80ddae:	c7 45 d8 91 ec 80 00 	movl   $0x80ec91,0xffffffd8(%ebp)
  msg.msg.conn = conn;
  80ddb5:	89 5d dc             	mov    %ebx,0xffffffdc(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80ddb8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ddbb:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  msg.msg.msg.bc.port = port;
  80ddbe:	66 89 55 e4          	mov    %dx,0xffffffe4(%ebp)
  TCPIP_APIMSG(&msg);
  80ddc2:	83 ec 0c             	sub    $0xc,%esp
  80ddc5:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  80ddc8:	50                   	push   %eax
  80ddc9:	e8 08 71 ff ff       	call   804ed6 <tcpip_apimsg>
  return conn->err;
  80ddce:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
}
  80ddd2:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80ddd5:	c9                   	leave  
  80ddd6:	c3                   	ret    

0080ddd7 <netconn_connect>:

/**
 * Connect a netconn to a specific remote IP address and port.
 *
 * @param conn the netconn to connect
 * @param addr the remote IP address to connect to
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ddd7:	55                   	push   %ebp
  80ddd8:	89 e5                	mov    %esp,%ebp
  80ddda:	53                   	push   %ebx
  80dddb:	83 ec 24             	sub    $0x24,%esp
  80ddde:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80dde1:	8b 55 10             	mov    0x10(%ebp),%edx
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80dde4:	85 db                	test   %ebx,%ebx
  80dde6:	75 17                	jne    80ddff <netconn_connect+0x28>
  80dde8:	83 ec 04             	sub    $0x4,%esp
  80ddeb:	68 7b 41 81 00       	push   $0x81417b
  80ddf0:	68 cc 00 00 00       	push   $0xcc
  80ddf5:	68 a6 40 81 00       	push   $0x8140a6
  80ddfa:	e8 cd 2c ff ff       	call   800acc <_panic>

  msg.function = do_connect;
  80ddff:	c7 45 d8 7a ed 80 00 	movl   $0x80ed7a,0xffffffd8(%ebp)
  msg.msg.conn = conn;
  80de06:	89 5d dc             	mov    %ebx,0xffffffdc(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80de09:	8b 45 0c             	mov    0xc(%ebp),%eax
  80de0c:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  msg.msg.msg.bc.port = port;
  80de0f:	66 89 55 e4          	mov    %dx,0xffffffe4(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80de13:	83 ec 0c             	sub    $0xc,%esp
  80de16:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  80de19:	50                   	push   %eax
  80de1a:	e8 b7 70 ff ff       	call   804ed6 <tcpip_apimsg>
  return conn->err;
  80de1f:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
}
  80de23:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80de26:	c9                   	leave  
  80de27:	c3                   	ret    

0080de28 <netconn_disconnect>:

/**
 * Disconnect a netconn from its current peer (only valid for UDP netconns).
 *
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80de28:	55                   	push   %ebp
  80de29:	89 e5                	mov    %esp,%ebp
  80de2b:	53                   	push   %ebx
  80de2c:	83 ec 24             	sub    $0x24,%esp
  80de2f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80de32:	85 db                	test   %ebx,%ebx
  80de34:	75 17                	jne    80de4d <netconn_disconnect+0x25>
  80de36:	83 ec 04             	sub    $0x4,%esp
  80de39:	68 3c 40 81 00       	push   $0x81403c
  80de3e:	68 e2 00 00 00       	push   $0xe2
  80de43:	68 a6 40 81 00       	push   $0x8140a6
  80de48:	e8 7f 2c ff ff       	call   800acc <_panic>

  msg.function = do_disconnect;
  80de4d:	c7 45 d8 42 ee 80 00 	movl   $0x80ee42,0xffffffd8(%ebp)
  msg.msg.conn = conn;
  80de54:	89 5d dc             	mov    %ebx,0xffffffdc(%ebp)
  TCPIP_APIMSG(&msg);
  80de57:	83 ec 0c             	sub    $0xc,%esp
  80de5a:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  80de5d:	50                   	push   %eax
  80de5e:	e8 73 70 ff ff       	call   804ed6 <tcpip_apimsg>
  return conn->err;
  80de63:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
}
  80de67:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80de6a:	c9                   	leave  
  80de6b:	c3                   	ret    

0080de6c <netconn_listen_with_backlog>:

/**
 * Set a TCP netconn into listen mode
 *
 * @param conn the tcp netconn to set to listen mode
 * @param backlog the listen backlog, only used if TCP_LISTEN_BACKLOG==1
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80de6c:	55                   	push   %ebp
  80de6d:	89 e5                	mov    %esp,%ebp
  80de6f:	53                   	push   %ebx
  80de70:	83 ec 24             	sub    $0x24,%esp
  80de73:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80de76:	85 db                	test   %ebx,%ebx
  80de78:	75 17                	jne    80de91 <netconn_listen_with_backlog+0x25>
  80de7a:	83 ec 04             	sub    $0x4,%esp
  80de7d:	68 99 41 81 00       	push   $0x814199
  80de82:	68 fa 00 00 00       	push   $0xfa
  80de87:	68 a6 40 81 00       	push   $0x8140a6
  80de8c:	e8 3b 2c ff ff       	call   800acc <_panic>

  msg.function = do_listen;
  80de91:	c7 45 d8 7a ee 80 00 	movl   $0x80ee7a,0xffffffd8(%ebp)
  msg.msg.conn = conn;
  80de98:	89 5d dc             	mov    %ebx,0xffffffdc(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80de9b:	83 ec 0c             	sub    $0xc,%esp
  80de9e:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  80dea1:	50                   	push   %eax
  80dea2:	e8 2f 70 ff ff       	call   804ed6 <tcpip_apimsg>
  return conn->err;
  80dea7:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
}
  80deab:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80deae:	c9                   	leave  
  80deaf:	c3                   	ret    

0080deb0 <netconn_accept>:

/**
 * Accept a new connection on a TCP listening netconn.
 *
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80deb0:	55                   	push   %ebp
  80deb1:	89 e5                	mov    %esp,%ebp
  80deb3:	53                   	push   %ebx
  80deb4:	83 ec 04             	sub    $0x4,%esp
  80deb7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80deba:	85 db                	test   %ebx,%ebx
  80debc:	75 17                	jne    80ded5 <netconn_accept+0x25>
  80debe:	83 ec 04             	sub    $0x4,%esp
  80dec1:	68 b6 41 81 00       	push   $0x8141b6
  80dec6:	68 10 01 00 00       	push   $0x110
  80decb:	68 a6 40 81 00       	push   $0x8140a6
  80ded0:	e8 f7 2b ff ff       	call   800acc <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80ded5:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80ded9:	75 17                	jne    80def2 <netconn_accept+0x42>
  80dedb:	83 ec 04             	sub    $0x4,%esp
  80dede:	68 60 40 81 00       	push   $0x814060
  80dee3:	68 11 01 00 00       	push   $0x111
  80dee8:	68 a6 40 81 00       	push   $0x8140a6
  80deed:	e8 da 2b ff ff       	call   800acc <_panic>

#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80def2:	83 ec 04             	sub    $0x4,%esp
  80def5:	6a 00                	push   $0x0
  80def7:	8d 45 f8             	lea    0xfffffff8(%ebp),%eax
  80defa:	50                   	push   %eax
  80defb:	ff 73 18             	pushl  0x18(%ebx)
  80defe:	e8 0b f2 ff ff       	call   80d10e <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80df03:	83 c4 10             	add    $0x10,%esp
  80df06:	83 7b 2c 00          	cmpl   $0x0,0x2c(%ebx)
  80df0a:	74 0e                	je     80df1a <netconn_accept+0x6a>
  80df0c:	83 ec 04             	sub    $0x4,%esp
  80df0f:	6a 00                	push   $0x0
  80df11:	6a 01                	push   $0x1
  80df13:	53                   	push   %ebx
  80df14:	ff 53 2c             	call   *0x2c(%ebx)
  80df17:	83 c4 10             	add    $0x10,%esp

#if TCP_LISTEN_BACKLOG
    if (newconn != NULL) {
      /* Let the stack know that we have accepted the connection. */
      struct api_msg msg;
      msg.function = do_recv;
      msg.msg.conn = conn;
      TCPIP_APIMSG(&msg);
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
  80df1a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
}
  80df1d:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80df20:	c9                   	leave  
  80df21:	c3                   	ret    

0080df22 <netconn_recv>:

/**
 * Receive data (in form of a netbuf containing a packet buffer) from a netconn
 *
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80df22:	55                   	push   %ebp
  80df23:	89 e5                	mov    %esp,%ebp
  80df25:	53                   	push   %ebx
  80df26:	83 ec 34             	sub    $0x34,%esp
  80df29:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80df2c:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80df33:	85 db                	test   %ebx,%ebx
  80df35:	75 17                	jne    80df4e <netconn_recv+0x2c>
  80df37:	83 ec 04             	sub    $0x4,%esp
  80df3a:	68 d3 41 81 00       	push   $0x8141d3
  80df3f:	68 3a 01 00 00       	push   $0x13a
  80df44:	68 a6 40 81 00       	push   $0x8140a6
  80df49:	e8 7e 2b ff ff       	call   800acc <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80df4e:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80df52:	75 0e                	jne    80df62 <netconn_recv+0x40>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80df54:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80df58:	b8 00 00 00 00       	mov    $0x0,%eax
  80df5d:	e9 54 01 00 00       	jmp    80e0b6 <netconn_recv+0x194>
  }

  if (ERR_IS_FATAL(conn->err)) {
    return NULL;
  80df62:	b8 00 00 00 00       	mov    $0x0,%eax
  80df67:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80df6b:	0f 8c 45 01 00 00    	jl     80e0b6 <netconn_recv+0x194>
  }

  if (conn->type == NETCONN_TCP) {
  80df71:	83 3b 10             	cmpl   $0x10,(%ebx)
  80df74:	0f 85 f5 00 00 00    	jne    80e06f <netconn_recv+0x14d>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80df7a:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80df7e:	75 0e                	jne    80df8e <netconn_recv+0x6c>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80df80:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80df84:	b8 00 00 00 00       	mov    $0x0,%eax
  80df89:	e9 28 01 00 00       	jmp    80e0b6 <netconn_recv+0x194>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80df8e:	83 ec 0c             	sub    $0xc,%esp
  80df91:	6a 06                	push   $0x6
  80df93:	e8 ff 91 ff ff       	call   807197 <memp_malloc>
  80df98:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)

    if (buf == NULL) {
  80df9b:	83 c4 10             	add    $0x10,%esp
  80df9e:	85 c0                	test   %eax,%eax
  80dfa0:	75 09                	jne    80dfab <netconn_recv+0x89>
      conn->err = ERR_MEM;
  80dfa2:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80dfa6:	e9 0b 01 00 00       	jmp    80e0b6 <netconn_recv+0x194>
    }

#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80dfab:	83 ec 04             	sub    $0x4,%esp
  80dfae:	6a 00                	push   $0x0
  80dfb0:	8d 45 d4             	lea    0xffffffd4(%ebp),%eax
  80dfb3:	50                   	push   %eax
  80dfb4:	ff 73 14             	pushl  0x14(%ebx)
  80dfb7:	e8 52 f1 ff ff       	call   80d10e <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80dfbc:	83 c4 10             	add    $0x10,%esp
      len = p->tot_len;
      SYS_ARCH_DEC(conn->recv_avail, len);
    } else {
      len = 0;
  80dfbf:	b8 00 00 00 00       	mov    $0x0,%eax
  80dfc4:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
  80dfc8:	74 0b                	je     80dfd5 <netconn_recv+0xb3>
  80dfca:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  80dfcd:	66 8b 40 08          	mov    0x8(%eax),%ax
  80dfd1:	66 29 43 20          	sub    %ax,0x20(%ebx)
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80dfd5:	83 7b 2c 00          	cmpl   $0x0,0x2c(%ebx)
  80dfd9:	74 10                	je     80dfeb <netconn_recv+0xc9>
  80dfdb:	83 ec 04             	sub    $0x4,%esp
  80dfde:	0f b7 c0             	movzwl %ax,%eax
  80dfe1:	50                   	push   %eax
  80dfe2:	6a 01                	push   $0x1
  80dfe4:	53                   	push   %ebx
  80dfe5:	ff 53 2c             	call   *0x2c(%ebx)
  80dfe8:	83 c4 10             	add    $0x10,%esp

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80dfeb:	83 7d d4 00          	cmpl   $0x0,0xffffffd4(%ebp)
  80dfef:	75 24                	jne    80e015 <netconn_recv+0xf3>
      memp_free(MEMP_NETBUF, buf);
  80dff1:	83 ec 08             	sub    $0x8,%esp
  80dff4:	ff 75 d0             	pushl  0xffffffd0(%ebp)
  80dff7:	6a 06                	push   $0x6
  80dff9:	e8 f3 91 ff ff       	call   8071f1 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80dffe:	83 c4 10             	add    $0x10,%esp
  80e001:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80e005:	75 04                	jne    80e00b <netconn_recv+0xe9>
        conn->err = ERR_CLSD;
  80e007:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
      }
      return NULL;
  80e00b:	b8 00 00 00 00       	mov    $0x0,%eax
  80e010:	e9 a1 00 00 00       	jmp    80e0b6 <netconn_recv+0x194>
    }

    buf->p = p;
  80e015:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
  80e018:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  80e01b:	89 10                	mov    %edx,(%eax)
    buf->ptr = p;
  80e01d:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
  80e020:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  80e023:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80e026:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  80e029:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80e02f:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  80e032:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80e039:	c7 45 d8 28 f0 80 00 	movl   $0x80f028,0xffffffd8(%ebp)
    msg.msg.conn = conn;
  80e040:	89 5d dc             	mov    %ebx,0xffffffdc(%ebp)
    if (buf != NULL) {
  80e043:	83 7d d0 00          	cmpl   $0x0,0xffffffd0(%ebp)
  80e047:	74 0f                	je     80e058 <netconn_recv+0x136>
      msg.msg.msg.r.len = buf->p->tot_len;
  80e049:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  80e04c:	8b 00                	mov    (%eax),%eax
  80e04e:	66 8b 40 08          	mov    0x8(%eax),%ax
  80e052:	66 89 45 e0          	mov    %ax,0xffffffe0(%ebp)
  80e056:	eb 06                	jmp    80e05e <netconn_recv+0x13c>
    } else {
      msg.msg.msg.r.len = 1;
  80e058:	66 c7 45 e0 01 00    	movw   $0x1,0xffffffe0(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80e05e:	83 ec 0c             	sub    $0xc,%esp
  80e061:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  80e064:	50                   	push   %eax
  80e065:	e8 6c 6e ff ff       	call   804ed6 <tcpip_apimsg>
  80e06a:	83 c4 10             	add    $0x10,%esp
  80e06d:	eb 44                	jmp    80e0b3 <netconn_recv+0x191>
#endif /* LWIP_TCP */
  } else {
#if (LWIP_UDP || LWIP_RAW)
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80e06f:	83 ec 04             	sub    $0x4,%esp
  80e072:	6a 00                	push   $0x0
  80e074:	8d 45 d0             	lea    0xffffffd0(%ebp),%eax
  80e077:	50                   	push   %eax
  80e078:	ff 73 14             	pushl  0x14(%ebx)
  80e07b:	e8 8e f0 ff ff       	call   80d10e <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80e080:	83 c4 10             	add    $0x10,%esp
  80e083:	83 7d d0 00          	cmpl   $0x0,0xffffffd0(%ebp)
  80e087:	74 2a                	je     80e0b3 <netconn_recv+0x191>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80e089:	8b 4d d0             	mov    0xffffffd0(%ebp),%ecx
  80e08c:	8b 11                	mov    (%ecx),%edx
  80e08e:	66 8b 43 20          	mov    0x20(%ebx),%ax
  80e092:	66 2b 42 08          	sub    0x8(%edx),%ax
  80e096:	66 89 43 20          	mov    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80e09a:	83 7b 2c 00          	cmpl   $0x0,0x2c(%ebx)
  80e09e:	74 13                	je     80e0b3 <netconn_recv+0x191>
  80e0a0:	83 ec 04             	sub    $0x4,%esp
  80e0a3:	8b 01                	mov    (%ecx),%eax
  80e0a5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80e0a9:	50                   	push   %eax
  80e0aa:	6a 01                	push   $0x1
  80e0ac:	53                   	push   %ebx
  80e0ad:	ff 53 2c             	call   *0x2c(%ebx)
  80e0b0:	83 c4 10             	add    $0x10,%esp
    }
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80e0b3:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
}
  80e0b6:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80e0b9:	c9                   	leave  
  80e0ba:	c3                   	ret    

0080e0bb <netconn_sendto>:

/**
 * Send data (in form of a netbuf) to a specific remote IP address and port.
 * Only to be used for UDP and RAW netconns (not TCP).
 *
 * @param conn the netconn over which to send data
 * @param buf a netbuf containing the data to send
 * @param addr the remote IP address to which to send the data
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80e0bb:	55                   	push   %ebp
  80e0bc:	89 e5                	mov    %esp,%ebp
  80e0be:	83 ec 08             	sub    $0x8,%esp
  80e0c1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e0c4:	8b 4d 14             	mov    0x14(%ebp),%ecx
  if (buf != NULL) {
    buf->addr = addr;
    buf->port = port;
    return netconn_send(conn, buf);
  }
  return ERR_VAL;
  80e0c7:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80e0cc:	85 d2                	test   %edx,%edx
  80e0ce:	74 19                	je     80e0e9 <netconn_sendto+0x2e>
  80e0d0:	8b 45 10             	mov    0x10(%ebp),%eax
  80e0d3:	89 42 08             	mov    %eax,0x8(%edx)
  80e0d6:	66 89 4a 0c          	mov    %cx,0xc(%edx)
  80e0da:	83 ec 08             	sub    $0x8,%esp
  80e0dd:	52                   	push   %edx
  80e0de:	ff 75 08             	pushl  0x8(%ebp)
  80e0e1:	e8 05 00 00 00       	call   80e0eb <netconn_send>
  80e0e6:	0f be c0             	movsbl %al,%eax
}
  80e0e9:	c9                   	leave  
  80e0ea:	c3                   	ret    

0080e0eb <netconn_send>:

/**
 * Send data over a UDP or RAW netconn (that is already connected).
 *
 * @param conn the UDP or RAW netconn over which to send data
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80e0eb:	55                   	push   %ebp
  80e0ec:	89 e5                	mov    %esp,%ebp
  80e0ee:	53                   	push   %ebx
  80e0ef:	83 ec 24             	sub    $0x24,%esp
  80e0f2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e0f5:	85 db                	test   %ebx,%ebx
  80e0f7:	75 17                	jne    80e110 <netconn_send+0x25>
  80e0f9:	83 ec 04             	sub    $0x4,%esp
  80e0fc:	68 ee 41 81 00       	push   $0x8141ee
  80e101:	68 b9 01 00 00       	push   $0x1b9
  80e106:	68 a6 40 81 00       	push   $0x8140a6
  80e10b:	e8 bc 29 ff ff       	call   800acc <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80e110:	c7 45 d8 6d ef 80 00 	movl   $0x80ef6d,0xffffffd8(%ebp)
  msg.msg.conn = conn;
  80e117:	89 5d dc             	mov    %ebx,0xffffffdc(%ebp)
  msg.msg.msg.b = buf;
  80e11a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e11d:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  TCPIP_APIMSG(&msg);
  80e120:	83 ec 0c             	sub    $0xc,%esp
  80e123:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  80e126:	50                   	push   %eax
  80e127:	e8 aa 6d ff ff       	call   804ed6 <tcpip_apimsg>
  return conn->err;
  80e12c:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
}
  80e130:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80e133:	c9                   	leave  
  80e134:	c3                   	ret    

0080e135 <netconn_write>:

/**
 * Send data over a TCP netconn.
 *
 * @param conn the TCP netconn over which to send data
 * @param dataptr pointer to the application buffer that contains the data to send
 * @param size size of the application data to send
 * @param apiflags combination of following flags :
 * - NETCONN_COPY (0x01) data will be copied into memory belonging to the stack
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80e135:	55                   	push   %ebp
  80e136:	89 e5                	mov    %esp,%ebp
  80e138:	53                   	push   %ebx
  80e139:	83 ec 24             	sub    $0x24,%esp
  80e13c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e13f:	8a 55 14             	mov    0x14(%ebp),%dl
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e142:	85 db                	test   %ebx,%ebx
  80e144:	75 17                	jne    80e15d <netconn_write+0x28>
  80e146:	83 ec 04             	sub    $0x4,%esp
  80e149:	68 09 42 81 00       	push   $0x814209
  80e14e:	68 d3 01 00 00       	push   $0x1d3
  80e153:	68 a6 40 81 00       	push   $0x8140a6
  80e158:	e8 6f 29 ff ff       	call   800acc <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80e15d:	83 3b 10             	cmpl   $0x10,(%ebx)
  80e160:	74 17                	je     80e179 <netconn_write+0x44>
  80e162:	83 ec 04             	sub    $0x4,%esp
  80e165:	68 84 40 81 00       	push   $0x814084
  80e16a:	68 d4 01 00 00       	push   $0x1d4
  80e16f:	68 a6 40 81 00       	push   $0x8140a6
  80e174:	e8 53 29 ff ff       	call   800acc <_panic>

  msg.function = do_write;
  80e179:	c7 45 d8 ce f1 80 00 	movl   $0x80f1ce,0xffffffd8(%ebp)
  msg.msg.conn = conn;
  80e180:	89 5d dc             	mov    %ebx,0xffffffdc(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80e183:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e186:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80e189:	88 55 e8             	mov    %dl,0xffffffe8(%ebp)
  msg.msg.msg.w.len = size;
  80e18c:	8b 45 10             	mov    0x10(%ebp),%eax
  80e18f:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80e192:	83 ec 0c             	sub    $0xc,%esp
  80e195:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  80e198:	50                   	push   %eax
  80e199:	e8 38 6d ff ff       	call   804ed6 <tcpip_apimsg>
  return conn->err;
  80e19e:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
}
  80e1a2:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80e1a5:	c9                   	leave  
  80e1a6:	c3                   	ret    

0080e1a7 <netconn_close>:

/**
 * Close a TCP netconn (doesn't delete it).
 *
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80e1a7:	55                   	push   %ebp
  80e1a8:	89 e5                	mov    %esp,%ebp
  80e1aa:	53                   	push   %ebx
  80e1ab:	83 ec 24             	sub    $0x24,%esp
  80e1ae:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e1b1:	85 db                	test   %ebx,%ebx
  80e1b3:	75 17                	jne    80e1cc <netconn_close+0x25>
  80e1b5:	83 ec 04             	sub    $0x4,%esp
  80e1b8:	68 25 42 81 00       	push   $0x814225
  80e1bd:	68 ed 01 00 00       	push   $0x1ed
  80e1c2:	68 a6 40 81 00       	push   $0x8140a6
  80e1c7:	e8 00 29 ff ff       	call   800acc <_panic>

  msg.function = do_close;
  80e1cc:	c7 45 d8 05 f3 80 00 	movl   $0x80f305,0xffffffd8(%ebp)
  msg.msg.conn = conn;
  80e1d3:	89 5d dc             	mov    %ebx,0xffffffdc(%ebp)
  tcpip_apimsg(&msg);
  80e1d6:	83 ec 0c             	sub    $0xc,%esp
  80e1d9:	8d 45 d8             	lea    0xffffffd8(%ebp),%eax
  80e1dc:	50                   	push   %eax
  80e1dd:	e8 f4 6c ff ff       	call   804ed6 <tcpip_apimsg>
  return conn->err;
  80e1e2:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
}
  80e1e6:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80e1e9:	c9                   	leave  
  80e1ea:	c3                   	ret    
	...

0080e1ec <recv_raw>:
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80e1ec:	55                   	push   %ebp
  80e1ed:	89 e5                	mov    %esp,%ebp
  80e1ef:	57                   	push   %edi
  80e1f0:	56                   	push   %esi
  80e1f1:	53                   	push   %ebx
  80e1f2:	83 ec 0c             	sub    $0xc,%esp
  80e1f5:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct pbuf *q;
  struct netbuf *buf;
  struct netconn *conn;
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
  80e1f8:	8b 5d 08             	mov    0x8(%ebp),%ebx

#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80e1fb:	85 db                	test   %ebx,%ebx
  80e1fd:	0f 84 cd 00 00 00    	je     80e2d0 <recv_raw+0xe4>
  80e203:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80e207:	0f 84 c3 00 00 00    	je     80e2d0 <recv_raw+0xe4>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80e20d:	83 ec 04             	sub    $0x4,%esp
  80e210:	6a 00                	push   $0x0
  80e212:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e216:	50                   	push   %eax
  80e217:	6a 03                	push   $0x3
  80e219:	e8 6a 92 ff ff       	call   807488 <pbuf_alloc>
  80e21e:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80e220:	83 c4 10             	add    $0x10,%esp
  80e223:	85 c0                	test   %eax,%eax
  80e225:	0f 84 a5 00 00 00    	je     80e2d0 <recv_raw+0xe4>
      if (pbuf_copy(q, p) != ERR_OK) {
  80e22b:	83 ec 08             	sub    $0x8,%esp
  80e22e:	57                   	push   %edi
  80e22f:	50                   	push   %eax
  80e230:	e8 21 99 ff ff       	call   807b56 <pbuf_copy>
  80e235:	83 c4 10             	add    $0x10,%esp
  80e238:	84 c0                	test   %al,%al
  80e23a:	74 11                	je     80e24d <recv_raw+0x61>
        pbuf_free(q);
  80e23c:	83 ec 0c             	sub    $0xc,%esp
  80e23f:	56                   	push   %esi
  80e240:	e8 d4 96 ff ff       	call   807919 <pbuf_free>
        q = NULL;
  80e245:	be 00 00 00 00       	mov    $0x0,%esi
  80e24a:	83 c4 10             	add    $0x10,%esp
      }
    }

    if(q != NULL) {
  80e24d:	85 f6                	test   %esi,%esi
  80e24f:	74 7f                	je     80e2d0 <recv_raw+0xe4>
      buf = memp_malloc(MEMP_NETBUF);
  80e251:	83 ec 0c             	sub    $0xc,%esp
  80e254:	6a 06                	push   $0x6
  80e256:	e8 3c 8f ff ff       	call   807197 <memp_malloc>
  80e25b:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80e25d:	83 c4 10             	add    $0x10,%esp
  80e260:	85 c0                	test   %eax,%eax
  80e262:	75 10                	jne    80e274 <recv_raw+0x88>
        pbuf_free(q);
  80e264:	83 ec 0c             	sub    $0xc,%esp
  80e267:	56                   	push   %esi
  80e268:	e8 ac 96 ff ff       	call   807919 <pbuf_free>
        return 0;
  80e26d:	b8 00 00 00 00       	mov    $0x0,%eax
  80e272:	eb 61                	jmp    80e2d5 <recv_raw+0xe9>
      }

      buf->p = q;
  80e274:	89 30                	mov    %esi,(%eax)
      buf->ptr = q;
  80e276:	89 70 04             	mov    %esi,0x4(%eax)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80e279:	8b 46 04             	mov    0x4(%esi),%eax
  80e27c:	83 c0 0c             	add    $0xc,%eax
  80e27f:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80e282:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e285:	66 0f b6 40 10       	movzbw 0x10(%eax),%ax
  80e28a:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80e28e:	66 8b 43 20          	mov    0x20(%ebx),%ax
  80e292:	66 03 46 08          	add    0x8(%esi),%ax
  80e296:	66 89 43 20          	mov    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80e29a:	83 7b 2c 00          	cmpl   $0x0,0x2c(%ebx)
  80e29e:	74 11                	je     80e2b1 <recv_raw+0xc5>
  80e2a0:	83 ec 04             	sub    $0x4,%esp
  80e2a3:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80e2a7:	50                   	push   %eax
  80e2a8:	6a 00                	push   $0x0
  80e2aa:	53                   	push   %ebx
  80e2ab:	ff 53 2c             	call   *0x2c(%ebx)
  80e2ae:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80e2b1:	83 ec 08             	sub    $0x8,%esp
  80e2b4:	57                   	push   %edi
  80e2b5:	ff 73 14             	pushl  0x14(%ebx)
  80e2b8:	e8 d5 ea ff ff       	call   80cd92 <sys_mbox_trypost>
  80e2bd:	83 c4 10             	add    $0x10,%esp
  80e2c0:	84 c0                	test   %al,%al
  80e2c2:	74 0c                	je     80e2d0 <recv_raw+0xe4>
        netbuf_delete(buf);
  80e2c4:	83 ec 0c             	sub    $0xc,%esp
  80e2c7:	57                   	push   %edi
  80e2c8:	e8 16 6d ff ff       	call   804fe3 <netbuf_delete>
  80e2cd:	83 c4 10             	add    $0x10,%esp
      }
    }
  }

  return 0; /* do not eat the packet */
  80e2d0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80e2d5:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80e2d8:	5b                   	pop    %ebx
  80e2d9:	5e                   	pop    %esi
  80e2da:	5f                   	pop    %edi
  80e2db:	c9                   	leave  
  80e2dc:	c3                   	ret    

0080e2dd <recv_udp>:
#endif /* LWIP_RAW*/

#if LWIP_UDP
/**
 * Receive callback function for UDP netconns.
 * Posts the packet to conn->recvmbox or deletes it on memory error.
 *
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80e2dd:	55                   	push   %ebp
  80e2de:	89 e5                	mov    %esp,%ebp
  80e2e0:	57                   	push   %edi
  80e2e1:	56                   	push   %esi
  80e2e2:	53                   	push   %ebx
  80e2e3:	83 ec 0c             	sub    $0xc,%esp
  80e2e6:	8b 55 08             	mov    0x8(%ebp),%edx
  80e2e9:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e2ec:	8b 7d 10             	mov    0x10(%ebp),%edi
  80e2ef:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80e2f2:	66 89 4d f2          	mov    %cx,0xfffffff2(%ebp)
  struct netbuf *buf;
  struct netconn *conn;
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80e2f6:	85 c0                	test   %eax,%eax
  80e2f8:	75 17                	jne    80e311 <recv_udp+0x34>
  80e2fa:	83 ec 04             	sub    $0x4,%esp
  80e2fd:	68 44 42 81 00       	push   $0x814244
  80e302:	68 8e 00 00 00       	push   $0x8e
  80e307:	68 8f 43 81 00       	push   $0x81438f
  80e30c:	e8 bb 27 ff ff       	call   800acc <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80e311:	85 d2                	test   %edx,%edx
  80e313:	75 17                	jne    80e32c <recv_udp+0x4f>
  80e315:	83 ec 04             	sub    $0x4,%esp
  80e318:	68 68 42 81 00       	push   $0x814268
  80e31d:	68 8f 00 00 00       	push   $0x8f
  80e322:	68 8f 43 81 00       	push   $0x81438f
  80e327:	e8 a0 27 ff ff       	call   800acc <_panic>
  conn = arg;
  80e32c:	89 d3                	mov    %edx,%ebx
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80e32e:	39 42 08             	cmp    %eax,0x8(%edx)
  80e331:	74 17                	je     80e34a <recv_udp+0x6d>
  80e333:	83 ec 04             	sub    $0x4,%esp
  80e336:	68 a6 43 81 00       	push   $0x8143a6
  80e33b:	68 91 00 00 00       	push   $0x91
  80e340:	68 8f 43 81 00       	push   $0x81438f
  80e345:	e8 82 27 ff ff       	call   800acc <_panic>

#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80e34a:	85 d2                	test   %edx,%edx
  80e34c:	74 06                	je     80e354 <recv_udp+0x77>
  80e34e:	83 7a 14 ff          	cmpl   $0xffffffff,0x14(%edx)
  80e352:	75 0b                	jne    80e35f <recv_udp+0x82>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80e354:	83 ec 0c             	sub    $0xc,%esp
  80e357:	57                   	push   %edi
  80e358:	e8 bc 95 ff ff       	call   807919 <pbuf_free>
    return;
  80e35d:	eb 70                	jmp    80e3cf <recv_udp+0xf2>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80e35f:	83 ec 0c             	sub    $0xc,%esp
  80e362:	6a 06                	push   $0x6
  80e364:	e8 2e 8e ff ff       	call   807197 <memp_malloc>
  80e369:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80e36b:	83 c4 10             	add    $0x10,%esp
  80e36e:	85 c0                	test   %eax,%eax
  80e370:	75 0b                	jne    80e37d <recv_udp+0xa0>
    pbuf_free(p);
  80e372:	83 ec 0c             	sub    $0xc,%esp
  80e375:	57                   	push   %edi
  80e376:	e8 9e 95 ff ff       	call   807919 <pbuf_free>
    return;
  80e37b:	eb 52                	jmp    80e3cf <recv_udp+0xf2>
  } else {
    buf->p = p;
  80e37d:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80e37f:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80e382:	8b 45 14             	mov    0x14(%ebp),%eax
  80e385:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80e388:	66 8b 45 f2          	mov    0xfffffff2(%ebp),%ax
  80e38c:	66 89 46 0c          	mov    %ax,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80e390:	66 8b 43 20          	mov    0x20(%ebx),%ax
  80e394:	66 03 47 08          	add    0x8(%edi),%ax
  80e398:	66 89 43 20          	mov    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80e39c:	83 7b 2c 00          	cmpl   $0x0,0x2c(%ebx)
  80e3a0:	74 11                	je     80e3b3 <recv_udp+0xd6>
  80e3a2:	83 ec 04             	sub    $0x4,%esp
  80e3a5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e3a9:	50                   	push   %eax
  80e3aa:	6a 00                	push   $0x0
  80e3ac:	53                   	push   %ebx
  80e3ad:	ff 53 2c             	call   *0x2c(%ebx)
  80e3b0:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80e3b3:	83 ec 08             	sub    $0x8,%esp
  80e3b6:	56                   	push   %esi
  80e3b7:	ff 73 14             	pushl  0x14(%ebx)
  80e3ba:	e8 d3 e9 ff ff       	call   80cd92 <sys_mbox_trypost>
  80e3bf:	83 c4 10             	add    $0x10,%esp
  80e3c2:	84 c0                	test   %al,%al
  80e3c4:	74 09                	je     80e3cf <recv_udp+0xf2>
    netbuf_delete(buf);
  80e3c6:	83 ec 0c             	sub    $0xc,%esp
  80e3c9:	56                   	push   %esi
  80e3ca:	e8 14 6c ff ff       	call   804fe3 <netbuf_delete>
    return;
  }
}
  80e3cf:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80e3d2:	5b                   	pop    %ebx
  80e3d3:	5e                   	pop    %esi
  80e3d4:	5f                   	pop    %edi
  80e3d5:	c9                   	leave  
  80e3d6:	c3                   	ret    

0080e3d7 <recv_tcp>:
#endif /* LWIP_UDP */

#if LWIP_TCP
/**
 * Receive callback function for TCP netconns.
 * Posts the packet to conn->recvmbox, but doesn't delete it on errors.
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80e3d7:	55                   	push   %ebp
  80e3d8:	89 e5                	mov    %esp,%ebp
  80e3da:	56                   	push   %esi
  80e3db:	53                   	push   %ebx
  80e3dc:	8b 55 08             	mov    0x8(%ebp),%edx
  80e3df:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e3e2:	8b 75 10             	mov    0x10(%ebp),%esi
  80e3e5:	8a 4d 14             	mov    0x14(%ebp),%cl
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80e3e8:	85 c0                	test   %eax,%eax
  80e3ea:	75 17                	jne    80e403 <recv_tcp+0x2c>
  80e3ec:	83 ec 04             	sub    $0x4,%esp
  80e3ef:	68 88 42 81 00       	push   $0x814288
  80e3f4:	68 c1 00 00 00       	push   $0xc1
  80e3f9:	68 8f 43 81 00       	push   $0x81438f
  80e3fe:	e8 c9 26 ff ff       	call   800acc <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80e403:	85 d2                	test   %edx,%edx
  80e405:	75 17                	jne    80e41e <recv_tcp+0x47>
  80e407:	83 ec 04             	sub    $0x4,%esp
  80e40a:	68 ac 42 81 00       	push   $0x8142ac
  80e40f:	68 c2 00 00 00       	push   $0xc2
  80e414:	68 8f 43 81 00       	push   $0x81438f
  80e419:	e8 ae 26 ff ff       	call   800acc <_panic>
  conn = arg;
  80e41e:	89 d3                	mov    %edx,%ebx
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80e420:	39 42 08             	cmp    %eax,0x8(%edx)
  80e423:	74 17                	je     80e43c <recv_tcp+0x65>
  80e425:	83 ec 04             	sub    $0x4,%esp
  80e428:	68 c4 43 81 00       	push   $0x8143c4
  80e42d:	68 c4 00 00 00       	push   $0xc4
  80e432:	68 8f 43 81 00       	push   $0x81438f
  80e437:	e8 90 26 ff ff       	call   800acc <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80e43c:	85 d2                	test   %edx,%edx
  80e43e:	74 06                	je     80e446 <recv_tcp+0x6f>
  80e440:	83 7a 14 ff          	cmpl   $0xffffffff,0x14(%edx)
  80e444:	75 07                	jne    80e44d <recv_tcp+0x76>
    return ERR_VAL;
  80e446:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80e44b:	eb 3f                	jmp    80e48c <recv_tcp+0xb5>
  }

  conn->err = err;
  80e44d:	88 4a 0c             	mov    %cl,0xc(%edx)
  if (p != NULL) {
    len = p->tot_len;
    SYS_ARCH_INC(conn->recv_avail, len);
  } else {
    len = 0;
  80e450:	b8 00 00 00 00       	mov    $0x0,%eax
  80e455:	85 f6                	test   %esi,%esi
  80e457:	74 08                	je     80e461 <recv_tcp+0x8a>
  80e459:	66 8b 46 08          	mov    0x8(%esi),%ax
  80e45d:	66 01 42 20          	add    %ax,0x20(%edx)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80e461:	83 7b 2c 00          	cmpl   $0x0,0x2c(%ebx)
  80e465:	74 10                	je     80e477 <recv_tcp+0xa0>
  80e467:	83 ec 04             	sub    $0x4,%esp
  80e46a:	0f b7 c0             	movzwl %ax,%eax
  80e46d:	50                   	push   %eax
  80e46e:	6a 00                	push   $0x0
  80e470:	53                   	push   %ebx
  80e471:	ff 53 2c             	call   *0x2c(%ebx)
  80e474:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80e477:	83 ec 08             	sub    $0x8,%esp
  80e47a:	56                   	push   %esi
  80e47b:	ff 73 14             	pushl  0x14(%ebx)
  80e47e:	e8 0f e9 ff ff       	call   80cd92 <sys_mbox_trypost>
  80e483:	83 c4 10             	add    $0x10,%esp
    return ERR_MEM;
  80e486:	3c 01                	cmp    $0x1,%al
  80e488:	19 c0                	sbb    %eax,%eax
  80e48a:	f7 d0                	not    %eax
  }

  return ERR_OK;
}
  80e48c:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80e48f:	5b                   	pop    %ebx
  80e490:	5e                   	pop    %esi
  80e491:	c9                   	leave  
  80e492:	c3                   	ret    

0080e493 <poll_tcp>:

/**
 * Poll callback function for TCP netconns.
 * Wakes up an application thread that waits for a connection to close
 * or data to be sent. The application thread then takes the
 * appropriate action to go on.
 *
 * Signals the conn->sem.
 * netconn_close waits for conn->sem if closing failed.
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80e493:	55                   	push   %ebp
  80e494:	89 e5                	mov    %esp,%ebp
  80e496:	83 ec 08             	sub    $0x8,%esp
  struct netconn *conn = arg;
  80e499:	8b 45 08             	mov    0x8(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80e49c:	85 c0                	test   %eax,%eax
  80e49e:	75 17                	jne    80e4b7 <poll_tcp+0x24>
  80e4a0:	83 ec 04             	sub    $0x4,%esp
  80e4a3:	68 e2 43 81 00       	push   $0x8143e2
  80e4a8:	68 eb 00 00 00       	push   $0xeb
  80e4ad:	68 8f 43 81 00       	push   $0x81438f
  80e4b2:	e8 15 26 ff ff       	call   800acc <_panic>

  if (conn->state == NETCONN_WRITE) {
  80e4b7:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80e4bb:	75 0e                	jne    80e4cb <poll_tcp+0x38>
    do_writemore(conn);
  80e4bd:	83 ec 0c             	sub    $0xc,%esp
  80e4c0:	50                   	push   %eax
  80e4c1:	e8 a4 0b 00 00       	call   80f06a <do_writemore>
  80e4c6:	83 c4 10             	add    $0x10,%esp
  80e4c9:	eb 12                	jmp    80e4dd <poll_tcp+0x4a>
  } else if (conn->state == NETCONN_CLOSE) {
  80e4cb:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80e4cf:	75 0c                	jne    80e4dd <poll_tcp+0x4a>
    do_close_internal(conn);
  80e4d1:	83 ec 0c             	sub    $0xc,%esp
  80e4d4:	50                   	push   %eax
  80e4d5:	e8 50 05 00 00       	call   80ea2a <do_close_internal>
  80e4da:	83 c4 10             	add    $0x10,%esp
  }

  return ERR_OK;
}
  80e4dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80e4e2:	c9                   	leave  
  80e4e3:	c3                   	ret    

0080e4e4 <sent_tcp>:

/**
 * Sent callback function for TCP netconns.
 * Signals the conn->sem and calls API_EVENT.
 * netconn_write waits for conn->sem if send buffer is low.
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80e4e4:	55                   	push   %ebp
  80e4e5:	89 e5                	mov    %esp,%ebp
  80e4e7:	56                   	push   %esi
  80e4e8:	53                   	push   %ebx
  80e4e9:	8b 75 10             	mov    0x10(%ebp),%esi
  struct netconn *conn = arg;
  80e4ec:	8b 5d 08             	mov    0x8(%ebp),%ebx

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80e4ef:	85 db                	test   %ebx,%ebx
  80e4f1:	75 17                	jne    80e50a <sent_tcp+0x26>
  80e4f3:	83 ec 04             	sub    $0x4,%esp
  80e4f6:	68 e2 43 81 00       	push   $0x8143e2
  80e4fb:	68 03 01 00 00       	push   $0x103
  80e500:	68 8f 43 81 00       	push   $0x81438f
  80e505:	e8 c2 25 ff ff       	call   800acc <_panic>

  if (conn->state == NETCONN_WRITE) {
  80e50a:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
  80e50e:	75 2b                	jne    80e53b <sent_tcp+0x57>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80e510:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80e514:	75 17                	jne    80e52d <sent_tcp+0x49>
  80e516:	83 ec 04             	sub    $0x4,%esp
  80e519:	68 ef 43 81 00       	push   $0x8143ef
  80e51e:	68 06 01 00 00       	push   $0x106
  80e523:	68 8f 43 81 00       	push   $0x81438f
  80e528:	e8 9f 25 ff ff       	call   800acc <_panic>
    do_writemore(conn);
  80e52d:	83 ec 0c             	sub    $0xc,%esp
  80e530:	53                   	push   %ebx
  80e531:	e8 34 0b 00 00       	call   80f06a <do_writemore>
  80e536:	83 c4 10             	add    $0x10,%esp
  80e539:	eb 12                	jmp    80e54d <sent_tcp+0x69>
  } else if (conn->state == NETCONN_CLOSE) {
  80e53b:	83 7b 04 04          	cmpl   $0x4,0x4(%ebx)
  80e53f:	75 0c                	jne    80e54d <sent_tcp+0x69>
    do_close_internal(conn);
  80e541:	83 ec 0c             	sub    $0xc,%esp
  80e544:	53                   	push   %ebx
  80e545:	e8 e0 04 00 00       	call   80ea2a <do_close_internal>
  80e54a:	83 c4 10             	add    $0x10,%esp
  }

  if (conn) {
  80e54d:	85 db                	test   %ebx,%ebx
  80e54f:	74 27                	je     80e578 <sent_tcp+0x94>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80e551:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80e555:	74 21                	je     80e578 <sent_tcp+0x94>
  80e557:	8b 43 08             	mov    0x8(%ebx),%eax
  80e55a:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80e560:	76 16                	jbe    80e578 <sent_tcp+0x94>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80e562:	83 7b 2c 00          	cmpl   $0x0,0x2c(%ebx)
  80e566:	74 10                	je     80e578 <sent_tcp+0x94>
  80e568:	83 ec 04             	sub    $0x4,%esp
  80e56b:	0f b7 c6             	movzwl %si,%eax
  80e56e:	50                   	push   %eax
  80e56f:	6a 02                	push   $0x2
  80e571:	53                   	push   %ebx
  80e572:	ff 53 2c             	call   *0x2c(%ebx)
  80e575:	83 c4 10             	add    $0x10,%esp
    }
  }
  
  return ERR_OK;
}
  80e578:	b8 00 00 00 00       	mov    $0x0,%eax
  80e57d:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80e580:	5b                   	pop    %ebx
  80e581:	5e                   	pop    %esi
  80e582:	c9                   	leave  
  80e583:	c3                   	ret    

0080e584 <err_tcp>:

/**
 * Error callback function for TCP netconns.
 * Signals conn->sem, posts to all conn mboxes and calls API_EVENT.
 * The application thread has then to decide what to do.
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80e584:	55                   	push   %ebp
  80e585:	89 e5                	mov    %esp,%ebp
  80e587:	53                   	push   %ebx
  80e588:	83 ec 04             	sub    $0x4,%esp
  80e58b:	8a 45 0c             	mov    0xc(%ebp),%al
  struct netconn *conn;

  conn = arg;
  80e58e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80e591:	85 db                	test   %ebx,%ebx
  80e593:	75 17                	jne    80e5ac <err_tcp+0x28>
  80e595:	83 ec 04             	sub    $0x4,%esp
  80e598:	68 e2 43 81 00       	push   $0x8143e2
  80e59d:	68 22 01 00 00       	push   $0x122
  80e5a2:	68 8f 43 81 00       	push   $0x81438f
  80e5a7:	e8 20 25 ff ff       	call   800acc <_panic>

  conn->pcb.tcp = NULL;
  80e5ac:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80e5b3:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80e5b6:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80e5ba:	74 24                	je     80e5e0 <err_tcp+0x5c>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80e5bc:	83 7b 2c 00          	cmpl   $0x0,0x2c(%ebx)
  80e5c0:	74 0e                	je     80e5d0 <err_tcp+0x4c>
  80e5c2:	83 ec 04             	sub    $0x4,%esp
  80e5c5:	6a 00                	push   $0x0
  80e5c7:	6a 00                	push   $0x0
  80e5c9:	53                   	push   %ebx
  80e5ca:	ff 53 2c             	call   *0x2c(%ebx)
  80e5cd:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->recvmbox, NULL);
  80e5d0:	83 ec 08             	sub    $0x8,%esp
  80e5d3:	6a 00                	push   $0x0
  80e5d5:	ff 73 14             	pushl  0x14(%ebx)
  80e5d8:	e8 85 e7 ff ff       	call   80cd62 <sys_mbox_post>
  80e5dd:	83 c4 10             	add    $0x10,%esp
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80e5e0:	83 7b 10 ff          	cmpl   $0xffffffff,0x10(%ebx)
  80e5e4:	74 1b                	je     80e601 <err_tcp+0x7d>
  80e5e6:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80e5ea:	75 15                	jne    80e601 <err_tcp+0x7d>
    conn->state = NETCONN_NONE;
  80e5ec:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80e5f3:	83 ec 0c             	sub    $0xc,%esp
  80e5f6:	ff 73 10             	pushl  0x10(%ebx)
  80e5f9:	e8 7c e9 ff ff       	call   80cf7a <sys_sem_signal>
  80e5fe:	83 c4 10             	add    $0x10,%esp
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80e601:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80e605:	74 24                	je     80e62b <err_tcp+0xa7>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80e607:	83 7b 2c 00          	cmpl   $0x0,0x2c(%ebx)
  80e60b:	74 0e                	je     80e61b <err_tcp+0x97>
  80e60d:	83 ec 04             	sub    $0x4,%esp
  80e610:	6a 00                	push   $0x0
  80e612:	6a 00                	push   $0x0
  80e614:	53                   	push   %ebx
  80e615:	ff 53 2c             	call   *0x2c(%ebx)
  80e618:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->acceptmbox, NULL);
  80e61b:	83 ec 08             	sub    $0x8,%esp
  80e61e:	6a 00                	push   $0x0
  80e620:	ff 73 18             	pushl  0x18(%ebx)
  80e623:	e8 3a e7 ff ff       	call   80cd62 <sys_mbox_post>
  80e628:	83 c4 10             	add    $0x10,%esp
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80e62b:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
  80e62f:	74 06                	je     80e637 <err_tcp+0xb3>
  80e631:	83 7b 04 04          	cmpl   $0x4,0x4(%ebx)
  80e635:	75 15                	jne    80e64c <err_tcp+0xc8>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80e637:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80e63e:	83 ec 0c             	sub    $0xc,%esp
  80e641:	ff 73 10             	pushl  0x10(%ebx)
  80e644:	e8 31 e9 ff ff       	call   80cf7a <sys_sem_signal>
  80e649:	83 c4 10             	add    $0x10,%esp
  }
}
  80e64c:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80e64f:	c9                   	leave  
  80e650:	c3                   	ret    

0080e651 <setup_tcp>:

/**
 * Setup a tcp_pcb with the correct callback function pointers
 * and their arguments.
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80e651:	55                   	push   %ebp
  80e652:	89 e5                	mov    %esp,%ebp
  80e654:	53                   	push   %ebx
  80e655:	83 ec 0c             	sub    $0xc,%esp
  80e658:	8b 45 08             	mov    0x8(%ebp),%eax
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80e65b:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80e65e:	50                   	push   %eax
  80e65f:	53                   	push   %ebx
  80e660:	e8 12 a9 ff ff       	call   808f77 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80e665:	83 c4 08             	add    $0x8,%esp
  80e668:	68 d7 e3 80 00       	push   $0x80e3d7
  80e66d:	53                   	push   %ebx
  80e66e:	e8 12 a9 ff ff       	call   808f85 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80e673:	83 c4 08             	add    $0x8,%esp
  80e676:	68 e4 e4 80 00       	push   $0x80e4e4
  80e67b:	53                   	push   %ebx
  80e67c:	e8 15 a9 ff ff       	call   808f96 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80e681:	83 c4 0c             	add    $0xc,%esp
  80e684:	6a 04                	push   $0x4
  80e686:	68 93 e4 80 00       	push   $0x80e493
  80e68b:	53                   	push   %ebx
  80e68c:	e8 35 a9 ff ff       	call   808fc6 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80e691:	83 c4 08             	add    $0x8,%esp
  80e694:	68 84 e5 80 00       	push   $0x80e584
  80e699:	53                   	push   %ebx
  80e69a:	e8 08 a9 ff ff       	call   808fa7 <tcp_err>
}
  80e69f:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80e6a2:	c9                   	leave  
  80e6a3:	c3                   	ret    

0080e6a4 <accept_function>:

/**
 * Accept callback function for TCP netconns.
 * Allocates a new netconn and posts that to conn->acceptmbox.
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80e6a4:	55                   	push   %ebp
  80e6a5:	89 e5                	mov    %esp,%ebp
  80e6a7:	56                   	push   %esi
  80e6a8:	53                   	push   %ebx
  80e6a9:	83 ec 10             	sub    $0x10,%esp
  80e6ac:	8a 45 10             	mov    0x10(%ebp),%al
  80e6af:	88 45 f7             	mov    %al,0xfffffff7(%ebp)
  struct netconn *newconn;
  struct netconn *conn;

#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  80e6b2:	8b 5d 08             	mov    0x8(%ebp),%ebx

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80e6b5:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80e6b9:	75 17                	jne    80e6d2 <accept_function+0x2e>
  80e6bb:	83 ec 04             	sub    $0x4,%esp
  80e6be:	68 cc 42 81 00       	push   $0x8142cc
  80e6c3:	68 65 01 00 00       	push   $0x165
  80e6c8:	68 8f 43 81 00       	push   $0x81438f
  80e6cd:	e8 fa 23 ff ff       	call   800acc <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80e6d2:	83 ec 08             	sub    $0x8,%esp
  80e6d5:	ff 73 2c             	pushl  0x2c(%ebx)
  80e6d8:	ff 33                	pushl  (%ebx)
  80e6da:	e8 af 01 00 00       	call   80e88e <netconn_alloc>
  80e6df:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80e6e1:	83 c4 10             	add    $0x10,%esp
    return ERR_MEM;
  80e6e4:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80e6e9:	85 c0                	test   %eax,%eax
  80e6eb:	74 59                	je     80e746 <accept_function+0xa2>
  }
  newconn->pcb.tcp = newpcb;
  80e6ed:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e6f0:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80e6f3:	83 ec 0c             	sub    $0xc,%esp
  80e6f6:	56                   	push   %esi
  80e6f7:	e8 55 ff ff ff       	call   80e651 <setup_tcp>
  newconn->err = err;
  80e6fc:	8a 45 f7             	mov    0xfffffff7(%ebp),%al
  80e6ff:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80e702:	83 c4 10             	add    $0x10,%esp
  80e705:	83 7b 2c 00          	cmpl   $0x0,0x2c(%ebx)
  80e709:	74 0e                	je     80e719 <accept_function+0x75>
  80e70b:	83 ec 04             	sub    $0x4,%esp
  80e70e:	6a 00                	push   $0x0
  80e710:	6a 00                	push   $0x0
  80e712:	53                   	push   %ebx
  80e713:	ff 53 2c             	call   *0x2c(%ebx)
  80e716:	83 c4 10             	add    $0x10,%esp

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80e719:	83 ec 08             	sub    $0x8,%esp
  80e71c:	56                   	push   %esi
  80e71d:	ff 73 18             	pushl  0x18(%ebx)
  80e720:	e8 6d e6 ff ff       	call   80cd92 <sys_mbox_trypost>
  80e725:	83 c4 10             	add    $0x10,%esp
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
    netconn_free(newconn);
    return ERR_MEM;
  }
  return ERR_OK;
  80e728:	ba 00 00 00 00       	mov    $0x0,%edx
  80e72d:	84 c0                	test   %al,%al
  80e72f:	74 15                	je     80e746 <accept_function+0xa2>
  80e731:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
  80e738:	83 ec 0c             	sub    $0xc,%esp
  80e73b:	56                   	push   %esi
  80e73c:	e8 fe 01 00 00       	call   80e93f <netconn_free>
  80e741:	ba ff ff ff ff       	mov    $0xffffffff,%edx
}
  80e746:	89 d0                	mov    %edx,%eax
  80e748:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80e74b:	5b                   	pop    %ebx
  80e74c:	5e                   	pop    %esi
  80e74d:	c9                   	leave  
  80e74e:	c3                   	ret    

0080e74f <pcb_new>:
#endif /* LWIP_TCP */

/**
 * Create a new pcb of a specific type.
 * Called from do_newconn().
 *
 * @param msg the api_msg_msg describing the connection type
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
  80e74f:	55                   	push   %ebp
  80e750:	89 e5                	mov    %esp,%ebp
  80e752:	56                   	push   %esi
  80e753:	53                   	push   %ebx
  80e754:	8b 75 08             	mov    0x8(%ebp),%esi
   msg->conn->err = ERR_OK;
  80e757:	8b 06                	mov    (%esi),%eax
  80e759:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80e75d:	8b 06                	mov    (%esi),%eax
  80e75f:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80e763:	74 17                	je     80e77c <pcb_new+0x2d>
  80e765:	83 ec 04             	sub    $0x4,%esp
  80e768:	68 f8 42 81 00       	push   $0x8142f8
  80e76d:	68 8a 01 00 00       	push   $0x18a
  80e772:	68 8f 43 81 00       	push   $0x81438f
  80e777:	e8 50 23 ff ff       	call   800acc <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80e77c:	8b 06                	mov    (%esi),%eax
  80e77e:	8b 00                	mov    (%eax),%eax
  80e780:	25 f0 00 00 00       	and    $0xf0,%eax
  80e785:	83 f8 20             	cmp    $0x20,%eax
  80e788:	74 5b                	je     80e7e5 <pcb_new+0x96>
  80e78a:	83 f8 20             	cmp    $0x20,%eax
  80e78d:	77 0e                	ja     80e79d <pcb_new+0x4e>
  80e78f:	83 f8 10             	cmp    $0x10,%eax
  80e792:	0f 84 8c 00 00 00    	je     80e824 <pcb_new+0xd5>
  80e798:	e9 ae 00 00 00       	jmp    80e84b <pcb_new+0xfc>
  80e79d:	83 f8 40             	cmp    $0x40,%eax
  80e7a0:	0f 85 a5 00 00 00    	jne    80e84b <pcb_new+0xfc>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80e7a6:	8b 1e                	mov    (%esi),%ebx
  80e7a8:	83 ec 0c             	sub    $0xc,%esp
  80e7ab:	0f b6 46 04          	movzbl 0x4(%esi),%eax
  80e7af:	50                   	push   %eax
  80e7b0:	e8 9e 29 00 00       	call   811153 <raw_new>
  80e7b5:	89 43 08             	mov    %eax,0x8(%ebx)
     if(msg->conn->pcb.raw == NULL) {
  80e7b8:	8b 06                	mov    (%esi),%eax
  80e7ba:	83 c4 10             	add    $0x10,%esp
  80e7bd:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80e7c1:	75 09                	jne    80e7cc <pcb_new+0x7d>
       msg->conn->err = ERR_MEM;
  80e7c3:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
       break;
  80e7c7:	e9 85 00 00 00       	jmp    80e851 <pcb_new+0x102>
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80e7cc:	83 ec 04             	sub    $0x4,%esp
  80e7cf:	ff 36                	pushl  (%esi)
  80e7d1:	68 ec e1 80 00       	push   $0x80e1ec
  80e7d6:	8b 06                	mov    (%esi),%eax
  80e7d8:	ff 70 08             	pushl  0x8(%eax)
  80e7db:	e8 0c 28 00 00       	call   810fec <raw_recv>
     break;
  80e7e0:	83 c4 10             	add    $0x10,%esp
  80e7e3:	eb 6c                	jmp    80e851 <pcb_new+0x102>
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80e7e5:	8b 1e                	mov    (%esi),%ebx
  80e7e7:	e8 4a d5 ff ff       	call   80bd36 <udp_new>
  80e7ec:	89 43 08             	mov    %eax,0x8(%ebx)
     if(msg->conn->pcb.udp == NULL) {
  80e7ef:	8b 06                	mov    (%esi),%eax
  80e7f1:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80e7f5:	75 06                	jne    80e7fd <pcb_new+0xae>
       msg->conn->err = ERR_MEM;
  80e7f7:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
       break;
  80e7fb:	eb 54                	jmp    80e851 <pcb_new+0x102>
     }
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80e7fd:	8b 06                	mov    (%esi),%eax
  80e7ff:	83 38 22             	cmpl   $0x22,(%eax)
  80e802:	75 07                	jne    80e80b <pcb_new+0xbc>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80e804:	8b 40 08             	mov    0x8(%eax),%eax
  80e807:	c6 40 10 01          	movb   $0x1,0x10(%eax)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80e80b:	83 ec 04             	sub    $0x4,%esp
  80e80e:	ff 36                	pushl  (%esi)
  80e810:	68 dd e2 80 00       	push   $0x80e2dd
  80e815:	8b 06                	mov    (%esi),%eax
  80e817:	ff 70 08             	pushl  0x8(%eax)
  80e81a:	e8 b9 d4 ff ff       	call   80bcd8 <udp_recv>
     break;
  80e81f:	83 c4 10             	add    $0x10,%esp
  80e822:	eb 2d                	jmp    80e851 <pcb_new+0x102>
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80e824:	8b 1e                	mov    (%esi),%ebx
  80e826:	e8 3d a7 ff ff       	call   808f68 <tcp_new>
  80e82b:	89 43 08             	mov    %eax,0x8(%ebx)
     if(msg->conn->pcb.tcp == NULL) {
  80e82e:	8b 06                	mov    (%esi),%eax
  80e830:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80e834:	75 06                	jne    80e83c <pcb_new+0xed>
       msg->conn->err = ERR_MEM;
  80e836:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
       break;
  80e83a:	eb 15                	jmp    80e851 <pcb_new+0x102>
     }
     setup_tcp(msg->conn);
  80e83c:	83 ec 0c             	sub    $0xc,%esp
  80e83f:	ff 36                	pushl  (%esi)
  80e841:	e8 0b fe ff ff       	call   80e651 <setup_tcp>
     break;
  80e846:	83 c4 10             	add    $0x10,%esp
  80e849:	eb 06                	jmp    80e851 <pcb_new+0x102>
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80e84b:	8b 06                	mov    (%esi),%eax
  80e84d:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
     break;
   }

  return msg->conn->err;
  80e851:	8b 06                	mov    (%esi),%eax
  80e853:	0f be 40 0c          	movsbl 0xc(%eax),%eax
}
  80e857:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80e85a:	5b                   	pop    %ebx
  80e85b:	5e                   	pop    %esi
  80e85c:	c9                   	leave  
  80e85d:	c3                   	ret    

0080e85e <do_newconn>:

/**
 * Create a new pcb of a specific type inside a netconn.
 * Called from netconn_new_with_proto_and_callback.
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80e85e:	55                   	push   %ebp
  80e85f:	89 e5                	mov    %esp,%ebp
  80e861:	53                   	push   %ebx
  80e862:	83 ec 04             	sub    $0x4,%esp
  80e865:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80e868:	8b 03                	mov    (%ebx),%eax
  80e86a:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80e86e:	75 0c                	jne    80e87c <do_newconn+0x1e>
     pcb_new(msg);
  80e870:	83 ec 0c             	sub    $0xc,%esp
  80e873:	53                   	push   %ebx
  80e874:	e8 d6 fe ff ff       	call   80e74f <pcb_new>
  80e879:	83 c4 10             	add    $0x10,%esp
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80e87c:	83 ec 0c             	sub    $0xc,%esp
  80e87f:	8b 03                	mov    (%ebx),%eax
  80e881:	ff 70 10             	pushl  0x10(%eax)
  80e884:	e8 f1 e6 ff ff       	call   80cf7a <sys_sem_signal>
}
  80e889:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80e88c:	c9                   	leave  
  80e88d:	c3                   	ret    

0080e88e <netconn_alloc>:

/**
 * Create a new netconn (of a specific type) that has a callback function.
 * The corresponding pcb is NOT created!
 *
 * @param t the type of 'connection' to create (@see enum netconn_type)
 * @param proto the IP protocol for RAW IP pcbs
 * @param callback a function to call on status changes (RX available, TX'ed)
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80e88e:	55                   	push   %ebp
  80e88f:	89 e5                	mov    %esp,%ebp
  80e891:	53                   	push   %ebx
  80e892:	83 ec 10             	sub    $0x10,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80e895:	6a 07                	push   $0x7
  80e897:	e8 fb 88 ff ff       	call   807197 <memp_malloc>
  80e89c:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80e89e:	83 c4 10             	add    $0x10,%esp
    return NULL;
  80e8a1:	b8 00 00 00 00       	mov    $0x0,%eax
  80e8a6:	85 db                	test   %ebx,%ebx
  80e8a8:	0f 84 8c 00 00 00    	je     80e93a <netconn_alloc+0xac>
  }

  conn->err = ERR_OK;
  80e8ae:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  conn->type = t;
  80e8b2:	8b 45 08             	mov    0x8(%ebp),%eax
  80e8b5:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80e8b7:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
#else
  switch(NETCONNTYPE_GROUP(t)) {
#if LWIP_RAW
  case NETCONN_RAW:
    size = DEFAULT_RAW_RECVMBOX_SIZE;
    break;
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    size = DEFAULT_UDP_RECVMBOX_SIZE;
    break;
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    size = DEFAULT_TCP_RECVMBOX_SIZE;
    break;
#endif /* LWIP_TCP */
  default:
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80e8be:	83 ec 0c             	sub    $0xc,%esp
  80e8c1:	6a 00                	push   $0x0
  80e8c3:	e8 a1 e5 ff ff       	call   80ce69 <sys_sem_new>
  80e8c8:	89 43 10             	mov    %eax,0x10(%ebx)
  80e8cb:	83 c4 10             	add    $0x10,%esp
  80e8ce:	83 f8 ff             	cmp    $0xffffffff,%eax
  80e8d1:	75 12                	jne    80e8e5 <netconn_alloc+0x57>
    memp_free(MEMP_NETCONN, conn);
  80e8d3:	83 ec 08             	sub    $0x8,%esp
  80e8d6:	53                   	push   %ebx
  80e8d7:	6a 07                	push   $0x7
  80e8d9:	e8 13 89 ff ff       	call   8071f1 <memp_free>
    return NULL;
  80e8de:	b8 00 00 00 00       	mov    $0x0,%eax
  80e8e3:	eb 55                	jmp    80e93a <netconn_alloc+0xac>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80e8e5:	83 ec 0c             	sub    $0xc,%esp
  80e8e8:	6a 00                	push   $0x0
  80e8ea:	e8 c0 e2 ff ff       	call   80cbaf <sys_mbox_new>
  80e8ef:	89 43 14             	mov    %eax,0x14(%ebx)
  80e8f2:	83 c4 10             	add    $0x10,%esp
  80e8f5:	83 f8 ff             	cmp    $0xffffffff,%eax
  80e8f8:	75 1d                	jne    80e917 <netconn_alloc+0x89>
    sys_sem_free(conn->op_completed);
  80e8fa:	83 ec 0c             	sub    $0xc,%esp
  80e8fd:	ff 73 10             	pushl  0x10(%ebx)
  80e900:	e8 fa e5 ff ff       	call   80ceff <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80e905:	83 c4 08             	add    $0x8,%esp
  80e908:	53                   	push   %ebx
  80e909:	6a 07                	push   $0x7
  80e90b:	e8 e1 88 ff ff       	call   8071f1 <memp_free>
    return NULL;
  80e910:	b8 00 00 00 00       	mov    $0x0,%eax
  80e915:	eb 23                	jmp    80e93a <netconn_alloc+0xac>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80e917:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80e91e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80e925:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80e92c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e92f:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80e932:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
#if LWIP_SO_RCVTIMEO
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  80e938:	89 d8                	mov    %ebx,%eax
}
  80e93a:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80e93d:	c9                   	leave  
  80e93e:	c3                   	ret    

0080e93f <netconn_free>:

/**
 * Delete a netconn and all its resources.
 * The pcb is NOT freed (since we might not be in the right thread context do this).
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80e93f:	55                   	push   %ebp
  80e940:	89 e5                	mov    %esp,%ebp
  80e942:	56                   	push   %esi
  80e943:	53                   	push   %ebx
  80e944:	83 ec 10             	sub    $0x10,%esp
  80e947:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80e94a:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80e94e:	74 17                	je     80e967 <netconn_free+0x28>
  80e950:	83 ec 04             	sub    $0x4,%esp
  80e953:	68 18 43 81 00       	push   $0x814318
  80e958:	68 26 02 00 00       	push   $0x226
  80e95d:	68 8f 43 81 00       	push   $0x81438f
  80e962:	e8 65 21 ff ff       	call   800acc <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80e967:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80e96b:	74 57                	je     80e9c4 <netconn_free+0x85>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80e96d:	eb 29                	jmp    80e998 <netconn_free+0x59>
      if (conn->type == NETCONN_TCP) {
  80e96f:	83 3b 10             	cmpl   $0x10,(%ebx)
  80e972:	75 16                	jne    80e98a <netconn_free+0x4b>
        if(mem != NULL) {
  80e974:	83 7d f4 00          	cmpl   $0x0,0xfffffff4(%ebp)
  80e978:	74 1e                	je     80e998 <netconn_free+0x59>
          pbuf_free((struct pbuf *)mem);
  80e97a:	83 ec 0c             	sub    $0xc,%esp
  80e97d:	ff 75 f4             	pushl  0xfffffff4(%ebp)
  80e980:	e8 94 8f ff ff       	call   807919 <pbuf_free>
  80e985:	83 c4 10             	add    $0x10,%esp
  80e988:	eb 0e                	jmp    80e998 <netconn_free+0x59>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80e98a:	83 ec 0c             	sub    $0xc,%esp
  80e98d:	ff 75 f4             	pushl  0xfffffff4(%ebp)
  80e990:	e8 4e 66 ff ff       	call   804fe3 <netbuf_delete>
  80e995:	83 c4 10             	add    $0x10,%esp
  80e998:	83 ec 08             	sub    $0x8,%esp
  80e99b:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  80e99e:	50                   	push   %eax
  80e99f:	ff 73 14             	pushl  0x14(%ebx)
  80e9a2:	e8 7e e8 ff ff       	call   80d225 <sys_arch_mbox_tryfetch>
  80e9a7:	83 c4 10             	add    $0x10,%esp
  80e9aa:	83 f8 ff             	cmp    $0xffffffff,%eax
  80e9ad:	75 c0                	jne    80e96f <netconn_free+0x30>
      }
    }
    sys_mbox_free(conn->recvmbox);
  80e9af:	83 ec 0c             	sub    $0xc,%esp
  80e9b2:	ff 73 14             	pushl  0x14(%ebx)
  80e9b5:	e8 fc e2 ff ff       	call   80ccb6 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80e9ba:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  80e9c1:	83 c4 10             	add    $0x10,%esp
  80e9c4:	8d 75 f4             	lea    0xfffffff4(%ebp),%esi
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80e9c7:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80e9cb:	75 10                	jne    80e9dd <netconn_free+0x9e>
  80e9cd:	eb 37                	jmp    80ea06 <netconn_free+0xc7>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      netconn_delete((struct netconn *)mem);
  80e9cf:	83 ec 0c             	sub    $0xc,%esp
  80e9d2:	ff 75 f4             	pushl  0xfffffff4(%ebp)
  80e9d5:	e8 b6 f2 ff ff       	call   80dc90 <netconn_delete>
  80e9da:	83 c4 10             	add    $0x10,%esp
  80e9dd:	83 ec 08             	sub    $0x8,%esp
  80e9e0:	56                   	push   %esi
  80e9e1:	ff 73 18             	pushl  0x18(%ebx)
  80e9e4:	e8 3c e8 ff ff       	call   80d225 <sys_arch_mbox_tryfetch>
  80e9e9:	83 c4 10             	add    $0x10,%esp
  80e9ec:	83 f8 ff             	cmp    $0xffffffff,%eax
  80e9ef:	75 de                	jne    80e9cf <netconn_free+0x90>
    }
    sys_mbox_free(conn->acceptmbox);
  80e9f1:	83 ec 0c             	sub    $0xc,%esp
  80e9f4:	ff 73 18             	pushl  0x18(%ebx)
  80e9f7:	e8 ba e2 ff ff       	call   80ccb6 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80e9fc:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  80ea03:	83 c4 10             	add    $0x10,%esp
  }

  sys_sem_free(conn->op_completed);
  80ea06:	83 ec 0c             	sub    $0xc,%esp
  80ea09:	ff 73 10             	pushl  0x10(%ebx)
  80ea0c:	e8 ee e4 ff ff       	call   80ceff <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80ea11:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80ea18:	83 c4 08             	add    $0x8,%esp
  80ea1b:	53                   	push   %ebx
  80ea1c:	6a 07                	push   $0x7
  80ea1e:	e8 ce 87 ff ff       	call   8071f1 <memp_free>
}
  80ea23:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80ea26:	5b                   	pop    %ebx
  80ea27:	5e                   	pop    %esi
  80ea28:	c9                   	leave  
  80ea29:	c3                   	ret    

0080ea2a <do_close_internal>:

#if LWIP_TCP
/**
 * Internal helper function to close a TCP netconn: since this sometimes
 * doesn't work at the first attempt, this function is called from multiple
 * places.
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80ea2a:	55                   	push   %ebp
  80ea2b:	89 e5                	mov    %esp,%ebp
  80ea2d:	53                   	push   %ebx
  80ea2e:	83 ec 04             	sub    $0x4,%esp
  80ea31:	8b 5d 08             	mov    0x8(%ebp),%ebx
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80ea34:	85 db                	test   %ebx,%ebx
  80ea36:	75 17                	jne    80ea4f <do_close_internal+0x25>
  80ea38:	83 ec 04             	sub    $0x4,%esp
  80ea3b:	68 fc 41 81 00       	push   $0x8141fc
  80ea40:	68 53 02 00 00       	push   $0x253
  80ea45:	68 8f 43 81 00       	push   $0x81438f
  80ea4a:	e8 7d 20 ff ff       	call   800acc <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80ea4f:	83 3b 10             	cmpl   $0x10,(%ebx)
  80ea52:	74 17                	je     80ea6b <do_close_internal+0x41>
  80ea54:	83 ec 04             	sub    $0x4,%esp
  80ea57:	68 05 44 81 00       	push   $0x814405
  80ea5c:	68 54 02 00 00       	push   $0x254
  80ea61:	68 8f 43 81 00       	push   $0x81438f
  80ea66:	e8 61 20 ff ff       	call   800acc <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80ea6b:	83 7b 04 04          	cmpl   $0x4,0x4(%ebx)
  80ea6f:	74 17                	je     80ea88 <do_close_internal+0x5e>
  80ea71:	83 ec 04             	sub    $0x4,%esp
  80ea74:	68 48 43 81 00       	push   $0x814348
  80ea79:	68 55 02 00 00       	push   $0x255
  80ea7e:	68 8f 43 81 00       	push   $0x81438f
  80ea83:	e8 44 20 ff ff       	call   800acc <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80ea88:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80ea8c:	75 17                	jne    80eaa5 <do_close_internal+0x7b>
  80ea8e:	83 ec 04             	sub    $0x4,%esp
  80ea91:	68 23 44 81 00       	push   $0x814423
  80ea96:	68 56 02 00 00       	push   $0x256
  80ea9b:	68 8f 43 81 00       	push   $0x81438f
  80eaa0:	e8 27 20 ff ff       	call   800acc <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80eaa5:	83 ec 08             	sub    $0x8,%esp
  80eaa8:	6a 00                	push   $0x0
  80eaaa:	ff 73 08             	pushl  0x8(%ebx)
  80eaad:	e8 c5 a4 ff ff       	call   808f77 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80eab2:	8b 43 08             	mov    0x8(%ebx),%eax
  80eab5:	83 c4 10             	add    $0x10,%esp
  80eab8:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80eabc:	75 10                	jne    80eace <do_close_internal+0xa4>
    tcp_accept(conn->pcb.tcp, NULL);
  80eabe:	83 ec 08             	sub    $0x8,%esp
  80eac1:	6a 00                	push   $0x0
  80eac3:	50                   	push   %eax
  80eac4:	e8 ef a4 ff ff       	call   808fb8 <tcp_accept>
  80eac9:	83 c4 10             	add    $0x10,%esp
  80eacc:	eb 46                	jmp    80eb14 <do_close_internal+0xea>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80eace:	83 ec 08             	sub    $0x8,%esp
  80ead1:	6a 00                	push   $0x0
  80ead3:	ff 73 08             	pushl  0x8(%ebx)
  80ead6:	e8 aa a4 ff ff       	call   808f85 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80eadb:	83 c4 08             	add    $0x8,%esp
  80eade:	6a 00                	push   $0x0
  80eae0:	ff 73 08             	pushl  0x8(%ebx)
  80eae3:	e8 d0 a4 ff ff       	call   808fb8 <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80eae8:	83 c4 08             	add    $0x8,%esp
  80eaeb:	6a 00                	push   $0x0
  80eaed:	ff 73 08             	pushl  0x8(%ebx)
  80eaf0:	e8 a1 a4 ff ff       	call   808f96 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80eaf5:	83 c4 0c             	add    $0xc,%esp
  80eaf8:	6a 04                	push   $0x4
  80eafa:	6a 00                	push   $0x0
  80eafc:	ff 73 08             	pushl  0x8(%ebx)
  80eaff:	e8 c2 a4 ff ff       	call   808fc6 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80eb04:	83 c4 08             	add    $0x8,%esp
  80eb07:	6a 00                	push   $0x0
  80eb09:	ff 73 08             	pushl  0x8(%ebx)
  80eb0c:	e8 96 a4 ff ff       	call   808fa7 <tcp_err>
  80eb11:	83 c4 10             	add    $0x10,%esp
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80eb14:	83 ec 0c             	sub    $0xc,%esp
  80eb17:	ff 73 08             	pushl  0x8(%ebx)
  80eb1a:	e8 ca 95 ff ff       	call   8080e9 <tcp_close>
  if (err == ERR_OK) {
  80eb1f:	83 c4 10             	add    $0x10,%esp
  80eb22:	84 c0                	test   %al,%al
  80eb24:	75 4a                	jne    80eb70 <do_close_internal+0x146>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80eb26:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80eb2d:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80eb34:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80eb38:	83 7b 2c 00          	cmpl   $0x0,0x2c(%ebx)
  80eb3c:	74 22                	je     80eb60 <do_close_internal+0x136>
  80eb3e:	83 ec 04             	sub    $0x4,%esp
  80eb41:	6a 00                	push   $0x0
  80eb43:	6a 00                	push   $0x0
  80eb45:	53                   	push   %ebx
  80eb46:	ff 53 2c             	call   *0x2c(%ebx)
  80eb49:	83 c4 10             	add    $0x10,%esp
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80eb4c:	83 7b 2c 00          	cmpl   $0x0,0x2c(%ebx)
  80eb50:	74 0e                	je     80eb60 <do_close_internal+0x136>
  80eb52:	83 ec 04             	sub    $0x4,%esp
  80eb55:	6a 00                	push   $0x0
  80eb57:	6a 02                	push   $0x2
  80eb59:	53                   	push   %ebx
  80eb5a:	ff 53 2c             	call   *0x2c(%ebx)
  80eb5d:	83 c4 10             	add    $0x10,%esp
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80eb60:	83 ec 0c             	sub    $0xc,%esp
  80eb63:	ff 73 10             	pushl  0x10(%ebx)
  80eb66:	e8 0f e4 ff ff       	call   80cf7a <sys_sem_signal>
  80eb6b:	83 c4 10             	add    $0x10,%esp
  80eb6e:	eb 61                	jmp    80ebd1 <do_close_internal+0x1a7>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80eb70:	8b 43 08             	mov    0x8(%ebx),%eax
  80eb73:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80eb77:	75 17                	jne    80eb90 <do_close_internal+0x166>
  80eb79:	83 ec 04             	sub    $0x4,%esp
  80eb7c:	68 6c 43 81 00       	push   $0x81436c
  80eb81:	68 75 02 00 00       	push   $0x275
  80eb86:	68 8f 43 81 00       	push   $0x81438f
  80eb8b:	e8 3c 1f ff ff       	call   800acc <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80eb90:	83 ec 08             	sub    $0x8,%esp
  80eb93:	68 e4 e4 80 00       	push   $0x80e4e4
  80eb98:	ff 73 08             	pushl  0x8(%ebx)
  80eb9b:	e8 f6 a3 ff ff       	call   808f96 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80eba0:	83 c4 0c             	add    $0xc,%esp
  80eba3:	6a 04                	push   $0x4
  80eba5:	68 93 e4 80 00       	push   $0x80e493
  80ebaa:	ff 73 08             	pushl  0x8(%ebx)
  80ebad:	e8 14 a4 ff ff       	call   808fc6 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80ebb2:	83 c4 08             	add    $0x8,%esp
  80ebb5:	68 84 e5 80 00       	push   $0x80e584
  80ebba:	ff 73 08             	pushl  0x8(%ebx)
  80ebbd:	e8 e5 a3 ff ff       	call   808fa7 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80ebc2:	83 c4 08             	add    $0x8,%esp
  80ebc5:	53                   	push   %ebx
  80ebc6:	ff 73 08             	pushl  0x8(%ebx)
  80ebc9:	e8 a9 a3 ff ff       	call   808f77 <tcp_arg>
  80ebce:	83 c4 10             	add    $0x10,%esp
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80ebd1:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80ebd4:	c9                   	leave  
  80ebd5:	c3                   	ret    

0080ebd6 <do_delconn>:
#endif /* LWIP_TCP */

/**
 * Delete the pcb inside a netconn.
 * Called from netconn_delete.
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80ebd6:	55                   	push   %ebp
  80ebd7:	89 e5                	mov    %esp,%ebp
  80ebd9:	53                   	push   %ebx
  80ebda:	83 ec 04             	sub    $0x4,%esp
  80ebdd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80ebe0:	8b 03                	mov    (%ebx),%eax
  80ebe2:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80ebe6:	74 62                	je     80ec4a <do_delconn+0x74>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80ebe8:	8b 00                	mov    (%eax),%eax
  80ebea:	25 f0 00 00 00       	and    $0xf0,%eax
  80ebef:	83 f8 20             	cmp    $0x20,%eax
  80ebf2:	74 23                	je     80ec17 <do_delconn+0x41>
  80ebf4:	83 f8 20             	cmp    $0x20,%eax
  80ebf7:	77 07                	ja     80ec00 <do_delconn+0x2a>
  80ebf9:	83 f8 10             	cmp    $0x10,%eax
  80ebfc:	74 37                	je     80ec35 <do_delconn+0x5f>
  80ebfe:	eb 4a                	jmp    80ec4a <do_delconn+0x74>
  80ec00:	83 f8 40             	cmp    $0x40,%eax
  80ec03:	75 45                	jne    80ec4a <do_delconn+0x74>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80ec05:	83 ec 0c             	sub    $0xc,%esp
  80ec08:	8b 03                	mov    (%ebx),%eax
  80ec0a:	ff 70 08             	pushl  0x8(%eax)
  80ec0d:	e8 f7 24 00 00       	call   811109 <raw_remove>
      break;
  80ec12:	83 c4 10             	add    $0x10,%esp
  80ec15:	eb 33                	jmp    80ec4a <do_delconn+0x74>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80ec17:	8b 03                	mov    (%ebx),%eax
  80ec19:	8b 40 08             	mov    0x8(%eax),%eax
  80ec1c:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
      udp_remove(msg->conn->pcb.udp);
  80ec23:	83 ec 0c             	sub    $0xc,%esp
  80ec26:	8b 03                	mov    (%ebx),%eax
  80ec28:	ff 70 08             	pushl  0x8(%eax)
  80ec2b:	e8 bc d0 ff ff       	call   80bcec <udp_remove>
      break;
  80ec30:	83 c4 10             	add    $0x10,%esp
  80ec33:	eb 15                	jmp    80ec4a <do_delconn+0x74>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80ec35:	8b 03                	mov    (%ebx),%eax
  80ec37:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80ec3e:	83 ec 0c             	sub    $0xc,%esp
  80ec41:	ff 33                	pushl  (%ebx)
  80ec43:	e8 e2 fd ff ff       	call   80ea2a <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80ec48:	eb 42                	jmp    80ec8c <do_delconn+0xb6>
#endif /* LWIP_TCP */
    default:
      break;
    }
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80ec4a:	8b 03                	mov    (%ebx),%eax
  80ec4c:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
  80ec50:	74 0e                	je     80ec60 <do_delconn+0x8a>
  80ec52:	83 ec 04             	sub    $0x4,%esp
  80ec55:	6a 00                	push   $0x0
  80ec57:	6a 00                	push   $0x0
  80ec59:	50                   	push   %eax
  80ec5a:	ff 50 2c             	call   *0x2c(%eax)
  80ec5d:	83 c4 10             	add    $0x10,%esp
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80ec60:	8b 03                	mov    (%ebx),%eax
  80ec62:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
  80ec66:	74 0e                	je     80ec76 <do_delconn+0xa0>
  80ec68:	83 ec 04             	sub    $0x4,%esp
  80ec6b:	6a 00                	push   $0x0
  80ec6d:	6a 02                	push   $0x2
  80ec6f:	50                   	push   %eax
  80ec70:	ff 50 2c             	call   *0x2c(%eax)
  80ec73:	83 c4 10             	add    $0x10,%esp

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80ec76:	8b 03                	mov    (%ebx),%eax
  80ec78:	83 78 10 ff          	cmpl   $0xffffffff,0x10(%eax)
  80ec7c:	74 0e                	je     80ec8c <do_delconn+0xb6>
    sys_sem_signal(msg->conn->op_completed);
  80ec7e:	83 ec 0c             	sub    $0xc,%esp
  80ec81:	ff 70 10             	pushl  0x10(%eax)
  80ec84:	e8 f1 e2 ff ff       	call   80cf7a <sys_sem_signal>
  80ec89:	83 c4 10             	add    $0x10,%esp
  }
}
  80ec8c:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80ec8f:	c9                   	leave  
  80ec90:	c3                   	ret    

0080ec91 <do_bind>:

/**
 * Bind a pcb contained in a netconn
 * Called from netconn_bind.
 *
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80ec91:	55                   	push   %ebp
  80ec92:	89 e5                	mov    %esp,%ebp
  80ec94:	56                   	push   %esi
  80ec95:	53                   	push   %ebx
  80ec96:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80ec99:	8b 06                	mov    (%esi),%eax
  80ec9b:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80ec9f:	7c 7b                	jl     80ed1c <do_bind+0x8b>
    if (msg->conn->pcb.tcp != NULL) {
  80eca1:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80eca5:	74 6f                	je     80ed16 <do_bind+0x85>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80eca7:	8b 00                	mov    (%eax),%eax
  80eca9:	25 f0 00 00 00       	and    $0xf0,%eax
  80ecae:	83 f8 20             	cmp    $0x20,%eax
  80ecb1:	74 29                	je     80ecdc <do_bind+0x4b>
  80ecb3:	83 f8 20             	cmp    $0x20,%eax
  80ecb6:	77 07                	ja     80ecbf <do_bind+0x2e>
  80ecb8:	83 f8 10             	cmp    $0x10,%eax
  80ecbb:	74 3c                	je     80ecf9 <do_bind+0x68>
  80ecbd:	eb 5d                	jmp    80ed1c <do_bind+0x8b>
  80ecbf:	83 f8 40             	cmp    $0x40,%eax
  80ecc2:	75 58                	jne    80ed1c <do_bind+0x8b>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80ecc4:	8b 1e                	mov    (%esi),%ebx
  80ecc6:	83 ec 08             	sub    $0x8,%esp
  80ecc9:	ff 76 04             	pushl  0x4(%esi)
  80eccc:	ff 73 08             	pushl  0x8(%ebx)
  80eccf:	e8 dd 22 00 00       	call   810fb1 <raw_bind>
  80ecd4:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80ecd7:	83 c4 10             	add    $0x10,%esp
  80ecda:	eb 40                	jmp    80ed1c <do_bind+0x8b>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80ecdc:	8b 1e                	mov    (%esi),%ebx
  80ecde:	83 ec 04             	sub    $0x4,%esp
  80ece1:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80ece5:	50                   	push   %eax
  80ece6:	ff 76 04             	pushl  0x4(%esi)
  80ece9:	ff 73 08             	pushl  0x8(%ebx)
  80ecec:	e8 95 ce ff ff       	call   80bb86 <udp_bind>
  80ecf1:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80ecf4:	83 c4 10             	add    $0x10,%esp
  80ecf7:	eb 23                	jmp    80ed1c <do_bind+0x8b>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80ecf9:	8b 1e                	mov    (%esi),%ebx
  80ecfb:	83 ec 04             	sub    $0x4,%esp
  80ecfe:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80ed02:	50                   	push   %eax
  80ed03:	ff 76 04             	pushl  0x4(%esi)
  80ed06:	ff 73 08             	pushl  0x8(%ebx)
  80ed09:	e8 46 96 ff ff       	call   808354 <tcp_bind>
  80ed0e:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80ed11:	83 c4 10             	add    $0x10,%esp
  80ed14:	eb 06                	jmp    80ed1c <do_bind+0x8b>
#endif /* LWIP_TCP */
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80ed16:	8b 06                	mov    (%esi),%eax
  80ed18:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80ed1c:	83 ec 0c             	sub    $0xc,%esp
  80ed1f:	8b 06                	mov    (%esi),%eax
  80ed21:	ff 70 10             	pushl  0x10(%eax)
  80ed24:	e8 51 e2 ff ff       	call   80cf7a <sys_sem_signal>
}
  80ed29:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80ed2c:	5b                   	pop    %ebx
  80ed2d:	5e                   	pop    %esi
  80ed2e:	c9                   	leave  
  80ed2f:	c3                   	ret    

0080ed30 <do_connected>:

#if LWIP_TCP
/**
 * TCP callback function if a connection (opened by tcp_connect/do_connect) has
 * been established (or reset by the remote host).
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80ed30:	55                   	push   %ebp
  80ed31:	89 e5                	mov    %esp,%ebp
  80ed33:	53                   	push   %ebx
  80ed34:	83 ec 04             	sub    $0x4,%esp
  80ed37:	8a 55 10             	mov    0x10(%ebp),%dl
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
  80ed3a:	8b 5d 08             	mov    0x8(%ebp),%ebx

  if (conn == NULL) {
    return ERR_VAL;
  80ed3d:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80ed42:	85 db                	test   %ebx,%ebx
  80ed44:	74 2f                	je     80ed75 <do_connected+0x45>
  }

  conn->err = err;
  80ed46:	88 53 0c             	mov    %dl,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80ed49:	83 3b 10             	cmpl   $0x10,(%ebx)
  80ed4c:	75 10                	jne    80ed5e <do_connected+0x2e>
  80ed4e:	84 d2                	test   %dl,%dl
  80ed50:	75 0c                	jne    80ed5e <do_connected+0x2e>
    setup_tcp(conn);
  80ed52:	83 ec 0c             	sub    $0xc,%esp
  80ed55:	53                   	push   %ebx
  80ed56:	e8 f6 f8 ff ff       	call   80e651 <setup_tcp>
  80ed5b:	83 c4 10             	add    $0x10,%esp
  }
  conn->state = NETCONN_NONE;
  80ed5e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80ed65:	83 ec 0c             	sub    $0xc,%esp
  80ed68:	ff 73 10             	pushl  0x10(%ebx)
  80ed6b:	e8 0a e2 ff ff       	call   80cf7a <sys_sem_signal>
  return ERR_OK;
  80ed70:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ed75:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80ed78:	c9                   	leave  
  80ed79:	c3                   	ret    

0080ed7a <do_connect>:
#endif /* LWIP_TCP */

/**
 * Connect a pcb contained inside a netconn
 * Called from netconn_connect.
 *
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80ed7a:	55                   	push   %ebp
  80ed7b:	89 e5                	mov    %esp,%ebp
  80ed7d:	56                   	push   %esi
  80ed7e:	53                   	push   %ebx
  80ed7f:	8b 75 08             	mov    0x8(%ebp),%esi
  if (msg->conn->pcb.tcp == NULL) {
  80ed82:	8b 06                	mov    (%esi),%eax
  80ed84:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80ed88:	75 10                	jne    80ed9a <do_connect+0x20>
    sys_sem_signal(msg->conn->op_completed);
  80ed8a:	83 ec 0c             	sub    $0xc,%esp
  80ed8d:	ff 70 10             	pushl  0x10(%eax)
  80ed90:	e8 e5 e1 ff ff       	call   80cf7a <sys_sem_signal>
    return;
  80ed95:	e9 a1 00 00 00       	jmp    80ee3b <do_connect+0xc1>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80ed9a:	8b 06                	mov    (%esi),%eax
  80ed9c:	8b 00                	mov    (%eax),%eax
  80ed9e:	25 f0 00 00 00       	and    $0xf0,%eax
  80eda3:	83 f8 20             	cmp    $0x20,%eax
  80eda6:	74 39                	je     80ede1 <do_connect+0x67>
  80eda8:	83 f8 20             	cmp    $0x20,%eax
  80edab:	77 0a                	ja     80edb7 <do_connect+0x3d>
  80edad:	83 f8 10             	cmp    $0x10,%eax
  80edb0:	74 59                	je     80ee0b <do_connect+0x91>
  80edb2:	e9 84 00 00 00       	jmp    80ee3b <do_connect+0xc1>
  80edb7:	83 f8 40             	cmp    $0x40,%eax
  80edba:	75 7f                	jne    80ee3b <do_connect+0xc1>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80edbc:	8b 1e                	mov    (%esi),%ebx
  80edbe:	83 ec 08             	sub    $0x8,%esp
  80edc1:	ff 76 04             	pushl  0x4(%esi)
  80edc4:	ff 73 08             	pushl  0x8(%ebx)
  80edc7:	e8 02 22 00 00       	call   810fce <raw_connect>
  80edcc:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80edcf:	83 c4 04             	add    $0x4,%esp
  80edd2:	8b 06                	mov    (%esi),%eax
  80edd4:	ff 70 10             	pushl  0x10(%eax)
  80edd7:	e8 9e e1 ff ff       	call   80cf7a <sys_sem_signal>
    break;
  80eddc:	83 c4 10             	add    $0x10,%esp
  80eddf:	eb 5a                	jmp    80ee3b <do_connect+0xc1>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80ede1:	8b 1e                	mov    (%esi),%ebx
  80ede3:	83 ec 04             	sub    $0x4,%esp
  80ede6:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80edea:	50                   	push   %eax
  80edeb:	ff 76 04             	pushl  0x4(%esi)
  80edee:	ff 73 08             	pushl  0x8(%ebx)
  80edf1:	e8 48 ce ff ff       	call   80bc3e <udp_connect>
  80edf6:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80edf9:	83 c4 04             	add    $0x4,%esp
  80edfc:	8b 06                	mov    (%esi),%eax
  80edfe:	ff 70 10             	pushl  0x10(%eax)
  80ee01:	e8 74 e1 ff ff       	call   80cf7a <sys_sem_signal>
    break;
  80ee06:	83 c4 10             	add    $0x10,%esp
  80ee09:	eb 30                	jmp    80ee3b <do_connect+0xc1>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80ee0b:	8b 06                	mov    (%esi),%eax
  80ee0d:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
    setup_tcp(msg->conn);
  80ee14:	83 ec 0c             	sub    $0xc,%esp
  80ee17:	ff 36                	pushl  (%esi)
  80ee19:	e8 33 f8 ff ff       	call   80e651 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80ee1e:	8b 1e                	mov    (%esi),%ebx
  80ee20:	68 30 ed 80 00       	push   $0x80ed30
  80ee25:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80ee29:	50                   	push   %eax
  80ee2a:	ff 76 04             	pushl  0x4(%esi)
  80ee2d:	ff 73 08             	pushl  0x8(%ebx)
  80ee30:	e8 5f 98 ff ff       	call   808694 <tcp_connect>
  80ee35:	88 43 0c             	mov    %al,0xc(%ebx)
                                 do_connected);
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
  80ee38:	83 c4 20             	add    $0x20,%esp
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80ee3b:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80ee3e:	5b                   	pop    %ebx
  80ee3f:	5e                   	pop    %esi
  80ee40:	c9                   	leave  
  80ee41:	c3                   	ret    

0080ee42 <do_disconnect>:

/**
 * Connect a pcb contained inside a netconn
 * Only used for UDP netconns.
 * Called from netconn_disconnect.
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80ee42:	55                   	push   %ebp
  80ee43:	89 e5                	mov    %esp,%ebp
  80ee45:	53                   	push   %ebx
  80ee46:	83 ec 04             	sub    $0x4,%esp
  80ee49:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80ee4c:	8b 13                	mov    (%ebx),%edx
  80ee4e:	8b 02                	mov    (%edx),%eax
  80ee50:	25 f0 00 00 00       	and    $0xf0,%eax
  80ee55:	83 f8 20             	cmp    $0x20,%eax
  80ee58:	75 0e                	jne    80ee68 <do_disconnect+0x26>
    udp_disconnect(msg->conn->pcb.udp);
  80ee5a:	83 ec 0c             	sub    $0xc,%esp
  80ee5d:	ff 72 08             	pushl  0x8(%edx)
  80ee60:	e8 58 ce ff ff       	call   80bcbd <udp_disconnect>
  80ee65:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80ee68:	83 ec 0c             	sub    $0xc,%esp
  80ee6b:	8b 03                	mov    (%ebx),%eax
  80ee6d:	ff 70 10             	pushl  0x10(%eax)
  80ee70:	e8 05 e1 ff ff       	call   80cf7a <sys_sem_signal>
}
  80ee75:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80ee78:	c9                   	leave  
  80ee79:	c3                   	ret    

0080ee7a <do_listen>:

/**
 * Set a TCP pcb contained in a netconn into listen mode
 * Called from netconn_listen.
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80ee7a:	55                   	push   %ebp
  80ee7b:	89 e5                	mov    %esp,%ebp
  80ee7d:	57                   	push   %edi
  80ee7e:	56                   	push   %esi
  80ee7f:	53                   	push   %ebx
  80ee80:	83 ec 0c             	sub    $0xc,%esp
  80ee83:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80ee86:	8b 13                	mov    (%ebx),%edx
  80ee88:	80 7a 0c fc          	cmpb   $0xfc,0xc(%edx)
  80ee8c:	0f 8c c6 00 00 00    	jl     80ef58 <do_listen+0xde>
    if (msg->conn->pcb.tcp != NULL) {
  80ee92:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  80ee96:	0f 84 bc 00 00 00    	je     80ef58 <do_listen+0xde>
      if (msg->conn->type == NETCONN_TCP) {
  80ee9c:	83 3a 10             	cmpl   $0x10,(%edx)
  80ee9f:	0f 85 b3 00 00 00    	jne    80ef58 <do_listen+0xde>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80eea5:	8b 42 08             	mov    0x8(%edx),%eax
  80eea8:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  80eeac:	0f 85 a0 00 00 00    	jne    80ef52 <do_listen+0xd8>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80eeb2:	83 ec 08             	sub    $0x8,%esp
  80eeb5:	68 ff 00 00 00       	push   $0xff
  80eeba:	ff 72 08             	pushl  0x8(%edx)
  80eebd:	e8 d6 95 ff ff       	call   808498 <tcp_listen_with_backlog>
  80eec2:	89 c7                	mov    %eax,%edi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80eec4:	83 c4 10             	add    $0x10,%esp
  80eec7:	85 c0                	test   %eax,%eax
  80eec9:	75 0b                	jne    80eed6 <do_listen+0x5c>
            msg->conn->err = ERR_MEM;
  80eecb:	8b 03                	mov    (%ebx),%eax
  80eecd:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80eed1:	e9 82 00 00 00       	jmp    80ef58 <do_listen+0xde>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80eed6:	8b 03                	mov    (%ebx),%eax
  80eed8:	83 78 14 ff          	cmpl   $0xffffffff,0x14(%eax)
  80eedc:	74 17                	je     80eef5 <do_listen+0x7b>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80eede:	83 ec 0c             	sub    $0xc,%esp
  80eee1:	ff 70 14             	pushl  0x14(%eax)
  80eee4:	e8 cd dd ff ff       	call   80ccb6 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80eee9:	8b 03                	mov    (%ebx),%eax
  80eeeb:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
  80eef2:	83 c4 10             	add    $0x10,%esp
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80eef5:	8b 33                	mov    (%ebx),%esi
  80eef7:	83 7e 18 ff          	cmpl   $0xffffffff,0x18(%esi)
  80eefb:	75 1b                	jne    80ef18 <do_listen+0x9e>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80eefd:	83 ec 0c             	sub    $0xc,%esp
  80ef00:	6a 00                	push   $0x0
  80ef02:	e8 a8 dc ff ff       	call   80cbaf <sys_mbox_new>
  80ef07:	89 46 18             	mov    %eax,0x18(%esi)
  80ef0a:	83 c4 10             	add    $0x10,%esp
  80ef0d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ef10:	75 06                	jne    80ef18 <do_listen+0x9e>
                msg->conn->err = ERR_MEM;
  80ef12:	8b 03                	mov    (%ebx),%eax
  80ef14:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80ef18:	8b 03                	mov    (%ebx),%eax
  80ef1a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80ef1e:	75 38                	jne    80ef58 <do_listen+0xde>
              msg->conn->state = NETCONN_LISTEN;
  80ef20:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80ef27:	8b 03                	mov    (%ebx),%eax
  80ef29:	89 78 08             	mov    %edi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80ef2c:	83 ec 08             	sub    $0x8,%esp
  80ef2f:	ff 33                	pushl  (%ebx)
  80ef31:	8b 03                	mov    (%ebx),%eax
  80ef33:	ff 70 08             	pushl  0x8(%eax)
  80ef36:	e8 3c a0 ff ff       	call   808f77 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80ef3b:	83 c4 08             	add    $0x8,%esp
  80ef3e:	68 a4 e6 80 00       	push   $0x80e6a4
  80ef43:	8b 03                	mov    (%ebx),%eax
  80ef45:	ff 70 08             	pushl  0x8(%eax)
  80ef48:	e8 6b a0 ff ff       	call   808fb8 <tcp_accept>
  80ef4d:	83 c4 10             	add    $0x10,%esp
  80ef50:	eb 06                	jmp    80ef58 <do_listen+0xde>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80ef52:	8b 03                	mov    (%ebx),%eax
  80ef54:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80ef58:	83 ec 0c             	sub    $0xc,%esp
  80ef5b:	8b 03                	mov    (%ebx),%eax
  80ef5d:	ff 70 10             	pushl  0x10(%eax)
  80ef60:	e8 15 e0 ff ff       	call   80cf7a <sys_sem_signal>
}
  80ef65:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80ef68:	5b                   	pop    %ebx
  80ef69:	5e                   	pop    %esi
  80ef6a:	5f                   	pop    %edi
  80ef6b:	c9                   	leave  
  80ef6c:	c3                   	ret    

0080ef6d <do_send>:

/**
 * Send some data on a RAW or UDP pcb contained in a netconn
 * Called from netconn_send
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80ef6d:	55                   	push   %ebp
  80ef6e:	89 e5                	mov    %esp,%ebp
  80ef70:	56                   	push   %esi
  80ef71:	53                   	push   %ebx
  80ef72:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80ef75:	8b 1e                	mov    (%esi),%ebx
  80ef77:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80ef7b:	0f 8c 93 00 00 00    	jl     80f014 <do_send+0xa7>
    if (msg->conn->pcb.tcp != NULL) {
  80ef81:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80ef85:	0f 84 89 00 00 00    	je     80f014 <do_send+0xa7>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80ef8b:	8b 03                	mov    (%ebx),%eax
  80ef8d:	25 f0 00 00 00       	and    $0xf0,%eax
  80ef92:	83 f8 20             	cmp    $0x20,%eax
  80ef95:	74 40                	je     80efd7 <do_send+0x6a>
  80ef97:	83 f8 40             	cmp    $0x40,%eax
  80ef9a:	75 78                	jne    80f014 <do_send+0xa7>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80ef9c:	8b 46 04             	mov    0x4(%esi),%eax
  80ef9f:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80efa3:	75 15                	jne    80efba <do_send+0x4d>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80efa5:	83 ec 08             	sub    $0x8,%esp
  80efa8:	ff 30                	pushl  (%eax)
  80efaa:	ff 73 08             	pushl  0x8(%ebx)
  80efad:	e8 3c 21 00 00       	call   8110ee <raw_send>
  80efb2:	88 43 0c             	mov    %al,0xc(%ebx)
  80efb5:	83 c4 10             	add    $0x10,%esp
  80efb8:	eb 5a                	jmp    80f014 <do_send+0xa7>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80efba:	8b 1e                	mov    (%esi),%ebx
  80efbc:	83 ec 04             	sub    $0x4,%esp
  80efbf:	8b 46 04             	mov    0x4(%esi),%eax
  80efc2:	ff 70 08             	pushl  0x8(%eax)
  80efc5:	ff 30                	pushl  (%eax)
  80efc7:	ff 73 08             	pushl  0x8(%ebx)
  80efca:	e8 31 20 00 00       	call   811000 <raw_sendto>
  80efcf:	88 43 0c             	mov    %al,0xc(%ebx)
  80efd2:	83 c4 10             	add    $0x10,%esp
        }
        break;
  80efd5:	eb 3d                	jmp    80f014 <do_send+0xa7>
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80efd7:	8b 46 04             	mov    0x4(%esi),%eax
  80efda:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80efde:	75 17                	jne    80eff7 <do_send+0x8a>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80efe0:	8b 1e                	mov    (%esi),%ebx
  80efe2:	83 ec 08             	sub    $0x8,%esp
  80efe5:	ff 30                	pushl  (%eax)
  80efe7:	ff 73 08             	pushl  0x8(%ebx)
  80efea:	e8 b4 c9 ff ff       	call   80b9a3 <udp_send>
  80efef:	88 43 0c             	mov    %al,0xc(%ebx)
  80eff2:	83 c4 10             	add    $0x10,%esp
  80eff5:	eb 1d                	jmp    80f014 <do_send+0xa7>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80eff7:	8b 1e                	mov    (%esi),%ebx
  80eff9:	8b 46 04             	mov    0x4(%esi),%eax
  80effc:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  80f000:	52                   	push   %edx
  80f001:	ff 70 08             	pushl  0x8(%eax)
  80f004:	ff 30                	pushl  (%eax)
  80f006:	ff 73 08             	pushl  0x8(%ebx)
  80f009:	e8 b5 c9 ff ff       	call   80b9c3 <udp_sendto>
  80f00e:	88 43 0c             	mov    %al,0xc(%ebx)
  80f011:	83 c4 10             	add    $0x10,%esp
        }
        break;
#endif /* LWIP_UDP */
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80f014:	83 ec 0c             	sub    $0xc,%esp
  80f017:	8b 06                	mov    (%esi),%eax
  80f019:	ff 70 10             	pushl  0x10(%eax)
  80f01c:	e8 59 df ff ff       	call   80cf7a <sys_sem_signal>
}
  80f021:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80f024:	5b                   	pop    %ebx
  80f025:	5e                   	pop    %esi
  80f026:	c9                   	leave  
  80f027:	c3                   	ret    

0080f028 <do_recv>:

/**
 * Recv some data from a RAW or UDP pcb contained in a netconn
 * Called from netconn_recv
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80f028:	55                   	push   %ebp
  80f029:	89 e5                	mov    %esp,%ebp
  80f02b:	53                   	push   %ebx
  80f02c:	83 ec 04             	sub    $0x4,%esp
  80f02f:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f032:	8b 13                	mov    (%ebx),%edx
  80f034:	80 7a 0c fc          	cmpb   $0xfc,0xc(%edx)
  80f038:	7c 1e                	jl     80f058 <do_recv+0x30>
    if (msg->conn->pcb.tcp != NULL) {
  80f03a:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  80f03e:	74 18                	je     80f058 <do_recv+0x30>
      if (msg->conn->type == NETCONN_TCP) {
  80f040:	83 3a 10             	cmpl   $0x10,(%edx)
  80f043:	75 13                	jne    80f058 <do_recv+0x30>
#if TCP_LISTEN_BACKLOG
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80f045:	83 ec 08             	sub    $0x8,%esp
  80f048:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80f04c:	50                   	push   %eax
  80f04d:	ff 72 08             	pushl  0x8(%edx)
  80f050:	e8 4b 95 ff ff       	call   8085a0 <tcp_recved>
  80f055:	83 c4 10             	add    $0x10,%esp
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80f058:	83 ec 0c             	sub    $0xc,%esp
  80f05b:	8b 03                	mov    (%ebx),%eax
  80f05d:	ff 70 10             	pushl  0x10(%eax)
  80f060:	e8 15 df ff ff       	call   80cf7a <sys_sem_signal>
}
  80f065:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80f068:	c9                   	leave  
  80f069:	c3                   	ret    

0080f06a <do_writemore>:

#if LWIP_TCP
/**
 * See if more data needs to be written from a previous call to netconn_write.
 * Called initially from do_write. If the first call can't send all data
 * (because of low memory or empty send-buffer), this function is called again
 * from sent_tcp() or poll_tcp() to send more data. If all data is sent, the
 * blocking application thread (waiting in netconn_write) is released.
 *
 * @param conn netconn (that is currently in state NETCONN_WRITE) to process
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80f06a:	55                   	push   %ebp
  80f06b:	89 e5                	mov    %esp,%ebp
  80f06d:	57                   	push   %edi
  80f06e:	56                   	push   %esi
  80f06f:	53                   	push   %ebx
  80f070:	83 ec 0c             	sub    $0xc,%esp
  80f073:	8b 75 08             	mov    0x8(%ebp),%esi
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  80f076:	c6 45 f3 00          	movb   $0x0,0xfffffff3(%ebp)

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80f07a:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
  80f07e:	74 17                	je     80f097 <do_writemore+0x2d>
  80f080:	83 ec 04             	sub    $0x4,%esp
  80f083:	68 36 44 81 00       	push   $0x814436
  80f088:	68 b8 03 00 00       	push   $0x3b8
  80f08d:	68 8f 43 81 00       	push   $0x81438f
  80f092:	e8 35 1a ff ff       	call   800acc <_panic>

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80f097:	8b 46 24             	mov    0x24(%esi),%eax
  80f09a:	8b 56 28             	mov    0x28(%esi),%edx
  80f09d:	8b 48 04             	mov    0x4(%eax),%ecx
  80f0a0:	01 d1                	add    %edx,%ecx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80f0a2:	8b 40 08             	mov    0x8(%eax),%eax
  80f0a5:	29 d0                	sub    %edx,%eax
    len = 0xffff;
  80f0a7:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80f0ac:	3d ff ff 00 00       	cmp    $0xffff,%eax
  80f0b1:	7f 0b                	jg     80f0be <do_writemore+0x54>
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80f0b3:	8b 46 24             	mov    0x24(%esi),%eax
  80f0b6:	66 8b 78 08          	mov    0x8(%eax),%di
  80f0ba:	66 2b 7e 28          	sub    0x28(%esi),%di
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80f0be:	8b 46 08             	mov    0x8(%esi),%eax
  80f0c1:	66 8b 40 6e          	mov    0x6e(%eax),%ax
  if (available < len) {
  80f0c5:	66 39 f8             	cmp    %di,%ax
  80f0c8:	73 02                	jae    80f0cc <do_writemore+0x62>
    /* don't try to write more than sendbuf */
    len = available;
  80f0ca:	89 c7                	mov    %eax,%edi
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80f0cc:	8b 46 24             	mov    0x24(%esi),%eax
  80f0cf:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80f0d3:	50                   	push   %eax
  80f0d4:	0f b7 df             	movzwl %di,%ebx
  80f0d7:	53                   	push   %ebx
  80f0d8:	51                   	push   %ecx
  80f0d9:	ff 76 08             	pushl  0x8(%esi)
  80f0dc:	e8 09 b6 ff ff       	call   80a6ea <tcp_write>
  80f0e1:	88 c2                	mov    %al,%dl
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80f0e3:	03 5e 28             	add    0x28(%esi),%ebx
  80f0e6:	8b 46 24             	mov    0x24(%esi),%eax
  80f0e9:	83 c4 10             	add    $0x10,%esp
  80f0ec:	3b 58 08             	cmp    0x8(%eax),%ebx
  80f0ef:	7e 17                	jle    80f108 <do_writemore+0x9e>
  80f0f1:	83 ec 04             	sub    $0x4,%esp
  80f0f4:	68 53 44 81 00       	push   $0x814453
  80f0f9:	68 cd 03 00 00       	push   $0x3cd
  80f0fe:	68 8f 43 81 00       	push   $0x81438f
  80f103:	e8 c4 19 ff ff       	call   800acc <_panic>
  if (err == ERR_OK) {
  80f108:	84 d2                	test   %dl,%dl
  80f10a:	75 7e                	jne    80f18a <do_writemore+0x120>
    conn->write_offset += len;
  80f10c:	0f b7 c7             	movzwl %di,%eax
  80f10f:	03 46 28             	add    0x28(%esi),%eax
  80f112:	89 46 28             	mov    %eax,0x28(%esi)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80f115:	8b 56 24             	mov    0x24(%esi),%edx
  80f118:	3b 42 08             	cmp    0x8(%edx),%eax
  80f11b:	75 12                	jne    80f12f <do_writemore+0xc5>
      /* everything was written */
      write_finished = 1;
  80f11d:	c6 45 f3 01          	movb   $0x1,0xfffffff3(%ebp)
      conn->write_msg = NULL;
  80f121:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
      conn->write_offset = 0;
  80f128:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80f12f:	8b 46 08             	mov    0x8(%esi),%eax
  80f132:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80f136:	74 14                	je     80f14c <do_writemore+0xe2>
  80f138:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80f13c:	75 0e                	jne    80f14c <do_writemore+0xe2>
  80f13e:	83 78 74 00          	cmpl   $0x0,0x74(%eax)
  80f142:	74 1a                	je     80f15e <do_writemore+0xf4>
  80f144:	8b 40 74             	mov    0x74(%eax),%eax
  80f147:	83 38 00             	cmpl   $0x0,(%eax)
  80f14a:	74 12                	je     80f15e <do_writemore+0xf4>
  80f14c:	83 ec 0c             	sub    $0xc,%esp
  80f14f:	ff 76 08             	pushl  0x8(%esi)
  80f152:	e8 5b bc ff ff       	call   80adb2 <tcp_output>
  80f157:	83 c4 10             	add    $0x10,%esp
  80f15a:	88 c2                	mov    %al,%dl
  80f15c:	eb 02                	jmp    80f160 <do_writemore+0xf6>
  80f15e:	b2 00                	mov    $0x0,%dl
    conn->err = err;
  80f160:	88 56 0c             	mov    %dl,0xc(%esi)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80f163:	84 d2                	test   %dl,%dl
  80f165:	75 3f                	jne    80f1a6 <do_writemore+0x13c>
  80f167:	8b 46 08             	mov    0x8(%esi),%eax
  80f16a:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80f170:	77 34                	ja     80f1a6 <do_writemore+0x13c>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80f172:	83 7e 2c 00          	cmpl   $0x0,0x2c(%esi)
  80f176:	74 2e                	je     80f1a6 <do_writemore+0x13c>
  80f178:	83 ec 04             	sub    $0x4,%esp
  80f17b:	0f b7 c7             	movzwl %di,%eax
  80f17e:	50                   	push   %eax
  80f17f:	6a 03                	push   $0x3
  80f181:	56                   	push   %esi
  80f182:	ff 56 2c             	call   *0x2c(%esi)
  80f185:	83 c4 10             	add    $0x10,%esp
  80f188:	eb 1c                	jmp    80f1a6 <do_writemore+0x13c>
    }
  } else if (err == ERR_MEM) {
  80f18a:	80 fa ff             	cmp    $0xff,%dl
  80f18d:	75 10                	jne    80f19f <do_writemore+0x135>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80f18f:	83 ec 0c             	sub    $0xc,%esp
  80f192:	ff 76 08             	pushl  0x8(%esi)
  80f195:	e8 18 bc ff ff       	call   80adb2 <tcp_output>
  80f19a:	83 c4 10             	add    $0x10,%esp
  80f19d:	eb 07                	jmp    80f1a6 <do_writemore+0x13c>

#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80f19f:	88 56 0c             	mov    %dl,0xc(%esi)
    write_finished = 1;
  80f1a2:	c6 45 f3 01          	movb   $0x1,0xfffffff3(%ebp)
  }

  if (write_finished) {
  80f1a6:	80 7d f3 00          	cmpb   $0x0,0xfffffff3(%ebp)
  80f1aa:	74 15                	je     80f1c1 <do_writemore+0x157>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80f1ac:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80f1b3:	83 ec 0c             	sub    $0xc,%esp
  80f1b6:	ff 76 10             	pushl  0x10(%esi)
  80f1b9:	e8 bc dd ff ff       	call   80cf7a <sys_sem_signal>
  80f1be:	83 c4 10             	add    $0x10,%esp
    }
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80f1c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80f1c6:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80f1c9:	5b                   	pop    %ebx
  80f1ca:	5e                   	pop    %esi
  80f1cb:	5f                   	pop    %edi
  80f1cc:	c9                   	leave  
  80f1cd:	c3                   	ret    

0080f1ce <do_write>:
#endif /* LWIP_TCP */

/**
 * Send some data on a TCP pcb contained in a netconn
 * Called from netconn_write
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80f1ce:	55                   	push   %ebp
  80f1cf:	89 e5                	mov    %esp,%ebp
  80f1d1:	83 ec 08             	sub    $0x8,%esp
  80f1d4:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f1d7:	8b 02                	mov    (%edx),%eax
  80f1d9:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80f1dd:	7c 32                	jl     80f211 <do_write+0x43>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80f1df:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80f1e3:	74 26                	je     80f20b <do_write+0x3d>
  80f1e5:	83 38 10             	cmpl   $0x10,(%eax)
  80f1e8:	75 21                	jne    80f20b <do_write+0x3d>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80f1ea:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80f1f1:	8b 02                	mov    (%edx),%eax
  80f1f3:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80f1f6:	8b 02                	mov    (%edx),%eax
  80f1f8:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
#if LWIP_TCPIP_CORE_LOCKING
      msg->conn->write_delayed = 0;
      if (do_writemore(msg->conn) != ERR_OK) {
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_WRITE);
        UNLOCK_TCPIP_CORE();
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80f1ff:	83 ec 0c             	sub    $0xc,%esp
  80f202:	ff 32                	pushl  (%edx)
  80f204:	e8 61 fe ff ff       	call   80f06a <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80f209:	eb 13                	jmp    80f21e <do_write+0x50>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80f20b:	8b 02                	mov    (%edx),%eax
  80f20d:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80f211:	83 ec 0c             	sub    $0xc,%esp
  80f214:	8b 02                	mov    (%edx),%eax
  80f216:	ff 70 10             	pushl  0x10(%eax)
  80f219:	e8 5c dd ff ff       	call   80cf7a <sys_sem_signal>
}
  80f21e:	c9                   	leave  
  80f21f:	c3                   	ret    

0080f220 <do_getaddr>:

/**
 * Return a connection's local or remote address
 * Called from netconn_getaddr
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80f220:	55                   	push   %ebp
  80f221:	89 e5                	mov    %esp,%ebp
  80f223:	83 ec 08             	sub    $0x8,%esp
  80f226:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if (msg->conn->pcb.ip != NULL) {
  80f229:	8b 01                	mov    (%ecx),%eax
  80f22b:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80f22f:	0f 84 bb 00 00 00    	je     80f2f0 <do_getaddr+0xd0>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80f235:	8b 51 04             	mov    0x4(%ecx),%edx
  80f238:	80 79 0c 00          	cmpb   $0x0,0xc(%ecx)
  80f23c:	74 07                	je     80f245 <do_getaddr+0x25>
  80f23e:	8b 40 08             	mov    0x8(%eax),%eax
  80f241:	8b 00                	mov    (%eax),%eax
  80f243:	eb 08                	jmp    80f24d <do_getaddr+0x2d>
  80f245:	8b 01                	mov    (%ecx),%eax
  80f247:	8b 40 08             	mov    0x8(%eax),%eax
  80f24a:	8b 40 04             	mov    0x4(%eax),%eax
  80f24d:	89 02                	mov    %eax,(%edx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f24f:	8b 01                	mov    (%ecx),%eax
  80f251:	8b 00                	mov    (%eax),%eax
  80f253:	25 f0 00 00 00       	and    $0xf0,%eax
  80f258:	83 f8 20             	cmp    $0x20,%eax
  80f25b:	74 38                	je     80f295 <do_getaddr+0x75>
  80f25d:	83 f8 20             	cmp    $0x20,%eax
  80f260:	77 0a                	ja     80f26c <do_getaddr+0x4c>
  80f262:	83 f8 10             	cmp    $0x10,%eax
  80f265:	74 67                	je     80f2ce <do_getaddr+0xae>
  80f267:	e9 8a 00 00 00       	jmp    80f2f6 <do_getaddr+0xd6>
  80f26c:	83 f8 40             	cmp    $0x40,%eax
  80f26f:	0f 85 81 00 00 00    	jne    80f2f6 <do_getaddr+0xd6>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80f275:	80 79 0c 00          	cmpb   $0x0,0xc(%ecx)
  80f279:	74 12                	je     80f28d <do_getaddr+0x6d>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80f27b:	8b 51 08             	mov    0x8(%ecx),%edx
  80f27e:	8b 01                	mov    (%ecx),%eax
  80f280:	8b 40 08             	mov    0x8(%eax),%eax
  80f283:	66 0f b6 40 10       	movzbw 0x10(%eax),%ax
  80f288:	66 89 02             	mov    %ax,(%edx)
  80f28b:	eb 69                	jmp    80f2f6 <do_getaddr+0xd6>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80f28d:	8b 01                	mov    (%ecx),%eax
  80f28f:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
      }
      break;
  80f293:	eb 61                	jmp    80f2f6 <do_getaddr+0xd6>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80f295:	80 79 0c 00          	cmpb   $0x0,0xc(%ecx)
  80f299:	74 11                	je     80f2ac <do_getaddr+0x8c>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80f29b:	8b 51 08             	mov    0x8(%ecx),%edx
  80f29e:	8b 01                	mov    (%ecx),%eax
  80f2a0:	8b 40 08             	mov    0x8(%eax),%eax
  80f2a3:	66 8b 40 12          	mov    0x12(%eax),%ax
  80f2a7:	66 89 02             	mov    %ax,(%edx)
  80f2aa:	eb 4a                	jmp    80f2f6 <do_getaddr+0xd6>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80f2ac:	8b 11                	mov    (%ecx),%edx
  80f2ae:	8b 42 08             	mov    0x8(%edx),%eax
  80f2b1:	f6 40 10 04          	testb  $0x4,0x10(%eax)
  80f2b5:	75 06                	jne    80f2bd <do_getaddr+0x9d>
          msg->conn->err = ERR_CONN;
  80f2b7:	c6 42 0c f8          	movb   $0xf8,0xc(%edx)
  80f2bb:	eb 39                	jmp    80f2f6 <do_getaddr+0xd6>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80f2bd:	8b 51 08             	mov    0x8(%ecx),%edx
  80f2c0:	8b 01                	mov    (%ecx),%eax
  80f2c2:	8b 40 08             	mov    0x8(%eax),%eax
  80f2c5:	66 8b 40 14          	mov    0x14(%eax),%ax
  80f2c9:	66 89 02             	mov    %ax,(%edx)
        }
      }
      break;
  80f2cc:	eb 28                	jmp    80f2f6 <do_getaddr+0xd6>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80f2ce:	8b 51 08             	mov    0x8(%ecx),%edx
  80f2d1:	80 79 0c 00          	cmpb   $0x0,0xc(%ecx)
  80f2d5:	74 0b                	je     80f2e2 <do_getaddr+0xc2>
  80f2d7:	8b 01                	mov    (%ecx),%eax
  80f2d9:	8b 40 08             	mov    0x8(%eax),%eax
  80f2dc:	66 8b 40 1c          	mov    0x1c(%eax),%ax
  80f2e0:	eb 09                	jmp    80f2eb <do_getaddr+0xcb>
  80f2e2:	8b 01                	mov    (%ecx),%eax
  80f2e4:	8b 40 08             	mov    0x8(%eax),%eax
  80f2e7:	66 8b 40 1e          	mov    0x1e(%eax),%ax
  80f2eb:	66 89 02             	mov    %ax,(%edx)
      break;
  80f2ee:	eb 06                	jmp    80f2f6 <do_getaddr+0xd6>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80f2f0:	8b 01                	mov    (%ecx),%eax
  80f2f2:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
  }
  TCPIP_APIMSG_ACK(msg);
  80f2f6:	83 ec 0c             	sub    $0xc,%esp
  80f2f9:	8b 01                	mov    (%ecx),%eax
  80f2fb:	ff 70 10             	pushl  0x10(%eax)
  80f2fe:	e8 77 dc ff ff       	call   80cf7a <sys_sem_signal>
}
  80f303:	c9                   	leave  
  80f304:	c3                   	ret    

0080f305 <do_close>:

/**
 * Close a TCP pcb contained in a netconn
 * Called from netconn_close
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80f305:	55                   	push   %ebp
  80f306:	89 e5                	mov    %esp,%ebp
  80f308:	83 ec 08             	sub    $0x8,%esp
  80f30b:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80f30e:	8b 02                	mov    (%edx),%eax
  80f310:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80f314:	74 1b                	je     80f331 <do_close+0x2c>
  80f316:	83 38 10             	cmpl   $0x10,(%eax)
  80f319:	75 16                	jne    80f331 <do_close+0x2c>
      msg->conn->state = NETCONN_CLOSE;
  80f31b:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80f322:	83 ec 0c             	sub    $0xc,%esp
  80f325:	ff 32                	pushl  (%edx)
  80f327:	e8 fe f6 ff ff       	call   80ea2a <do_close_internal>
  80f32c:	83 c4 10             	add    $0x10,%esp
  80f32f:	eb 16                	jmp    80f347 <do_close+0x42>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80f331:	8b 02                	mov    (%edx),%eax
  80f333:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80f337:	83 ec 0c             	sub    $0xc,%esp
  80f33a:	8b 02                	mov    (%edx),%eax
  80f33c:	ff 70 10             	pushl  0x10(%eax)
  80f33f:	e8 36 dc ff ff       	call   80cf7a <sys_sem_signal>
  80f344:	83 c4 10             	add    $0x10,%esp
  }
}
  80f347:	c9                   	leave  
  80f348:	c3                   	ret    
  80f349:	00 00                	add    %al,(%eax)
	...

0080f34c <tcp_input>:
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  80f34c:	55                   	push   %ebp
  80f34d:	89 e5                	mov    %esp,%ebp
  80f34f:	57                   	push   %edi
  80f350:	56                   	push   %esi
  80f351:	53                   	push   %ebx
  80f352:	83 ec 18             	sub    $0x18,%esp
  80f355:	8b 75 08             	mov    0x8(%ebp),%esi
  struct tcp_pcb *pcb, *prev;
  struct tcp_pcb_listen *lpcb;
  u8_t hdrlen;
  err_t err;

  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  80f358:	8b 46 04             	mov    0x4(%esi),%eax
  80f35b:	a3 d4 e5 b3 00       	mov    %eax,0xb3e5d4
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80f360:	0f b7 00             	movzwl (%eax),%eax
  80f363:	50                   	push   %eax
  80f364:	e8 0c b3 ff ff       	call   80a675 <ntohs>
  80f369:	c1 e8 06             	shr    $0x6,%eax
  80f36c:	83 e0 3c             	and    $0x3c,%eax
  80f36f:	03 46 04             	add    0x4(%esi),%eax
  80f372:	a3 d0 e5 b3 00       	mov    %eax,0xb3e5d0

#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80f377:	a1 d4 e5 b3 00       	mov    0xb3e5d4,%eax
  80f37c:	0f b7 00             	movzwl (%eax),%eax
  80f37f:	89 04 24             	mov    %eax,(%esp)
  80f382:	e8 ee b2 ff ff       	call   80a675 <ntohs>
  80f387:	83 c4 08             	add    $0x8,%esp
  80f38a:	c1 e8 06             	shr    $0x6,%eax
  80f38d:	83 e0 3c             	and    $0x3c,%eax
  80f390:	f7 d8                	neg    %eax
  80f392:	98                   	cwtl   
  80f393:	50                   	push   %eax
  80f394:	56                   	push   %esi
  80f395:	e8 a9 84 ff ff       	call   807843 <pbuf_header>
  80f39a:	83 c4 10             	add    $0x10,%esp
  80f39d:	84 c0                	test   %al,%al
  80f39f:	75 07                	jne    80f3a8 <tcp_input+0x5c>
  80f3a1:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80f3a6:	77 0e                	ja     80f3b6 <tcp_input+0x6a>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80f3a8:	83 ec 0c             	sub    $0xc,%esp
  80f3ab:	56                   	push   %esi
  80f3ac:	e8 68 85 ff ff       	call   807919 <pbuf_free>
    return;
  80f3b1:	e9 ed 05 00 00       	jmp    80f9a3 <tcp_input+0x657>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80f3b6:	83 ec 08             	sub    $0x8,%esp
  80f3b9:	ff 75 0c             	pushl  0xc(%ebp)
  80f3bc:	a1 d4 e5 b3 00       	mov    0xb3e5d4,%eax
  80f3c1:	83 c0 10             	add    $0x10,%eax
  80f3c4:	50                   	push   %eax
  80f3c5:	e8 ce 9d ff ff       	call   809198 <ip_addr_isbroadcast>
  80f3ca:	83 c4 10             	add    $0x10,%esp
  80f3cd:	84 c0                	test   %al,%al
  80f3cf:	75 2b                	jne    80f3fc <tcp_input+0xb0>
  80f3d1:	8b 1d d4 e5 b3 00    	mov    0xb3e5d4,%ebx
  80f3d7:	83 ec 0c             	sub    $0xc,%esp
  80f3da:	68 00 00 00 f0       	push   $0xf0000000
  80f3df:	e8 d2 b2 ff ff       	call   80a6b6 <ntohl>
  80f3e4:	23 43 10             	and    0x10(%ebx),%eax
  80f3e7:	89 c3                	mov    %eax,%ebx
  80f3e9:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80f3f0:	e8 c1 b2 ff ff       	call   80a6b6 <ntohl>
  80f3f5:	83 c4 10             	add    $0x10,%esp
  80f3f8:	39 c3                	cmp    %eax,%ebx
  80f3fa:	75 0e                	jne    80f40a <tcp_input+0xbe>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80f3fc:	83 ec 0c             	sub    $0xc,%esp
  80f3ff:	56                   	push   %esi
  80f400:	e8 14 85 ff ff       	call   807919 <pbuf_free>
    return;
  80f405:	e9 99 05 00 00       	jmp    80f9a3 <tcp_input+0x657>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80f40a:	83 ec 0c             	sub    $0xc,%esp
  80f40d:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f411:	50                   	push   %eax
  80f412:	6a 06                	push   $0x6
  80f414:	a1 d4 e5 b3 00       	mov    0xb3e5d4,%eax
  80f419:	8d 50 10             	lea    0x10(%eax),%edx
  80f41c:	52                   	push   %edx
  80f41d:	83 c0 0c             	add    $0xc,%eax
  80f420:	50                   	push   %eax
  80f421:	56                   	push   %esi
  80f422:	e8 e7 ac ff ff       	call   80a10e <inet_chksum_pseudo>
  80f427:	83 c4 20             	add    $0x20,%esp
  80f42a:	66 85 c0             	test   %ax,%ax
  80f42d:	74 0e                	je     80f43d <tcp_input+0xf1>
      (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len) != 0) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
        inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src), (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len)));
#if TCP_DEBUG
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80f42f:	83 ec 0c             	sub    $0xc,%esp
  80f432:	56                   	push   %esi
  80f433:	e8 e1 84 ff ff       	call   807919 <pbuf_free>
    return;
  80f438:	e9 66 05 00 00       	jmp    80f9a3 <tcp_input+0x657>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  80f43d:	83 ec 0c             	sub    $0xc,%esp
  80f440:	a1 d0 e5 b3 00       	mov    0xb3e5d0,%eax
  80f445:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80f449:	50                   	push   %eax
  80f44a:	e8 26 b2 ff ff       	call   80a675 <ntohs>
  80f44f:	66 c1 e8 0c          	shr    $0xc,%ax
  if(pbuf_header(p, -(hdrlen * 4))){
  80f453:	83 c4 08             	add    $0x8,%esp
  80f456:	0f b6 c0             	movzbl %al,%eax
  80f459:	c1 e0 02             	shl    $0x2,%eax
  80f45c:	f7 d8                	neg    %eax
  80f45e:	98                   	cwtl   
  80f45f:	50                   	push   %eax
  80f460:	56                   	push   %esi
  80f461:	e8 dd 83 ff ff       	call   807843 <pbuf_header>
  80f466:	83 c4 10             	add    $0x10,%esp
  80f469:	84 c0                	test   %al,%al
  80f46b:	74 0e                	je     80f47b <tcp_input+0x12f>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80f46d:	83 ec 0c             	sub    $0xc,%esp
  80f470:	56                   	push   %esi
  80f471:	e8 a3 84 ff ff       	call   807919 <pbuf_free>
    return;
  80f476:	e9 28 05 00 00       	jmp    80f9a3 <tcp_input+0x657>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  80f47b:	8b 1d d0 e5 b3 00    	mov    0xb3e5d0,%ebx
  80f481:	83 ec 0c             	sub    $0xc,%esp
  80f484:	0f b7 03             	movzwl (%ebx),%eax
  80f487:	50                   	push   %eax
  80f488:	e8 e8 b1 ff ff       	call   80a675 <ntohs>
  80f48d:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80f490:	8b 1d d0 e5 b3 00    	mov    0xb3e5d0,%ebx
  80f496:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80f49a:	89 04 24             	mov    %eax,(%esp)
  80f49d:	e8 d3 b1 ff ff       	call   80a675 <ntohs>
  80f4a2:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80f4a6:	8b 1d d0 e5 b3 00    	mov    0xb3e5d0,%ebx
  80f4ac:	83 c4 04             	add    $0x4,%esp
  80f4af:	ff 73 04             	pushl  0x4(%ebx)
  80f4b2:	e8 ff b1 ff ff       	call   80a6b6 <ntohl>
  80f4b7:	89 43 04             	mov    %eax,0x4(%ebx)
  80f4ba:	a3 d8 e5 b3 00       	mov    %eax,0xb3e5d8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80f4bf:	8b 1d d0 e5 b3 00    	mov    0xb3e5d0,%ebx
  80f4c5:	83 c4 04             	add    $0x4,%esp
  80f4c8:	ff 73 08             	pushl  0x8(%ebx)
  80f4cb:	e8 e6 b1 ff ff       	call   80a6b6 <ntohl>
  80f4d0:	89 43 08             	mov    %eax,0x8(%ebx)
  80f4d3:	a3 dc e5 b3 00       	mov    %eax,0xb3e5dc
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80f4d8:	8b 1d d0 e5 b3 00    	mov    0xb3e5d0,%ebx
  80f4de:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80f4e2:	89 04 24             	mov    %eax,(%esp)
  80f4e5:	e8 8b b1 ff ff       	call   80a675 <ntohs>
  80f4ea:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80f4ee:	a1 d0 e5 b3 00       	mov    0xb3e5d0,%eax
  80f4f3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80f4f7:	89 04 24             	mov    %eax,(%esp)
  80f4fa:	e8 76 b1 ff ff       	call   80a675 <ntohs>
  80f4ff:	83 e0 3f             	and    $0x3f,%eax
  80f502:	a2 e0 e5 b3 00       	mov    %al,0xb3e5e0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80f507:	b8 00 00 00 00       	mov    $0x0,%eax
  80f50c:	83 c4 10             	add    $0x10,%esp
  80f50f:	f6 05 e0 e5 b3 00 01 	testb  $0x1,0xb3e5e0
  80f516:	75 09                	jne    80f521 <tcp_input+0x1d5>
  80f518:	f6 05 e0 e5 b3 00 02 	testb  $0x2,0xb3e5e0
  80f51f:	74 05                	je     80f526 <tcp_input+0x1da>
  80f521:	b8 01 00 00 00       	mov    $0x1,%eax
  80f526:	66 03 46 08          	add    0x8(%esi),%ax
  80f52a:	66 a3 e2 e5 b3 00    	mov    %ax,0xb3e5e2

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  80f530:	bf 00 00 00 00       	mov    $0x0,%edi

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f535:	8b 1d 68 e6 b3 00    	mov    0xb3e668,%ebx
  80f53b:	85 db                	test   %ebx,%ebx
  80f53d:	0f 84 ec 00 00 00    	je     80f62f <tcp_input+0x2e3>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80f543:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  80f547:	75 17                	jne    80f560 <tcp_input+0x214>
  80f549:	83 ec 04             	sub    $0x4,%esp
  80f54c:	68 74 44 81 00       	push   $0x814474
  80f551:	68 b5 00 00 00       	push   $0xb5
  80f556:	68 e0 45 81 00       	push   $0x8145e0
  80f55b:	e8 6c 15 ff ff       	call   800acc <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80f560:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80f564:	75 17                	jne    80f57d <tcp_input+0x231>
  80f566:	83 ec 04             	sub    $0x4,%esp
  80f569:	68 9c 44 81 00       	push   $0x81449c
  80f56e:	68 b6 00 00 00       	push   $0xb6
  80f573:	68 e0 45 81 00       	push   $0x8145e0
  80f578:	e8 4f 15 ff ff       	call   800acc <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80f57d:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  80f581:	75 17                	jne    80f59a <tcp_input+0x24e>
  80f583:	83 ec 04             	sub    $0x4,%esp
  80f586:	68 c8 44 81 00       	push   $0x8144c8
  80f58b:	68 b7 00 00 00       	push   $0xb7
  80f590:	68 e0 45 81 00       	push   $0x8145e0
  80f595:	e8 32 15 ff ff       	call   800acc <_panic>
    if (pcb->remote_port == tcphdr->src &&
  80f59a:	8b 15 d0 e5 b3 00    	mov    0xb3e5d0,%edx
  80f5a0:	66 8b 43 1e          	mov    0x1e(%ebx),%ax
  80f5a4:	66 3b 02             	cmp    (%edx),%ax
  80f5a7:	75 6f                	jne    80f618 <tcp_input+0x2cc>
  80f5a9:	66 8b 43 1c          	mov    0x1c(%ebx),%ax
  80f5ad:	66 3b 42 02          	cmp    0x2(%edx),%ax
  80f5b1:	75 65                	jne    80f618 <tcp_input+0x2cc>
  80f5b3:	8b 15 d4 e5 b3 00    	mov    0xb3e5d4,%edx
  80f5b9:	8b 43 04             	mov    0x4(%ebx),%eax
  80f5bc:	3b 42 0c             	cmp    0xc(%edx),%eax
  80f5bf:	75 57                	jne    80f618 <tcp_input+0x2cc>
  80f5c1:	8b 03                	mov    (%ebx),%eax
  80f5c3:	3b 42 10             	cmp    0x10(%edx),%eax
  80f5c6:	75 50                	jne    80f618 <tcp_input+0x2cc>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80f5c8:	39 5b 0c             	cmp    %ebx,0xc(%ebx)
  80f5cb:	75 17                	jne    80f5e4 <tcp_input+0x298>
  80f5cd:	83 ec 04             	sub    $0x4,%esp
  80f5d0:	68 f0 44 81 00       	push   $0x8144f0
  80f5d5:	68 c0 00 00 00       	push   $0xc0
  80f5da:	68 e0 45 81 00       	push   $0x8145e0
  80f5df:	e8 e8 14 ff ff       	call   800acc <_panic>
      if (prev != NULL) {
  80f5e4:	85 ff                	test   %edi,%edi
  80f5e6:	74 14                	je     80f5fc <tcp_input+0x2b0>
        prev->next = pcb->next;
  80f5e8:	8b 43 0c             	mov    0xc(%ebx),%eax
  80f5eb:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80f5ee:	a1 68 e6 b3 00       	mov    0xb3e668,%eax
  80f5f3:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80f5f6:	89 1d 68 e6 b3 00    	mov    %ebx,0xb3e668
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80f5fc:	39 5b 0c             	cmp    %ebx,0xc(%ebx)
  80f5ff:	75 26                	jne    80f627 <tcp_input+0x2db>
  80f601:	83 ec 04             	sub    $0x4,%esp
  80f604:	68 1c 45 81 00       	push   $0x81451c
  80f609:	68 c6 00 00 00       	push   $0xc6
  80f60e:	68 e0 45 81 00       	push   $0x8145e0
  80f613:	e8 b4 14 ff ff       	call   800acc <_panic>
      break;
    }
    prev = pcb;
  80f618:	89 df                	mov    %ebx,%edi
  80f61a:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80f61d:	85 db                	test   %ebx,%ebx
  80f61f:	0f 85 1e ff ff ff    	jne    80f543 <tcp_input+0x1f7>
  80f625:	eb 08                	jmp    80f62f <tcp_input+0x2e3>
  }

  if (pcb == NULL) {
  80f627:	85 db                	test   %ebx,%ebx
  80f629:	0f 85 e0 00 00 00    	jne    80f70f <tcp_input+0x3c3>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80f62f:	8b 1d 7c e6 b3 00    	mov    0xb3e67c,%ebx
  80f635:	85 db                	test   %ebx,%ebx
  80f637:	74 68                	je     80f6a1 <tcp_input+0x355>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80f639:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80f63d:	74 17                	je     80f656 <tcp_input+0x30a>
  80f63f:	83 ec 04             	sub    $0x4,%esp
  80f642:	68 48 45 81 00       	push   $0x814548
  80f647:	68 d0 00 00 00       	push   $0xd0
  80f64c:	68 e0 45 81 00       	push   $0x8145e0
  80f651:	e8 76 14 ff ff       	call   800acc <_panic>
      if (pcb->remote_port == tcphdr->src &&
  80f656:	8b 15 d0 e5 b3 00    	mov    0xb3e5d0,%edx
  80f65c:	66 8b 43 1e          	mov    0x1e(%ebx),%ax
  80f660:	66 3b 02             	cmp    (%edx),%ax
  80f663:	75 35                	jne    80f69a <tcp_input+0x34e>
  80f665:	66 8b 43 1c          	mov    0x1c(%ebx),%ax
  80f669:	66 3b 42 02          	cmp    0x2(%edx),%ax
  80f66d:	75 2b                	jne    80f69a <tcp_input+0x34e>
  80f66f:	8b 15 d4 e5 b3 00    	mov    0xb3e5d4,%edx
  80f675:	8b 43 04             	mov    0x4(%ebx),%eax
  80f678:	3b 42 0c             	cmp    0xc(%edx),%eax
  80f67b:	75 1d                	jne    80f69a <tcp_input+0x34e>
  80f67d:	8b 03                	mov    (%ebx),%eax
  80f67f:	3b 42 10             	cmp    0x10(%edx),%eax
  80f682:	75 16                	jne    80f69a <tcp_input+0x34e>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
  80f684:	83 ec 0c             	sub    $0xc,%esp
  80f687:	53                   	push   %ebx
  80f688:	e8 9b 04 00 00       	call   80fb28 <tcp_timewait_input>
        pbuf_free(p);
  80f68d:	89 34 24             	mov    %esi,(%esp)
  80f690:	e8 84 82 ff ff       	call   807919 <pbuf_free>
        return;
  80f695:	e9 09 03 00 00       	jmp    80f9a3 <tcp_input+0x657>
  80f69a:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80f69d:	85 db                	test   %ebx,%ebx
  80f69f:	75 98                	jne    80f639 <tcp_input+0x2ed>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  80f6a1:	bf 00 00 00 00       	mov    $0x0,%edi
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80f6a6:	8b 0d 70 e6 b3 00    	mov    0xb3e670,%ecx
  80f6ac:	85 c9                	test   %ecx,%ecx
  80f6ae:	74 57                	je     80f707 <tcp_input+0x3bb>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80f6b0:	83 39 00             	cmpl   $0x0,(%ecx)
  80f6b3:	74 0c                	je     80f6c1 <tcp_input+0x375>
  80f6b5:	8b 11                	mov    (%ecx),%edx
  80f6b7:	a1 d4 e5 b3 00       	mov    0xb3e5d4,%eax
  80f6bc:	3b 50 10             	cmp    0x10(%eax),%edx
  80f6bf:	75 3d                	jne    80f6fe <tcp_input+0x3b2>
  80f6c1:	66 8b 51 1c          	mov    0x1c(%ecx),%dx
  80f6c5:	a1 d0 e5 b3 00       	mov    0xb3e5d0,%eax
  80f6ca:	66 3b 50 02          	cmp    0x2(%eax),%dx
  80f6ce:	75 2e                	jne    80f6fe <tcp_input+0x3b2>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  80f6d0:	85 ff                	test   %edi,%edi
  80f6d2:	74 14                	je     80f6e8 <tcp_input+0x39c>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80f6d4:	8b 41 0c             	mov    0xc(%ecx),%eax
  80f6d7:	89 47 0c             	mov    %eax,0xc(%edi)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80f6da:	a1 70 e6 b3 00       	mov    0xb3e670,%eax
  80f6df:	89 41 0c             	mov    %eax,0xc(%ecx)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80f6e2:	89 0d 70 e6 b3 00    	mov    %ecx,0xb3e670
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
  80f6e8:	83 ec 0c             	sub    $0xc,%esp
  80f6eb:	51                   	push   %ecx
  80f6ec:	e8 ba 02 00 00       	call   80f9ab <tcp_listen_input>
        pbuf_free(p);
  80f6f1:	89 34 24             	mov    %esi,(%esp)
  80f6f4:	e8 20 82 ff ff       	call   807919 <pbuf_free>
        return;
  80f6f9:	e9 a5 02 00 00       	jmp    80f9a3 <tcp_input+0x657>
      }
      prev = (struct tcp_pcb *)lpcb;
  80f6fe:	89 cf                	mov    %ecx,%edi
  80f700:	8b 49 0c             	mov    0xc(%ecx),%ecx
  80f703:	85 c9                	test   %ecx,%ecx
  80f705:	75 a9                	jne    80f6b0 <tcp_input+0x364>
    }
  }

#if TCP_INPUT_DEBUG
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  80f707:	85 db                	test   %ebx,%ebx
  80f709:	0f 84 34 02 00 00    	je     80f943 <tcp_input+0x5f7>
    /* The incoming segment belongs to a connection. */
#if TCP_INPUT_DEBUG
#if TCP_DEBUG
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  80f70f:	c7 05 bc e5 b3 00 00 	movl   $0x0,0xb3e5bc
  80f716:	00 00 00 
    inseg.len = p->tot_len;
  80f719:	66 8b 46 08          	mov    0x8(%esi),%ax
  80f71d:	66 a3 c8 e5 b3 00    	mov    %ax,0xb3e5c8
    inseg.dataptr = p->payload;
  80f723:	8b 46 04             	mov    0x4(%esi),%eax
  80f726:	a3 c4 e5 b3 00       	mov    %eax,0xb3e5c4
    inseg.p = p;
  80f72b:	89 35 c0 e5 b3 00    	mov    %esi,0xb3e5c0
    inseg.tcphdr = tcphdr;
  80f731:	a1 d0 e5 b3 00       	mov    0xb3e5d0,%eax
  80f736:	a3 cc e5 b3 00       	mov    %eax,0xb3e5cc

    recv_data = NULL;
  80f73b:	c7 05 e8 e5 b3 00 00 	movl   $0x0,0xb3e5e8
  80f742:	00 00 00 
    recv_flags = 0;
  80f745:	c6 05 e4 e5 b3 00 00 	movb   $0x0,0xb3e5e4

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80f74c:	83 bb 80 00 00 00 00 	cmpl   $0x0,0x80(%ebx)
  80f753:	74 61                	je     80f7b6 <tcp_input+0x46a>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80f755:	83 bb 88 00 00 00 00 	cmpl   $0x0,0x88(%ebx)
  80f75c:	74 19                	je     80f777 <tcp_input+0x42b>
  80f75e:	6a 00                	push   $0x0
  80f760:	ff b3 80 00 00 00    	pushl  0x80(%ebx)
  80f766:	53                   	push   %ebx
  80f767:	ff 73 18             	pushl  0x18(%ebx)
  80f76a:	ff 93 88 00 00 00    	call   *0x88(%ebx)
  80f770:	89 c7                	mov    %eax,%edi
  80f772:	83 c4 10             	add    $0x10,%esp
  80f775:	eb 1f                	jmp    80f796 <tcp_input+0x44a>
  80f777:	bf 00 00 00 00       	mov    $0x0,%edi
  80f77c:	83 bb 80 00 00 00 00 	cmpl   $0x0,0x80(%ebx)
  80f783:	74 11                	je     80f796 <tcp_input+0x44a>
  80f785:	83 ec 0c             	sub    $0xc,%esp
  80f788:	ff b3 80 00 00 00    	pushl  0x80(%ebx)
  80f78e:	e8 86 81 ff ff       	call   807919 <pbuf_free>
  80f793:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
  80f796:	89 f8                	mov    %edi,%eax
  80f798:	84 c0                	test   %al,%al
  80f79a:	75 0c                	jne    80f7a8 <tcp_input+0x45c>
        pcb->refused_data = NULL;
  80f79c:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80f7a3:	00 00 00 
  80f7a6:	eb 0e                	jmp    80f7b6 <tcp_input+0x46a>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  80f7a8:	83 ec 0c             	sub    $0xc,%esp
  80f7ab:	56                   	push   %esi
  80f7ac:	e8 68 81 ff ff       	call   807919 <pbuf_free>
        return;
  80f7b1:	e9 ed 01 00 00       	jmp    80f9a3 <tcp_input+0x657>
      }
    }

    tcp_input_pcb = pcb;
  80f7b6:	89 1d 84 e6 b3 00    	mov    %ebx,0xb3e684
    err = tcp_process(pcb);
  80f7bc:	83 ec 0c             	sub    $0xc,%esp
  80f7bf:	53                   	push   %ebx
  80f7c0:	e8 b3 03 00 00       	call   80fb78 <tcp_process>
    tcp_input_pcb = NULL;
  80f7c5:	c7 05 84 e6 b3 00 00 	movl   $0x0,0xb3e684
  80f7cc:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
  80f7cf:	83 c4 10             	add    $0x10,%esp
  80f7d2:	3c fb                	cmp    $0xfb,%al
  80f7d4:	0f 84 43 01 00 00    	je     80f91d <tcp_input+0x5d1>
      if (recv_flags & TF_RESET) {
  80f7da:	f6 05 e4 e5 b3 00 08 	testb  $0x8,0xb3e5e4
  80f7e1:	74 3b                	je     80f81e <tcp_input+0x4d2>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80f7e3:	83 bb 98 00 00 00 00 	cmpl   $0x0,0x98(%ebx)
  80f7ea:	74 11                	je     80f7fd <tcp_input+0x4b1>
  80f7ec:	83 ec 08             	sub    $0x8,%esp
  80f7ef:	6a fa                	push   $0xfffffffa
  80f7f1:	ff 73 18             	pushl  0x18(%ebx)
  80f7f4:	ff 93 98 00 00 00    	call   *0x98(%ebx)
  80f7fa:	83 c4 10             	add    $0x10,%esp
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80f7fd:	83 ec 08             	sub    $0x8,%esp
  80f800:	53                   	push   %ebx
  80f801:	68 68 e6 b3 00       	push   $0xb3e668
  80f806:	e8 56 98 ff ff       	call   809061 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80f80b:	83 c4 08             	add    $0x8,%esp
  80f80e:	53                   	push   %ebx
  80f80f:	6a 02                	push   $0x2
  80f811:	e8 db 79 ff ff       	call   8071f1 <memp_free>
  80f816:	83 c4 10             	add    $0x10,%esp
  80f819:	e9 ff 00 00 00       	jmp    80f91d <tcp_input+0x5d1>
      } else if (recv_flags & TF_CLOSED) {
  80f81e:	f6 05 e4 e5 b3 00 10 	testb  $0x10,0xb3e5e4
  80f825:	74 21                	je     80f848 <tcp_input+0x4fc>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80f827:	83 ec 08             	sub    $0x8,%esp
  80f82a:	53                   	push   %ebx
  80f82b:	68 68 e6 b3 00       	push   $0xb3e668
  80f830:	e8 2c 98 ff ff       	call   809061 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80f835:	83 c4 08             	add    $0x8,%esp
  80f838:	53                   	push   %ebx
  80f839:	6a 02                	push   $0x2
  80f83b:	e8 b1 79 ff ff       	call   8071f1 <memp_free>
  80f840:	83 c4 10             	add    $0x10,%esp
  80f843:	e9 d5 00 00 00       	jmp    80f91d <tcp_input+0x5d1>
      } else {
        err = ERR_OK;
  80f848:	bf 00 00 00 00       	mov    $0x0,%edi
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80f84d:	66 83 7b 6c 00       	cmpw   $0x0,0x6c(%ebx)
  80f852:	74 20                	je     80f874 <tcp_input+0x528>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80f854:	83 bb 84 00 00 00 00 	cmpl   $0x0,0x84(%ebx)
  80f85b:	74 17                	je     80f874 <tcp_input+0x528>
  80f85d:	83 ec 04             	sub    $0x4,%esp
  80f860:	0f b7 43 6c          	movzwl 0x6c(%ebx),%eax
  80f864:	50                   	push   %eax
  80f865:	53                   	push   %ebx
  80f866:	ff 73 18             	pushl  0x18(%ebx)
  80f869:	ff 93 84 00 00 00    	call   *0x84(%ebx)
  80f86f:	89 c7                	mov    %eax,%edi
  80f871:	83 c4 10             	add    $0x10,%esp
        }
      
        if (recv_data != NULL) {
  80f874:	83 3d e8 e5 b3 00 00 	cmpl   $0x0,0xb3e5e8
  80f87b:	74 64                	je     80f8e1 <tcp_input+0x595>
          if(flags & TCP_PSH) {
  80f87d:	f6 05 e0 e5 b3 00 08 	testb  $0x8,0xb3e5e0
  80f884:	74 09                	je     80f88f <tcp_input+0x543>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80f886:	a1 e8 e5 b3 00       	mov    0xb3e5e8,%eax
  80f88b:	80 48 0d 01          	orb    $0x1,0xd(%eax)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80f88f:	83 bb 88 00 00 00 00 	cmpl   $0x0,0x88(%ebx)
  80f896:	74 19                	je     80f8b1 <tcp_input+0x565>
  80f898:	6a 00                	push   $0x0
  80f89a:	ff 35 e8 e5 b3 00    	pushl  0xb3e5e8
  80f8a0:	53                   	push   %ebx
  80f8a1:	ff 73 18             	pushl  0x18(%ebx)
  80f8a4:	ff 93 88 00 00 00    	call   *0x88(%ebx)
  80f8aa:	89 c7                	mov    %eax,%edi
  80f8ac:	83 c4 10             	add    $0x10,%esp
  80f8af:	eb 1f                	jmp    80f8d0 <tcp_input+0x584>
  80f8b1:	bf 00 00 00 00       	mov    $0x0,%edi
  80f8b6:	83 3d e8 e5 b3 00 00 	cmpl   $0x0,0xb3e5e8
  80f8bd:	74 11                	je     80f8d0 <tcp_input+0x584>
  80f8bf:	83 ec 0c             	sub    $0xc,%esp
  80f8c2:	ff 35 e8 e5 b3 00    	pushl  0xb3e5e8
  80f8c8:	e8 4c 80 ff ff       	call   807919 <pbuf_free>
  80f8cd:	83 c4 10             	add    $0x10,%esp

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  80f8d0:	89 f8                	mov    %edi,%eax
  80f8d2:	84 c0                	test   %al,%al
  80f8d4:	74 0b                	je     80f8e1 <tcp_input+0x595>
            pcb->refused_data = recv_data;
  80f8d6:	a1 e8 e5 b3 00       	mov    0xb3e5e8,%eax
  80f8db:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: keep incoming packet, because pcb is \"full\"\n"));
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80f8e1:	f6 05 e4 e5 b3 00 20 	testb  $0x20,0xb3e5e4
  80f8e8:	74 21                	je     80f90b <tcp_input+0x5bf>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80f8ea:	bf 00 00 00 00       	mov    $0x0,%edi
  80f8ef:	83 bb 88 00 00 00 00 	cmpl   $0x0,0x88(%ebx)
  80f8f6:	74 13                	je     80f90b <tcp_input+0x5bf>
  80f8f8:	6a 00                	push   $0x0
  80f8fa:	6a 00                	push   $0x0
  80f8fc:	53                   	push   %ebx
  80f8fd:	ff 73 18             	pushl  0x18(%ebx)
  80f900:	ff 93 88 00 00 00    	call   *0x88(%ebx)
  80f906:	89 c7                	mov    %eax,%edi
  80f908:	83 c4 10             	add    $0x10,%esp
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  80f90b:	89 f8                	mov    %edi,%eax
  80f90d:	84 c0                	test   %al,%al
  80f90f:	75 0c                	jne    80f91d <tcp_input+0x5d1>
          tcp_output(pcb);
  80f911:	83 ec 0c             	sub    $0xc,%esp
  80f914:	53                   	push   %ebx
  80f915:	e8 98 b4 ff ff       	call   80adb2 <tcp_output>
  80f91a:	83 c4 10             	add    $0x10,%esp
        }
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  80f91d:	83 3d c0 e5 b3 00 00 	cmpl   $0x0,0xb3e5c0
  80f924:	74 7d                	je     80f9a3 <tcp_input+0x657>
    {
      pbuf_free(inseg.p);
  80f926:	83 ec 0c             	sub    $0xc,%esp
  80f929:	ff 35 c0 e5 b3 00    	pushl  0xb3e5c0
  80f92f:	e8 e5 7f ff ff       	call   807919 <pbuf_free>
      inseg.p = NULL;
  80f934:	c7 05 c0 e5 b3 00 00 	movl   $0x0,0xb3e5c0
  80f93b:	00 00 00 
  80f93e:	83 c4 10             	add    $0x10,%esp
  80f941:	eb 60                	jmp    80f9a3 <tcp_input+0x657>
    }
#if TCP_INPUT_DEBUG
#if TCP_DEBUG
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */
      
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80f943:	83 ec 0c             	sub    $0xc,%esp
  80f946:	a1 d0 e5 b3 00       	mov    0xb3e5d0,%eax
  80f94b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80f94f:	50                   	push   %eax
  80f950:	e8 20 ad ff ff       	call   80a675 <ntohs>
  80f955:	83 c4 10             	add    $0x10,%esp
  80f958:	a8 04                	test   $0x4,%al
  80f95a:	75 3b                	jne    80f997 <tcp_input+0x64b>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  80f95c:	83 ec 08             	sub    $0x8,%esp
  80f95f:	8b 15 d0 e5 b3 00    	mov    0xb3e5d0,%edx
  80f965:	0f b7 02             	movzwl (%edx),%eax
  80f968:	50                   	push   %eax
  80f969:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80f96d:	50                   	push   %eax
  80f96e:	a1 d4 e5 b3 00       	mov    0xb3e5d4,%eax
  80f973:	8d 50 0c             	lea    0xc(%eax),%edx
  80f976:	52                   	push   %edx
  80f977:	83 c0 10             	add    $0x10,%eax
  80f97a:	50                   	push   %eax
  80f97b:	0f b7 05 e2 e5 b3 00 	movzwl 0xb3e5e2,%eax
  80f982:	03 05 d8 e5 b3 00    	add    0xb3e5d8,%eax
  80f988:	50                   	push   %eax
  80f989:	ff 35 dc e5 b3 00    	pushl  0xb3e5dc
  80f98f:	e8 ce b8 ff ff       	call   80b262 <tcp_rst>
  80f994:	83 c4 20             	add    $0x20,%esp
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  80f997:	83 ec 0c             	sub    $0xc,%esp
  80f99a:	56                   	push   %esi
  80f99b:	e8 79 7f ff ff       	call   807919 <pbuf_free>
  80f9a0:	83 c4 10             	add    $0x10,%esp
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  80f9a3:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  80f9a6:	5b                   	pop    %ebx
  80f9a7:	5e                   	pop    %esi
  80f9a8:	5f                   	pop    %edi
  80f9a9:	c9                   	leave  
  80f9aa:	c3                   	ret    

0080f9ab <tcp_listen_input>:

/**
 * Called by tcp_input() when a segment arrives for a listening
 * connection (from tcp_input()).
 *
 * @param pcb the tcp_pcb_listen for which a segment arrived
 * @return ERR_OK if the segment was processed
 *         another err_t on error
 *
 * @note the return value is not (yet?) used in tcp_input()
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
  80f9ab:	55                   	push   %ebp
  80f9ac:	89 e5                	mov    %esp,%ebp
  80f9ae:	56                   	push   %esi
  80f9af:	53                   	push   %ebx
  80f9b0:	83 ec 10             	sub    $0x10,%esp
  80f9b3:	8b 75 08             	mov    0x8(%ebp),%esi
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  80f9b6:	f6 05 e0 e5 b3 00 10 	testb  $0x10,0xb3e5e0
  80f9bd:	74 41                	je     80fa00 <tcp_listen_input+0x55>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  80f9bf:	83 ec 08             	sub    $0x8,%esp
  80f9c2:	8b 15 d0 e5 b3 00    	mov    0xb3e5d0,%edx
  80f9c8:	0f b7 02             	movzwl (%edx),%eax
  80f9cb:	50                   	push   %eax
  80f9cc:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80f9d0:	50                   	push   %eax
  80f9d1:	a1 d4 e5 b3 00       	mov    0xb3e5d4,%eax
  80f9d6:	8d 50 0c             	lea    0xc(%eax),%edx
  80f9d9:	52                   	push   %edx
  80f9da:	83 c0 10             	add    $0x10,%eax
  80f9dd:	50                   	push   %eax
  80f9de:	0f b7 05 e2 e5 b3 00 	movzwl 0xb3e5e2,%eax
  80f9e5:	03 05 d8 e5 b3 00    	add    0xb3e5d8,%eax
  80f9eb:	50                   	push   %eax
  80f9ec:	a1 dc e5 b3 00       	mov    0xb3e5dc,%eax
  80f9f1:	40                   	inc    %eax
  80f9f2:	50                   	push   %eax
  80f9f3:	e8 6a b8 ff ff       	call   80b262 <tcp_rst>
  80f9f8:	83 c4 20             	add    $0x20,%esp
  80f9fb:	e9 1c 01 00 00       	jmp    80fb1c <tcp_listen_input+0x171>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  80fa00:	f6 05 e0 e5 b3 00 02 	testb  $0x2,0xb3e5e0
  80fa07:	0f 84 0f 01 00 00    	je     80fb1c <tcp_listen_input+0x171>
    LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  80fa0d:	83 ec 0c             	sub    $0xc,%esp
  80fa10:	0f b6 46 14          	movzbl 0x14(%esi),%eax
  80fa14:	50                   	push   %eax
  80fa15:	e8 54 94 ff ff       	call   808e6e <tcp_alloc>
  80fa1a:	89 c3                	mov    %eax,%ebx
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  80fa1c:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
      return ERR_MEM;
  80fa1f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80fa24:	85 db                	test   %ebx,%ebx
  80fa26:	0f 84 f5 00 00 00    	je     80fb21 <tcp_listen_input+0x176>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80fa2c:	b8 00 00 00 00       	mov    $0x0,%eax
  80fa31:	83 3d d4 e5 b3 00 f0 	cmpl   $0xfffffff0,0xb3e5d4
  80fa38:	74 08                	je     80fa42 <tcp_listen_input+0x97>
  80fa3a:	a1 d4 e5 b3 00       	mov    0xb3e5d4,%eax
  80fa3f:	8b 40 10             	mov    0x10(%eax),%eax
  80fa42:	89 03                	mov    %eax,(%ebx)
    npcb->local_port = pcb->local_port;
  80fa44:	66 8b 46 1c          	mov    0x1c(%esi),%ax
  80fa48:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80fa4c:	b8 00 00 00 00       	mov    $0x0,%eax
  80fa51:	83 3d d4 e5 b3 00 f4 	cmpl   $0xfffffff4,0xb3e5d4
  80fa58:	74 08                	je     80fa62 <tcp_listen_input+0xb7>
  80fa5a:	a1 d4 e5 b3 00       	mov    0xb3e5d4,%eax
  80fa5f:	8b 40 0c             	mov    0xc(%eax),%eax
  80fa62:	89 43 04             	mov    %eax,0x4(%ebx)
    npcb->remote_port = tcphdr->src;
  80fa65:	a1 d0 e5 b3 00       	mov    0xb3e5d0,%eax
  80fa6a:	66 8b 00             	mov    (%eax),%ax
  80fa6d:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    npcb->state = SYN_RCVD;
  80fa71:	c7 43 10 03 00 00 00 	movl   $0x3,0x10(%ebx)
    npcb->rcv_nxt = seqno + 1;
  80fa78:	a1 d8 e5 b3 00       	mov    0xb3e5d8,%eax
  80fa7d:	40                   	inc    %eax
  80fa7e:	89 43 24             	mov    %eax,0x24(%ebx)
    npcb->snd_wnd = tcphdr->wnd;
  80fa81:	a1 d0 e5 b3 00       	mov    0xb3e5d0,%eax
  80fa86:	66 8b 40 0e          	mov    0xe(%eax),%ax
  80fa8a:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
    npcb->ssthresh = npcb->snd_wnd;
  80fa8e:	66 89 43 50          	mov    %ax,0x50(%ebx)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80fa92:	a1 d8 e5 b3 00       	mov    0xb3e5d8,%eax
  80fa97:	48                   	dec    %eax
  80fa98:	89 43 60             	mov    %eax,0x60(%ebx)
    npcb->callback_arg = pcb->callback_arg;
  80fa9b:	8b 46 18             	mov    0x18(%esi),%eax
  80fa9e:	89 43 18             	mov    %eax,0x18(%ebx)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  80faa1:	8b 46 20             	mov    0x20(%esi),%eax
  80faa4:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80faaa:	66 8b 46 08          	mov    0x8(%esi),%ax
  80faae:	25 99 01 00 00       	and    $0x199,%eax
  80fab3:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  80fab7:	a1 68 e6 b3 00       	mov    0xb3e668,%eax
  80fabc:	89 43 0c             	mov    %eax,0xc(%ebx)
  80fabf:	89 1d 68 e6 b3 00    	mov    %ebx,0xb3e668
  80fac5:	e8 84 50 ff ff       	call   804b4e <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  80faca:	83 ec 0c             	sub    $0xc,%esp
  80facd:	53                   	push   %ebx
  80face:	e8 73 13 00 00       	call   810e46 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80fad3:	83 c4 08             	add    $0x8,%esp
  80fad6:	8d 43 04             	lea    0x4(%ebx),%eax
  80fad9:	50                   	push   %eax
  80fada:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80fade:	50                   	push   %eax
  80fadf:	e8 7d 96 ff ff       	call   809161 <tcp_eff_send_mss>
  80fae4:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  80fae8:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80faef:	e8 96 ab ff ff       	call   80a68a <htonl>
  80faf4:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80faf7:	83 c4 0c             	add    $0xc,%esp
  80fafa:	6a 04                	push   $0x4
  80fafc:	8d 45 f4             	lea    0xfffffff4(%ebp),%eax
  80faff:	50                   	push   %eax
  80fb00:	6a 00                	push   $0x0
  80fb02:	6a 12                	push   $0x12
  80fb04:	6a 00                	push   $0x0
  80fb06:	6a 00                	push   $0x0
  80fb08:	53                   	push   %ebx
  80fb09:	e8 35 ac ff ff       	call   80a743 <tcp_enqueue>
    return tcp_output(npcb);
  80fb0e:	83 c4 14             	add    $0x14,%esp
  80fb11:	53                   	push   %ebx
  80fb12:	e8 9b b2 ff ff       	call   80adb2 <tcp_output>
  80fb17:	0f be c0             	movsbl %al,%eax
  80fb1a:	eb 05                	jmp    80fb21 <tcp_listen_input+0x176>
  }
  return ERR_OK;
  80fb1c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fb21:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  80fb24:	5b                   	pop    %ebx
  80fb25:	5e                   	pop    %esi
  80fb26:	c9                   	leave  
  80fb27:	c3                   	ret    

0080fb28 <tcp_timewait_input>:

/**
 * Called by tcp_input() when a segment arrives for a connection in
 * TIME_WAIT.
 *
 * @param pcb the tcp_pcb for which a segment arrived
 *
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  80fb28:	55                   	push   %ebp
  80fb29:	89 e5                	mov    %esp,%ebp
  80fb2b:	53                   	push   %ebx
  80fb2c:	83 ec 04             	sub    $0x4,%esp
  80fb2f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80fb32:	0f b7 05 e2 e5 b3 00 	movzwl 0xb3e5e2,%eax
  80fb39:	89 c2                	mov    %eax,%edx
  80fb3b:	03 15 d8 e5 b3 00    	add    0xb3e5d8,%edx
  80fb41:	89 d0                	mov    %edx,%eax
  80fb43:	2b 43 24             	sub    0x24(%ebx),%eax
  80fb46:	85 c0                	test   %eax,%eax
  80fb48:	7e 03                	jle    80fb4d <tcp_timewait_input+0x25>
    pcb->rcv_nxt = seqno + tcplen;
  80fb4a:	89 53 24             	mov    %edx,0x24(%ebx)
  }
  if (tcplen > 0) {
  80fb4d:	66 83 3d e2 e5 b3 00 	cmpw   $0x0,0xb3e5e2
  80fb54:	00 
  80fb55:	74 10                	je     80fb67 <tcp_timewait_input+0x3f>
    tcp_ack_now(pcb);
  80fb57:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80fb5b:	83 ec 0c             	sub    $0xc,%esp
  80fb5e:	53                   	push   %ebx
  80fb5f:	e8 4e b2 ff ff       	call   80adb2 <tcp_output>
  80fb64:	83 c4 10             	add    $0x10,%esp
  }
  return tcp_output(pcb);
  80fb67:	83 ec 0c             	sub    $0xc,%esp
  80fb6a:	53                   	push   %ebx
  80fb6b:	e8 42 b2 ff ff       	call   80adb2 <tcp_output>
  80fb70:	0f be c0             	movsbl %al,%eax
}
  80fb73:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  80fb76:	c9                   	leave  
  80fb77:	c3                   	ret    

0080fb78 <tcp_process>:

/**
 * Implements the TCP state machine. Called by tcp_input. In some
 * states tcp_receive() is called to receive data. The tcp_seg
 * argument will be freed by the caller (tcp_input()) unless the
 * recv_data pointer in the pcb is set.
 *
 * @param pcb the tcp_pcb for which a segment arrived
 *
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  80fb78:	55                   	push   %ebp
  80fb79:	89 e5                	mov    %esp,%ebp
  80fb7b:	56                   	push   %esi
  80fb7c:	53                   	push   %ebx
  80fb7d:	8b 75 08             	mov    0x8(%ebp),%esi
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  80fb80:	b3 00                	mov    $0x0,%bl
  err_t err;
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  80fb82:	f6 05 e0 e5 b3 00 04 	testb  $0x4,0xb3e5e0
  80fb89:	74 6f                	je     80fbfa <tcp_process+0x82>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  80fb8b:	83 7e 10 02          	cmpl   $0x2,0x10(%esi)
  80fb8f:	75 0f                	jne    80fba0 <tcp_process+0x28>
      if (ackno == pcb->snd_nxt) {
  80fb91:	8b 46 54             	mov    0x54(%esi),%eax
  80fb94:	3b 05 dc e5 b3 00    	cmp    0xb3e5dc,%eax
  80fb9a:	75 1f                	jne    80fbbb <tcp_process+0x43>
        acceptable = 1;
  80fb9c:	b3 01                	mov    $0x1,%bl
  80fb9e:	eb 1b                	jmp    80fbbb <tcp_process+0x43>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80fba0:	8b 56 24             	mov    0x24(%esi),%edx
  80fba3:	8b 0d d8 e5 b3 00    	mov    0xb3e5d8,%ecx
  80fba9:	39 d1                	cmp    %edx,%ecx
  80fbab:	78 0e                	js     80fbbb <tcp_process+0x43>
  80fbad:	0f b7 46 28          	movzwl 0x28(%esi),%eax
  80fbb1:	01 d0                	add    %edx,%eax
  80fbb3:	29 c1                	sub    %eax,%ecx
  80fbb5:	85 c9                	test   %ecx,%ecx
  80fbb7:	7f 02                	jg     80fbbb <tcp_process+0x43>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
  80fbb9:	b3 01                	mov    $0x1,%bl
      }
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags = TF_RESET;
      pcb->flags &= ~TF_ACK_DELAY;
      return ERR_RST;
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
  80fbbb:	b8 00 00 00 00       	mov    $0x0,%eax
  80fbc0:	84 db                	test   %bl,%bl
  80fbc2:	0f 84 9b 05 00 00    	je     810163 <tcp_process+0x5eb>
  80fbc8:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  80fbcc:	75 17                	jne    80fbe5 <tcp_process+0x6d>
  80fbce:	83 ec 04             	sub    $0x4,%esp
  80fbd1:	68 78 45 81 00       	push   $0x814578
  80fbd6:	68 09 02 00 00       	push   $0x209
  80fbdb:	68 e0 45 81 00       	push   $0x8145e0
  80fbe0:	e8 e7 0e ff ff       	call   800acc <_panic>
  80fbe5:	c6 05 e4 e5 b3 00 08 	movb   $0x8,0xb3e5e4
  80fbec:	80 66 20 fe          	andb   $0xfe,0x20(%esi)
  80fbf0:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  80fbf5:	e9 69 05 00 00       	jmp    810163 <tcp_process+0x5eb>
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  80fbfa:	a1 6c e6 b3 00       	mov    0xb3e66c,%eax
  80fbff:	89 46 2c             	mov    %eax,0x2c(%esi)
  pcb->keep_cnt_sent = 0;
  80fc02:	c6 86 a5 00 00 00 00 	movb   $0x0,0xa5(%esi)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  80fc09:	83 7e 10 09          	cmpl   $0x9,0x10(%esi)
  80fc0d:	0f 87 4b 05 00 00    	ja     81015e <tcp_process+0x5e6>
  80fc13:	8b 46 10             	mov    0x10(%esi),%eax
  80fc16:	ff 24 85 64 46 81 00 	jmp    *0x814664(,%eax,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80fc1d:	0f b6 05 e0 e5 b3 00 	movzbl 0xb3e5e0,%eax
  80fc24:	a8 10                	test   $0x10,%al
  80fc26:	0f 84 16 01 00 00    	je     80fd42 <tcp_process+0x1ca>
  80fc2c:	a8 02                	test   $0x2,%al
  80fc2e:	0f 84 0e 01 00 00    	je     80fd42 <tcp_process+0x1ca>
  80fc34:	83 ec 0c             	sub    $0xc,%esp
  80fc37:	8b 46 78             	mov    0x78(%esi),%eax
  80fc3a:	8b 40 10             	mov    0x10(%eax),%eax
  80fc3d:	ff 70 04             	pushl  0x4(%eax)
  80fc40:	e8 71 aa ff ff       	call   80a6b6 <ntohl>
  80fc45:	40                   	inc    %eax
  80fc46:	83 c4 10             	add    $0x10,%esp
  80fc49:	3b 05 dc e5 b3 00    	cmp    0xb3e5dc,%eax
  80fc4f:	0f 85 ed 00 00 00    	jne    80fd42 <tcp_process+0x1ca>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
  80fc55:	66 ff 46 6e          	incw   0x6e(%esi)
      pcb->rcv_nxt = seqno + 1;
  80fc59:	a1 d8 e5 b3 00       	mov    0xb3e5d8,%eax
  80fc5e:	40                   	inc    %eax
  80fc5f:	89 46 24             	mov    %eax,0x24(%esi)
      pcb->lastack = ackno;
  80fc62:	a1 dc e5 b3 00       	mov    0xb3e5dc,%eax
  80fc67:	89 46 48             	mov    %eax,0x48(%esi)
      pcb->snd_wnd = tcphdr->wnd;
  80fc6a:	a1 d0 e5 b3 00       	mov    0xb3e5d0,%eax
  80fc6f:	66 8b 40 0e          	mov    0xe(%eax),%ax
  80fc73:	66 89 46 5c          	mov    %ax,0x5c(%esi)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80fc77:	a1 d8 e5 b3 00       	mov    0xb3e5d8,%eax
  80fc7c:	48                   	dec    %eax
  80fc7d:	89 46 60             	mov    %eax,0x60(%esi)
      pcb->state = ESTABLISHED;
  80fc80:	c7 46 10 04 00 00 00 	movl   $0x4,0x10(%esi)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  80fc87:	83 ec 0c             	sub    $0xc,%esp
  80fc8a:	56                   	push   %esi
  80fc8b:	e8 b6 11 00 00       	call   810e46 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80fc90:	83 c4 08             	add    $0x8,%esp
  80fc93:	8d 46 04             	lea    0x4(%esi),%eax
  80fc96:	50                   	push   %eax
  80fc97:	0f b7 46 34          	movzwl 0x34(%esi),%eax
  80fc9b:	50                   	push   %eax
  80fc9c:	e8 c0 94 ff ff       	call   809161 <tcp_eff_send_mss>
  80fca1:	66 89 46 34          	mov    %ax,0x34(%esi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  80fca5:	0f b7 d0             	movzwl %ax,%edx
  80fca8:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80fcab:	d1 e0                	shl    %eax
  80fcad:	66 89 46 50          	mov    %ax,0x50(%esi)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80fcb1:	83 c4 10             	add    $0x10,%esp
  80fcb4:	8d 04 12             	lea    (%edx,%edx,1),%eax
  80fcb7:	66 83 7e 4e 01       	cmpw   $0x1,0x4e(%esi)
  80fcbc:	74 04                	je     80fcc2 <tcp_process+0x14a>
  80fcbe:	66 8b 46 34          	mov    0x34(%esi),%ax
  80fcc2:	66 89 46 4e          	mov    %ax,0x4e(%esi)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80fcc6:	66 83 7e 70 00       	cmpw   $0x0,0x70(%esi)
  80fccb:	75 17                	jne    80fce4 <tcp_process+0x16c>
  80fccd:	83 ec 04             	sub    $0x4,%esp
  80fcd0:	68 f7 45 81 00       	push   $0x8145f7
  80fcd5:	68 35 02 00 00       	push   $0x235
  80fcda:	68 e0 45 81 00       	push   $0x8145e0
  80fcdf:	e8 e8 0d ff ff       	call   800acc <_panic>
      --pcb->snd_queuelen;
  80fce4:	66 ff 4e 70          	decw   0x70(%esi)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  80fce8:	8b 56 78             	mov    0x78(%esi),%edx
      pcb->unacked = rseg->next;
  80fceb:	8b 02                	mov    (%edx),%eax
  80fced:	89 46 78             	mov    %eax,0x78(%esi)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80fcf0:	85 c0                	test   %eax,%eax
  80fcf2:	75 08                	jne    80fcfc <tcp_process+0x184>
        pcb->rtime = -1;
  80fcf4:	66 c7 46 32 ff ff    	movw   $0xffff,0x32(%esi)
  80fcfa:	eb 0a                	jmp    80fd06 <tcp_process+0x18e>
      else {
        pcb->rtime = 0;
  80fcfc:	66 c7 46 32 00 00    	movw   $0x0,0x32(%esi)
        pcb->nrtx = 0;
  80fd02:	c6 46 46 00          	movb   $0x0,0x46(%esi)
      }

      tcp_seg_free(rseg);
  80fd06:	83 ec 0c             	sub    $0xc,%esp
  80fd09:	52                   	push   %edx
  80fd0a:	e8 e8 8f ff ff       	call   808cf7 <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80fd0f:	83 c4 10             	add    $0x10,%esp
  80fd12:	83 be 8c 00 00 00 00 	cmpl   $0x0,0x8c(%esi)
  80fd19:	74 12                	je     80fd2d <tcp_process+0x1b5>
  80fd1b:	83 ec 04             	sub    $0x4,%esp
  80fd1e:	6a 00                	push   $0x0
  80fd20:	56                   	push   %esi
  80fd21:	ff 76 18             	pushl  0x18(%esi)
  80fd24:	ff 96 8c 00 00 00    	call   *0x8c(%esi)
  80fd2a:	83 c4 10             	add    $0x10,%esp
      tcp_ack_now(pcb);
  80fd2d:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  80fd31:	83 ec 0c             	sub    $0xc,%esp
  80fd34:	56                   	push   %esi
  80fd35:	e8 78 b0 ff ff       	call   80adb2 <tcp_output>
  80fd3a:	83 c4 10             	add    $0x10,%esp
  80fd3d:	e9 1c 04 00 00       	jmp    81015e <tcp_process+0x5e6>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  80fd42:	f6 05 e0 e5 b3 00 10 	testb  $0x10,0xb3e5e0
  80fd49:	0f 84 0f 04 00 00    	je     81015e <tcp_process+0x5e6>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80fd4f:	83 ec 08             	sub    $0x8,%esp
  80fd52:	8b 15 d0 e5 b3 00    	mov    0xb3e5d0,%edx
  80fd58:	0f b7 02             	movzwl (%edx),%eax
  80fd5b:	50                   	push   %eax
  80fd5c:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80fd60:	50                   	push   %eax
  80fd61:	a1 d4 e5 b3 00       	mov    0xb3e5d4,%eax
  80fd66:	8d 50 0c             	lea    0xc(%eax),%edx
  80fd69:	52                   	push   %edx
  80fd6a:	83 c0 10             	add    $0x10,%eax
  80fd6d:	50                   	push   %eax
  80fd6e:	0f b7 05 e2 e5 b3 00 	movzwl 0xb3e5e2,%eax
  80fd75:	03 05 d8 e5 b3 00    	add    0xb3e5d8,%eax
  80fd7b:	50                   	push   %eax
  80fd7c:	ff 35 dc e5 b3 00    	pushl  0xb3e5dc
  80fd82:	e8 db b4 ff ff       	call   80b262 <tcp_rst>
  80fd87:	83 c4 20             	add    $0x20,%esp
        tcphdr->dest, tcphdr->src);
    }
    break;
  80fd8a:	e9 cf 03 00 00       	jmp    81015e <tcp_process+0x5e6>
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  80fd8f:	0f b6 05 e0 e5 b3 00 	movzbl 0xb3e5e0,%eax
  80fd96:	a8 10                	test   $0x10,%al
  80fd98:	0f 84 c0 03 00 00    	je     81015e <tcp_process+0x5e6>
  80fd9e:	a8 04                	test   $0x4,%al
  80fda0:	0f 85 b8 03 00 00    	jne    81015e <tcp_process+0x5e6>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80fda6:	8b 15 dc e5 b3 00    	mov    0xb3e5dc,%edx
  80fdac:	89 d0                	mov    %edx,%eax
  80fdae:	2b 46 48             	sub    0x48(%esi),%eax
  80fdb1:	48                   	dec    %eax
  80fdb2:	0f 88 b6 00 00 00    	js     80fe6e <tcp_process+0x2f6>
  80fdb8:	89 d0                	mov    %edx,%eax
  80fdba:	2b 46 54             	sub    0x54(%esi),%eax
  80fdbd:	85 c0                	test   %eax,%eax
  80fdbf:	0f 8f a9 00 00 00    	jg     80fe6e <tcp_process+0x2f6>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  80fdc5:	c7 46 10 04 00 00 00 	movl   $0x4,0x10(%esi)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80fdcc:	83 be 90 00 00 00 00 	cmpl   $0x0,0x90(%esi)
  80fdd3:	75 17                	jne    80fdec <tcp_process+0x274>
  80fdd5:	83 ec 04             	sub    $0x4,%esp
  80fdd8:	68 0d 46 81 00       	push   $0x81460d
  80fddd:	68 5b 02 00 00       	push   $0x25b
  80fde2:	68 e0 45 81 00       	push   $0x8145e0
  80fde7:	e8 e0 0c ff ff       	call   800acc <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80fdec:	83 ec 04             	sub    $0x4,%esp
  80fdef:	6a 00                	push   $0x0
  80fdf1:	56                   	push   %esi
  80fdf2:	ff 76 18             	pushl  0x18(%esi)
  80fdf5:	ff 96 90 00 00 00    	call   *0x90(%esi)
  80fdfb:	83 c4 10             	add    $0x10,%esp
        if (err != ERR_OK) {
  80fdfe:	84 c0                	test   %al,%al
  80fe00:	74 13                	je     80fe15 <tcp_process+0x29d>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  80fe02:	83 ec 0c             	sub    $0xc,%esp
  80fe05:	56                   	push   %esi
  80fe06:	e8 3e 84 ff ff       	call   808249 <tcp_abort>
          return ERR_ABRT;
  80fe0b:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80fe10:	e9 4e 03 00 00       	jmp    810163 <tcp_process+0x5eb>
        }
        old_cwnd = pcb->cwnd;
  80fe15:	66 8b 5e 4e          	mov    0x4e(%esi),%bx
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  80fe19:	83 ec 0c             	sub    $0xc,%esp
  80fe1c:	56                   	push   %esi
  80fe1d:	e8 48 03 00 00       	call   81016a <tcp_receive>
  80fe22:	88 c2                	mov    %al,%dl

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80fe24:	83 c4 10             	add    $0x10,%esp
  80fe27:	66 83 fb 01          	cmp    $0x1,%bx
  80fe2b:	75 08                	jne    80fe35 <tcp_process+0x2bd>
  80fe2d:	0f b7 46 34          	movzwl 0x34(%esi),%eax
  80fe31:	d1 e0                	shl    %eax
  80fe33:	eb 04                	jmp    80fe39 <tcp_process+0x2c1>
  80fe35:	66 8b 46 34          	mov    0x34(%esi),%ax
  80fe39:	66 89 46 4e          	mov    %ax,0x4e(%esi)

        if ((flags & TCP_FIN) && accepted_inseq) {
  80fe3d:	f6 05 e0 e5 b3 00 01 	testb  $0x1,0xb3e5e0
  80fe44:	0f 84 14 03 00 00    	je     81015e <tcp_process+0x5e6>
  80fe4a:	84 d2                	test   %dl,%dl
  80fe4c:	0f 84 0c 03 00 00    	je     81015e <tcp_process+0x5e6>
          tcp_ack_now(pcb);
  80fe52:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  80fe56:	83 ec 0c             	sub    $0xc,%esp
  80fe59:	56                   	push   %esi
  80fe5a:	e8 53 af ff ff       	call   80adb2 <tcp_output>
          pcb->state = CLOSE_WAIT;
  80fe5f:	c7 46 10 07 00 00 00 	movl   $0x7,0x10(%esi)
  80fe66:	83 c4 10             	add    $0x10,%esp
  80fe69:	e9 f0 02 00 00       	jmp    81015e <tcp_process+0x5e6>
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80fe6e:	83 ec 08             	sub    $0x8,%esp
  80fe71:	8b 15 d0 e5 b3 00    	mov    0xb3e5d0,%edx
  80fe77:	0f b7 02             	movzwl (%edx),%eax
  80fe7a:	50                   	push   %eax
  80fe7b:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80fe7f:	50                   	push   %eax
  80fe80:	a1 d4 e5 b3 00       	mov    0xb3e5d4,%eax
  80fe85:	8d 50 0c             	lea    0xc(%eax),%edx
  80fe88:	52                   	push   %edx
  80fe89:	83 c0 10             	add    $0x10,%eax
  80fe8c:	50                   	push   %eax
  80fe8d:	0f b7 05 e2 e5 b3 00 	movzwl 0xb3e5e2,%eax
  80fe94:	03 05 d8 e5 b3 00    	add    0xb3e5d8,%eax
  80fe9a:	50                   	push   %eax
  80fe9b:	ff 35 dc e5 b3 00    	pushl  0xb3e5dc
  80fea1:	e8 bc b3 ff ff       	call   80b262 <tcp_rst>
  80fea6:	83 c4 20             	add    $0x20,%esp
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
  80fea9:	e9 b0 02 00 00       	jmp    81015e <tcp_process+0x5e6>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  80feae:	83 ec 0c             	sub    $0xc,%esp
  80feb1:	56                   	push   %esi
  80feb2:	e8 b3 02 00 00       	call   81016a <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80feb7:	83 c4 10             	add    $0x10,%esp
  80feba:	f6 05 e0 e5 b3 00 01 	testb  $0x1,0xb3e5e0
  80fec1:	0f 84 97 02 00 00    	je     81015e <tcp_process+0x5e6>
  80fec7:	84 c0                	test   %al,%al
  80fec9:	0f 84 8f 02 00 00    	je     81015e <tcp_process+0x5e6>
      tcp_ack_now(pcb);
  80fecf:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  80fed3:	83 ec 0c             	sub    $0xc,%esp
  80fed6:	56                   	push   %esi
  80fed7:	e8 d6 ae ff ff       	call   80adb2 <tcp_output>
      pcb->state = CLOSE_WAIT;
  80fedc:	c7 46 10 07 00 00 00 	movl   $0x7,0x10(%esi)
  80fee3:	83 c4 10             	add    $0x10,%esp
    }
    break;
  80fee6:	e9 73 02 00 00       	jmp    81015e <tcp_process+0x5e6>
  case FIN_WAIT_1:
    tcp_receive(pcb);
  80feeb:	83 ec 0c             	sub    $0xc,%esp
  80feee:	56                   	push   %esi
  80feef:	e8 76 02 00 00       	call   81016a <tcp_receive>
    if (flags & TCP_FIN) {
  80fef4:	0f b6 05 e0 e5 b3 00 	movzbl 0xb3e5e0,%eax
  80fefb:	83 c4 10             	add    $0x10,%esp
  80fefe:	a8 01                	test   $0x1,%al
  80ff00:	0f 84 bb 00 00 00    	je     80ffc1 <tcp_process+0x449>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80ff06:	a8 10                	test   $0x10,%al
  80ff08:	0f 84 97 00 00 00    	je     80ffa5 <tcp_process+0x42d>
  80ff0e:	8b 46 54             	mov    0x54(%esi),%eax
  80ff11:	3b 05 dc e5 b3 00    	cmp    0xb3e5dc,%eax
  80ff17:	0f 85 88 00 00 00    	jne    80ffa5 <tcp_process+0x42d>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  80ff1d:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  80ff21:	83 ec 0c             	sub    $0xc,%esp
  80ff24:	56                   	push   %esi
  80ff25:	e8 88 ae ff ff       	call   80adb2 <tcp_output>
        tcp_pcb_purge(pcb);
  80ff2a:	89 34 24             	mov    %esi,(%esp)
  80ff2d:	e8 ab 90 ff ff       	call   808fdd <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80ff32:	83 c4 10             	add    $0x10,%esp
  80ff35:	39 35 68 e6 b3 00    	cmp    %esi,0xb3e668
  80ff3b:	75 12                	jne    80ff4f <tcp_process+0x3d7>
  80ff3d:	8b 46 0c             	mov    0xc(%esi),%eax
  80ff40:	a3 68 e6 b3 00       	mov    %eax,0xb3e668
  80ff45:	eb 38                	jmp    80ff7f <tcp_process+0x407>
  80ff47:	8b 46 0c             	mov    0xc(%esi),%eax
  80ff4a:	89 42 0c             	mov    %eax,0xc(%edx)
  80ff4d:	eb 30                	jmp    80ff7f <tcp_process+0x407>
  80ff4f:	a1 68 e6 b3 00       	mov    0xb3e668,%eax
  80ff54:	a3 74 e6 b3 00       	mov    %eax,0xb3e674
  80ff59:	85 c0                	test   %eax,%eax
  80ff5b:	74 22                	je     80ff7f <tcp_process+0x407>
  80ff5d:	8b 15 74 e6 b3 00    	mov    0xb3e674,%edx
  80ff63:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  80ff67:	74 05                	je     80ff6e <tcp_process+0x3f6>
  80ff69:	39 72 0c             	cmp    %esi,0xc(%edx)
  80ff6c:	74 d9                	je     80ff47 <tcp_process+0x3cf>
  80ff6e:	a1 74 e6 b3 00       	mov    0xb3e674,%eax
  80ff73:	8b 40 0c             	mov    0xc(%eax),%eax
  80ff76:	a3 74 e6 b3 00       	mov    %eax,0xb3e674
  80ff7b:	85 c0                	test   %eax,%eax
  80ff7d:	75 de                	jne    80ff5d <tcp_process+0x3e5>
  80ff7f:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
        pcb->state = TIME_WAIT;
  80ff86:	c7 46 10 0a 00 00 00 	movl   $0xa,0x10(%esi)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80ff8d:	a1 7c e6 b3 00       	mov    0xb3e67c,%eax
  80ff92:	89 46 0c             	mov    %eax,0xc(%esi)
  80ff95:	89 35 7c e6 b3 00    	mov    %esi,0xb3e67c
  80ff9b:	e8 ae 4b ff ff       	call   804b4e <tcp_timer_needed>
  80ffa0:	e9 b9 01 00 00       	jmp    81015e <tcp_process+0x5e6>
      } else {
        tcp_ack_now(pcb);
  80ffa5:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  80ffa9:	83 ec 0c             	sub    $0xc,%esp
  80ffac:	56                   	push   %esi
  80ffad:	e8 00 ae ff ff       	call   80adb2 <tcp_output>
        pcb->state = CLOSING;
  80ffb2:	c7 46 10 08 00 00 00 	movl   $0x8,0x10(%esi)
  80ffb9:	83 c4 10             	add    $0x10,%esp
  80ffbc:	e9 9d 01 00 00       	jmp    81015e <tcp_process+0x5e6>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80ffc1:	f6 05 e0 e5 b3 00 10 	testb  $0x10,0xb3e5e0
  80ffc8:	0f 84 90 01 00 00    	je     81015e <tcp_process+0x5e6>
  80ffce:	8b 46 54             	mov    0x54(%esi),%eax
  80ffd1:	3b 05 dc e5 b3 00    	cmp    0xb3e5dc,%eax
  80ffd7:	0f 85 81 01 00 00    	jne    81015e <tcp_process+0x5e6>
      pcb->state = FIN_WAIT_2;
  80ffdd:	c7 46 10 06 00 00 00 	movl   $0x6,0x10(%esi)
    }
    break;
  80ffe4:	e9 75 01 00 00       	jmp    81015e <tcp_process+0x5e6>
  case FIN_WAIT_2:
    tcp_receive(pcb);
  80ffe9:	83 ec 0c             	sub    $0xc,%esp
  80ffec:	56                   	push   %esi
  80ffed:	e8 78 01 00 00       	call   81016a <tcp_receive>
    if (flags & TCP_FIN) {
  80fff2:	83 c4 10             	add    $0x10,%esp
  80fff5:	f6 05 e0 e5 b3 00 01 	testb  $0x1,0xb3e5e0
  80fffc:	0f 84 5c 01 00 00    	je     81015e <tcp_process+0x5e6>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  810002:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  810006:	83 ec 0c             	sub    $0xc,%esp
  810009:	56                   	push   %esi
  81000a:	e8 a3 ad ff ff       	call   80adb2 <tcp_output>
      tcp_pcb_purge(pcb);
  81000f:	89 34 24             	mov    %esi,(%esp)
  810012:	e8 c6 8f ff ff       	call   808fdd <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  810017:	83 c4 10             	add    $0x10,%esp
  81001a:	39 35 68 e6 b3 00    	cmp    %esi,0xb3e668
  810020:	75 12                	jne    810034 <tcp_process+0x4bc>
  810022:	8b 46 0c             	mov    0xc(%esi),%eax
  810025:	a3 68 e6 b3 00       	mov    %eax,0xb3e668
  81002a:	eb 38                	jmp    810064 <tcp_process+0x4ec>
  81002c:	8b 46 0c             	mov    0xc(%esi),%eax
  81002f:	89 42 0c             	mov    %eax,0xc(%edx)
  810032:	eb 30                	jmp    810064 <tcp_process+0x4ec>
  810034:	a1 68 e6 b3 00       	mov    0xb3e668,%eax
  810039:	a3 74 e6 b3 00       	mov    %eax,0xb3e674
  81003e:	85 c0                	test   %eax,%eax
  810040:	74 22                	je     810064 <tcp_process+0x4ec>
  810042:	8b 15 74 e6 b3 00    	mov    0xb3e674,%edx
  810048:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  81004c:	74 05                	je     810053 <tcp_process+0x4db>
  81004e:	39 72 0c             	cmp    %esi,0xc(%edx)
  810051:	74 d9                	je     81002c <tcp_process+0x4b4>
  810053:	a1 74 e6 b3 00       	mov    0xb3e674,%eax
  810058:	8b 40 0c             	mov    0xc(%eax),%eax
  81005b:	a3 74 e6 b3 00       	mov    %eax,0xb3e674
  810060:	85 c0                	test   %eax,%eax
  810062:	75 de                	jne    810042 <tcp_process+0x4ca>
  810064:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
      pcb->state = TIME_WAIT;
  81006b:	c7 46 10 0a 00 00 00 	movl   $0xa,0x10(%esi)
      TCP_REG(&tcp_tw_pcbs, pcb);
  810072:	a1 7c e6 b3 00       	mov    0xb3e67c,%eax
  810077:	89 46 0c             	mov    %eax,0xc(%esi)
  81007a:	89 35 7c e6 b3 00    	mov    %esi,0xb3e67c
  810080:	e8 c9 4a ff ff       	call   804b4e <tcp_timer_needed>
    }
    break;
  810085:	e9 d4 00 00 00       	jmp    81015e <tcp_process+0x5e6>
  case CLOSING:
    tcp_receive(pcb);
  81008a:	83 ec 0c             	sub    $0xc,%esp
  81008d:	56                   	push   %esi
  81008e:	e8 d7 00 00 00       	call   81016a <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  810093:	83 c4 10             	add    $0x10,%esp
  810096:	f6 05 e0 e5 b3 00 10 	testb  $0x10,0xb3e5e0
  81009d:	0f 84 bb 00 00 00    	je     81015e <tcp_process+0x5e6>
  8100a3:	8b 46 54             	mov    0x54(%esi),%eax
  8100a6:	3b 05 dc e5 b3 00    	cmp    0xb3e5dc,%eax
  8100ac:	0f 85 ac 00 00 00    	jne    81015e <tcp_process+0x5e6>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  8100b2:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  8100b6:	83 ec 0c             	sub    $0xc,%esp
  8100b9:	56                   	push   %esi
  8100ba:	e8 f3 ac ff ff       	call   80adb2 <tcp_output>
      tcp_pcb_purge(pcb);
  8100bf:	89 34 24             	mov    %esi,(%esp)
  8100c2:	e8 16 8f ff ff       	call   808fdd <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  8100c7:	83 c4 10             	add    $0x10,%esp
  8100ca:	39 35 68 e6 b3 00    	cmp    %esi,0xb3e668
  8100d0:	75 12                	jne    8100e4 <tcp_process+0x56c>
  8100d2:	8b 46 0c             	mov    0xc(%esi),%eax
  8100d5:	a3 68 e6 b3 00       	mov    %eax,0xb3e668
  8100da:	eb 38                	jmp    810114 <tcp_process+0x59c>
  8100dc:	8b 46 0c             	mov    0xc(%esi),%eax
  8100df:	89 42 0c             	mov    %eax,0xc(%edx)
  8100e2:	eb 30                	jmp    810114 <tcp_process+0x59c>
  8100e4:	a1 68 e6 b3 00       	mov    0xb3e668,%eax
  8100e9:	a3 74 e6 b3 00       	mov    %eax,0xb3e674
  8100ee:	85 c0                	test   %eax,%eax
  8100f0:	74 22                	je     810114 <tcp_process+0x59c>
  8100f2:	8b 15 74 e6 b3 00    	mov    0xb3e674,%edx
  8100f8:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  8100fc:	74 05                	je     810103 <tcp_process+0x58b>
  8100fe:	39 72 0c             	cmp    %esi,0xc(%edx)
  810101:	74 d9                	je     8100dc <tcp_process+0x564>
  810103:	a1 74 e6 b3 00       	mov    0xb3e674,%eax
  810108:	8b 40 0c             	mov    0xc(%eax),%eax
  81010b:	a3 74 e6 b3 00       	mov    %eax,0xb3e674
  810110:	85 c0                	test   %eax,%eax
  810112:	75 de                	jne    8100f2 <tcp_process+0x57a>
  810114:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
      pcb->state = TIME_WAIT;
  81011b:	c7 46 10 0a 00 00 00 	movl   $0xa,0x10(%esi)
      TCP_REG(&tcp_tw_pcbs, pcb);
  810122:	a1 7c e6 b3 00       	mov    0xb3e67c,%eax
  810127:	89 46 0c             	mov    %eax,0xc(%esi)
  81012a:	89 35 7c e6 b3 00    	mov    %esi,0xb3e67c
  810130:	e8 19 4a ff ff       	call   804b4e <tcp_timer_needed>
    }
    break;
  810135:	eb 27                	jmp    81015e <tcp_process+0x5e6>
  case LAST_ACK:
    tcp_receive(pcb);
  810137:	83 ec 0c             	sub    $0xc,%esp
  81013a:	56                   	push   %esi
  81013b:	e8 2a 00 00 00       	call   81016a <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  810140:	83 c4 10             	add    $0x10,%esp
  810143:	f6 05 e0 e5 b3 00 10 	testb  $0x10,0xb3e5e0
  81014a:	74 12                	je     81015e <tcp_process+0x5e6>
  81014c:	8b 46 54             	mov    0x54(%esi),%eax
  81014f:	3b 05 dc e5 b3 00    	cmp    0xb3e5dc,%eax
  810155:	75 07                	jne    81015e <tcp_process+0x5e6>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  810157:	c6 05 e4 e5 b3 00 10 	movb   $0x10,0xb3e5e4
    }
    break;
  default:
    break;
  }
  return ERR_OK;
  81015e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810163:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  810166:	5b                   	pop    %ebx
  810167:	5e                   	pop    %esi
  810168:	c9                   	leave  
  810169:	c3                   	ret    

0081016a <tcp_receive>:

/**
 * Called by tcp_process. Checks if the given segment is an ACK for outstanding
 * data, and if so frees the memory of the buffered data. Next, is places the
 * segment on any of the receive queues (pcb->recved or pcb->ooseq). If the segment
 * is buffered, the pbuf is referenced by pbuf_ref so that it will not be freed until
 * i it has been removed from the buffer.
 *
 * If the incoming segment constitutes an ACK for a segment that was used for RTT
 * estimation, the RTT is estimated here as well.
 *
 * Called from tcp_process().
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  81016a:	55                   	push   %ebp
  81016b:	89 e5                	mov    %esp,%ebp
  81016d:	57                   	push   %edi
  81016e:	56                   	push   %esi
  81016f:	53                   	push   %ebx
  810170:	83 ec 2c             	sub    $0x2c,%esp
  810173:	8b 75 08             	mov    0x8(%ebp),%esi
  struct tcp_seg *next;
#if TCP_QUEUE_OOSEQ
  struct tcp_seg *prev, *cseg;
#endif
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  810176:	c6 45 ef 00          	movb   $0x0,0xffffffef(%ebp)

  if (flags & TCP_ACK) {
  81017a:	f6 05 e0 e5 b3 00 10 	testb  $0x10,0xb3e5e0
  810181:	0f 84 75 04 00 00    	je     8105fc <tcp_receive+0x492>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  810187:	0f b7 56 5c          	movzwl 0x5c(%esi),%edx
  81018b:	8b 46 60             	mov    0x60(%esi),%eax
  81018e:	01 c2                	add    %eax,%edx

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  810190:	3b 05 d8 e5 b3 00    	cmp    0xb3e5d8,%eax
  810196:	78 2c                	js     8101c4 <tcp_receive+0x5a>
  810198:	3b 05 d8 e5 b3 00    	cmp    0xb3e5d8,%eax
  81019e:	75 0a                	jne    8101aa <tcp_receive+0x40>
  8101a0:	a1 dc e5 b3 00       	mov    0xb3e5dc,%eax
  8101a5:	39 46 64             	cmp    %eax,0x64(%esi)
  8101a8:	78 1a                	js     8101c4 <tcp_receive+0x5a>
  8101aa:	8b 46 64             	mov    0x64(%esi),%eax
  8101ad:	3b 05 dc e5 b3 00    	cmp    0xb3e5dc,%eax
  8101b3:	75 43                	jne    8101f8 <tcp_receive+0x8e>
  8101b5:	a1 d0 e5 b3 00       	mov    0xb3e5d0,%eax
  8101ba:	66 8b 40 0e          	mov    0xe(%eax),%ax
  8101be:	66 3b 46 5c          	cmp    0x5c(%esi),%ax
  8101c2:	76 34                	jbe    8101f8 <tcp_receive+0x8e>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
  8101c4:	a1 d0 e5 b3 00       	mov    0xb3e5d0,%eax
  8101c9:	66 8b 40 0e          	mov    0xe(%eax),%ax
  8101cd:	66 89 46 5c          	mov    %ax,0x5c(%esi)
      pcb->snd_wl1 = seqno;
  8101d1:	a1 d8 e5 b3 00       	mov    0xb3e5d8,%eax
  8101d6:	89 46 60             	mov    %eax,0x60(%esi)
      pcb->snd_wl2 = ackno;
  8101d9:	a1 dc e5 b3 00       	mov    0xb3e5dc,%eax
  8101de:	89 46 64             	mov    %eax,0x64(%esi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  8101e1:	66 83 7e 5c 00       	cmpw   $0x0,0x5c(%esi)
  8101e6:	74 10                	je     8101f8 <tcp_receive+0x8e>
  8101e8:	80 be a4 00 00 00 00 	cmpb   $0x0,0xa4(%esi)
  8101ef:	74 07                	je     8101f8 <tcp_receive+0x8e>
          pcb->persist_backoff = 0;
  8101f1:	c6 86 a4 00 00 00 00 	movb   $0x0,0xa4(%esi)
      }
      LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %"U16_F"\n", pcb->snd_wnd));
#if TCP_WND_DEBUG
    } else {
      if (pcb->snd_wnd != tcphdr->wnd) {
        LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: no window update lastack %"U32_F" snd_max %"U32_F" ackno %"U32_F" wl1 %"U32_F" seqno %"U32_F" wl2 %"U32_F"\n",
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  8101f8:	8b 46 48             	mov    0x48(%esi),%eax
  8101fb:	3b 05 dc e5 b3 00    	cmp    0xb3e5dc,%eax
  810201:	0f 85 ab 00 00 00    	jne    8102b2 <tcp_receive+0x148>
      pcb->acked = 0;
  810207:	66 c7 46 6c 00 00    	movw   $0x0,0x6c(%esi)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  81020d:	0f b7 46 5c          	movzwl 0x5c(%esi),%eax
  810211:	03 46 60             	add    0x60(%esi),%eax
  810214:	39 d0                	cmp    %edx,%eax
  810216:	0f 85 03 03 00 00    	jne    81051f <tcp_receive+0x3b5>
        ++pcb->dupacks;
  81021c:	fe 46 4c             	incb   0x4c(%esi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  81021f:	80 7e 4c 02          	cmpb   $0x2,0x4c(%esi)
  810223:	0f 86 f6 02 00 00    	jbe    81051f <tcp_receive+0x3b5>
  810229:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  81022d:	0f 84 ec 02 00 00    	je     81051f <tcp_receive+0x3b5>
          if (!(pcb->flags & TF_INFR)) {
  810233:	f6 46 20 04          	testb  $0x4,0x20(%esi)
  810237:	75 5e                	jne    810297 <tcp_receive+0x12d>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  810239:	83 ec 0c             	sub    $0xc,%esp
  81023c:	56                   	push   %esi
  81023d:	e8 a1 b1 ff ff       	call   80b3e3 <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  810242:	83 c4 10             	add    $0x10,%esp
  810245:	66 8b 46 4e          	mov    0x4e(%esi),%ax
  810249:	66 3b 46 5c          	cmp    0x5c(%esi),%ax
  81024d:	76 0d                	jbe    81025c <tcp_receive+0xf2>
              pcb->ssthresh = pcb->snd_wnd / 2;
  81024f:	66 8b 46 5c          	mov    0x5c(%esi),%ax
  810253:	66 d1 e8             	shr    %ax
  810256:	66 89 46 50          	mov    %ax,0x50(%esi)
  81025a:	eb 0b                	jmp    810267 <tcp_receive+0xfd>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  81025c:	66 8b 46 4e          	mov    0x4e(%esi),%ax
  810260:	66 d1 e8             	shr    %ax
  810263:	66 89 46 50          	mov    %ax,0x50(%esi)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  810267:	0f b7 56 50          	movzwl 0x50(%esi),%edx
  81026b:	0f b7 46 34          	movzwl 0x34(%esi),%eax
  81026f:	d1 e0                	shl    %eax
  810271:	39 c2                	cmp    %eax,%edx
  810273:	7d 0a                	jge    81027f <tcp_receive+0x115>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  810275:	0f b7 46 34          	movzwl 0x34(%esi),%eax
  810279:	d1 e0                	shl    %eax
  81027b:	66 89 46 50          	mov    %ax,0x50(%esi)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  81027f:	0f b7 46 34          	movzwl 0x34(%esi),%eax
  810283:	8d 04 40             	lea    (%eax,%eax,2),%eax
  810286:	66 03 46 50          	add    0x50(%esi),%ax
  81028a:	66 89 46 4e          	mov    %ax,0x4e(%esi)
            pcb->flags |= TF_INFR;
  81028e:	80 4e 20 04          	orb    $0x4,0x20(%esi)
  810292:	e9 88 02 00 00       	jmp    81051f <tcp_receive+0x3b5>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  810297:	66 8b 46 4e          	mov    0x4e(%esi),%ax
  81029b:	66 03 46 34          	add    0x34(%esi),%ax
  81029f:	66 3b 46 4e          	cmp    0x4e(%esi),%ax
  8102a3:	0f 86 76 02 00 00    	jbe    81051f <tcp_receive+0x3b5>
              pcb->cwnd += pcb->mss;
  8102a9:	66 89 46 4e          	mov    %ax,0x4e(%esi)
  8102ad:	e9 6d 02 00 00       	jmp    81051f <tcp_receive+0x3b5>
            }
          }
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  8102b2:	8b 15 dc e5 b3 00    	mov    0xb3e5dc,%edx
  8102b8:	89 d0                	mov    %edx,%eax
  8102ba:	2b 46 48             	sub    0x48(%esi),%eax
  8102bd:	48                   	dec    %eax
  8102be:	0f 88 b0 01 00 00    	js     810474 <tcp_receive+0x30a>
  8102c4:	89 d0                	mov    %edx,%eax
  8102c6:	2b 46 58             	sub    0x58(%esi),%eax
  8102c9:	85 c0                	test   %eax,%eax
  8102cb:	0f 8f a3 01 00 00    	jg     810474 <tcp_receive+0x30a>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  8102d1:	f6 46 20 04          	testb  $0x4,0x20(%esi)
  8102d5:	74 0c                	je     8102e3 <tcp_receive+0x179>
        pcb->flags &= ~TF_INFR;
  8102d7:	80 66 20 fb          	andb   $0xfb,0x20(%esi)
        pcb->cwnd = pcb->ssthresh;
  8102db:	66 8b 46 50          	mov    0x50(%esi),%ax
  8102df:	66 89 46 4e          	mov    %ax,0x4e(%esi)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  8102e3:	c6 46 46 00          	movb   $0x0,0x46(%esi)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  8102e7:	66 8b 46 40          	mov    0x40(%esi),%ax
  8102eb:	66 c1 f8 03          	sar    $0x3,%ax
  8102ef:	66 03 46 42          	add    0x42(%esi),%ax
  8102f3:	66 89 46 44          	mov    %ax,0x44(%esi)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  8102f7:	a1 dc e5 b3 00       	mov    0xb3e5dc,%eax
  8102fc:	66 2b 46 48          	sub    0x48(%esi),%ax
  810300:	66 89 46 6c          	mov    %ax,0x6c(%esi)

      pcb->snd_buf += pcb->acked;
  810304:	66 01 46 6e          	add    %ax,0x6e(%esi)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  810308:	c6 46 4c 00          	movb   $0x0,0x4c(%esi)
      pcb->lastack = ackno;
  81030c:	a1 dc e5 b3 00       	mov    0xb3e5dc,%eax
  810311:	89 46 48             	mov    %eax,0x48(%esi)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  810314:	83 7e 10 03          	cmpl   $0x3,0x10(%esi)
  810318:	0f 86 c4 00 00 00    	jbe    8103e2 <tcp_receive+0x278>
        if (pcb->cwnd < pcb->ssthresh) {
  81031e:	66 8b 46 4e          	mov    0x4e(%esi),%ax
  810322:	66 3b 46 50          	cmp    0x50(%esi),%ax
  810326:	73 17                	jae    81033f <tcp_receive+0x1d5>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  810328:	66 03 46 34          	add    0x34(%esi),%ax
  81032c:	66 3b 46 4e          	cmp    0x4e(%esi),%ax
  810330:	0f 86 ac 00 00 00    	jbe    8103e2 <tcp_receive+0x278>
            pcb->cwnd += pcb->mss;
  810336:	66 89 46 4e          	mov    %ax,0x4e(%esi)
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
  81033a:	e9 a3 00 00 00       	jmp    8103e2 <tcp_receive+0x278>
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  81033f:	0f b7 46 34          	movzwl 0x34(%esi),%eax
  810343:	0f af c0             	imul   %eax,%eax
  810346:	0f b7 56 4e          	movzwl 0x4e(%esi),%edx
  81034a:	89 d1                	mov    %edx,%ecx
  81034c:	99                   	cltd   
  81034d:	f7 f9                	idiv   %ecx
  81034f:	66 03 46 4e          	add    0x4e(%esi),%ax
          if (new_cwnd > pcb->cwnd) {
  810353:	66 39 46 4e          	cmp    %ax,0x4e(%esi)
  810357:	0f 83 85 00 00 00    	jae    8103e2 <tcp_receive+0x278>
            pcb->cwnd = new_cwnd;
  81035d:	66 89 46 4e          	mov    %ax,0x4e(%esi)
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: congestion avoidance cwnd %"U16_F"\n", pcb->cwnd));
        }
      }
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: ACK for %"U32_F", unacked->seqno %"U32_F":%"U32_F"\n",
                                    ackno,
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno): 0,
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  810361:	eb 7f                	jmp    8103e2 <tcp_receive+0x278>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
                         TCP_TCPLEN(pcb->unacked), ackno)) {
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  810363:	8b 5e 78             	mov    0x78(%esi),%ebx
        pcb->unacked = pcb->unacked->next;
  810366:	8b 03                	mov    (%ebx),%eax
  810368:	89 46 78             	mov    %eax,0x78(%esi)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81036b:	83 ec 0c             	sub    $0xc,%esp
  81036e:	ff 73 04             	pushl  0x4(%ebx)
  810371:	e8 72 76 ff ff       	call   8079e8 <pbuf_clen>
  810376:	66 0f b6 c0          	movzbw %al,%ax
  81037a:	83 c4 10             	add    $0x10,%esp
  81037d:	66 39 46 70          	cmp    %ax,0x70(%esi)
  810381:	73 17                	jae    81039a <tcp_receive+0x230>
  810383:	83 ec 04             	sub    $0x4,%esp
  810386:	68 98 45 81 00       	push   $0x814598
  81038b:	68 55 03 00 00       	push   $0x355
  810390:	68 e0 45 81 00       	push   $0x8145e0
  810395:	e8 32 07 ff ff       	call   800acc <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  81039a:	83 ec 0c             	sub    $0xc,%esp
  81039d:	ff 73 04             	pushl  0x4(%ebx)
  8103a0:	e8 43 76 ff ff       	call   8079e8 <pbuf_clen>
  8103a5:	66 0f b6 c0          	movzbw %al,%ax
  8103a9:	66 29 46 70          	sub    %ax,0x70(%esi)
        tcp_seg_free(next);
  8103ad:	89 1c 24             	mov    %ebx,(%esp)
  8103b0:	e8 42 89 ff ff       	call   808cf7 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
  8103b5:	83 c4 10             	add    $0x10,%esp
        if (pcb->snd_queuelen != 0) {
  8103b8:	66 83 7e 70 00       	cmpw   $0x0,0x70(%esi)
  8103bd:	74 23                	je     8103e2 <tcp_receive+0x278>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  8103bf:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  8103c3:	75 23                	jne    8103e8 <tcp_receive+0x27e>
  8103c5:	83 7e 74 00          	cmpl   $0x0,0x74(%esi)
  8103c9:	75 17                	jne    8103e2 <tcp_receive+0x278>
  8103cb:	83 ec 04             	sub    $0x4,%esp
  8103ce:	68 c0 45 81 00       	push   $0x8145c0
  8103d3:	68 5c 03 00 00       	push   $0x35c
  8103d8:	68 e0 45 81 00       	push   $0x8145e0
  8103dd:	e8 ea 06 ff ff       	call   800acc <_panic>
  8103e2:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  8103e6:	74 75                	je     81045d <tcp_receive+0x2f3>
  8103e8:	83 ec 0c             	sub    $0xc,%esp
  8103eb:	8b 46 78             	mov    0x78(%esi),%eax
  8103ee:	8b 40 10             	mov    0x10(%eax),%eax
  8103f1:	ff 70 04             	pushl  0x4(%eax)
  8103f4:	e8 bd a2 ff ff       	call   80a6b6 <ntohl>
  8103f9:	89 c7                	mov    %eax,%edi
  8103fb:	8b 46 78             	mov    0x78(%esi),%eax
  8103fe:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  810402:	c7 45 e8 00 00 00 00 	movl   $0x0,0xffffffe8(%ebp)
  810409:	8b 40 10             	mov    0x10(%eax),%eax
  81040c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810410:	89 04 24             	mov    %eax,(%esp)
  810413:	e8 5d a2 ff ff       	call   80a675 <ntohs>
  810418:	83 c4 10             	add    $0x10,%esp
  81041b:	a8 01                	test   $0x1,%al
  81041d:	75 1a                	jne    810439 <tcp_receive+0x2cf>
  81041f:	83 ec 0c             	sub    $0xc,%esp
  810422:	8b 46 78             	mov    0x78(%esi),%eax
  810425:	8b 40 10             	mov    0x10(%eax),%eax
  810428:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81042c:	50                   	push   %eax
  81042d:	e8 43 a2 ff ff       	call   80a675 <ntohs>
  810432:	83 c4 10             	add    $0x10,%esp
  810435:	a8 02                	test   $0x2,%al
  810437:	74 07                	je     810440 <tcp_receive+0x2d6>
  810439:	c7 45 e8 01 00 00 00 	movl   $0x1,0xffffffe8(%ebp)
  810440:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  810443:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  810446:	8d 04 07             	lea    (%edi,%eax,1),%eax
  810449:	2b 05 dc e5 b3 00    	sub    0xb3e5dc,%eax
  81044f:	85 c0                	test   %eax,%eax
  810451:	0f 8e 0c ff ff ff    	jle    810363 <tcp_receive+0x1f9>
                      pcb->unsent != NULL);
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  810457:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  81045b:	75 08                	jne    810465 <tcp_receive+0x2fb>
        pcb->rtime = -1;
  81045d:	66 c7 46 32 ff ff    	movw   $0xffff,0x32(%esi)
  810463:	eb 06                	jmp    81046b <tcp_receive+0x301>
      else
        pcb->rtime = 0;
  810465:	66 c7 46 32 00 00    	movw   $0x0,0x32(%esi)

      pcb->polltmr = 0;
  81046b:	c6 46 30 00          	movb   $0x0,0x30(%esi)
  81046f:	e9 ab 00 00 00       	jmp    81051f <tcp_receive+0x3b5>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  810474:	66 c7 46 6c 00 00    	movw   $0x0,0x6c(%esi)
    }

    /* We go through the ->unsent list to see if any of the segments
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81047a:	e9 a0 00 00 00       	jmp    81051f <tcp_receive+0x3b5>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  81047f:	8b 5e 74             	mov    0x74(%esi),%ebx
      pcb->unsent = pcb->unsent->next;
  810482:	8b 03                	mov    (%ebx),%eax
  810484:	89 46 74             	mov    %eax,0x74(%esi)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  810487:	83 ec 0c             	sub    $0xc,%esp
  81048a:	ff 73 04             	pushl  0x4(%ebx)
  81048d:	e8 56 75 ff ff       	call   8079e8 <pbuf_clen>
  810492:	66 0f b6 c0          	movzbw %al,%ax
  810496:	83 c4 10             	add    $0x10,%esp
  810499:	66 39 46 70          	cmp    %ax,0x70(%esi)
  81049d:	73 17                	jae    8104b6 <tcp_receive+0x34c>
  81049f:	83 ec 04             	sub    $0x4,%esp
  8104a2:	68 98 45 81 00       	push   $0x814598
  8104a7:	68 7f 03 00 00       	push   $0x37f
  8104ac:	68 e0 45 81 00       	push   $0x8145e0
  8104b1:	e8 16 06 ff ff       	call   800acc <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  8104b6:	83 ec 0c             	sub    $0xc,%esp
  8104b9:	ff 73 04             	pushl  0x4(%ebx)
  8104bc:	e8 27 75 ff ff       	call   8079e8 <pbuf_clen>
  8104c1:	66 0f b6 c0          	movzbw %al,%ax
  8104c5:	66 29 46 70          	sub    %ax,0x70(%esi)
      tcp_seg_free(next);
  8104c9:	89 1c 24             	mov    %ebx,(%esp)
  8104cc:	e8 26 88 ff ff       	call   808cf7 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
  8104d1:	83 c4 10             	add    $0x10,%esp
      if (pcb->snd_queuelen != 0) {
  8104d4:	66 83 7e 70 00       	cmpw   $0x0,0x70(%esi)
  8104d9:	74 23                	je     8104fe <tcp_receive+0x394>
        LWIP_ASSERT("tcp_receive: valid queue length",
  8104db:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  8104df:	75 1d                	jne    8104fe <tcp_receive+0x394>
  8104e1:	83 7e 74 00          	cmpl   $0x0,0x74(%esi)
  8104e5:	75 21                	jne    810508 <tcp_receive+0x39e>
  8104e7:	83 ec 04             	sub    $0x4,%esp
  8104ea:	68 c0 45 81 00       	push   $0x8145c0
  8104ef:	68 85 03 00 00       	push   $0x385
  8104f4:	68 e0 45 81 00       	push   $0x8145e0
  8104f9:	e8 ce 05 ff ff       	call   800acc <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  8104fe:	83 7e 74 00          	cmpl   $0x0,0x74(%esi)
  810502:	0f 84 95 00 00 00    	je     81059d <tcp_receive+0x433>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  810508:	83 ec 0c             	sub    $0xc,%esp
  81050b:	8b 46 74             	mov    0x74(%esi),%eax
  81050e:	8b 40 10             	mov    0x10(%eax),%eax
  810511:	ff 70 04             	pushl  0x4(%eax)
  810514:	e8 71 a1 ff ff       	call   80a68a <htonl>
  810519:	89 46 54             	mov    %eax,0x54(%esi)
  81051c:	83 c4 10             	add    $0x10,%esp
  81051f:	83 7e 74 00          	cmpl   $0x0,0x74(%esi)
  810523:	74 78                	je     81059d <tcp_receive+0x433>
  810525:	83 ec 0c             	sub    $0xc,%esp
  810528:	8b 46 74             	mov    0x74(%esi),%eax
  81052b:	8b 40 10             	mov    0x10(%eax),%eax
  81052e:	ff 70 04             	pushl  0x4(%eax)
  810531:	e8 80 a1 ff ff       	call   80a6b6 <ntohl>
  810536:	89 c7                	mov    %eax,%edi
  810538:	8b 46 74             	mov    0x74(%esi),%eax
  81053b:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  81053f:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  810546:	8b 40 10             	mov    0x10(%eax),%eax
  810549:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81054d:	89 04 24             	mov    %eax,(%esp)
  810550:	e8 20 a1 ff ff       	call   80a675 <ntohs>
  810555:	83 c4 10             	add    $0x10,%esp
  810558:	a8 01                	test   $0x1,%al
  81055a:	75 1a                	jne    810576 <tcp_receive+0x40c>
  81055c:	83 ec 0c             	sub    $0xc,%esp
  81055f:	8b 46 74             	mov    0x74(%esi),%eax
  810562:	8b 40 10             	mov    0x10(%eax),%eax
  810565:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810569:	50                   	push   %eax
  81056a:	e8 06 a1 ff ff       	call   80a675 <ntohs>
  81056f:	83 c4 10             	add    $0x10,%esp
  810572:	a8 02                	test   $0x2,%al
  810574:	74 07                	je     81057d <tcp_receive+0x413>
  810576:	c7 45 e4 01 00 00 00 	movl   $0x1,0xffffffe4(%ebp)
  81057d:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
  810580:	8d 04 0b             	lea    (%ebx,%ecx,1),%eax
  810583:	8d 04 07             	lea    (%edi,%eax,1),%eax
  810586:	8b 15 dc e5 b3 00    	mov    0xb3e5dc,%edx
  81058c:	39 c2                	cmp    %eax,%edx
  81058e:	78 0d                	js     81059d <tcp_receive+0x433>
  810590:	89 d0                	mov    %edx,%eax
  810592:	2b 46 58             	sub    0x58(%esi),%eax
  810595:	85 c0                	test   %eax,%eax
  810597:	0f 8e e2 fe ff ff    	jle    81047f <tcp_receive+0x315>
      }
    }
    /* End of ACK for new data processing. */

    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: pcb->rttest %"U32_F" rtseq %"U32_F" ackno %"U32_F"\n",
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  81059d:	83 7e 38 00          	cmpl   $0x0,0x38(%esi)
  8105a1:	74 59                	je     8105fc <tcp_receive+0x492>
  8105a3:	a1 dc e5 b3 00       	mov    0xb3e5dc,%eax
  8105a8:	39 46 3c             	cmp    %eax,0x3c(%esi)
  8105ab:	79 4f                	jns    8105fc <tcp_receive+0x492>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  8105ad:	66 8b 0d 6c e6 b3 00 	mov    0xb3e66c,%cx
  8105b4:	66 2b 4e 38          	sub    0x38(%esi),%cx

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  8105b8:	66 8b 46 40          	mov    0x40(%esi),%ax
  8105bc:	89 c2                	mov    %eax,%edx
  8105be:	66 c1 fa 03          	sar    $0x3,%dx
  8105c2:	66 29 d1             	sub    %dx,%cx
      pcb->sa += m;
  8105c5:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  8105c8:	66 89 46 40          	mov    %ax,0x40(%esi)
      if (m < 0) {
  8105cc:	66 85 c9             	test   %cx,%cx
  8105cf:	79 02                	jns    8105d3 <tcp_receive+0x469>
        m = -m;
  8105d1:	f7 d9                	neg    %ecx
      }
      m = m - (pcb->sv >> 2);
  8105d3:	66 8b 56 42          	mov    0x42(%esi),%dx
  8105d7:	89 d0                	mov    %edx,%eax
  8105d9:	66 c1 f8 02          	sar    $0x2,%ax
  8105dd:	66 29 c1             	sub    %ax,%cx
      pcb->sv += m;
  8105e0:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  8105e3:	66 89 56 42          	mov    %dx,0x42(%esi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  8105e7:	66 8b 46 40          	mov    0x40(%esi),%ax
  8105eb:	66 c1 f8 03          	sar    $0x3,%ax
  8105ef:	01 d0                	add    %edx,%eax
  8105f1:	66 89 46 44          	mov    %ax,0x44(%esi)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  8105f5:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  8105fc:	66 83 3d e2 e5 b3 00 	cmpw   $0x0,0xb3e5e2
  810603:	00 
  810604:	0f 84 04 08 00 00    	je     810e0e <tcp_receive+0xca4>
    /* This code basically does three things:

    +) If the incoming segment contains data that is the next
    in-sequence data, this data is passed to the application. This
    might involve trimming the first edge of the data. The rcv_nxt
    variable and the advertised window are adjusted.

    +) If the incoming segment has data that is above the next
    sequence number expected (->rcv_nxt), the segment is placed on
    the ->ooseq queue. This is done by finding the appropriate
    place in the ->ooseq queue (which is ordered by sequence
    number) and trim the segment in both ends if needed. An
    immediate ACK is sent to indicate that we received an
    out-of-sequence segment.

    +) Finally, we check if the first segment on the ->ooseq queue
    now is in sequence (i.e., if rcv_nxt >= ooseq->seqno). If
    rcv_nxt > ooseq->seqno, we must trim the first edge of the
    segment on ->ooseq before we adjust rcv_nxt. The data in the
    segments that are now on sequence are chained onto the
    incoming segment so that we only need to call the application
    once.
    */

    /* First, we check if we must trim the first edge. We have to do
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  81060a:	8b 15 d8 e5 b3 00    	mov    0xb3e5d8,%edx
  810610:	8b 4e 24             	mov    0x24(%esi),%ecx
  810613:	89 cb                	mov    %ecx,%ebx
  810615:	29 d3                	sub    %edx,%ebx
  810617:	89 d8                	mov    %ebx,%eax
  810619:	48                   	dec    %eax
  81061a:	0f 88 3e 01 00 00    	js     81075e <tcp_receive+0x5f4>
  810620:	0f b7 05 e2 e5 b3 00 	movzwl 0xb3e5e2,%eax
  810627:	01 d0                	add    %edx,%eax
  810629:	29 c1                	sub    %eax,%ecx
  81062b:	89 c8                	mov    %ecx,%eax
  81062d:	40                   	inc    %eax
  81062e:	85 c0                	test   %eax,%eax
  810630:	0f 8f 28 01 00 00    	jg     81075e <tcp_receive+0x5f4>
      /* Trimming the first edge is done by pushing the payload
         pointer in the pbuf downwards. This is somewhat tricky since
         we do not want to discard the full contents of the pbuf up to
         the new starting point of the data since we have to keep the
         TCP header which is present in the first pbuf in the chain.

         What is done is really quite a nasty hack: the first pbuf in
         the pbuf chain is pointed to by inseg.p. Since we need to be
         able to deallocate the whole pbuf, we cannot change this
         inseg.p pointer to point to any of the later pbufs in the
         chain. Instead, we point the ->payload pointer in the first
         pbuf to data in one of the later pbufs. We also set the
         inseg.data pointer to point to the right place. This way, the
         ->p pointer will still point to the first pbuf, but the
         ->p->payload pointer will point to data in another pbuf.

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  810636:	89 d9                	mov    %ebx,%ecx
      p = inseg.p;
  810638:	8b 1d c0 e5 b3 00    	mov    0xb3e5c0,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  81063e:	85 db                	test   %ebx,%ebx
  810640:	75 17                	jne    810659 <tcp_receive+0x4ef>
  810642:	83 ec 04             	sub    $0x4,%esp
  810645:	68 21 46 81 00       	push   $0x814621
  81064a:	68 e5 03 00 00       	push   $0x3e5
  81064f:	68 e0 45 81 00       	push   $0x8145e0
  810654:	e8 73 04 ff ff       	call   800acc <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  810659:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  81065f:	7e 17                	jle    810678 <tcp_receive+0x50e>
  810661:	83 ec 04             	sub    $0x4,%esp
  810664:	68 31 46 81 00       	push   $0x814631
  810669:	68 e6 03 00 00       	push   $0x3e6
  81066e:	68 e0 45 81 00       	push   $0x8145e0
  810673:	e8 54 04 ff ff       	call   800acc <_panic>
      if (inseg.p->len < off) {
  810678:	8b 15 c0 e5 b3 00    	mov    0xb3e5c0,%edx
  81067e:	0f b7 42 0a          	movzwl 0xa(%edx),%eax
  810682:	39 c8                	cmp    %ecx,%eax
  810684:	7d 7a                	jge    810700 <tcp_receive+0x596>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  810686:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  81068a:	39 c8                	cmp    %ecx,%eax
  81068c:	7d 17                	jge    8106a5 <tcp_receive+0x53b>
  81068e:	83 ec 04             	sub    $0x4,%esp
  810691:	68 40 46 81 00       	push   $0x814640
  810696:	68 e8 03 00 00       	push   $0x3e8
  81069b:	68 e0 45 81 00       	push   $0x8145e0
  8106a0:	e8 27 04 ff ff       	call   800acc <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  8106a5:	a1 c0 e5 b3 00       	mov    0xb3e5c0,%eax
  8106aa:	66 8b 40 08          	mov    0x8(%eax),%ax
  8106ae:	89 c7                	mov    %eax,%edi
  8106b0:	66 29 cf             	sub    %cx,%di
        while (p->len < off) {
          off -= p->len;
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
  8106b3:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8106b7:	89 c2                	mov    %eax,%edx
  8106b9:	39 c8                	cmp    %ecx,%eax
  8106bb:	7d 16                	jge    8106d3 <tcp_receive+0x569>
  8106bd:	29 d1                	sub    %edx,%ecx
  8106bf:	66 89 7b 08          	mov    %di,0x8(%ebx)
  8106c3:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
  8106c9:	8b 1b                	mov    (%ebx),%ebx
  8106cb:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  8106cf:	39 ca                	cmp    %ecx,%edx
  8106d1:	7c ea                	jl     8106bd <tcp_receive+0x553>
        }
        if(pbuf_header(p, (s16_t)-off)) {
  8106d3:	83 ec 08             	sub    $0x8,%esp
  8106d6:	89 c8                	mov    %ecx,%eax
  8106d8:	f7 d8                	neg    %eax
  8106da:	98                   	cwtl   
  8106db:	50                   	push   %eax
  8106dc:	53                   	push   %ebx
  8106dd:	e8 61 71 ff ff       	call   807843 <pbuf_header>
  8106e2:	83 c4 10             	add    $0x10,%esp
  8106e5:	84 c0                	test   %al,%al
  8106e7:	74 49                	je     810732 <tcp_receive+0x5c8>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  8106e9:	83 ec 04             	sub    $0x4,%esp
  8106ec:	68 50 46 81 00       	push   $0x814650
  8106f1:	68 f5 03 00 00       	push   $0x3f5
  8106f6:	68 e0 45 81 00       	push   $0x8145e0
  8106fb:	e8 cc 03 ff ff       	call   800acc <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  810700:	83 ec 08             	sub    $0x8,%esp
  810703:	89 c8                	mov    %ecx,%eax
  810705:	f7 d8                	neg    %eax
  810707:	98                   	cwtl   
  810708:	50                   	push   %eax
  810709:	ff 35 c0 e5 b3 00    	pushl  0xb3e5c0
  81070f:	e8 2f 71 ff ff       	call   807843 <pbuf_header>
  810714:	83 c4 10             	add    $0x10,%esp
  810717:	84 c0                	test   %al,%al
  810719:	74 17                	je     810732 <tcp_receive+0x5c8>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81071b:	83 ec 04             	sub    $0x4,%esp
  81071e:	68 50 46 81 00       	push   $0x814650
  810723:	68 fa 03 00 00       	push   $0x3fa
  810728:	68 e0 45 81 00       	push   $0x8145e0
  81072d:	e8 9a 03 ff ff       	call   800acc <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  810732:	8b 43 04             	mov    0x4(%ebx),%eax
  810735:	a3 c4 e5 b3 00       	mov    %eax,0xb3e5c4
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  81073a:	8b 46 24             	mov    0x24(%esi),%eax
  81073d:	66 2b 05 d8 e5 b3 00 	sub    0xb3e5d8,%ax
  810744:	66 29 05 c8 e5 b3 00 	sub    %ax,0xb3e5c8
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  81074b:	8b 56 24             	mov    0x24(%esi),%edx
  81074e:	89 15 d8 e5 b3 00    	mov    %edx,0xb3e5d8
  810754:	a1 cc e5 b3 00       	mov    0xb3e5cc,%eax
  810759:	89 50 04             	mov    %edx,0x4(%eax)
  81075c:	eb 1b                	jmp    810779 <tcp_receive+0x60f>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  81075e:	8b 56 24             	mov    0x24(%esi),%edx
  810761:	39 15 d8 e5 b3 00    	cmp    %edx,0xb3e5d8
  810767:	79 10                	jns    810779 <tcp_receive+0x60f>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  810769:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  81076d:	83 ec 0c             	sub    $0xc,%esp
  810770:	56                   	push   %esi
  810771:	e8 3c a6 ff ff       	call   80adb2 <tcp_output>
  810776:	83 c4 10             	add    $0x10,%esp
      }
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  810779:	8b 4e 24             	mov    0x24(%esi),%ecx
  81077c:	8b 15 d8 e5 b3 00    	mov    0xb3e5d8,%edx
  810782:	39 ca                	cmp    %ecx,%edx
  810784:	0f 88 72 06 00 00    	js     810dfc <tcp_receive+0xc92>
  81078a:	0f b7 46 28          	movzwl 0x28(%esi),%eax
  81078e:	01 c8                	add    %ecx,%eax
  810790:	29 c2                	sub    %eax,%edx
  810792:	89 d0                	mov    %edx,%eax
  810794:	40                   	inc    %eax
  810795:	85 c0                	test   %eax,%eax
  810797:	0f 8f 5f 06 00 00    	jg     810dfc <tcp_receive+0xc92>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81079d:	3b 0d d8 e5 b3 00    	cmp    0xb3e5d8,%ecx
  8107a3:	0f 85 d4 03 00 00    	jne    810b7d <tcp_receive+0xa13>
        accepted_inseq = 1; 
  8107a9:	c6 45 ef 01          	movb   $0x1,0xffffffef(%ebp)
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  8107ad:	83 7e 7c 00          	cmpl   $0x0,0x7c(%esi)
  8107b1:	0f 84 8c 00 00 00    	je     810843 <tcp_receive+0x6d9>
  8107b7:	8b 7e 7c             	mov    0x7c(%esi),%edi
  8107ba:	8b 47 10             	mov    0x10(%edi),%eax
  8107bd:	0f b7 15 c8 e5 b3 00 	movzwl 0xb3e5c8,%edx
  8107c4:	01 ca                	add    %ecx,%edx
  8107c6:	8b 58 04             	mov    0x4(%eax),%ebx
  8107c9:	89 d8                	mov    %ebx,%eax
  8107cb:	29 d0                	sub    %edx,%eax
  8107cd:	85 c0                	test   %eax,%eax
  8107cf:	7f 72                	jg     810843 <tcp_receive+0x6d9>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  8107d1:	66 83 7f 0c 00       	cmpw   $0x0,0xc(%edi)
  8107d6:	74 22                	je     8107fa <tcp_receive+0x690>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  8107d8:	89 d8                	mov    %ebx,%eax
  8107da:	66 29 c8             	sub    %cx,%ax
  8107dd:	66 a3 c8 e5 b3 00    	mov    %ax,0xb3e5c8
            pbuf_realloc(inseg.p, inseg.len);
  8107e3:	83 ec 08             	sub    $0x8,%esp
  8107e6:	0f b7 c0             	movzwl %ax,%eax
  8107e9:	50                   	push   %eax
  8107ea:	ff 35 c0 e5 b3 00    	pushl  0xb3e5c0
  8107f0:	e8 2d 6f ff ff       	call   807722 <pbuf_realloc>
  8107f5:	83 c4 10             	add    $0x10,%esp
  8107f8:	eb 49                	jmp    810843 <tcp_receive+0x6d9>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  8107fa:	83 ec 0c             	sub    $0xc,%esp
  8107fd:	a1 cc e5 b3 00       	mov    0xb3e5cc,%eax
  810802:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810806:	50                   	push   %eax
  810807:	e8 69 9e ff ff       	call   80a675 <ntohs>
  81080c:	89 c3                	mov    %eax,%ebx
  81080e:	83 e3 03             	and    $0x3,%ebx
  810811:	8b 46 7c             	mov    0x7c(%esi),%eax
  810814:	8b 40 10             	mov    0x10(%eax),%eax
  810817:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81081b:	89 04 24             	mov    %eax,(%esp)
  81081e:	e8 52 9e ff ff       	call   80a675 <ntohs>
  810823:	83 e0 03             	and    $0x3,%eax
  810826:	83 c4 10             	add    $0x10,%esp
  810829:	39 c3                	cmp    %eax,%ebx
  81082b:	75 16                	jne    810843 <tcp_receive+0x6d9>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  81082d:	8b 56 7c             	mov    0x7c(%esi),%edx
              pcb->ooseq = pcb->ooseq->next;
  810830:	8b 02                	mov    (%edx),%eax
  810832:	89 46 7c             	mov    %eax,0x7c(%esi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  810835:	83 ec 08             	sub    $0x8,%esp
  810838:	52                   	push   %edx
  810839:	6a 04                	push   $0x4
  81083b:	e8 b1 69 ff ff       	call   8071f1 <memp_free>
  810840:	83 c4 10             	add    $0x10,%esp
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  810843:	bb 00 00 00 00       	mov    $0x0,%ebx
  810848:	83 ec 0c             	sub    $0xc,%esp
  81084b:	a1 cc e5 b3 00       	mov    0xb3e5cc,%eax
  810850:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810854:	50                   	push   %eax
  810855:	e8 1b 9e ff ff       	call   80a675 <ntohs>
  81085a:	83 c4 10             	add    $0x10,%esp
  81085d:	a8 01                	test   $0x1,%al
  81085f:	75 19                	jne    81087a <tcp_receive+0x710>
  810861:	83 ec 0c             	sub    $0xc,%esp
  810864:	a1 cc e5 b3 00       	mov    0xb3e5cc,%eax
  810869:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81086d:	50                   	push   %eax
  81086e:	e8 02 9e ff ff       	call   80a675 <ntohs>
  810873:	83 c4 10             	add    $0x10,%esp
  810876:	a8 02                	test   $0x2,%al
  810878:	74 05                	je     81087f <tcp_receive+0x715>
  81087a:	bb 01 00 00 00       	mov    $0x1,%ebx
  81087f:	89 d8                	mov    %ebx,%eax
  810881:	66 03 05 c8 e5 b3 00 	add    0xb3e5c8,%ax
  810888:	66 a3 e2 e5 b3 00    	mov    %ax,0xb3e5e2

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  81088e:	83 7e 10 07          	cmpl   $0x7,0x10(%esi)
  810892:	74 06                	je     81089a <tcp_receive+0x730>
          pcb->rcv_nxt += tcplen;
  810894:	0f b7 c0             	movzwl %ax,%eax
  810897:	01 46 24             	add    %eax,0x24(%esi)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  81089a:	66 8b 46 28          	mov    0x28(%esi),%ax
  81089e:	66 3b 05 e2 e5 b3 00 	cmp    0xb3e5e2,%ax
  8108a5:	73 08                	jae    8108af <tcp_receive+0x745>
          pcb->rcv_wnd = 0;
  8108a7:	66 c7 46 28 00 00    	movw   $0x0,0x28(%esi)
  8108ad:	eb 0f                	jmp    8108be <tcp_receive+0x754>
        } else {
          pcb->rcv_wnd -= tcplen;
  8108af:	66 8b 46 28          	mov    0x28(%esi),%ax
  8108b3:	66 2b 05 e2 e5 b3 00 	sub    0xb3e5e2,%ax
  8108ba:	66 89 46 28          	mov    %ax,0x28(%esi)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  8108be:	66 8b 46 2a          	mov    0x2a(%esi),%ax
  8108c2:	66 3b 05 e2 e5 b3 00 	cmp    0xb3e5e2,%ax
  8108c9:	73 08                	jae    8108d3 <tcp_receive+0x769>
          pcb->rcv_ann_wnd = 0;
  8108cb:	66 c7 46 2a 00 00    	movw   $0x0,0x2a(%esi)
  8108d1:	eb 0f                	jmp    8108e2 <tcp_receive+0x778>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  8108d3:	66 8b 46 2a          	mov    0x2a(%esi),%ax
  8108d7:	66 2b 05 e2 e5 b3 00 	sub    0xb3e5e2,%ax
  8108de:	66 89 46 2a          	mov    %ax,0x2a(%esi)
        }

        /* If there is data in the segment, we make preparations to
           pass this up to the application. The ->recv_data variable
           is used for holding the pbuf that goes to the
           application. The code for reassembling out-of-sequence data
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  8108e2:	a1 c0 e5 b3 00       	mov    0xb3e5c0,%eax
  8108e7:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  8108ec:	74 0f                	je     8108fd <tcp_receive+0x793>
          recv_data = inseg.p;
  8108ee:	a3 e8 e5 b3 00       	mov    %eax,0xb3e5e8
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  8108f3:	c7 05 c0 e5 b3 00 00 	movl   $0x0,0xb3e5c0
  8108fa:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  8108fd:	83 ec 0c             	sub    $0xc,%esp
  810900:	a1 cc e5 b3 00       	mov    0xb3e5cc,%eax
  810905:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810909:	50                   	push   %eax
  81090a:	e8 66 9d ff ff       	call   80a675 <ntohs>
  81090f:	83 c4 10             	add    $0x10,%esp
  810912:	a8 01                	test   $0x1,%al
  810914:	74 07                	je     81091d <tcp_receive+0x7b3>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  810916:	c6 05 e4 e5 b3 00 20 	movb   $0x20,0xb3e5e4
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
            pcb->rcv_wnd = 0;
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
            pcb->rcv_ann_wnd = 0;
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
          }

          if (cseg->p->tot_len > 0) {
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
              pbuf_cat(recv_data, cseg->p);
            } else {
              recv_data = cseg->p;
            }
            cseg->p = NULL;
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
              pcb->state = CLOSE_WAIT;
            } 
          }


          pcb->ooseq = cseg->next;
          tcp_seg_free(cseg);
  81091d:	83 7e 7c 00          	cmpl   $0x0,0x7c(%esi)
  810921:	0f 84 2a 02 00 00    	je     810b51 <tcp_receive+0x9e7>
  810927:	8b 46 7c             	mov    0x7c(%esi),%eax
  81092a:	89 c2                	mov    %eax,%edx
  81092c:	8b 40 10             	mov    0x10(%eax),%eax
  81092f:	8b 40 04             	mov    0x4(%eax),%eax
  810932:	3b 46 24             	cmp    0x24(%esi),%eax
  810935:	0f 85 16 02 00 00    	jne    810b51 <tcp_receive+0x9e7>
  81093b:	89 d7                	mov    %edx,%edi
  81093d:	8b 42 10             	mov    0x10(%edx),%eax
  810940:	8b 40 04             	mov    0x4(%eax),%eax
  810943:	a3 d8 e5 b3 00       	mov    %eax,0xb3e5d8
  810948:	0f b7 5a 0c          	movzwl 0xc(%edx),%ebx
  81094c:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  810953:	83 ec 0c             	sub    $0xc,%esp
  810956:	8b 42 10             	mov    0x10(%edx),%eax
  810959:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81095d:	50                   	push   %eax
  81095e:	e8 12 9d ff ff       	call   80a675 <ntohs>
  810963:	83 c4 10             	add    $0x10,%esp
  810966:	a8 01                	test   $0x1,%al
  810968:	75 17                	jne    810981 <tcp_receive+0x817>
  81096a:	83 ec 0c             	sub    $0xc,%esp
  81096d:	8b 47 10             	mov    0x10(%edi),%eax
  810970:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810974:	50                   	push   %eax
  810975:	e8 fb 9c ff ff       	call   80a675 <ntohs>
  81097a:	83 c4 10             	add    $0x10,%esp
  81097d:	a8 02                	test   $0x2,%al
  81097f:	74 07                	je     810988 <tcp_receive+0x81e>
  810981:	c7 45 e0 01 00 00 00 	movl   $0x1,0xffffffe0(%ebp)
  810988:	8b 4d e0             	mov    0xffffffe0(%ebp),%ecx
  81098b:	8d 04 0b             	lea    (%ebx,%ecx,1),%eax
  81098e:	01 46 24             	add    %eax,0x24(%esi)
  810991:	0f b7 5e 28          	movzwl 0x28(%esi),%ebx
  810995:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  810999:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  81099c:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  8109a3:	83 ec 0c             	sub    $0xc,%esp
  8109a6:	8b 47 10             	mov    0x10(%edi),%eax
  8109a9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8109ad:	50                   	push   %eax
  8109ae:	e8 c2 9c ff ff       	call   80a675 <ntohs>
  8109b3:	83 c4 10             	add    $0x10,%esp
  8109b6:	a8 01                	test   $0x1,%al
  8109b8:	75 17                	jne    8109d1 <tcp_receive+0x867>
  8109ba:	83 ec 0c             	sub    $0xc,%esp
  8109bd:	8b 47 10             	mov    0x10(%edi),%eax
  8109c0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8109c4:	50                   	push   %eax
  8109c5:	e8 ab 9c ff ff       	call   80a675 <ntohs>
  8109ca:	83 c4 10             	add    $0x10,%esp
  8109cd:	a8 02                	test   $0x2,%al
  8109cf:	74 07                	je     8109d8 <tcp_receive+0x86e>
  8109d1:	c7 45 d8 01 00 00 00 	movl   $0x1,0xffffffd8(%ebp)
  8109d8:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  8109db:	03 45 d8             	add    0xffffffd8(%ebp),%eax
  8109de:	39 c3                	cmp    %eax,%ebx
  8109e0:	7d 08                	jge    8109ea <tcp_receive+0x880>
  8109e2:	66 c7 46 28 00 00    	movw   $0x0,0x28(%esi)
  8109e8:	eb 42                	jmp    810a2c <tcp_receive+0x8c2>
  8109ea:	bb 00 00 00 00       	mov    $0x0,%ebx
  8109ef:	83 ec 0c             	sub    $0xc,%esp
  8109f2:	8b 47 10             	mov    0x10(%edi),%eax
  8109f5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8109f9:	50                   	push   %eax
  8109fa:	e8 76 9c ff ff       	call   80a675 <ntohs>
  8109ff:	83 c4 10             	add    $0x10,%esp
  810a02:	a8 01                	test   $0x1,%al
  810a04:	75 17                	jne    810a1d <tcp_receive+0x8b3>
  810a06:	83 ec 0c             	sub    $0xc,%esp
  810a09:	8b 47 10             	mov    0x10(%edi),%eax
  810a0c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810a10:	50                   	push   %eax
  810a11:	e8 5f 9c ff ff       	call   80a675 <ntohs>
  810a16:	83 c4 10             	add    $0x10,%esp
  810a19:	a8 02                	test   $0x2,%al
  810a1b:	74 05                	je     810a22 <tcp_receive+0x8b8>
  810a1d:	bb 01 00 00 00       	mov    $0x1,%ebx
  810a22:	89 d8                	mov    %ebx,%eax
  810a24:	66 03 47 0c          	add    0xc(%edi),%ax
  810a28:	66 29 46 28          	sub    %ax,0x28(%esi)
  810a2c:	0f b7 5e 2a          	movzwl 0x2a(%esi),%ebx
  810a30:	0f b7 57 0c          	movzwl 0xc(%edi),%edx
  810a34:	89 55 d4             	mov    %edx,0xffffffd4(%ebp)
  810a37:	c7 45 d0 00 00 00 00 	movl   $0x0,0xffffffd0(%ebp)
  810a3e:	83 ec 0c             	sub    $0xc,%esp
  810a41:	8b 47 10             	mov    0x10(%edi),%eax
  810a44:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810a48:	50                   	push   %eax
  810a49:	e8 27 9c ff ff       	call   80a675 <ntohs>
  810a4e:	83 c4 10             	add    $0x10,%esp
  810a51:	a8 01                	test   $0x1,%al
  810a53:	75 17                	jne    810a6c <tcp_receive+0x902>
  810a55:	83 ec 0c             	sub    $0xc,%esp
  810a58:	8b 47 10             	mov    0x10(%edi),%eax
  810a5b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810a5f:	50                   	push   %eax
  810a60:	e8 10 9c ff ff       	call   80a675 <ntohs>
  810a65:	83 c4 10             	add    $0x10,%esp
  810a68:	a8 02                	test   $0x2,%al
  810a6a:	74 07                	je     810a73 <tcp_receive+0x909>
  810a6c:	c7 45 d0 01 00 00 00 	movl   $0x1,0xffffffd0(%ebp)
  810a73:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  810a76:	03 45 d0             	add    0xffffffd0(%ebp),%eax
  810a79:	39 c3                	cmp    %eax,%ebx
  810a7b:	7d 08                	jge    810a85 <tcp_receive+0x91b>
  810a7d:	66 c7 46 2a 00 00    	movw   $0x0,0x2a(%esi)
  810a83:	eb 42                	jmp    810ac7 <tcp_receive+0x95d>
  810a85:	bb 00 00 00 00       	mov    $0x0,%ebx
  810a8a:	83 ec 0c             	sub    $0xc,%esp
  810a8d:	8b 47 10             	mov    0x10(%edi),%eax
  810a90:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810a94:	50                   	push   %eax
  810a95:	e8 db 9b ff ff       	call   80a675 <ntohs>
  810a9a:	83 c4 10             	add    $0x10,%esp
  810a9d:	a8 01                	test   $0x1,%al
  810a9f:	75 17                	jne    810ab8 <tcp_receive+0x94e>
  810aa1:	83 ec 0c             	sub    $0xc,%esp
  810aa4:	8b 47 10             	mov    0x10(%edi),%eax
  810aa7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810aab:	50                   	push   %eax
  810aac:	e8 c4 9b ff ff       	call   80a675 <ntohs>
  810ab1:	83 c4 10             	add    $0x10,%esp
  810ab4:	a8 02                	test   $0x2,%al
  810ab6:	74 05                	je     810abd <tcp_receive+0x953>
  810ab8:	bb 01 00 00 00       	mov    $0x1,%ebx
  810abd:	89 d8                	mov    %ebx,%eax
  810abf:	66 03 47 0c          	add    0xc(%edi),%ax
  810ac3:	66 29 46 2a          	sub    %ax,0x2a(%esi)
  810ac7:	8b 47 04             	mov    0x4(%edi),%eax
  810aca:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  810acf:	74 2c                	je     810afd <tcp_receive+0x993>
  810ad1:	83 3d e8 e5 b3 00 00 	cmpl   $0x0,0xb3e5e8
  810ad8:	74 14                	je     810aee <tcp_receive+0x984>
  810ada:	83 ec 08             	sub    $0x8,%esp
  810add:	50                   	push   %eax
  810ade:	ff 35 e8 e5 b3 00    	pushl  0xb3e5e8
  810ae4:	e8 27 6f ff ff       	call   807a10 <pbuf_cat>
  810ae9:	83 c4 10             	add    $0x10,%esp
  810aec:	eb 08                	jmp    810af6 <tcp_receive+0x98c>
  810aee:	8b 47 04             	mov    0x4(%edi),%eax
  810af1:	a3 e8 e5 b3 00       	mov    %eax,0xb3e5e8
  810af6:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
  810afd:	83 ec 0c             	sub    $0xc,%esp
  810b00:	8b 47 10             	mov    0x10(%edi),%eax
  810b03:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810b07:	50                   	push   %eax
  810b08:	e8 68 9b ff ff       	call   80a675 <ntohs>
  810b0d:	83 c4 10             	add    $0x10,%esp
  810b10:	a8 01                	test   $0x1,%al
  810b12:	74 14                	je     810b28 <tcp_receive+0x9be>
  810b14:	c6 05 e4 e5 b3 00 20 	movb   $0x20,0xb3e5e4
  810b1b:	83 7e 10 04          	cmpl   $0x4,0x10(%esi)
  810b1f:	75 07                	jne    810b28 <tcp_receive+0x9be>
  810b21:	c7 46 10 07 00 00 00 	movl   $0x7,0x10(%esi)
  810b28:	8b 07                	mov    (%edi),%eax
  810b2a:	89 46 7c             	mov    %eax,0x7c(%esi)
  810b2d:	83 ec 0c             	sub    $0xc,%esp
  810b30:	57                   	push   %edi
  810b31:	e8 c1 81 ff ff       	call   808cf7 <tcp_seg_free>
  810b36:	83 c4 10             	add    $0x10,%esp
  810b39:	83 7e 7c 00          	cmpl   $0x0,0x7c(%esi)
  810b3d:	74 12                	je     810b51 <tcp_receive+0x9e7>
  810b3f:	8b 56 7c             	mov    0x7c(%esi),%edx
  810b42:	8b 42 10             	mov    0x10(%edx),%eax
  810b45:	8b 40 04             	mov    0x4(%eax),%eax
  810b48:	3b 46 24             	cmp    0x24(%esi),%eax
  810b4b:	0f 84 ea fd ff ff    	je     81093b <tcp_receive+0x7d1>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  810b51:	f6 46 20 01          	testb  $0x1,0x20(%esi)
  810b55:	74 1d                	je     810b74 <tcp_receive+0xa0a>
  810b57:	8a 46 20             	mov    0x20(%esi),%al
  810b5a:	83 e0 fe             	and    $0xfffffffe,%eax
  810b5d:	83 c8 02             	or     $0x2,%eax
  810b60:	88 46 20             	mov    %al,0x20(%esi)
  810b63:	83 ec 0c             	sub    $0xc,%esp
  810b66:	56                   	push   %esi
  810b67:	e8 46 a2 ff ff       	call   80adb2 <tcp_output>
  810b6c:	83 c4 10             	add    $0x10,%esp
  810b6f:	e9 c6 02 00 00       	jmp    810e3a <tcp_receive+0xcd0>
  810b74:	80 4e 20 01          	orb    $0x1,0x20(%esi)
  810b78:	e9 bd 02 00 00       	jmp    810e3a <tcp_receive+0xcd0>

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  810b7d:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  810b81:	83 ec 0c             	sub    $0xc,%esp
  810b84:	56                   	push   %esi
  810b85:	e8 28 a2 ff ff       	call   80adb2 <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  810b8a:	83 c4 10             	add    $0x10,%esp
  810b8d:	83 7e 7c 00          	cmpl   $0x0,0x7c(%esi)
  810b91:	75 18                	jne    810bab <tcp_receive+0xa41>
          pcb->ooseq = tcp_seg_copy(&inseg);
  810b93:	83 ec 0c             	sub    $0xc,%esp
  810b96:	68 bc e5 b3 00       	push   $0xb3e5bc
  810b9b:	e8 a6 81 ff ff       	call   808d46 <tcp_seg_copy>
  810ba0:	89 46 7c             	mov    %eax,0x7c(%esi)
  810ba3:	83 c4 10             	add    $0x10,%esp
  810ba6:	e9 8f 02 00 00       	jmp    810e3a <tcp_receive+0xcd0>
        } else {
          /* If the queue is not empty, we walk through the queue and
             try to find a place where the sequence number of the
             incoming segment is between the sequence numbers of the
             previous and the next segment on the ->ooseq queue. That is
             the place where we put the incoming segment. If needed, we
             trim the second edges of the previous and the incoming
             segment so that it will fit into the sequence.

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
  810bab:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  810bb2:	8b 5e 7c             	mov    0x7c(%esi),%ebx
  810bb5:	85 db                	test   %ebx,%ebx
  810bb7:	0f 84 7d 02 00 00    	je     810e3a <tcp_receive+0xcd0>
            if (seqno == next->tcphdr->seqno) {
  810bbd:	8b 43 10             	mov    0x10(%ebx),%eax
  810bc0:	8b 40 04             	mov    0x4(%eax),%eax
  810bc3:	3b 05 d8 e5 b3 00    	cmp    0xb3e5d8,%eax
  810bc9:	0f 85 91 00 00 00    	jne    810c60 <tcp_receive+0xaf6>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  810bcf:	66 a1 c8 e5 b3 00    	mov    0xb3e5c8,%ax
  810bd5:	66 3b 43 0c          	cmp    0xc(%ebx),%ax
  810bd9:	0f 86 5b 02 00 00    	jbe    810e3a <tcp_receive+0xcd0>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  810bdf:	83 ec 0c             	sub    $0xc,%esp
  810be2:	68 bc e5 b3 00       	push   $0xb3e5bc
  810be7:	e8 5a 81 ff ff       	call   808d46 <tcp_seg_copy>
  810bec:	89 c7                	mov    %eax,%edi
                if (cseg != NULL) {
  810bee:	83 c4 10             	add    $0x10,%esp
  810bf1:	85 c0                	test   %eax,%eax
  810bf3:	0f 84 41 02 00 00    	je     810e3a <tcp_receive+0xcd0>
                  cseg->next = next->next;
  810bf9:	8b 03                	mov    (%ebx),%eax
  810bfb:	89 07                	mov    %eax,(%edi)
                  if (prev != NULL) {
  810bfd:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  810c01:	74 07                	je     810c0a <tcp_receive+0xaa0>
                    prev->next = cseg;
  810c03:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  810c06:	89 39                	mov    %edi,(%ecx)
  810c08:	eb 03                	jmp    810c0d <tcp_receive+0xaa3>
                  } else {
                    pcb->ooseq = cseg;
  810c0a:	89 7e 7c             	mov    %edi,0x7c(%esi)
                  }
                  tcp_seg_free(next);
  810c0d:	83 ec 0c             	sub    $0xc,%esp
  810c10:	53                   	push   %ebx
  810c11:	e8 e1 80 ff ff       	call   808cf7 <tcp_seg_free>
                  if (cseg->next != NULL) {
  810c16:	83 c4 10             	add    $0x10,%esp
  810c19:	83 3f 00             	cmpl   $0x0,(%edi)
  810c1c:	0f 84 18 02 00 00    	je     810e3a <tcp_receive+0xcd0>
                    next = cseg->next;
  810c22:	8b 1f                	mov    (%edi),%ebx
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  810c24:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  810c28:	8b 0d d8 e5 b3 00    	mov    0xb3e5d8,%ecx
  810c2e:	01 c8                	add    %ecx,%eax
  810c30:	8b 53 10             	mov    0x10(%ebx),%edx
  810c33:	8b 52 04             	mov    0x4(%edx),%edx
  810c36:	29 d0                	sub    %edx,%eax
  810c38:	85 c0                	test   %eax,%eax
  810c3a:	0f 8e fa 01 00 00    	jle    810e3a <tcp_receive+0xcd0>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  810c40:	89 d0                	mov    %edx,%eax
  810c42:	66 29 c8             	sub    %cx,%ax
  810c45:	66 89 47 0c          	mov    %ax,0xc(%edi)
                      pbuf_realloc(cseg->p, cseg->len);
  810c49:	83 ec 08             	sub    $0x8,%esp
  810c4c:	0f b7 c0             	movzwl %ax,%eax
  810c4f:	50                   	push   %eax
  810c50:	ff 77 04             	pushl  0x4(%edi)
  810c53:	e8 ca 6a ff ff       	call   807722 <pbuf_realloc>
  810c58:	83 c4 10             	add    $0x10,%esp
                    }
                  }
                }
                break;
  810c5b:	e9 da 01 00 00       	jmp    810e3a <tcp_receive+0xcd0>
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  810c60:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  810c64:	75 65                	jne    810ccb <tcp_receive+0xb61>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  810c66:	8b 43 10             	mov    0x10(%ebx),%eax
  810c69:	8b 48 04             	mov    0x4(%eax),%ecx
  810c6c:	8b 15 d8 e5 b3 00    	mov    0xb3e5d8,%edx
  810c72:	39 ca                	cmp    %ecx,%edx
  810c74:	0f 89 10 01 00 00    	jns    810d8a <tcp_receive+0xc20>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  810c7a:	0f b7 05 c8 e5 b3 00 	movzwl 0xb3e5c8,%eax
  810c81:	01 d0                	add    %edx,%eax
  810c83:	29 c8                	sub    %ecx,%eax
  810c85:	85 c0                	test   %eax,%eax
  810c87:	7e 20                	jle    810ca9 <tcp_receive+0xb3f>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  810c89:	89 c8                	mov    %ecx,%eax
  810c8b:	66 29 d0             	sub    %dx,%ax
  810c8e:	66 a3 c8 e5 b3 00    	mov    %ax,0xb3e5c8
                    pbuf_realloc(inseg.p, inseg.len);
  810c94:	83 ec 08             	sub    $0x8,%esp
  810c97:	0f b7 c0             	movzwl %ax,%eax
  810c9a:	50                   	push   %eax
  810c9b:	ff 35 c0 e5 b3 00    	pushl  0xb3e5c0
  810ca1:	e8 7c 6a ff ff       	call   807722 <pbuf_realloc>
  810ca6:	83 c4 10             	add    $0x10,%esp
                  }
                  cseg = tcp_seg_copy(&inseg);
  810ca9:	83 ec 0c             	sub    $0xc,%esp
  810cac:	68 bc e5 b3 00       	push   $0xb3e5bc
  810cb1:	e8 90 80 ff ff       	call   808d46 <tcp_seg_copy>
                  if (cseg != NULL) {
  810cb6:	83 c4 10             	add    $0x10,%esp
  810cb9:	85 c0                	test   %eax,%eax
  810cbb:	0f 84 79 01 00 00    	je     810e3a <tcp_receive+0xcd0>
                    cseg->next = next;
  810cc1:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  810cc3:	89 46 7c             	mov    %eax,0x7c(%esi)
                  }
                  break;
  810cc6:	e9 6f 01 00 00       	jmp    810e3a <tcp_receive+0xcd0>
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  810ccb:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  810cce:	8b 42 10             	mov    0x10(%edx),%eax
  810cd1:	8b 15 d8 e5 b3 00    	mov    0xb3e5d8,%edx
  810cd7:	89 d1                	mov    %edx,%ecx
  810cd9:	2b 48 04             	sub    0x4(%eax),%ecx
  810cdc:	89 c8                	mov    %ecx,%eax
  810cde:	48                   	dec    %eax
  810cdf:	0f 88 a5 00 00 00    	js     810d8a <tcp_receive+0xc20>
  810ce5:	8b 43 10             	mov    0x10(%ebx),%eax
  810ce8:	8b 48 04             	mov    0x4(%eax),%ecx
  810ceb:	89 d0                	mov    %edx,%eax
  810ced:	29 c8                	sub    %ecx,%eax
  810cef:	40                   	inc    %eax
  810cf0:	85 c0                	test   %eax,%eax
  810cf2:	0f 8f 92 00 00 00    	jg     810d8a <tcp_receive+0xc20>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  810cf8:	0f b7 05 c8 e5 b3 00 	movzwl 0xb3e5c8,%eax
  810cff:	01 d0                	add    %edx,%eax
  810d01:	29 c8                	sub    %ecx,%eax
  810d03:	85 c0                	test   %eax,%eax
  810d05:	7e 20                	jle    810d27 <tcp_receive+0xbbd>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  810d07:	89 c8                	mov    %ecx,%eax
  810d09:	66 29 d0             	sub    %dx,%ax
  810d0c:	66 a3 c8 e5 b3 00    	mov    %ax,0xb3e5c8
                  pbuf_realloc(inseg.p, inseg.len);
  810d12:	83 ec 08             	sub    $0x8,%esp
  810d15:	0f b7 c0             	movzwl %ax,%eax
  810d18:	50                   	push   %eax
  810d19:	ff 35 c0 e5 b3 00    	pushl  0xb3e5c0
  810d1f:	e8 fe 69 ff ff       	call   807722 <pbuf_realloc>
  810d24:	83 c4 10             	add    $0x10,%esp
                }

                cseg = tcp_seg_copy(&inseg);
  810d27:	83 ec 0c             	sub    $0xc,%esp
  810d2a:	68 bc e5 b3 00       	push   $0xb3e5bc
  810d2f:	e8 12 80 ff ff       	call   808d46 <tcp_seg_copy>
  810d34:	89 c7                	mov    %eax,%edi
                if (cseg != NULL) {
  810d36:	83 c4 10             	add    $0x10,%esp
  810d39:	85 c0                	test   %eax,%eax
  810d3b:	0f 84 f9 00 00 00    	je     810e3a <tcp_receive+0xcd0>
                  cseg->next = next;
  810d41:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  810d43:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  810d46:	89 38                	mov    %edi,(%eax)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  810d48:	8b 50 10             	mov    0x10(%eax),%edx
  810d4b:	8b 4d f0             	mov    0xfffffff0(%ebp),%ecx
  810d4e:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  810d52:	8b 4a 04             	mov    0x4(%edx),%ecx
  810d55:	01 c8                	add    %ecx,%eax
  810d57:	8b 15 d8 e5 b3 00    	mov    0xb3e5d8,%edx
  810d5d:	29 d0                	sub    %edx,%eax
  810d5f:	85 c0                	test   %eax,%eax
  810d61:	0f 8e d3 00 00 00    	jle    810e3a <tcp_receive+0xcd0>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  810d67:	89 d0                	mov    %edx,%eax
  810d69:	66 29 c8             	sub    %cx,%ax
  810d6c:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  810d6f:	66 89 42 0c          	mov    %ax,0xc(%edx)
                    pbuf_realloc(prev->p, prev->len);
  810d73:	83 ec 08             	sub    $0x8,%esp
  810d76:	0f b7 c0             	movzwl %ax,%eax
  810d79:	50                   	push   %eax
  810d7a:	ff 72 04             	pushl  0x4(%edx)
  810d7d:	e8 a0 69 ff ff       	call   807722 <pbuf_realloc>
  810d82:	83 c4 10             	add    $0x10,%esp
                  }
                }
                break;
  810d85:	e9 b0 00 00 00       	jmp    810e3a <tcp_receive+0xcd0>
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  810d8a:	83 3b 00             	cmpl   $0x0,(%ebx)
  810d8d:	75 5e                	jne    810ded <tcp_receive+0xc83>
  810d8f:	8b 53 10             	mov    0x10(%ebx),%edx
  810d92:	a1 d8 e5 b3 00       	mov    0xb3e5d8,%eax
  810d97:	2b 42 04             	sub    0x4(%edx),%eax
  810d9a:	85 c0                	test   %eax,%eax
  810d9c:	7e 4f                	jle    810ded <tcp_receive+0xc83>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  810d9e:	83 ec 0c             	sub    $0xc,%esp
  810da1:	68 bc e5 b3 00       	push   $0xb3e5bc
  810da6:	e8 9b 7f ff ff       	call   808d46 <tcp_seg_copy>
  810dab:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  810dad:	83 c4 10             	add    $0x10,%esp
  810db0:	85 c0                	test   %eax,%eax
  810db2:	0f 84 82 00 00 00    	je     810e3a <tcp_receive+0xcd0>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  810db8:	8b 53 10             	mov    0x10(%ebx),%edx
  810dbb:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  810dbf:	8b 4a 04             	mov    0x4(%edx),%ecx
  810dc2:	01 c8                	add    %ecx,%eax
  810dc4:	8b 15 d8 e5 b3 00    	mov    0xb3e5d8,%edx
  810dca:	29 d0                	sub    %edx,%eax
  810dcc:	85 c0                	test   %eax,%eax
  810dce:	7e 6a                	jle    810e3a <tcp_receive+0xcd0>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  810dd0:	89 d0                	mov    %edx,%eax
  810dd2:	66 29 c8             	sub    %cx,%ax
  810dd5:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  810dd9:	83 ec 08             	sub    $0x8,%esp
  810ddc:	0f b7 c0             	movzwl %ax,%eax
  810ddf:	50                   	push   %eax
  810de0:	ff 73 04             	pushl  0x4(%ebx)
  810de3:	e8 3a 69 ff ff       	call   807722 <pbuf_realloc>
  810de8:	83 c4 10             	add    $0x10,%esp
                  }
                }
                break;
  810deb:	eb 4d                	jmp    810e3a <tcp_receive+0xcd0>
              }
            }
            prev = next;
  810ded:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
  810df0:	8b 1b                	mov    (%ebx),%ebx
  810df2:	85 db                	test   %ebx,%ebx
  810df4:	0f 85 c3 fd ff ff    	jne    810bbd <tcp_receive+0xa53>
  810dfa:	eb 3e                	jmp    810e3a <tcp_receive+0xcd0>
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  810dfc:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  810e00:	83 ec 0c             	sub    $0xc,%esp
  810e03:	56                   	push   %esi
  810e04:	e8 a9 9f ff ff       	call   80adb2 <tcp_output>
  810e09:	83 c4 10             	add    $0x10,%esp
  810e0c:	eb 2c                	jmp    810e3a <tcp_receive+0xcd0>
    }
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  810e0e:	8b 56 24             	mov    0x24(%esi),%edx
  810e11:	8b 0d d8 e5 b3 00    	mov    0xb3e5d8,%ecx
  810e17:	39 d1                	cmp    %edx,%ecx
  810e19:	78 0f                	js     810e2a <tcp_receive+0xcc0>
  810e1b:	0f b7 46 28          	movzwl 0x28(%esi),%eax
  810e1f:	01 d0                	add    %edx,%eax
  810e21:	29 c1                	sub    %eax,%ecx
  810e23:	89 c8                	mov    %ecx,%eax
  810e25:	40                   	inc    %eax
  810e26:	85 c0                	test   %eax,%eax
  810e28:	7e 10                	jle    810e3a <tcp_receive+0xcd0>
      tcp_ack_now(pcb);
  810e2a:	80 4e 20 02          	orb    $0x2,0x20(%esi)
  810e2e:	83 ec 0c             	sub    $0xc,%esp
  810e31:	56                   	push   %esi
  810e32:	e8 7b 9f ff ff       	call   80adb2 <tcp_output>
  810e37:	83 c4 10             	add    $0x10,%esp
    }
  }
  return accepted_inseq;
  810e3a:	0f b6 45 ef          	movzbl 0xffffffef(%ebp),%eax
}
  810e3e:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  810e41:	5b                   	pop    %ebx
  810e42:	5e                   	pop    %esi
  810e43:	5f                   	pop    %edi
  810e44:	c9                   	leave  
  810e45:	c3                   	ret    

00810e46 <tcp_parseopt>:

/**
 * Parses the options contained in the incoming segment. (Code taken
 * from uIP with only small changes.)
 *
 * Called from tcp_listen_input() and tcp_process().
 * Currently, only the MSS option is supported!
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  810e46:	55                   	push   %ebp
  810e47:	89 e5                	mov    %esp,%ebp
  810e49:	56                   	push   %esi
  810e4a:	53                   	push   %ebx
  810e4b:	83 ec 1c             	sub    $0x1c,%esp
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  810e4e:	a1 d0 e5 b3 00       	mov    0xb3e5d0,%eax
  810e53:	8d 70 14             	lea    0x14(%eax),%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  810e56:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810e5a:	50                   	push   %eax
  810e5b:	e8 15 98 ff ff       	call   80a675 <ntohs>
  810e60:	66 c1 e8 0c          	shr    $0xc,%ax
  810e64:	83 c4 10             	add    $0x10,%esp
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  810e67:	c6 45 f7 00          	movb   $0x0,0xfffffff7(%ebp)
  810e6b:	66 83 f8 05          	cmp    $0x5,%ax
  810e6f:	77 68                	ja     810ed9 <tcp_parseopt+0x93>
  810e71:	e9 92 00 00 00       	jmp    810f08 <tcp_parseopt+0xc2>
      opt = opts[c];
  810e76:	0f b6 45 f7          	movzbl 0xfffffff7(%ebp),%eax
  810e7a:	8a 04 30             	mov    (%eax,%esi,1),%al
      if (opt == 0x00) {
  810e7d:	84 c0                	test   %al,%al
  810e7f:	0f 84 83 00 00 00    	je     810f08 <tcp_parseopt+0xc2>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  810e85:	3c 01                	cmp    $0x1,%al
  810e87:	75 05                	jne    810e8e <tcp_parseopt+0x48>
        ++c;
  810e89:	fe 45 f7             	incb   0xfffffff7(%ebp)
  810e8c:	eb 4b                	jmp    810ed9 <tcp_parseopt+0x93>
        /* NOP option. */
      } else if (opt == 0x02 &&
  810e8e:	3c 02                	cmp    $0x2,%al
  810e90:	75 35                	jne    810ec7 <tcp_parseopt+0x81>
  810e92:	0f b6 55 f7          	movzbl 0xfffffff7(%ebp),%edx
  810e96:	80 7c 32 01 04       	cmpb   $0x4,0x1(%edx,%esi,1)
  810e9b:	75 2a                	jne    810ec7 <tcp_parseopt+0x81>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  810e9d:	0f b6 44 32 02       	movzbl 0x2(%edx,%esi,1),%eax
  810ea2:	c1 e0 08             	shl    $0x8,%eax
  810ea5:	66 0f b6 54 32 03    	movzbw 0x3(%edx,%esi,1),%dx
  810eab:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  810ead:	8d 50 ff             	lea    0xffffffff(%eax),%edx
  810eb0:	89 c1                	mov    %eax,%ecx
  810eb2:	66 81 fa b3 05       	cmp    $0x5b3,%dx
  810eb7:	76 05                	jbe    810ebe <tcp_parseopt+0x78>
  810eb9:	b9 b4 05 00 00       	mov    $0x5b4,%ecx
  810ebe:	8b 45 08             	mov    0x8(%ebp),%eax
  810ec1:	66 89 48 34          	mov    %cx,0x34(%eax)

        /* And we are done processing options. */
        break;
  810ec5:	eb 41                	jmp    810f08 <tcp_parseopt+0xc2>
      } else {
        if (opts[c + 1] == 0) {
  810ec7:	0f b6 45 f7          	movzbl 0xfffffff7(%ebp),%eax
  810ecb:	80 7c 30 01 00       	cmpb   $0x0,0x1(%eax,%esi,1)
  810ed0:	74 36                	je     810f08 <tcp_parseopt+0xc2>
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  810ed2:	8a 54 30 01          	mov    0x1(%eax,%esi,1),%dl
  810ed6:	00 55 f7             	add    %dl,0xfffffff7(%ebp)
  810ed9:	0f b6 5d f7          	movzbl 0xfffffff7(%ebp),%ebx
  810edd:	83 ec 0c             	sub    $0xc,%esp
  810ee0:	a1 d0 e5 b3 00       	mov    0xb3e5d0,%eax
  810ee5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810ee9:	50                   	push   %eax
  810eea:	e8 86 97 ff ff       	call   80a675 <ntohs>
  810eef:	66 c1 e8 0c          	shr    $0xc,%ax
  810ef3:	0f b7 c0             	movzwl %ax,%eax
  810ef6:	8d 04 85 ec ff ff ff 	lea    0xffffffec(,%eax,4),%eax
  810efd:	83 c4 10             	add    $0x10,%esp
  810f00:	39 c3                	cmp    %eax,%ebx
  810f02:	0f 8c 6e ff ff ff    	jl     810e76 <tcp_parseopt+0x30>
      }
    }
  }
}
  810f08:	8d 65 f8             	lea    0xfffffff8(%ebp),%esp
  810f0b:	5b                   	pop    %ebx
  810f0c:	5e                   	pop    %esi
  810f0d:	c9                   	leave  
  810f0e:	c3                   	ret    
	...

00810f10 <raw_input>:
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  810f10:	55                   	push   %ebp
  810f11:	89 e5                	mov    %esp,%ebp
  810f13:	57                   	push   %edi
  810f14:	56                   	push   %esi
  810f15:	53                   	push   %ebx
  810f16:	83 ec 18             	sub    $0x18,%esp
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  810f19:	c6 45 ef 00          	movb   $0x0,0xffffffef(%ebp)

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  810f1d:	8b 45 08             	mov    0x8(%ebp),%eax
  810f20:	8b 40 04             	mov    0x4(%eax),%eax
  810f23:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  proto = IPH_PROTO(iphdr);
  810f26:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  810f2a:	50                   	push   %eax
  810f2b:	e8 45 97 ff ff       	call   80a675 <ntohs>
  810f30:	89 c6                	mov    %eax,%esi
  810f32:	81 e6 ff 00 00 00    	and    $0xff,%esi

  prev = NULL;
  810f38:	bf 00 00 00 00       	mov    $0x0,%edi
  pcb = raw_pcbs;
  810f3d:	8b 1d ec e5 b3 00    	mov    0xb3e5ec,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  810f43:	83 c4 10             	add    $0x10,%esp
    if (pcb->protocol == proto) {
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
            pcb->next = raw_pcbs;
            raw_pcbs = pcb;
          }
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  810f46:	85 db                	test   %ebx,%ebx
  810f48:	74 5b                	je     810fa5 <raw_input+0x95>
  810f4a:	0f b6 53 10          	movzbl 0x10(%ebx),%edx
  810f4e:	0f bf c6             	movswl %si,%eax
  810f51:	39 c2                	cmp    %eax,%edx
  810f53:	75 41                	jne    810f96 <raw_input+0x86>
  810f55:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
  810f59:	74 3b                	je     810f96 <raw_input+0x86>
  810f5b:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  810f5e:	83 c0 0c             	add    $0xc,%eax
  810f61:	50                   	push   %eax
  810f62:	ff 75 08             	pushl  0x8(%ebp)
  810f65:	53                   	push   %ebx
  810f66:	ff 73 18             	pushl  0x18(%ebx)
  810f69:	ff 53 14             	call   *0x14(%ebx)
  810f6c:	83 c4 10             	add    $0x10,%esp
  810f6f:	84 c0                	test   %al,%al
  810f71:	74 23                	je     810f96 <raw_input+0x86>
  810f73:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  810f7a:	c6 45 ef 01          	movb   $0x1,0xffffffef(%ebp)
  810f7e:	85 ff                	test   %edi,%edi
  810f80:	74 14                	je     810f96 <raw_input+0x86>
  810f82:	8b 43 0c             	mov    0xc(%ebx),%eax
  810f85:	89 47 0c             	mov    %eax,0xc(%edi)
  810f88:	a1 ec e5 b3 00       	mov    0xb3e5ec,%eax
  810f8d:	89 43 0c             	mov    %eax,0xc(%ebx)
  810f90:	89 1d ec e5 b3 00    	mov    %ebx,0xb3e5ec
  810f96:	89 df                	mov    %ebx,%edi
  810f98:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  810f9b:	80 7d ef 00          	cmpb   $0x0,0xffffffef(%ebp)
  810f9f:	75 04                	jne    810fa5 <raw_input+0x95>
  810fa1:	85 db                	test   %ebx,%ebx
  810fa3:	75 a5                	jne    810f4a <raw_input+0x3a>
  }
  return eaten;
  810fa5:	0f b6 45 ef          	movzbl 0xffffffef(%ebp),%eax
}
  810fa9:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  810fac:	5b                   	pop    %ebx
  810fad:	5e                   	pop    %esi
  810fae:	5f                   	pop    %edi
  810faf:	c9                   	leave  
  810fb0:	c3                   	ret    

00810fb1 <raw_bind>:

/**
 * Bind a RAW PCB.
 *
 * @param pcb RAW PCB to be bound with a local address ipaddr.
 * @param ipaddr local IP address to bind with. Use IP_ADDR_ANY to
 * bind to all local interfaces.
 *
 * @return lwIP error code.
 * - ERR_OK. Successful. No error occured.
 * - ERR_USE. The specified IP address is already bound to by
 * another RAW PCB.
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  810fb1:	55                   	push   %ebp
  810fb2:	89 e5                	mov    %esp,%ebp
  810fb4:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->local_ip, ipaddr);
  810fb7:	ba 00 00 00 00       	mov    $0x0,%edx
  810fbc:	85 c0                	test   %eax,%eax
  810fbe:	74 02                	je     810fc2 <raw_bind+0x11>
  810fc0:	8b 10                	mov    (%eax),%edx
  810fc2:	8b 45 08             	mov    0x8(%ebp),%eax
  810fc5:	89 10                	mov    %edx,(%eax)
  return ERR_OK;
}
  810fc7:	b8 00 00 00 00       	mov    $0x0,%eax
  810fcc:	c9                   	leave  
  810fcd:	c3                   	ret    

00810fce <raw_connect>:

/**
 * Connect an RAW PCB. This function is required by upper layers
 * of lwip. Using the raw api you could use raw_sendto() instead
 *
 * This will associate the RAW PCB with the remote address.
 *
 * @param pcb RAW PCB to be connected with remote address ipaddr and port.
 * @param ipaddr remote IP address to connect with.
 *
 * @return lwIP error code
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  810fce:	55                   	push   %ebp
  810fcf:	89 e5                	mov    %esp,%ebp
  810fd1:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->remote_ip, ipaddr);
  810fd4:	ba 00 00 00 00       	mov    $0x0,%edx
  810fd9:	85 c0                	test   %eax,%eax
  810fdb:	74 02                	je     810fdf <raw_connect+0x11>
  810fdd:	8b 10                	mov    (%eax),%edx
  810fdf:	8b 45 08             	mov    0x8(%ebp),%eax
  810fe2:	89 50 04             	mov    %edx,0x4(%eax)
  return ERR_OK;
}
  810fe5:	b8 00 00 00 00       	mov    $0x0,%eax
  810fea:	c9                   	leave  
  810feb:	c3                   	ret    

00810fec <raw_recv>:


/**
 * Set the callback function for received packets that match the
 * raw PCB's protocol and binding. 
 * 
 * The callback function MUST either
 * - eat the packet by calling pbuf_free() and returning non-zero. The
 *   packet will not be passed to other raw PCBs or other protocol layers.
 * - not free the packet, and return zero. The packet will be matched
 *   against further PCBs and/or forwarded to another protocol layers.
 * 
 * @return non-zero if the packet was free()d, zero if the packet remains
 * available for others.
 */
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  810fec:	55                   	push   %ebp
  810fed:	89 e5                	mov    %esp,%ebp
  810fef:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  810ff2:	8b 55 0c             	mov    0xc(%ebp),%edx
  810ff5:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  810ff8:	8b 55 10             	mov    0x10(%ebp),%edx
  810ffb:	89 50 18             	mov    %edx,0x18(%eax)
}
  810ffe:	c9                   	leave  
  810fff:	c3                   	ret    

00811000 <raw_sendto>:

/**
 * Send the raw IP packet to the given address. Note that actually you cannot
 * modify the IP headers (this is inconsistent with the receive callback where
 * you actually get the IP headers), you can only specify the IP payload here.
 * It requires some more changes in lwIP. (there will be a raw_send() function
 * then.)
 *
 * @param pcb the raw pcb which to send
 * @param p the IP payload to send
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  811000:	55                   	push   %ebp
  811001:	89 e5                	mov    %esp,%ebp
  811003:	57                   	push   %edi
  811004:	56                   	push   %esi
  811005:	53                   	push   %ebx
  811006:	83 ec 14             	sub    $0x14,%esp
  811009:	8b 75 08             	mov    0x8(%ebp),%esi
  81100c:	8b 7d 0c             	mov    0xc(%ebp),%edi
  err_t err;
  struct netif *netif;
  struct ip_addr *src_ip;
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  81100f:	6a 14                	push   $0x14
  811011:	57                   	push   %edi
  811012:	e8 2c 68 ff ff       	call   807843 <pbuf_header>
  811017:	83 c4 10             	add    $0x10,%esp
  81101a:	84 c0                	test   %al,%al
  81101c:	74 2f                	je     81104d <raw_sendto+0x4d>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  81101e:	83 ec 04             	sub    $0x4,%esp
  811021:	6a 00                	push   $0x0
  811023:	6a 00                	push   $0x0
  811025:	6a 01                	push   $0x1
  811027:	e8 5c 64 ff ff       	call   807488 <pbuf_alloc>
  81102c:	89 c3                	mov    %eax,%ebx
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  81102e:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  811031:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  811036:	85 db                	test   %ebx,%ebx
  811038:	0f 84 a8 00 00 00    	je     8110e6 <raw_sendto+0xe6>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  81103e:	83 ec 08             	sub    $0x8,%esp
  811041:	57                   	push   %edi
  811042:	53                   	push   %ebx
  811043:	e8 5a 6a ff ff       	call   807aa2 <pbuf_chain>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  811048:	83 c4 10             	add    $0x10,%esp
  81104b:	eb 2b                	jmp    811078 <raw_sendto+0x78>
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  81104d:	89 fb                	mov    %edi,%ebx
    if(pbuf_header(q, -IP_HLEN)) {
  81104f:	83 ec 08             	sub    $0x8,%esp
  811052:	6a ec                	push   $0xffffffec
  811054:	57                   	push   %edi
  811055:	e8 e9 67 ff ff       	call   807843 <pbuf_header>
  81105a:	83 c4 10             	add    $0x10,%esp
  81105d:	84 c0                	test   %al,%al
  81105f:	74 17                	je     811078 <raw_sendto+0x78>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  811061:	83 ec 04             	sub    $0x4,%esp
  811064:	68 8c 46 81 00       	push   $0x81468c
  811069:	68 e3 00 00 00       	push   $0xe3
  81106e:	68 b2 46 81 00       	push   $0x8146b2
  811073:	e8 54 fa fe ff       	call   800acc <_panic>
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  811078:	83 ec 0c             	sub    $0xc,%esp
  81107b:	ff 75 10             	pushl  0x10(%ebp)
  81107e:	e8 71 81 ff ff       	call   8091f4 <ip_route>
  811083:	83 c4 10             	add    $0x10,%esp
  811086:	85 c0                	test   %eax,%eax
  811088:	75 17                	jne    8110a1 <raw_sendto+0xa1>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  81108a:	39 fb                	cmp    %edi,%ebx
  81108c:	74 0c                	je     81109a <raw_sendto+0x9a>
      pbuf_free(q);
  81108e:	83 ec 0c             	sub    $0xc,%esp
  811091:	53                   	push   %ebx
  811092:	e8 82 68 ff ff       	call   807919 <pbuf_free>
  811097:	83 c4 10             	add    $0x10,%esp
    }
    return ERR_RTE;
  81109a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  81109f:	eb 45                	jmp    8110e6 <raw_sendto+0xe6>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  8110a1:	85 f6                	test   %esi,%esi
  8110a3:	74 07                	je     8110ac <raw_sendto+0xac>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  8110a5:	89 f2                	mov    %esi,%edx
  8110a7:	83 3e 00             	cmpl   $0x0,(%esi)
  8110aa:	75 03                	jne    8110af <raw_sendto+0xaf>
  8110ac:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  8110af:	83 ec 04             	sub    $0x4,%esp
  8110b2:	50                   	push   %eax
  8110b3:	0f b6 46 10          	movzbl 0x10(%esi),%eax
  8110b7:	50                   	push   %eax
  8110b8:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  8110bc:	50                   	push   %eax
  8110bd:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  8110c1:	50                   	push   %eax
  8110c2:	ff 75 10             	pushl  0x10(%ebp)
  8110c5:	52                   	push   %edx
  8110c6:	53                   	push   %ebx
  8110c7:	e8 74 84 ff ff       	call   809540 <ip_output_if>
  8110cc:	89 c6                	mov    %eax,%esi
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  8110ce:	83 c4 20             	add    $0x20,%esp
  8110d1:	39 fb                	cmp    %edi,%ebx
  8110d3:	74 0c                	je     8110e1 <raw_sendto+0xe1>
    /* free the header */
    pbuf_free(q);
  8110d5:	83 ec 0c             	sub    $0xc,%esp
  8110d8:	53                   	push   %ebx
  8110d9:	e8 3b 68 ff ff       	call   807919 <pbuf_free>
  8110de:	83 c4 10             	add    $0x10,%esp
  }
  return err;
  8110e1:	89 f2                	mov    %esi,%edx
  8110e3:	0f be c2             	movsbl %dl,%eax
}
  8110e6:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8110e9:	5b                   	pop    %ebx
  8110ea:	5e                   	pop    %esi
  8110eb:	5f                   	pop    %edi
  8110ec:	c9                   	leave  
  8110ed:	c3                   	ret    

008110ee <raw_send>:

/**
 * Send the raw IP packet to the address given by raw_connect()
 *
 * @param pcb the raw pcb which to send
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  8110ee:	55                   	push   %ebp
  8110ef:	89 e5                	mov    %esp,%ebp
  8110f1:	83 ec 0c             	sub    $0xc,%esp
  8110f4:	8b 55 08             	mov    0x8(%ebp),%edx
  return raw_sendto(pcb, p, &pcb->remote_ip);
  8110f7:	8d 42 04             	lea    0x4(%edx),%eax
  8110fa:	50                   	push   %eax
  8110fb:	ff 75 0c             	pushl  0xc(%ebp)
  8110fe:	52                   	push   %edx
  8110ff:	e8 fc fe ff ff       	call   811000 <raw_sendto>
  811104:	0f be c0             	movsbl %al,%eax
}
  811107:	c9                   	leave  
  811108:	c3                   	ret    

00811109 <raw_remove>:

/**
 * Remove an RAW PCB.
 *
 * @param pcb RAW PCB to be removed. The PCB is removed from the list of
 * RAW PCB's and the data structure is freed from memory.
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  811109:	55                   	push   %ebp
  81110a:	89 e5                	mov    %esp,%ebp
  81110c:	83 ec 08             	sub    $0x8,%esp
  81110f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  811112:	39 0d ec e5 b3 00    	cmp    %ecx,0xb3e5ec
  811118:	75 0a                	jne    811124 <raw_remove+0x1b>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  81111a:	8b 41 0c             	mov    0xc(%ecx),%eax
  81111d:	a3 ec e5 b3 00       	mov    %eax,0xb3e5ec
  811122:	eb 22                	jmp    811146 <raw_remove+0x3d>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  811124:	8b 15 ec e5 b3 00    	mov    0xb3e5ec,%edx
  81112a:	85 d2                	test   %edx,%edx
  81112c:	74 18                	je     811146 <raw_remove+0x3d>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  81112e:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  811132:	74 0b                	je     81113f <raw_remove+0x36>
  811134:	39 4a 0c             	cmp    %ecx,0xc(%edx)
  811137:	75 06                	jne    81113f <raw_remove+0x36>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  811139:	8b 41 0c             	mov    0xc(%ecx),%eax
  81113c:	89 42 0c             	mov    %eax,0xc(%edx)
  81113f:	8b 52 0c             	mov    0xc(%edx),%edx
  811142:	85 d2                	test   %edx,%edx
  811144:	75 e8                	jne    81112e <raw_remove+0x25>
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  811146:	83 ec 08             	sub    $0x8,%esp
  811149:	51                   	push   %ecx
  81114a:	6a 00                	push   $0x0
  81114c:	e8 a0 60 ff ff       	call   8071f1 <memp_free>
}
  811151:	c9                   	leave  
  811152:	c3                   	ret    

00811153 <raw_new>:

/**
 * Create a RAW PCB.
 *
 * @return The RAW PCB which was created. NULL if the PCB data structure
 * could not be allocated.
 *
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  811153:	55                   	push   %ebp
  811154:	89 e5                	mov    %esp,%ebp
  811156:	53                   	push   %ebx
  811157:	83 ec 10             	sub    $0x10,%esp
  81115a:	8a 45 08             	mov    0x8(%ebp),%al
  81115d:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  811160:	6a 00                	push   $0x0
  811162:	e8 30 60 ff ff       	call   807197 <memp_malloc>
  811167:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  811169:	83 c4 10             	add    $0x10,%esp
  81116c:	85 c0                	test   %eax,%eax
  81116e:	74 28                	je     811198 <raw_new+0x45>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  811170:	83 ec 04             	sub    $0x4,%esp
  811173:	6a 1c                	push   $0x1c
  811175:	6a 00                	push   $0x0
  811177:	50                   	push   %eax
  811178:	e8 6c 01 ff ff       	call   8012e9 <memset>
    pcb->protocol = proto;
  81117d:	8a 45 fb             	mov    0xfffffffb(%ebp),%al
  811180:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  811183:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  811187:	a1 ec e5 b3 00       	mov    0xb3e5ec,%eax
  81118c:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  81118f:	89 1d ec e5 b3 00    	mov    %ebx,0xb3e5ec
  811195:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  811198:	89 d8                	mov    %ebx,%eax
  81119a:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  81119d:	c9                   	leave  
  81119e:	c3                   	ret    
	...

008111a0 <icmp_input>:
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  8111a0:	55                   	push   %ebp
  8111a1:	89 e5                	mov    %esp,%ebp
  8111a3:	57                   	push   %edi
  8111a4:	56                   	push   %esi
  8111a5:	53                   	push   %ebx
  8111a6:	83 ec 18             	sub    $0x18,%esp
  8111a9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t type;
#ifdef LWIP_DEBUG
  u8_t code;
#endif /* LWIP_DEBUG */
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  struct ip_addr tmpaddr;
  s16_t hlen;

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  8111ac:	8b 73 04             	mov    0x4(%ebx),%esi
  hlen = IPH_HL(iphdr) * 4;
  8111af:	0f b7 06             	movzwl (%esi),%eax
  8111b2:	50                   	push   %eax
  8111b3:	e8 bd 94 ff ff       	call   80a675 <ntohs>
  8111b8:	c1 e8 06             	shr    $0x6,%eax
  8111bb:	89 c7                	mov    %eax,%edi
  8111bd:	83 e7 3c             	and    $0x3c,%edi
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  8111c0:	83 c4 08             	add    $0x8,%esp
  8111c3:	89 f8                	mov    %edi,%eax
  8111c5:	f7 d8                	neg    %eax
  8111c7:	98                   	cwtl   
  8111c8:	50                   	push   %eax
  8111c9:	53                   	push   %ebx
  8111ca:	e8 74 66 ff ff       	call   807843 <pbuf_header>
  8111cf:	83 c4 10             	add    $0x10,%esp
  8111d2:	84 c0                	test   %al,%al
  8111d4:	0f 85 b0 02 00 00    	jne    81148a <icmp_input+0x2ea>
  8111da:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  8111df:	0f 86 a5 02 00 00    	jbe    81148a <icmp_input+0x2ea>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  8111e5:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  8111e8:	80 38 08             	cmpb   $0x8,(%eax)
  8111eb:	0f 85 8e 02 00 00    	jne    81147f <icmp_input+0x2df>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  8111f1:	83 ec 08             	sub    $0x8,%esp
  8111f4:	ff 75 0c             	pushl  0xc(%ebp)
  8111f7:	8d 46 10             	lea    0x10(%esi),%eax
  8111fa:	50                   	push   %eax
  8111fb:	e8 98 7f ff ff       	call   809198 <ip_addr_isbroadcast>
  811200:	83 c4 10             	add    $0x10,%esp
  811203:	84 c0                	test   %al,%al
  811205:	75 27                	jne    81122e <icmp_input+0x8e>
  811207:	83 ec 0c             	sub    $0xc,%esp
  81120a:	68 00 00 00 f0       	push   $0xf0000000
  81120f:	e8 a2 94 ff ff       	call   80a6b6 <ntohl>
  811214:	23 46 10             	and    0x10(%esi),%eax
  811217:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  81121a:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  811221:	e8 90 94 ff ff       	call   80a6b6 <ntohl>
  811226:	83 c4 10             	add    $0x10,%esp
  811229:	39 45 ec             	cmp    %eax,0xffffffec(%ebp)
  81122c:	75 0e                	jne    81123c <icmp_input+0x9c>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  81122e:	83 ec 0c             	sub    $0xc,%esp
  811231:	53                   	push   %ebx
  811232:	e8 e2 66 ff ff       	call   807919 <pbuf_free>
      return;
  811237:	e9 62 02 00 00       	jmp    81149e <icmp_input+0x2fe>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  81123c:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  811241:	0f 86 43 02 00 00    	jbe    81148a <icmp_input+0x2ea>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  811247:	83 ec 0c             	sub    $0xc,%esp
  81124a:	53                   	push   %ebx
  81124b:	e8 11 91 ff ff       	call   80a361 <inet_chksum_pbuf>
  811250:	83 c4 10             	add    $0x10,%esp
  811253:	66 85 c0             	test   %ax,%ax
  811256:	74 0e                	je     811266 <icmp_input+0xc6>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  811258:	83 ec 0c             	sub    $0xc,%esp
  81125b:	53                   	push   %ebx
  81125c:	e8 b8 66 ff ff       	call   807919 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  811261:	e9 38 02 00 00       	jmp    81149e <icmp_input+0x2fe>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  811266:	83 ec 08             	sub    $0x8,%esp
  811269:	6a 22                	push   $0x22
  81126b:	53                   	push   %ebx
  81126c:	e8 d2 65 ff ff       	call   807843 <pbuf_header>
  811271:	83 c4 10             	add    $0x10,%esp
  811274:	84 c0                	test   %al,%al
  811276:	0f 84 dc 00 00 00    	je     811358 <icmp_input+0x1b8>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  81127c:	83 ec 08             	sub    $0x8,%esp
  81127f:	0f bf c7             	movswl %di,%eax
  811282:	50                   	push   %eax
  811283:	53                   	push   %ebx
  811284:	e8 ba 65 ff ff       	call   807843 <pbuf_header>
  811289:	83 c4 10             	add    $0x10,%esp
  81128c:	84 c0                	test   %al,%al
  81128e:	74 14                	je     8112a4 <icmp_input+0x104>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  811290:	83 ec 04             	sub    $0x4,%esp
  811293:	68 c8 46 81 00       	push   $0x8146c8
  811298:	6a 7b                	push   $0x7b
  81129a:	68 bc 47 81 00       	push   $0x8147bc
  81129f:	e8 28 f8 fe ff       	call   800acc <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  8112a4:	83 ec 04             	sub    $0x4,%esp
  8112a7:	6a 00                	push   $0x0
  8112a9:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8112ad:	50                   	push   %eax
  8112ae:	6a 02                	push   $0x2
  8112b0:	e8 d3 61 ff ff       	call   807488 <pbuf_alloc>
  8112b5:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
      if (r == NULL) {
  8112b8:	83 c4 10             	add    $0x10,%esp
  8112bb:	85 c0                	test   %eax,%eax
  8112bd:	0f 84 d2 01 00 00    	je     811495 <icmp_input+0x2f5>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  8112c3:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  8112c7:	0f bf c7             	movswl %di,%eax
  8112ca:	83 c0 08             	add    $0x8,%eax
  8112cd:	39 c2                	cmp    %eax,%edx
  8112cf:	73 17                	jae    8112e8 <icmp_input+0x148>
  8112d1:	83 ec 04             	sub    $0x4,%esp
  8112d4:	68 fc 46 81 00       	push   $0x8146fc
  8112d9:	68 85 00 00 00       	push   $0x85
  8112de:	68 bc 47 81 00       	push   $0x8147bc
  8112e3:	e8 e4 f7 fe ff       	call   800acc <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  8112e8:	83 ec 08             	sub    $0x8,%esp
  8112eb:	53                   	push   %ebx
  8112ec:	ff 75 e8             	pushl  0xffffffe8(%ebp)
  8112ef:	e8 62 68 ff ff       	call   807b56 <pbuf_copy>
  8112f4:	83 c4 10             	add    $0x10,%esp
  8112f7:	84 c0                	test   %al,%al
  8112f9:	74 17                	je     811312 <icmp_input+0x172>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  8112fb:	83 ec 04             	sub    $0x4,%esp
  8112fe:	68 34 47 81 00       	push   $0x814734
  811303:	68 88 00 00 00       	push   $0x88
  811308:	68 bc 47 81 00       	push   $0x8147bc
  81130d:	e8 ba f7 fe ff       	call   800acc <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  811312:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  811315:	8b 70 04             	mov    0x4(%eax),%esi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  811318:	83 ec 08             	sub    $0x8,%esp
  81131b:	89 f8                	mov    %edi,%eax
  81131d:	f7 d8                	neg    %eax
  81131f:	98                   	cwtl   
  811320:	50                   	push   %eax
  811321:	ff 75 e8             	pushl  0xffffffe8(%ebp)
  811324:	e8 1a 65 ff ff       	call   807843 <pbuf_header>
  811329:	83 c4 10             	add    $0x10,%esp
  81132c:	84 c0                	test   %al,%al
  81132e:	74 17                	je     811347 <icmp_input+0x1a7>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  811330:	83 ec 04             	sub    $0x4,%esp
  811333:	68 5c 47 81 00       	push   $0x81475c
  811338:	68 8e 00 00 00       	push   $0x8e
  81133d:	68 bc 47 81 00       	push   $0x8147bc
  811342:	e8 85 f7 fe ff       	call   800acc <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  811347:	83 ec 0c             	sub    $0xc,%esp
  81134a:	53                   	push   %ebx
  81134b:	e8 c9 65 ff ff       	call   807919 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  811350:	8b 5d e8             	mov    0xffffffe8(%ebp),%ebx
  811353:	83 c4 10             	add    $0x10,%esp
  811356:	eb 29                	jmp    811381 <icmp_input+0x1e1>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  811358:	83 ec 08             	sub    $0x8,%esp
  81135b:	6a de                	push   $0xffffffde
  81135d:	53                   	push   %ebx
  81135e:	e8 e0 64 ff ff       	call   807843 <pbuf_header>
  811363:	83 c4 10             	add    $0x10,%esp
  811366:	84 c0                	test   %al,%al
  811368:	74 17                	je     811381 <icmp_input+0x1e1>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  81136a:	83 ec 04             	sub    $0x4,%esp
  81136d:	68 5c 47 81 00       	push   $0x81475c
  811372:	68 98 00 00 00       	push   $0x98
  811377:	68 bc 47 81 00       	push   $0x8147bc
  81137c:	e8 4b f7 fe ff       	call   800acc <_panic>
        goto memerr;
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  811381:	8b 53 04             	mov    0x4(%ebx),%edx
  811384:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
    tmpaddr.addr = iphdr->src.addr;
  811387:	8b 56 0c             	mov    0xc(%esi),%edx
    iphdr->src.addr = iphdr->dest.addr;
  81138a:	8b 46 10             	mov    0x10(%esi),%eax
  81138d:	89 46 0c             	mov    %eax,0xc(%esi)
    iphdr->dest.addr = tmpaddr.addr;
  811390:	89 56 10             	mov    %edx,0x10(%esi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  811393:	83 ec 0c             	sub    $0xc,%esp
  811396:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  811399:	0f b7 02             	movzwl (%edx),%eax
  81139c:	50                   	push   %eax
  81139d:	e8 d3 92 ff ff       	call   80a675 <ntohs>
  8113a2:	0f b6 c0             	movzbl %al,%eax
  8113a5:	89 04 24             	mov    %eax,(%esp)
  8113a8:	e8 b2 92 ff ff       	call   80a65f <htons>
  8113ad:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  8113b0:	66 89 02             	mov    %ax,(%edx)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  8113b3:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  8113ba:	e8 a0 92 ff ff       	call   80a65f <htons>
  8113bf:	83 c4 10             	add    $0x10,%esp
  8113c2:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  8113c5:	66 39 42 02          	cmp    %ax,0x2(%edx)
  8113c9:	72 1e                	jb     8113e9 <icmp_input+0x249>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  8113cb:	83 ec 0c             	sub    $0xc,%esp
  8113ce:	68 00 08 00 00       	push   $0x800
  8113d3:	e8 87 92 ff ff       	call   80a65f <htons>
  8113d8:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  8113db:	66 03 42 02          	add    0x2(%edx),%ax
  8113df:	40                   	inc    %eax
  8113e0:	66 89 42 02          	mov    %ax,0x2(%edx)
  8113e4:	83 c4 10             	add    $0x10,%esp
  8113e7:	eb 17                	jmp    811400 <icmp_input+0x260>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  8113e9:	83 ec 0c             	sub    $0xc,%esp
  8113ec:	68 00 08 00 00       	push   $0x800
  8113f1:	e8 69 92 ff ff       	call   80a65f <htons>
  8113f6:	8b 55 f0             	mov    0xfffffff0(%ebp),%edx
  8113f9:	66 01 42 02          	add    %ax,0x2(%edx)
  8113fd:	83 c4 10             	add    $0x10,%esp
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  811400:	83 ec 0c             	sub    $0xc,%esp
  811403:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  811407:	50                   	push   %eax
  811408:	e8 68 92 ff ff       	call   80a675 <ntohs>
  81140d:	0d 00 ff ff ff       	or     $0xffffff00,%eax
  811412:	0f b7 c0             	movzwl %ax,%eax
  811415:	89 04 24             	mov    %eax,(%esp)
  811418:	e8 42 92 ff ff       	call   80a65f <htons>
  81141d:	66 89 46 08          	mov    %ax,0x8(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  811421:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  811427:	83 c4 08             	add    $0x8,%esp
  81142a:	6a 14                	push   $0x14
  81142c:	56                   	push   %esi
  81142d:	e8 15 8f ff ff       	call   80a347 <inet_chksum>
  811432:	66 89 46 0a          	mov    %ax,0xa(%esi)
#endif /* CHECKSUM_GEN_IP */

    ICMP_STATS_INC(icmp.xmit);
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  811436:	83 c4 08             	add    $0x8,%esp
  811439:	0f bf c7             	movswl %di,%eax
  81143c:	50                   	push   %eax
  81143d:	53                   	push   %ebx
  81143e:	e8 00 64 ff ff       	call   807843 <pbuf_header>
  811443:	83 c4 10             	add    $0x10,%esp
  811446:	84 c0                	test   %al,%al
  811448:	74 17                	je     811461 <icmp_input+0x2c1>
      LWIP_ASSERT("Can't move over header in packet", 0);
  81144a:	83 ec 04             	sub    $0x4,%esp
  81144d:	68 f0 37 81 00       	push   $0x8137f0
  811452:	68 b9 00 00 00       	push   $0xb9
  811457:	68 bc 47 81 00       	push   $0x8147bc
  81145c:	e8 6b f6 fe ff       	call   800acc <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  811461:	83 ec 04             	sub    $0x4,%esp
  811464:	ff 75 0c             	pushl  0xc(%ebp)
  811467:	6a 01                	push   $0x1
  811469:	6a 00                	push   $0x0
  81146b:	68 ff 00 00 00       	push   $0xff
  811470:	6a 00                	push   $0x0
  811472:	8d 46 0c             	lea    0xc(%esi),%eax
  811475:	50                   	push   %eax
  811476:	53                   	push   %ebx
  811477:	e8 c4 80 ff ff       	call   809540 <ip_output_if>
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
  81147c:	83 c4 20             	add    $0x20,%esp
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
  default:
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  81147f:	83 ec 0c             	sub    $0xc,%esp
  811482:	53                   	push   %ebx
  811483:	e8 91 64 ff ff       	call   807919 <pbuf_free>
  return;
  811488:	eb 14                	jmp    81149e <icmp_input+0x2fe>
lenerr:
  pbuf_free(p);
  81148a:	83 ec 0c             	sub    $0xc,%esp
  81148d:	53                   	push   %ebx
  81148e:	e8 86 64 ff ff       	call   807919 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  811493:	eb 09                	jmp    81149e <icmp_input+0x2fe>
memerr:
  pbuf_free(p);
  811495:	83 ec 0c             	sub    $0xc,%esp
  811498:	53                   	push   %ebx
  811499:	e8 7b 64 ff ff       	call   807919 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  81149e:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  8114a1:	5b                   	pop    %ebx
  8114a2:	5e                   	pop    %esi
  8114a3:	5f                   	pop    %edi
  8114a4:	c9                   	leave  
  8114a5:	c3                   	ret    

008114a6 <icmp_dest_unreach>:

/**
 * Send an icmp 'destination unreachable' packet, called from ip_input() if
 * the transport layer protocol is unknown and from udp_input() if the local
 * port is not bound.
 *
 * @param p the input packet for which the 'unreachable' should be sent,
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  8114a6:	55                   	push   %ebp
  8114a7:	89 e5                	mov    %esp,%ebp
  8114a9:	57                   	push   %edi
  8114aa:	56                   	push   %esi
  8114ab:	53                   	push   %ebx
  8114ac:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  8114af:	6a 00                	push   $0x0
  8114b1:	6a 24                	push   $0x24
  8114b3:	6a 01                	push   $0x1
  8114b5:	e8 ce 5f ff ff       	call   807488 <pbuf_alloc>
  8114ba:	89 c7                	mov    %eax,%edi
                 PBUF_RAM);
  if (q == NULL) {
  8114bc:	83 c4 10             	add    $0x10,%esp
  8114bf:	85 c0                	test   %eax,%eax
  8114c1:	0f 84 b4 00 00 00    	je     81157b <icmp_dest_unreach+0xd5>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  8114c7:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  8114cc:	77 17                	ja     8114e5 <icmp_dest_unreach+0x3f>
  8114ce:	83 ec 04             	sub    $0x4,%esp
  8114d1:	68 90 47 81 00       	push   $0x814790
  8114d6:	68 ef 00 00 00       	push   $0xef
  8114db:	68 bc 47 81 00       	push   $0x8147bc
  8114e0:	e8 e7 f5 fe ff       	call   800acc <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  8114e5:	8b 45 08             	mov    0x8(%ebp),%eax
  8114e8:	8b 70 04             	mov    0x4(%eax),%esi

  idur = q->payload;
  8114eb:	8b 5f 04             	mov    0x4(%edi),%ebx
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  8114ee:	83 ec 0c             	sub    $0xc,%esp
  8114f1:	0f b7 03             	movzwl (%ebx),%eax
  8114f4:	50                   	push   %eax
  8114f5:	e8 7b 91 ff ff       	call   80a675 <ntohs>
  8114fa:	80 cc 03             	or     $0x3,%ah
  8114fd:	25 ff 03 00 00       	and    $0x3ff,%eax
  811502:	89 04 24             	mov    %eax,(%esp)
  811505:	e8 55 91 ff ff       	call   80a65f <htons>
  81150a:	66 89 03             	mov    %ax,(%ebx)
  ICMPH_CODE_SET(idur, t);
  81150d:	0f b7 c0             	movzwl %ax,%eax
  811510:	89 04 24             	mov    %eax,(%esp)
  811513:	e8 5d 91 ff ff       	call   80a675 <ntohs>
  811518:	b0 00                	mov    $0x0,%al
  81151a:	0b 45 0c             	or     0xc(%ebp),%eax
  81151d:	0f b7 c0             	movzwl %ax,%eax
  811520:	89 04 24             	mov    %eax,(%esp)
  811523:	e8 37 91 ff ff       	call   80a65f <htons>
  811528:	66 89 03             	mov    %ax,(%ebx)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  81152b:	83 c4 0c             	add    $0xc,%esp
  81152e:	6a 1c                	push   $0x1c
  811530:	8b 45 08             	mov    0x8(%ebp),%eax
  811533:	ff 70 04             	pushl  0x4(%eax)
  811536:	8b 47 04             	mov    0x4(%edi),%eax
  811539:	83 c0 08             	add    $0x8,%eax
  81153c:	50                   	push   %eax
  81153d:	e8 65 fe fe ff       	call   8013a7 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  811542:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
  idur->chksum = inet_chksum(idur, q->len);
  811548:	83 c4 08             	add    $0x8,%esp
  81154b:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
  81154f:	50                   	push   %eax
  811550:	53                   	push   %ebx
  811551:	e8 f1 8d ff ff       	call   80a347 <inet_chksum>
  811556:	66 89 43 02          	mov    %ax,0x2(%ebx)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  81155a:	83 c4 08             	add    $0x8,%esp
  81155d:	6a 01                	push   $0x1
  81155f:	6a 00                	push   $0x0
  811561:	68 ff 00 00 00       	push   $0xff
  811566:	83 c6 0c             	add    $0xc,%esi
  811569:	56                   	push   %esi
  81156a:	6a 00                	push   $0x0
  81156c:	57                   	push   %edi
  81156d:	e8 7d 81 ff ff       	call   8096ef <ip_output>
  pbuf_free(q);
  811572:	83 c4 14             	add    $0x14,%esp
  811575:	57                   	push   %edi
  811576:	e8 9e 63 ff ff       	call   807919 <pbuf_free>
}
  81157b:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  81157e:	5b                   	pop    %ebx
  81157f:	5e                   	pop    %esi
  811580:	5f                   	pop    %edi
  811581:	c9                   	leave  
  811582:	c3                   	ret    

00811583 <icmp_time_exceeded>:

#if IP_FORWARD || IP_REASSEMBLY
/**
 * Send a 'time exceeded' packet, called from ip_forward() if TTL is 0.
 *
 * @param p the input packet for which the 'time exceeded' should be sent,
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  811583:	55                   	push   %ebp
  811584:	89 e5                	mov    %esp,%ebp
  811586:	57                   	push   %edi
  811587:	56                   	push   %esi
  811588:	53                   	push   %ebx
  811589:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  81158c:	6a 00                	push   $0x0
  81158e:	6a 24                	push   $0x24
  811590:	6a 01                	push   $0x1
  811592:	e8 f1 5e ff ff       	call   807488 <pbuf_alloc>
  811597:	89 c7                	mov    %eax,%edi
                 PBUF_RAM);
  if (q == NULL) {
  811599:	83 c4 10             	add    $0x10,%esp
  81159c:	85 c0                	test   %eax,%eax
  81159e:	0f 84 b4 00 00 00    	je     811658 <icmp_time_exceeded+0xd5>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  8115a4:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  8115a9:	77 17                	ja     8115c2 <icmp_time_exceeded+0x3f>
  8115ab:	83 ec 04             	sub    $0x4,%esp
  8115ae:	68 90 47 81 00       	push   $0x814790
  8115b3:	68 1e 01 00 00       	push   $0x11e
  8115b8:	68 bc 47 81 00       	push   $0x8147bc
  8115bd:	e8 0a f5 fe ff       	call   800acc <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  8115c2:	8b 45 08             	mov    0x8(%ebp),%eax
  8115c5:	8b 70 04             	mov    0x4(%eax),%esi
  LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded from "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  8115c8:	8b 5f 04             	mov    0x4(%edi),%ebx
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  8115cb:	83 ec 0c             	sub    $0xc,%esp
  8115ce:	0f b7 03             	movzwl (%ebx),%eax
  8115d1:	50                   	push   %eax
  8115d2:	e8 9e 90 ff ff       	call   80a675 <ntohs>
  8115d7:	80 cc 0b             	or     $0xb,%ah
  8115da:	25 ff 0b 00 00       	and    $0xbff,%eax
  8115df:	89 04 24             	mov    %eax,(%esp)
  8115e2:	e8 78 90 ff ff       	call   80a65f <htons>
  8115e7:	66 89 03             	mov    %ax,(%ebx)
  ICMPH_CODE_SET(tehdr, t);
  8115ea:	0f b7 c0             	movzwl %ax,%eax
  8115ed:	89 04 24             	mov    %eax,(%esp)
  8115f0:	e8 80 90 ff ff       	call   80a675 <ntohs>
  8115f5:	b0 00                	mov    $0x0,%al
  8115f7:	0b 45 0c             	or     0xc(%ebp),%eax
  8115fa:	0f b7 c0             	movzwl %ax,%eax
  8115fd:	89 04 24             	mov    %eax,(%esp)
  811600:	e8 5a 90 ff ff       	call   80a65f <htons>
  811605:	66 89 03             	mov    %ax,(%ebx)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  811608:	83 c4 0c             	add    $0xc,%esp
  81160b:	6a 1c                	push   $0x1c
  81160d:	8b 45 08             	mov    0x8(%ebp),%eax
  811610:	ff 70 04             	pushl  0x4(%eax)
  811613:	8b 47 04             	mov    0x4(%edi),%eax
  811616:	83 c0 08             	add    $0x8,%eax
  811619:	50                   	push   %eax
  81161a:	e8 88 fd fe ff       	call   8013a7 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  81161f:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  811625:	83 c4 08             	add    $0x8,%esp
  811628:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
  81162c:	50                   	push   %eax
  81162d:	53                   	push   %ebx
  81162e:	e8 14 8d ff ff       	call   80a347 <inet_chksum>
  811633:	66 89 43 02          	mov    %ax,0x2(%ebx)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  811637:	83 c4 08             	add    $0x8,%esp
  81163a:	6a 01                	push   $0x1
  81163c:	6a 00                	push   $0x0
  81163e:	68 ff 00 00 00       	push   $0xff
  811643:	83 c6 0c             	add    $0xc,%esi
  811646:	56                   	push   %esi
  811647:	6a 00                	push   $0x0
  811649:	57                   	push   %edi
  81164a:	e8 a0 80 ff ff       	call   8096ef <ip_output>
  pbuf_free(q);
  81164f:	83 c4 14             	add    $0x14,%esp
  811652:	57                   	push   %edi
  811653:	e8 c1 62 ff ff       	call   807919 <pbuf_free>
}
  811658:	8d 65 f4             	lea    0xfffffff4(%ebp),%esp
  81165b:	5b                   	pop    %ebx
  81165c:	5e                   	pop    %esi
  81165d:	5f                   	pop    %edi
  81165e:	c9                   	leave  
  81165f:	c3                   	ret    

00811660 <__udivdi3>:
  811660:	55                   	push   %ebp
  811661:	89 e5                	mov    %esp,%ebp
  811663:	57                   	push   %edi
  811664:	56                   	push   %esi
  811665:	83 ec 14             	sub    $0x14,%esp
  811668:	8b 55 14             	mov    0x14(%ebp),%edx
  81166b:	8b 75 08             	mov    0x8(%ebp),%esi
  81166e:	8b 7d 0c             	mov    0xc(%ebp),%edi
  811671:	8b 45 10             	mov    0x10(%ebp),%eax
  811674:	85 d2                	test   %edx,%edx
  811676:	89 75 f0             	mov    %esi,0xfffffff0(%ebp)
  811679:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  81167c:	89 55 f4             	mov    %edx,0xfffffff4(%ebp)
  81167f:	89 fe                	mov    %edi,%esi
  811681:	75 11                	jne    811694 <__udivdi3+0x34>
  811683:	39 f8                	cmp    %edi,%eax
  811685:	76 4d                	jbe    8116d4 <__udivdi3+0x74>
  811687:	89 fa                	mov    %edi,%edx
  811689:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  81168c:	f7 75 e4             	divl   0xffffffe4(%ebp)
  81168f:	89 c7                	mov    %eax,%edi
  811691:	eb 09                	jmp    81169c <__udivdi3+0x3c>
  811693:	90                   	nop    
  811694:	39 7d f4             	cmp    %edi,0xfffffff4(%ebp)
  811697:	76 17                	jbe    8116b0 <__udivdi3+0x50>
  811699:	31 ff                	xor    %edi,%edi
  81169b:	90                   	nop    
  81169c:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  8116a3:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  8116a6:	83 c4 14             	add    $0x14,%esp
  8116a9:	5e                   	pop    %esi
  8116aa:	89 f8                	mov    %edi,%eax
  8116ac:	5f                   	pop    %edi
  8116ad:	c9                   	leave  
  8116ae:	c3                   	ret    
  8116af:	90                   	nop    
  8116b0:	0f bd 45 f4          	bsr    0xfffffff4(%ebp),%eax
  8116b4:	89 c7                	mov    %eax,%edi
  8116b6:	83 f7 1f             	xor    $0x1f,%edi
  8116b9:	75 4d                	jne    811708 <__udivdi3+0xa8>
  8116bb:	3b 75 f4             	cmp    0xfffffff4(%ebp),%esi
  8116be:	77 0a                	ja     8116ca <__udivdi3+0x6a>
  8116c0:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  8116c3:	31 ff                	xor    %edi,%edi
  8116c5:	39 55 f0             	cmp    %edx,0xfffffff0(%ebp)
  8116c8:	72 d2                	jb     81169c <__udivdi3+0x3c>
  8116ca:	bf 01 00 00 00       	mov    $0x1,%edi
  8116cf:	eb cb                	jmp    81169c <__udivdi3+0x3c>
  8116d1:	8d 76 00             	lea    0x0(%esi),%esi
  8116d4:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  8116d7:	85 c0                	test   %eax,%eax
  8116d9:	75 0e                	jne    8116e9 <__udivdi3+0x89>
  8116db:	b8 01 00 00 00       	mov    $0x1,%eax
  8116e0:	31 c9                	xor    %ecx,%ecx
  8116e2:	31 d2                	xor    %edx,%edx
  8116e4:	f7 f1                	div    %ecx
  8116e6:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  8116e9:	89 f0                	mov    %esi,%eax
  8116eb:	31 d2                	xor    %edx,%edx
  8116ed:	f7 75 e4             	divl   0xffffffe4(%ebp)
  8116f0:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  8116f3:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  8116f6:	f7 75 e4             	divl   0xffffffe4(%ebp)
  8116f9:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  8116fc:	83 c4 14             	add    $0x14,%esp
  8116ff:	89 c7                	mov    %eax,%edi
  811701:	5e                   	pop    %esi
  811702:	89 f8                	mov    %edi,%eax
  811704:	5f                   	pop    %edi
  811705:	c9                   	leave  
  811706:	c3                   	ret    
  811707:	90                   	nop    
  811708:	b8 20 00 00 00       	mov    $0x20,%eax
  81170d:	29 f8                	sub    %edi,%eax
  81170f:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
  811712:	89 f9                	mov    %edi,%ecx
  811714:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  811717:	d3 e2                	shl    %cl,%edx
  811719:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  81171c:	8a 4d e8             	mov    0xffffffe8(%ebp),%cl
  81171f:	d3 e8                	shr    %cl,%eax
  811721:	09 c2                	or     %eax,%edx
  811723:	89 f9                	mov    %edi,%ecx
  811725:	d3 65 e4             	shll   %cl,0xffffffe4(%ebp)
  811728:	89 55 f4             	mov    %edx,0xfffffff4(%ebp)
  81172b:	8a 4d e8             	mov    0xffffffe8(%ebp),%cl
  81172e:	89 f2                	mov    %esi,%edx
  811730:	d3 ea                	shr    %cl,%edx
  811732:	89 f9                	mov    %edi,%ecx
  811734:	d3 e6                	shl    %cl,%esi
  811736:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  811739:	8a 4d e8             	mov    0xffffffe8(%ebp),%cl
  81173c:	d3 e8                	shr    %cl,%eax
  81173e:	09 c6                	or     %eax,%esi
  811740:	89 f9                	mov    %edi,%ecx
  811742:	89 f0                	mov    %esi,%eax
  811744:	f7 75 f4             	divl   0xfffffff4(%ebp)
  811747:	89 d6                	mov    %edx,%esi
  811749:	89 c7                	mov    %eax,%edi
  81174b:	d3 65 f0             	shll   %cl,0xfffffff0(%ebp)
  81174e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  811751:	f7 e7                	mul    %edi
  811753:	39 f2                	cmp    %esi,%edx
  811755:	77 0f                	ja     811766 <__udivdi3+0x106>
  811757:	0f 85 3f ff ff ff    	jne    81169c <__udivdi3+0x3c>
  81175d:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
  811760:	0f 86 36 ff ff ff    	jbe    81169c <__udivdi3+0x3c>
  811766:	4f                   	dec    %edi
  811767:	e9 30 ff ff ff       	jmp    81169c <__udivdi3+0x3c>

0081176c <__umoddi3>:
  81176c:	55                   	push   %ebp
  81176d:	89 e5                	mov    %esp,%ebp
  81176f:	57                   	push   %edi
  811770:	56                   	push   %esi
  811771:	83 ec 30             	sub    $0x30,%esp
  811774:	8b 55 14             	mov    0x14(%ebp),%edx
  811777:	8b 45 10             	mov    0x10(%ebp),%eax
  81177a:	89 d7                	mov    %edx,%edi
  81177c:	8d 4d f0             	lea    0xfffffff0(%ebp),%ecx
  81177f:	89 c6                	mov    %eax,%esi
  811781:	8b 55 0c             	mov    0xc(%ebp),%edx
  811784:	8b 45 08             	mov    0x8(%ebp),%eax
  811787:	85 ff                	test   %edi,%edi
  811789:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
  811790:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  811797:	89 4d ec             	mov    %ecx,0xffffffec(%ebp)
  81179a:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  81179d:	89 55 cc             	mov    %edx,0xffffffcc(%ebp)
  8117a0:	75 3e                	jne    8117e0 <__umoddi3+0x74>
  8117a2:	39 d6                	cmp    %edx,%esi
  8117a4:	0f 86 a2 00 00 00    	jbe    81184c <__umoddi3+0xe0>
  8117aa:	f7 f6                	div    %esi
  8117ac:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  8117af:	85 c9                	test   %ecx,%ecx
  8117b1:	89 55 dc             	mov    %edx,0xffffffdc(%ebp)
  8117b4:	74 1b                	je     8117d1 <__umoddi3+0x65>
  8117b6:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  8117b9:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  8117bc:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  8117c3:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  8117c6:	8b 55 e0             	mov    0xffffffe0(%ebp),%edx
  8117c9:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
  8117cc:	89 10                	mov    %edx,(%eax)
  8117ce:	89 48 04             	mov    %ecx,0x4(%eax)
  8117d1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  8117d4:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  8117d7:	83 c4 30             	add    $0x30,%esp
  8117da:	5e                   	pop    %esi
  8117db:	5f                   	pop    %edi
  8117dc:	c9                   	leave  
  8117dd:	c3                   	ret    
  8117de:	89 f6                	mov    %esi,%esi
  8117e0:	3b 7d cc             	cmp    0xffffffcc(%ebp),%edi
  8117e3:	76 1f                	jbe    811804 <__umoddi3+0x98>
  8117e5:	8b 55 08             	mov    0x8(%ebp),%edx
  8117e8:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
  8117eb:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
  8117ee:	89 4d e4             	mov    %ecx,0xffffffe4(%ebp)
  8117f1:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  8117f4:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  8117f7:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  8117fa:	89 55 f4             	mov    %edx,0xfffffff4(%ebp)
  8117fd:	83 c4 30             	add    $0x30,%esp
  811800:	5e                   	pop    %esi
  811801:	5f                   	pop    %edi
  811802:	c9                   	leave  
  811803:	c3                   	ret    
  811804:	0f bd c7             	bsr    %edi,%eax
  811807:	83 f0 1f             	xor    $0x1f,%eax
  81180a:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
  81180d:	75 61                	jne    811870 <__umoddi3+0x104>
  81180f:	39 7d cc             	cmp    %edi,0xffffffcc(%ebp)
  811812:	77 05                	ja     811819 <__umoddi3+0xad>
  811814:	39 75 dc             	cmp    %esi,0xffffffdc(%ebp)
  811817:	72 10                	jb     811829 <__umoddi3+0xbd>
  811819:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
  81181c:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  81181f:	29 f0                	sub    %esi,%eax
  811821:	19 fa                	sbb    %edi,%edx
  811823:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  811826:	89 55 cc             	mov    %edx,0xffffffcc(%ebp)
  811829:	8b 55 ec             	mov    0xffffffec(%ebp),%edx
  81182c:	85 d2                	test   %edx,%edx
  81182e:	74 a1                	je     8117d1 <__umoddi3+0x65>
  811830:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  811833:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
  811836:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  811839:	89 55 e4             	mov    %edx,0xffffffe4(%ebp)
  81183c:	8b 4d ec             	mov    0xffffffec(%ebp),%ecx
  81183f:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  811842:	8b 55 e4             	mov    0xffffffe4(%ebp),%edx
  811845:	89 01                	mov    %eax,(%ecx)
  811847:	89 51 04             	mov    %edx,0x4(%ecx)
  81184a:	eb 85                	jmp    8117d1 <__umoddi3+0x65>
  81184c:	85 f6                	test   %esi,%esi
  81184e:	75 0b                	jne    81185b <__umoddi3+0xef>
  811850:	b8 01 00 00 00       	mov    $0x1,%eax
  811855:	31 d2                	xor    %edx,%edx
  811857:	f7 f6                	div    %esi
  811859:	89 c6                	mov    %eax,%esi
  81185b:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  81185e:	89 fa                	mov    %edi,%edx
  811860:	f7 f6                	div    %esi
  811862:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  811865:	89 55 cc             	mov    %edx,0xffffffcc(%ebp)
  811868:	f7 f6                	div    %esi
  81186a:	e9 3d ff ff ff       	jmp    8117ac <__umoddi3+0x40>
  81186f:	90                   	nop    
  811870:	b8 20 00 00 00       	mov    $0x20,%eax
  811875:	2b 45 d4             	sub    0xffffffd4(%ebp),%eax
  811878:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)
  81187b:	89 fa                	mov    %edi,%edx
  81187d:	8a 4d d4             	mov    0xffffffd4(%ebp),%cl
  811880:	d3 e2                	shl    %cl,%edx
  811882:	89 f0                	mov    %esi,%eax
  811884:	8a 4d d8             	mov    0xffffffd8(%ebp),%cl
  811887:	d3 e8                	shr    %cl,%eax
  811889:	8a 4d d4             	mov    0xffffffd4(%ebp),%cl
  81188c:	d3 e6                	shl    %cl,%esi
  81188e:	89 d7                	mov    %edx,%edi
  811890:	8a 4d d8             	mov    0xffffffd8(%ebp),%cl
  811893:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
  811896:	09 c7                	or     %eax,%edi
  811898:	d3 ea                	shr    %cl,%edx
  81189a:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  81189d:	8a 4d d4             	mov    0xffffffd4(%ebp),%cl
  8118a0:	d3 e0                	shl    %cl,%eax
  8118a2:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  8118a5:	8a 4d d8             	mov    0xffffffd8(%ebp),%cl
  8118a8:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  8118ab:	d3 e8                	shr    %cl,%eax
  8118ad:	0b 45 cc             	or     0xffffffcc(%ebp),%eax
  8118b0:	89 45 cc             	mov    %eax,0xffffffcc(%ebp)
  8118b3:	8a 4d d4             	mov    0xffffffd4(%ebp),%cl
  8118b6:	f7 f7                	div    %edi
  8118b8:	89 55 cc             	mov    %edx,0xffffffcc(%ebp)
  8118bb:	d3 65 dc             	shll   %cl,0xffffffdc(%ebp)
  8118be:	f7 e6                	mul    %esi
  8118c0:	3b 55 cc             	cmp    0xffffffcc(%ebp),%edx
  8118c3:	89 45 c8             	mov    %eax,0xffffffc8(%ebp)
  8118c6:	77 0a                	ja     8118d2 <__umoddi3+0x166>
  8118c8:	75 12                	jne    8118dc <__umoddi3+0x170>
  8118ca:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  8118cd:	39 45 c8             	cmp    %eax,0xffffffc8(%ebp)
  8118d0:	76 0a                	jbe    8118dc <__umoddi3+0x170>
  8118d2:	8b 4d c8             	mov    0xffffffc8(%ebp),%ecx
  8118d5:	29 f1                	sub    %esi,%ecx
  8118d7:	19 fa                	sbb    %edi,%edx
  8118d9:	89 4d c8             	mov    %ecx,0xffffffc8(%ebp)
  8118dc:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  8118df:	85 c0                	test   %eax,%eax
  8118e1:	0f 84 ea fe ff ff    	je     8117d1 <__umoddi3+0x65>
  8118e7:	8b 4d cc             	mov    0xffffffcc(%ebp),%ecx
  8118ea:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  8118ed:	2b 45 c8             	sub    0xffffffc8(%ebp),%eax
  8118f0:	19 d1                	sbb    %edx,%ecx
  8118f2:	89 4d cc             	mov    %ecx,0xffffffcc(%ebp)
  8118f5:	89 ca                	mov    %ecx,%edx
  8118f7:	8a 4d d8             	mov    0xffffffd8(%ebp),%cl
  8118fa:	d3 e2                	shl    %cl,%edx
  8118fc:	8a 4d d4             	mov    0xffffffd4(%ebp),%cl
  8118ff:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  811902:	d3 e8                	shr    %cl,%eax
  811904:	09 c2                	or     %eax,%edx
  811906:	8b 45 cc             	mov    0xffffffcc(%ebp),%eax
  811909:	d3 e8                	shr    %cl,%eax
  81190b:	89 55 e0             	mov    %edx,0xffffffe0(%ebp)
  81190e:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)
  811911:	e9 ad fe ff ff       	jmp    8117c3 <__umoddi3+0x57>
